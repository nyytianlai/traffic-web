var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as mars3d$1 from "mars3d";
import { Cesium as Cesium$1 } from "mars3d";
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
var areaFactors = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function geometry$1(type, coordinates, _options) {
  switch (type) {
    case "Point":
      return point(coordinates).geometry;
    case "LineString":
      return lineString(coordinates).geometry;
    case "Polygon":
      return polygon(coordinates).geometry;
    case "MultiPoint":
      return multiPoint(coordinates).geometry;
    case "MultiLineString":
      return multiLineString(coordinates).geometry;
    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;
    default:
      throw new Error(type + " is invalid");
  }
}
function point(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber$2(coordinates[0]) || !isNumber$2(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  var geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function points$3(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  return featureCollection$1(coordinates.map(function(coords) {
    return point(coords, properties);
  }), options);
}
function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];
    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }
    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  var geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function polygons(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  return featureCollection$1(coordinates.map(function(coords) {
    return polygon(coords, properties);
  }), options);
}
function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  var geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  return featureCollection$1(coordinates.map(function(coords) {
    return lineString(coords, properties);
  }), options);
}
function featureCollection$1(features2, options) {
  if (options === void 0) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features2;
  return fc;
}
function multiLineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiPoint",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiPolygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "GeometryCollection",
    geometries
  };
  return feature(geom, properties, options);
}
function round$4(num, precision) {
  if (precision === void 0) {
    precision = 0;
  }
  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }
  var multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians2, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians2 * factor;
}
function lengthToRadians(distance11, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance11 / factor;
}
function lengthToDegrees(distance11, units) {
  return radiansToDegrees(lengthToRadians(distance11, units));
}
function bearingToAzimuth(bearing2) {
  var angle4 = bearing2 % 360;
  if (angle4 < 0) {
    angle4 += 360;
  }
  return angle4;
}
function radiansToDegrees(radians2) {
  var degrees2 = radians2 % (2 * Math.PI);
  return degrees2 * 180 / Math.PI;
}
function degreesToRadians(degrees2) {
  var radians2 = degrees2 % 360;
  return radians2 * Math.PI / 180;
}
function convertLength(length3, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "kilometers";
  }
  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }
  if (!(length3 >= 0)) {
    throw new Error("length must be a positive number");
  }
  return radiansToLength(lengthToRadians(length3, originalUnit), finalUnit);
}
function convertArea(area5, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "meters";
  }
  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }
  if (!(area5 >= 0)) {
    throw new Error("area must be a positive number");
  }
  var startFactor = areaFactors[originalUnit];
  if (!startFactor) {
    throw new Error("invalid original units");
  }
  var finalFactor = areaFactors[finalUnit];
  if (!finalFactor) {
    throw new Error("invalid final units");
  }
  return area5 / startFactor * finalFactor;
}
function isNumber$2(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject$5(input) {
  return !!input && input.constructor === Object;
}
function validateBBox(bbox2) {
  if (!bbox2) {
    throw new Error("bbox is required");
  }
  if (!Array.isArray(bbox2)) {
    throw new Error("bbox must be an Array");
  }
  if (bbox2.length !== 4 && bbox2.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }
  bbox2.forEach(function(num) {
    if (!isNumber$2(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}
function validateId(id) {
  if (!id) {
    throw new Error("id is required");
  }
  if (["string", "number"].indexOf(typeof id) === -1) {
    throw new Error("id must be a number or a string");
  }
}
var es$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  earthRadius,
  factors,
  unitsFactors,
  areaFactors,
  feature,
  geometry: geometry$1,
  point,
  points: points$3,
  polygon,
  polygons,
  lineString,
  lineStrings,
  featureCollection: featureCollection$1,
  multiLineString,
  multiPoint,
  multiPolygon,
  geometryCollection,
  round: round$4,
  radiansToLength,
  lengthToRadians,
  lengthToDegrees,
  bearingToAzimuth,
  radiansToDegrees,
  degreesToRadians,
  convertLength,
  convertArea,
  isNumber: isNumber$2,
  isObject: isObject$5,
  validateBBox,
  validateId
}, Symbol.toStringTag, { value: "Module" }));
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null)
    return;
  var j, k, l, geometry2, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection2, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop2 = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop2; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection2 = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection2 ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry2 = isGeometryCollection2 ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry2 === null)
        continue;
      coords = geometry2.coordinates;
      var geomType = geometry2.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint")
              multiFeatureIndex++;
          }
          if (geomType === "LineString")
            multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString")
              multiFeatureIndex++;
            if (geomType === "Polygon")
              geometryIndex++;
          }
          if (geomType === "Polygon")
            multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry2.geometries.length; j++)
            if (coordEach(geometry2.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (coordIndex === 0 && initialValue === void 0)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false)
          break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function(currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
function featureEach$1(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false)
        break;
    }
  }
}
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach$1(geojson, function(currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentFeature;
    else
      previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function(coord) {
    coords.push(coord);
  });
  return coords;
}
function geomEach(geojson, callback) {
  var i, j, g, geometry2, stopG, geometryMaybeCollection, isGeometryCollection2, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop2 = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop2; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection2 = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection2 ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry2 = isGeometryCollection2 ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry2 === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry2.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry2,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry2.geometries.length; j++) {
            if (callback(
              geometry2.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        );
    }
  );
  return previousValue;
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry2, featureIndex, properties, bbox2, id) {
    var type = geometry2 === null ? null : geometry2.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry2, properties, { bbox: bbox2, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry2.coordinates.length; multiFeatureIndex++) {
      var coordinate2 = geometry2.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate2
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function(currentFeature, featureIndex, multiFeatureIndex) {
      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry)
      return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint")
      return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}
function lineEach(geojson, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    if (feature2.geometry === null)
      return;
    var type = feature2.geometry.type;
    var coords = feature2.geometry.coordinates;
    switch (type) {
      case "LineString":
        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback(
            lineString(coords[geometryIndex], feature2.properties),
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
        }
        break;
    }
  });
}
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}
function findSegment(geojson, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0)
        segmentIndex = coords.length + segmentIndex - 1;
      return lineString(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}
function findPoint(geojson, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
      return point(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return point(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0)
        coordIndex = coords.length + coordIndex;
      return point(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return point(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return point(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return point(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}
var es$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  coordAll,
  coordEach,
  coordReduce,
  featureEach: featureEach$1,
  featureReduce,
  findPoint,
  findSegment,
  flattenEach,
  flattenReduce,
  geomEach,
  geomReduce,
  lineEach,
  lineReduce,
  propEach,
  propReduce,
  segmentEach,
  segmentReduce
}, Symbol.toStringTag, { value: "Module" }));
function bbox$1(geojson) {
  var result = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, function(coord) {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }
    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }
    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }
    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}
bbox$1["default"] = bbox$1;
var es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": bbox$1
}, Symbol.toStringTag, { value: "Module" }));
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return coord.geometry.coordinates;
    }
    if (coord.type === "Point") {
      return coord.coordinates;
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return coord;
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function containsNumber(coordinates) {
  if (coordinates.length > 1 && isNumber$2(coordinates[0]) && isNumber$2(coordinates[1])) {
    return true;
  }
  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }
  throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name2) {
  if (!type || !name2) {
    throw new Error("type and name required");
  }
  if (!value || value.type !== type) {
    throw new Error("Invalid input to " + name2 + ": must be a " + type + ", given " + value.type);
  }
}
function featureOf(feature2, type, name2) {
  if (!feature2) {
    throw new Error("No feature passed");
  }
  if (!name2) {
    throw new Error(".featureOf() requires a name");
  }
  if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
    throw new Error("Invalid input to " + name2 + ", Feature with geometry required");
  }
  if (!feature2.geometry || feature2.geometry.type !== type) {
    throw new Error("Invalid input to " + name2 + ": must be a " + type + ", given " + feature2.geometry.type);
  }
}
function collectionOf(featureCollection2, type, name2) {
  if (!featureCollection2) {
    throw new Error("No featureCollection passed");
  }
  if (!name2) {
    throw new Error(".collectionOf() requires a name");
  }
  if (!featureCollection2 || featureCollection2.type !== "FeatureCollection") {
    throw new Error("Invalid input to " + name2 + ", FeatureCollection required");
  }
  for (var _i = 0, _a2 = featureCollection2.features; _i < _a2.length; _i++) {
    var feature2 = _a2[_i];
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error("Invalid input to " + name2 + ", Feature with geometry required");
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error("Invalid input to " + name2 + ": must be a " + type + ", given " + feature2.geometry.type);
    }
  }
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
function getType$1(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }
  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }
  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }
  return geojson.type;
}
var index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getCoord,
  getCoords,
  containsNumber,
  geojsonType,
  featureOf,
  collectionOf,
  getGeom,
  getType: getType$1
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty$1.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/**
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
var defaultSettings$1 = {
  successCallback: null,
  verbose: false
};
var settings$1 = {};
function isoContours(data, threshold, options) {
  options = options ? options : {};
  var optionKeys = Object.keys(defaultSettings$1);
  for (var i = 0; i < optionKeys.length; i++) {
    var key = optionKeys[i];
    var val = options[key];
    val = typeof val !== "undefined" && val !== null ? val : defaultSettings$1[key];
    settings$1[key] = val;
  }
  if (settings$1.verbose)
    console.log(
      "MarchingSquaresJS-isoContours: computing isocontour for " + threshold
    );
  var ret = contourGrid2Paths(computeContourGrid(data, threshold));
  if (typeof settings$1.successCallback === "function")
    settings$1.successCallback(ret);
  return ret;
}
function interpolateX$1(y2, y02, y12) {
  return (y2 - y02) / (y12 - y02);
}
function computeContourGrid(data, threshold) {
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var ContourGrid = { rows, cols, cells: [] };
  for (var j = 0; j < rows; ++j) {
    ContourGrid.cells[j] = [];
    for (var i = 0; i < cols; ++i) {
      var cval = 0;
      var tl = data[j + 1][i];
      var tr = data[j + 1][i + 1];
      var br = data[j][i + 1];
      var bl = data[j][i];
      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
        continue;
      }
      cval |= tl >= threshold ? 8 : 0;
      cval |= tr >= threshold ? 4 : 0;
      cval |= br >= threshold ? 2 : 0;
      cval |= bl >= threshold ? 1 : 0;
      var flipped = false;
      if (cval === 5 || cval === 10) {
        var average2 = (tl + tr + br + bl) / 4;
        if (cval === 5 && average2 < threshold) {
          cval = 10;
          flipped = true;
        } else if (cval === 10 && average2 < threshold) {
          cval = 5;
          flipped = true;
        }
      }
      if (cval !== 0 && cval !== 15) {
        var top, bottom, left, right;
        top = bottom = left = right = 0.5;
        if (cval === 1) {
          left = 1 - interpolateX$1(threshold, tl, bl);
          bottom = 1 - interpolateX$1(threshold, br, bl);
        } else if (cval === 2) {
          bottom = interpolateX$1(threshold, bl, br);
          right = 1 - interpolateX$1(threshold, tr, br);
        } else if (cval === 3) {
          left = 1 - interpolateX$1(threshold, tl, bl);
          right = 1 - interpolateX$1(threshold, tr, br);
        } else if (cval === 4) {
          top = interpolateX$1(threshold, tl, tr);
          right = interpolateX$1(threshold, br, tr);
        } else if (cval === 5) {
          top = interpolateX$1(threshold, tl, tr);
          right = interpolateX$1(threshold, br, tr);
          bottom = 1 - interpolateX$1(threshold, br, bl);
          left = 1 - interpolateX$1(threshold, tl, bl);
        } else if (cval === 6) {
          bottom = interpolateX$1(threshold, bl, br);
          top = interpolateX$1(threshold, tl, tr);
        } else if (cval === 7) {
          left = 1 - interpolateX$1(threshold, tl, bl);
          top = interpolateX$1(threshold, tl, tr);
        } else if (cval === 8) {
          left = interpolateX$1(threshold, bl, tl);
          top = 1 - interpolateX$1(threshold, tr, tl);
        } else if (cval === 9) {
          bottom = 1 - interpolateX$1(threshold, br, bl);
          top = 1 - interpolateX$1(threshold, tr, tl);
        } else if (cval === 10) {
          top = 1 - interpolateX$1(threshold, tr, tl);
          right = 1 - interpolateX$1(threshold, tr, br);
          bottom = interpolateX$1(threshold, bl, br);
          left = interpolateX$1(threshold, bl, tl);
        } else if (cval === 11) {
          top = 1 - interpolateX$1(threshold, tr, tl);
          right = 1 - interpolateX$1(threshold, tr, br);
        } else if (cval === 12) {
          left = interpolateX$1(threshold, bl, tl);
          right = interpolateX$1(threshold, br, tr);
        } else if (cval === 13) {
          bottom = 1 - interpolateX$1(threshold, br, bl);
          right = interpolateX$1(threshold, br, tr);
        } else if (cval === 14) {
          left = interpolateX$1(threshold, bl, tl);
          bottom = interpolateX$1(threshold, bl, br);
        } else {
          console.log(
            "MarchingSquaresJS-isoContours: Illegal cval detected: " + cval
          );
        }
        ContourGrid.cells[j][i] = {
          cval,
          flipped,
          top,
          right,
          bottom,
          left
        };
      }
    }
  }
  return ContourGrid;
}
function isSaddle(cell) {
  return cell.cval === 5 || cell.cval === 10;
}
function isTrivial(cell) {
  return cell.cval === 0 || cell.cval === 15;
}
function clearCell(cell) {
  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {
    cell.cval = 15;
  }
}
function getXY(cell, edge) {
  if (edge === "top") {
    return [cell.top, 1];
  } else if (edge === "bottom") {
    return [cell.bottom, 0];
  } else if (edge === "right") {
    return [1, cell.right];
  } else if (edge === "left") {
    return [0, cell.left];
  }
}
function contourGrid2Paths(grid) {
  var paths = [];
  var path_idx = 0;
  var epsilon3 = 1e-7;
  grid.cells.forEach(function(g, j) {
    g.forEach(function(gg, i) {
      if (typeof gg !== "undefined" && !isSaddle(gg) && !isTrivial(gg)) {
        var p = tracePath(grid.cells, j, i);
        var merged = false;
        if (p.info === "mergeable") {
          var x2 = p.path[p.path.length - 1][0], y2 = p.path[p.path.length - 1][1];
          for (var k = path_idx - 1; k >= 0; k--) {
            if (Math.abs(paths[k][0][0] - x2) <= epsilon3 && Math.abs(paths[k][0][1] - y2) <= epsilon3) {
              for (var l = p.path.length - 2; l >= 0; --l) {
                paths[k].unshift(p.path[l]);
              }
              merged = true;
              break;
            }
          }
        }
        if (!merged)
          paths[path_idx++] = p.path;
      }
    });
  });
  return paths;
}
function tracePath(grid, j, i) {
  var maxj = grid.length;
  var p = [];
  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];
  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];
  var dx, dy;
  var startEdge = [
    "none",
    "left",
    "bottom",
    "left",
    "right",
    "none",
    "bottom",
    "left",
    "top",
    "top",
    "none",
    "top",
    "right",
    "right",
    "bottom",
    "none"
  ];
  var nextEdge = [
    "none",
    "bottom",
    "right",
    "right",
    "top",
    "top",
    "top",
    "top",
    "left",
    "bottom",
    "right",
    "right",
    "left",
    "bottom",
    "left",
    "none"
  ];
  var edge;
  var currentCell = grid[j][i];
  var cval = currentCell.cval;
  var edge = startEdge[cval];
  var pt = getXY(currentCell, edge);
  p.push([i + pt[0], j + pt[1]]);
  edge = nextEdge[cval];
  pt = getXY(currentCell, edge);
  p.push([i + pt[0], j + pt[1]]);
  clearCell(currentCell);
  var k = i + dxContour[cval];
  var l = j + dyContour[cval];
  var prev_cval = cval;
  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {
    currentCell = grid[l][k];
    if (typeof currentCell === "undefined") {
      break;
    }
    cval = currentCell.cval;
    if (cval === 0 || cval === 15) {
      return { path: p, info: "mergeable" };
    }
    edge = nextEdge[cval];
    dx = dxContour[cval];
    dy = dyContour[cval];
    if (cval === 5 || cval === 10) {
      if (cval === 5) {
        if (currentCell.flipped) {
          if (dyContour[prev_cval] === -1) {
            edge = "left";
            dx = -1;
            dy = 0;
          } else {
            edge = "right";
            dx = 1;
            dy = 0;
          }
        } else {
          if (dxContour[prev_cval] === -1) {
            edge = "bottom";
            dx = 0;
            dy = -1;
          }
        }
      } else if (cval === 10) {
        if (currentCell.flipped) {
          if (dxContour[prev_cval] === -1) {
            edge = "top";
            dx = 0;
            dy = 1;
          } else {
            edge = "bottom";
            dx = 0;
            dy = -1;
          }
        } else {
          if (dyContour[prev_cval] === 1) {
            edge = "left";
            dx = -1;
            dy = 0;
          }
        }
      }
    }
    pt = getXY(currentCell, edge);
    p.push([k + pt[0], l + pt[1]]);
    clearCell(currentCell);
    k += dx;
    l += dy;
    prev_cval = cval;
  }
  return { path: p, info: "closed" };
}
function gridToMatrix$1(grid, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip4 = options.flip;
  var flags2 = options.flags;
  collectionOf(grid, "Point", "input must contain Points");
  var pointsMatrix = sortPointsByLatLng$1(grid, flip4);
  var matrix = [];
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point4 = pointRow[c];
      if (point4.properties[zProperty])
        row.push(point4.properties[zProperty]);
      else
        row.push(0);
      if (flags2 === true)
        point4.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }
  return matrix;
}
function sortPointsByLatLng$1(points2, flip4) {
  var pointsByLatitude = {};
  featureEach$1(points2, function(point4) {
    var lat2 = getCoords(point4)[1];
    if (!pointsByLatitude[lat2])
      pointsByLatitude[lat2] = [];
    pointsByLatitude[lat2].push(point4);
  });
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat2) {
    var row = pointsByLatitude[lat2];
    var rowOrderedByLongitude = row.sort(function(a, b) {
      return getCoords(a)[0] - getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });
  var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
    if (flip4)
      return getCoords(a[0])[1] - getCoords(b[0])[1];
    else
      return getCoords(b[0])[1] - getCoords(a[0])[1];
  });
  return pointMatrix;
}
function isolines(pointGrid2, breaks, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var commonProperties = options.commonProperties || {};
  var breaksProperties = options.breaksProperties || [];
  collectionOf(pointGrid2, "Point", "Input must contain Points");
  if (!breaks)
    throw new Error("breaks is required");
  if (!Array.isArray(breaks))
    throw new Error("breaks must be an Array");
  if (!isObject$5(commonProperties))
    throw new Error("commonProperties must be an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties must be an Array");
  var matrix = gridToMatrix$1(pointGrid2, { zProperty, flip: true });
  var createdIsoLines = createIsoLines(
    matrix,
    breaks,
    zProperty,
    commonProperties,
    breaksProperties
  );
  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid2);
  return featureCollection$1(scaledIsolines);
}
function createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {
  var results = [];
  for (var i = 1; i < breaks.length; i++) {
    var threshold = +breaks[i];
    var properties = objectAssign({}, commonProperties, breaksProperties[i]);
    properties[zProperty] = threshold;
    var isoline = multiLineString(isoContours(matrix, threshold), properties);
    results.push(isoline);
  }
  return results;
}
function rescaleIsolines(createdIsoLines, matrix, points2) {
  var gridBbox = bbox$1(points2);
  var originalWidth = gridBbox[2] - gridBbox[0];
  var originalHeigth = gridBbox[3] - gridBbox[1];
  var x02 = gridBbox[0];
  var y02 = gridBbox[1];
  var matrixWidth = matrix[0].length - 1;
  var matrixHeight = matrix.length - 1;
  var scaleX = originalWidth / matrixWidth;
  var scaleY = originalHeigth / matrixHeight;
  var resize = function(point4) {
    point4[0] = point4[0] * scaleX + x02;
    point4[1] = point4[1] * scaleY + y02;
  };
  createdIsoLines.forEach(function(isoline) {
    coordEach(isoline, resize);
  });
  return createdIsoLines;
}
var concaveman$2 = { exports: {} };
var rbush_min$1 = { exports: {} };
(function(module, exports) {
  !function(t, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    function t(t2, r2, e3, a2, h2) {
      !function t3(n2, r3, e4, a3, h3) {
        for (; a3 > e4; ) {
          if (a3 - e4 > 600) {
            var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m3 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
            t3(n2, r3, m3, c2, h3);
          }
          var p2 = n2[r3], d2 = e4, x2 = a3;
          for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
            for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
              d2++;
            for (; h3(n2[x2], p2) > 0; )
              x2--;
          }
          0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
        }
      }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
    }
    function i(t2, i2, n2) {
      var r2 = t2[i2];
      t2[i2] = t2[n2], t2[n2] = r2;
    }
    function n(t2, i2) {
      return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
    }
    var r = function(t2) {
      void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function e2(t2, i2, n2) {
      if (!n2)
        return i2.indexOf(t2);
      for (var r2 = 0; r2 < i2.length; r2++)
        if (n2(t2, i2[r2]))
          return r2;
      return -1;
    }
    function a(t2, i2) {
      h(t2, 0, t2.children.length, i2, t2);
    }
    function h(t2, i2, n2, r2, e3) {
      e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
      for (var a2 = i2; a2 < n2; a2++) {
        var h2 = t2.children[a2];
        o(e3, t2.leaf ? r2(h2) : h2);
      }
      return e3;
    }
    function o(t2, i2) {
      return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
    }
    function s(t2, i2) {
      return t2.minX - i2.minX;
    }
    function l(t2, i2) {
      return t2.minY - i2.minY;
    }
    function f(t2) {
      return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
    }
    function u(t2) {
      return t2.maxX - t2.minX + (t2.maxY - t2.minY);
    }
    function m2(t2, i2) {
      return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
    }
    function c(t2, i2) {
      return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
    }
    function p(t2) {
      return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    function d(i2, n2, r2, e3, a2) {
      for (var h2 = [n2, r2]; h2.length; )
        if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
          var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
          t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
        }
    }
    return r.prototype.all = function() {
      return this._all(this.data, []);
    }, r.prototype.search = function(t2) {
      var i2 = this.data, n2 = [];
      if (!c(t2, i2))
        return n2;
      for (var r2 = this.toBBox, e3 = []; i2; ) {
        for (var a2 = 0; a2 < i2.children.length; a2++) {
          var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
          c(t2, o2) && (i2.leaf ? n2.push(h2) : m2(t2, o2) ? this._all(h2, n2) : e3.push(h2));
        }
        i2 = e3.pop();
      }
      return n2;
    }, r.prototype.collides = function(t2) {
      var i2 = this.data;
      if (!c(t2, i2))
        return false;
      for (var n2 = []; i2; ) {
        for (var r2 = 0; r2 < i2.children.length; r2++) {
          var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
          if (c(t2, a2)) {
            if (i2.leaf || m2(t2, a2))
              return true;
            n2.push(e3);
          }
        }
        i2 = n2.pop();
      }
      return false;
    }, r.prototype.load = function(t2) {
      if (!t2 || !t2.length)
        return this;
      if (t2.length < this._minEntries) {
        for (var i2 = 0; i2 < t2.length; i2++)
          this.insert(t2[i2]);
        return this;
      }
      var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
      if (this.data.children.length)
        if (this.data.height === n2.height)
          this._splitRoot(this.data, n2);
        else {
          if (this.data.height < n2.height) {
            var r2 = this.data;
            this.data = n2, n2 = r2;
          }
          this._insert(n2, this.data.height - n2.height - 1, true);
        }
      else
        this.data = n2;
      return this;
    }, r.prototype.insert = function(t2) {
      return t2 && this._insert(t2, this.data.height - 1), this;
    }, r.prototype.clear = function() {
      return this.data = p([]), this;
    }, r.prototype.remove = function(t2, i2) {
      if (!t2)
        return this;
      for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
        if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
          var f2 = e2(t2, h2.children, i2);
          if (-1 !== f2)
            return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
        }
        a2 || h2.leaf || !m2(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
      }
      return this;
    }, r.prototype.toBBox = function(t2) {
      return t2;
    }, r.prototype.compareMinX = function(t2, i2) {
      return t2.minX - i2.minX;
    }, r.prototype.compareMinY = function(t2, i2) {
      return t2.minY - i2.minY;
    }, r.prototype.toJSON = function() {
      return this.data;
    }, r.prototype.fromJSON = function(t2) {
      return this.data = t2, this;
    }, r.prototype._all = function(t2, i2) {
      for (var n2 = []; t2; )
        t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
      return i2;
    }, r.prototype._build = function(t2, i2, n2, r2) {
      var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
      if (h2 <= o2)
        return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
      r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
      var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
      d(t2, i2, n2, l2, this.compareMinX);
      for (var f2 = i2; f2 <= n2; f2 += l2) {
        var u2 = Math.min(f2 + l2 - 1, n2);
        d(t2, f2, u2, s2, this.compareMinY);
        for (var m3 = f2; m3 <= u2; m3 += s2) {
          var c2 = Math.min(m3 + s2 - 1, u2);
          e3.children.push(this._build(t2, m3, c2, r2 - 1));
        }
      }
      return a(e3, this.toBBox), e3;
    }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
      for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
        for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
          var s2 = i2.children[o2], l2 = f(s2), u2 = (m3 = t2, c2 = s2, (Math.max(c2.maxX, m3.maxX) - Math.min(c2.minX, m3.minX)) * (Math.max(c2.maxY, m3.maxY) - Math.min(c2.minY, m3.minY)) - l2);
          u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
        }
        i2 = h2 || i2.children[0];
      }
      var m3, c2;
      return i2;
    }, r.prototype._insert = function(t2, i2, n2) {
      var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
      for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
        this._split(e3, i2), i2--;
      this._adjustParentBBoxes(r2, e3, i2);
    }, r.prototype._split = function(t2, i2) {
      var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
      this._chooseSplitAxis(n2, e3, r2);
      var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
      o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
    }, r.prototype._splitRoot = function(t2, i2) {
      this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
      for (var r2, e3, a2, o2, s2, l2, u2, m3 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
        var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
        v < m3 ? (m3 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m3 && M < c2 && (c2 = M, r2 = p2);
      }
      return r2 || n2 - i2;
    }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
      var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
      this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
    }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
      t2.children.sort(r2);
      for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
        var m3 = t2.children[f2];
        o(a2, t2.leaf ? e3(m3) : m3), l2 += u(a2);
      }
      for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
        var p2 = t2.children[c2];
        o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
      }
      return l2;
    }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
      for (var r2 = n2; r2 >= 0; r2--)
        o(i2[r2], t2);
    }, r.prototype._condense = function(t2) {
      for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
        0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
    }, r;
  });
})(rbush_min$1);
class TinyQueue {
  constructor(data = [], compare11 = defaultCompare) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare11;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--)
        this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0)
      return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data, compare: compare11 } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare11(item, current) >= 0)
        break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const { data, compare: compare11 } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;
      if (right < this.length && compare11(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare11(best, item) >= 0)
        break;
      data[pos] = best;
      pos = left;
    }
    data[pos] = item;
  }
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var tinyqueue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": TinyQueue
}, Symbol.toStringTag, { value: "Module" }));
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(tinyqueue);
var pointInPolygon$1 = { exports: {} };
var flat = function pointInPolygonFlat(point4, vs, start2, end2) {
  var x2 = point4[0], y2 = point4[1];
  var inside2 = false;
  if (start2 === void 0)
    start2 = 0;
  if (end2 === void 0)
    end2 = vs.length;
  var len2 = (end2 - start2) / 2;
  for (var i = 0, j = len2 - 1; i < len2; j = i++) {
    var xi = vs[start2 + i * 2 + 0], yi = vs[start2 + i * 2 + 1];
    var xj = vs[start2 + j * 2 + 0], yj = vs[start2 + j * 2 + 1];
    var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect2)
      inside2 = !inside2;
  }
  return inside2;
};
var nested = function pointInPolygonNested(point4, vs, start2, end2) {
  var x2 = point4[0], y2 = point4[1];
  var inside2 = false;
  if (start2 === void 0)
    start2 = 0;
  if (end2 === void 0)
    end2 = vs.length;
  var len2 = end2 - start2;
  for (var i = 0, j = len2 - 1; i < len2; j = i++) {
    var xi = vs[i + start2][0], yi = vs[i + start2][1];
    var xj = vs[j + start2][0], yj = vs[j + start2][1];
    var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect2)
      inside2 = !inside2;
  }
  return inside2;
};
var pointInPolygonFlat2 = flat;
var pointInPolygonNested2 = nested;
pointInPolygon$1.exports = function pointInPolygon(point4, vs, start2, end2) {
  if (vs.length > 0 && Array.isArray(vs[0])) {
    return pointInPolygonNested2(point4, vs, start2, end2);
  } else {
    return pointInPolygonFlat2(point4, vs, start2, end2);
  }
};
pointInPolygon$1.exports.nested = pointInPolygonNested2;
pointInPolygon$1.exports.flat = pointInPolygonFlat2;
var orient2d_min = { exports: {} };
(function(module, exports) {
  !function(t, e2) {
    e2(exports);
  }(commonjsGlobal, function(t) {
    const e2 = 134217729, n = 33306690738754706e-32;
    function r(t2, e3, n2, r2, o2) {
      let f2, i2, u2, c2, s2 = e3[0], a2 = r2[0], d2 = 0, l2 = 0;
      a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a2, a2 = r2[++l2]);
      let p = 0;
      if (d2 < t2 && l2 < n2)
        for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
          a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
      for (; d2 < t2; )
        u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
      for (; l2 < n2; )
        u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
      return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
    }
    function o(t2) {
      return new Float64Array(t2);
    }
    const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
    t.orient2d = function(t2, o2, p, b, y2, h) {
      const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
      if (0 === M || 0 === x2 || M > 0 != x2 > 0)
        return j;
      const m2 = Math.abs(M + x2);
      return Math.abs(j) >= f * m2 ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
        let M2, x3, j2, m3, _, v, w, A, F, O, P, g, k, q, z, B2, C, D;
        const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
        _ = (z = (A = E - (w = (v = e2 * E) - (v - E))) * (O = I - (F = (v = e2 * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e2 * H) - (v - H))) * (O = G - (F = (v = e2 * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
        let J = function(t4, e3) {
          let n2 = e3[0];
          for (let r2 = 1; r2 < t4; r2++)
            n2 += e3[r2];
          return n2;
        }(4, c), K = i * h2;
        if (J >= K || -J >= K)
          return J;
        if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m3 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M2 && 0 === x3 && 0 === j2 && 0 === m3)
          return J;
        if (K = u * h2 + n * Math.abs(J), (J += E * m3 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K)
          return J;
        _ = (z = (A = M2 - (w = (v = e2 * M2) - (v - M2))) * (O = I - (F = (v = e2 * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e2 * x3) - (v - x3))) * (O = G - (F = (v = e2 * G) - (v - G))) - ((B2 = x3 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
        const L = r(4, c, 4, l, s);
        _ = (z = (A = E - (w = (v = e2 * E) - (v - E))) * (O = m3 - (F = (v = e2 * m3) - (v - m3))) - ((q = E * m3) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e2 * H) - (v - H))) * (O = j2 - (F = (v = e2 * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
        const N = r(L, s, 4, l, a);
        _ = (z = (A = M2 - (w = (v = e2 * M2) - (v - M2))) * (O = m3 - (F = (v = e2 * m3) - (v - m3))) - ((q = M2 * m3) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e2 * x3) - (v - x3))) * (O = j2 - (F = (v = e2 * j2) - (v - j2))) - ((B2 = x3 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
        const Q = r(N, a, 4, l, d);
        return d[Q - 1];
      }(t2, o2, p, b, y2, h, m2);
    }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
      return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
    }, Object.defineProperty(t, "__esModule", { value: true });
  });
})(orient2d_min, orient2d_min.exports);
var RBush = rbush_min$1.exports;
var Queue = require$$1$1;
var pointInPolygon2 = pointInPolygon$1.exports;
var orient = orient2d_min.exports.orient2d;
if (Queue.default) {
  Queue = Queue.default;
}
concaveman$2.exports = concaveman;
concaveman$2.exports.default = concaveman;
function concaveman(points2, concavity, lengthThreshold) {
  concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
  lengthThreshold = lengthThreshold || 0;
  var hull = fastConvexHull(points2);
  var tree = new RBush(16);
  tree.toBBox = function(a2) {
    return {
      minX: a2[0],
      minY: a2[1],
      maxX: a2[0],
      maxY: a2[1]
    };
  };
  tree.compareMinX = function(a2, b2) {
    return a2[0] - b2[0];
  };
  tree.compareMinY = function(a2, b2) {
    return a2[1] - b2[1];
  };
  tree.load(points2);
  var queue = [];
  for (var i = 0, last; i < hull.length; i++) {
    var p = hull[i];
    tree.remove(p);
    last = insertNode$1(p, last);
    queue.push(last);
  }
  var segTree = new RBush(16);
  for (i = 0; i < queue.length; i++)
    segTree.insert(updateBBox(queue[i]));
  var sqConcavity = concavity * concavity;
  var sqLenThreshold = lengthThreshold * lengthThreshold;
  while (queue.length) {
    var node = queue.shift();
    var a = node.p;
    var b = node.next.p;
    var sqLen = getSqDist$1(a, b);
    if (sqLen < sqLenThreshold)
      continue;
    var maxSqLen = sqLen / sqConcavity;
    p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
    if (p && Math.min(getSqDist$1(p, a), getSqDist$1(p, b)) <= maxSqLen) {
      queue.push(node);
      queue.push(insertNode$1(p, node));
      tree.remove(p);
      segTree.remove(node);
      segTree.insert(updateBBox(node));
      segTree.insert(updateBBox(node.next));
    }
  }
  node = last;
  var concave2 = [];
  do {
    concave2.push(node.p);
    node = node.next;
  } while (node !== last);
  concave2.push(node.p);
  return concave2;
}
function findCandidate(tree, a, b, c, d, maxDist, segTree) {
  var queue = new Queue([], compareDist);
  var node = tree.data;
  while (node) {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      var dist3 = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
      if (dist3 > maxDist)
        continue;
      queue.push({
        node: child,
        dist: dist3
      });
    }
    while (queue.length && !queue.peek().node.children) {
      var item = queue.pop();
      var p = item.node;
      var d0 = sqSegDist(p, a, b);
      var d1 = sqSegDist(p, c, d);
      if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
        return p;
    }
    node = queue.pop();
    if (node)
      node = node.node;
  }
  return null;
}
function compareDist(a, b) {
  return a.dist - b.dist;
}
function sqSegBoxDist(a, b, bbox2) {
  if (inside(a, bbox2) || inside(b, bbox2))
    return 0;
  var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.maxX, bbox2.minY);
  if (d1 === 0)
    return 0;
  var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.minX, bbox2.maxY);
  if (d2 === 0)
    return 0;
  var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.maxX, bbox2.minY, bbox2.maxX, bbox2.maxY);
  if (d3 === 0)
    return 0;
  var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.maxY, bbox2.maxX, bbox2.maxY);
  if (d4 === 0)
    return 0;
  return Math.min(d1, d2, d3, d4);
}
function inside(a, bbox2) {
  return a[0] >= bbox2.minX && a[0] <= bbox2.maxX && a[1] >= bbox2.minY && a[1] <= bbox2.maxY;
}
function noIntersections(a, b, segTree) {
  var minX2 = Math.min(a[0], b[0]);
  var minY2 = Math.min(a[1], b[1]);
  var maxX2 = Math.max(a[0], b[0]);
  var maxY2 = Math.max(a[1], b[1]);
  var edges2 = segTree.search({ minX: minX2, minY: minY2, maxX: maxX2, maxY: maxY2 });
  for (var i = 0; i < edges2.length; i++) {
    if (intersects$3(edges2[i].p, edges2[i].next.p, a, b))
      return false;
  }
  return true;
}
function cross(p1, p2, p3) {
  return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
function intersects$3(p1, q1, p2, q2) {
  return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
}
function updateBBox(node) {
  var p1 = node.p;
  var p2 = node.next.p;
  node.minX = Math.min(p1[0], p2[0]);
  node.minY = Math.min(p1[1], p2[1]);
  node.maxX = Math.max(p1[0], p2[0]);
  node.maxY = Math.max(p1[1], p2[1]);
  return node;
}
function fastConvexHull(points2) {
  var left = points2[0];
  var top = points2[0];
  var right = points2[0];
  var bottom = points2[0];
  for (var i = 0; i < points2.length; i++) {
    var p = points2[i];
    if (p[0] < left[0])
      left = p;
    if (p[0] > right[0])
      right = p;
    if (p[1] < top[1])
      top = p;
    if (p[1] > bottom[1])
      bottom = p;
  }
  var cull = [left, top, right, bottom];
  var filtered = cull.slice();
  for (i = 0; i < points2.length; i++) {
    if (!pointInPolygon2(points2[i], cull))
      filtered.push(points2[i]);
  }
  return convexHull(filtered);
}
function insertNode$1(p, prev) {
  var node = {
    p,
    prev: null,
    next: null,
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  };
  if (!prev) {
    node.prev = node;
    node.next = node;
  } else {
    node.next = prev.next;
    node.prev = prev;
    prev.next.prev = node;
    prev.next = node;
  }
  return node;
}
function getSqDist$1(p1, p2) {
  var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
}
function sqSegDist(p, p1, p2) {
  var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
  if (dx !== 0 || dy !== 0) {
    var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x2 = p2[0];
      y2 = p2[1];
    } else if (t > 0) {
      x2 += dx * t;
      y2 += dy * t;
    }
  }
  dx = p[0] - x2;
  dy = p[1] - y2;
  return dx * dx + dy * dy;
}
function sqSegSegDist(x02, y02, x12, y12, x2, y2, x3, y3) {
  var ux = x12 - x02;
  var uy = y12 - y02;
  var vx = x3 - x2;
  var vy = y3 - y2;
  var wx2 = x02 - x2;
  var wy = y02 - y2;
  var a = ux * ux + uy * uy;
  var b = ux * vx + uy * vy;
  var c = vx * vx + vy * vy;
  var d = ux * wx2 + uy * wy;
  var e2 = vx * wx2 + vy * wy;
  var D = a * c - b * b;
  var sc, sN, tc, tN;
  var sD = D;
  var tD = D;
  if (D === 0) {
    sN = 0;
    sD = 1;
    tN = e2;
    tD = c;
  } else {
    sN = b * e2 - c * d;
    tN = a * e2 - b * d;
    if (sN < 0) {
      sN = 0;
      tN = e2;
      tD = c;
    } else if (sN > sD) {
      sN = sD;
      tN = e2 + b;
      tD = c;
    }
  }
  if (tN < 0) {
    tN = 0;
    if (-d < 0)
      sN = 0;
    else if (-d > a)
      sN = sD;
    else {
      sN = -d;
      sD = a;
    }
  } else if (tN > tD) {
    tN = tD;
    if (-d + b < 0)
      sN = 0;
    else if (-d + b > a)
      sN = sD;
    else {
      sN = -d + b;
      sD = a;
    }
  }
  sc = sN === 0 ? 0 : sN / sD;
  tc = tN === 0 ? 0 : tN / tD;
  var cx = (1 - sc) * x02 + sc * x12;
  var cy = (1 - sc) * y02 + sc * y12;
  var cx2 = (1 - tc) * x2 + tc * x3;
  var cy2 = (1 - tc) * y2 + tc * y3;
  var dx = cx2 - cx;
  var dy = cy2 - cy;
  return dx * dx + dy * dy;
}
function compareByX(a, b) {
  return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
}
function convexHull(points2) {
  points2.sort(compareByX);
  var lower = [];
  for (var i = 0; i < points2.length; i++) {
    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points2[i]) <= 0) {
      lower.pop();
    }
    lower.push(points2[i]);
  }
  var upper = [];
  for (var ii = points2.length - 1; ii >= 0; ii--) {
    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points2[ii]) <= 0) {
      upper.pop();
    }
    upper.push(points2[ii]);
  }
  upper.pop();
  lower.pop();
  return lower.concat(upper);
}
var concaveman$1 = concaveman$2.exports;
function convex(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  options.concavity = options.concavity || Infinity;
  var points2 = [];
  coordEach(geojson, function(coord) {
    points2.push([coord[0], coord[1]]);
  });
  if (!points2.length) {
    return null;
  }
  var convexHull2 = concaveman$1(points2, options.concavity);
  if (convexHull2.length > 3) {
    return polygon([convexHull2]);
  }
  return null;
}
function booleanPointInPolygon(point4, polygon4, options) {
  if (options === void 0) {
    options = {};
  }
  if (!point4) {
    throw new Error("point is required");
  }
  if (!polygon4) {
    throw new Error("polygon is required");
  }
  var pt = getCoord(point4);
  var geom = getGeom(polygon4);
  var type = geom.type;
  var bbox2 = polygon4.bbox;
  var polys = geom.coordinates;
  if (bbox2 && inBBox(pt, bbox2) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  var insidePoly = false;
  for (var i = 0; i < polys.length && !insidePoly; i++) {
    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
      var inHole = false;
      var k = 1;
      while (k < polys[i].length && !inHole) {
        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
          inHole = true;
        }
        k++;
      }
      if (!inHole) {
        insidePoly = true;
      }
    }
  }
  return insidePoly;
}
function inRing(pt, ring, ignoreBoundary) {
  var isInside2 = false;
  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
    ring = ring.slice(0, ring.length - 1);
  }
  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    var xi = ring[i][0];
    var yi = ring[i][1];
    var xj = ring[j][0];
    var yj = ring[j][1];
    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
    if (onBoundary) {
      return !ignoreBoundary;
    }
    var intersect2 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
    if (intersect2) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function inBBox(pt, bbox2) {
  return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
}
function pointsWithinPolygon(points2, polygons2) {
  var results = [];
  featureEach$1(points2, function(point4) {
    var contained = false;
    if (point4.geometry.type === "Point") {
      geomEach(polygons2, function(polygon4) {
        if (booleanPointInPolygon(point4, polygon4))
          contained = true;
      });
      if (contained) {
        results.push(point4);
      }
    } else if (point4.geometry.type === "MultiPoint") {
      var pointsWithin = [];
      geomEach(polygons2, function(polygon4) {
        coordEach(point4, function(pointCoord) {
          if (booleanPointInPolygon(pointCoord, polygon4)) {
            contained = true;
            pointsWithin.push(pointCoord);
          }
        });
      });
      if (contained) {
        results.push(multiPoint(pointsWithin));
      }
    } else {
      throw new Error("Input geometry must be a Point or MultiPoint");
    }
  });
  return featureCollection$1(results);
}
function distance$2(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
function tin(points2, z) {
  var isPointZ = false;
  return featureCollection$1(triangulate(points2.features.map(function(p) {
    var point4 = {
      x: p.geometry.coordinates[0],
      y: p.geometry.coordinates[1]
    };
    if (z) {
      point4.z = p.properties[z];
    } else if (p.geometry.coordinates.length === 3) {
      isPointZ = true;
      point4.z = p.geometry.coordinates[2];
    }
    return point4;
  })).map(function(triangle) {
    var a = [triangle.a.x, triangle.a.y];
    var b = [triangle.b.x, triangle.b.y];
    var c = [triangle.c.x, triangle.c.y];
    var properties = {};
    if (isPointZ) {
      a.push(triangle.a.z);
      b.push(triangle.b.z);
      c.push(triangle.c.z);
    } else {
      properties = {
        a: triangle.a.z,
        b: triangle.b.z,
        c: triangle.c.z
      };
    }
    return polygon([[a, b, c, a]], properties);
  }));
}
var Triangle$2 = function() {
  function Triangle3(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
    var A = b.x - a.x;
    var B2 = b.y - a.y;
    var C = c.x - a.x;
    var D = c.y - a.y;
    var E = A * (a.x + b.x) + B2 * (a.y + b.y);
    var F = C * (a.x + c.x) + D * (a.y + c.y);
    var G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
    var dx;
    var dy;
    this.x = (D * E - B2 * F) / G;
    this.y = (A * F - C * E) / G;
    dx = this.x - a.x;
    dy = this.y - a.y;
    this.r = dx * dx + dy * dy;
  }
  return Triangle3;
}();
function byX(a, b) {
  return b.x - a.x;
}
function dedup$1(edges2) {
  var j = edges2.length;
  var a;
  var b;
  var i;
  var m2;
  var n;
  outer:
    while (j) {
      b = edges2[--j];
      a = edges2[--j];
      i = j;
      while (i) {
        n = edges2[--i];
        m2 = edges2[--i];
        if (a === m2 && b === n || a === n && b === m2) {
          edges2.splice(j, 2);
          edges2.splice(i, 2);
          j -= 2;
          continue outer;
        }
      }
    }
}
function triangulate(vertices) {
  if (vertices.length < 3) {
    return [];
  }
  vertices.sort(byX);
  var i = vertices.length - 1;
  var xmin = vertices[i].x;
  var xmax = vertices[0].x;
  var ymin = vertices[i].y;
  var ymax = ymin;
  var epsilon3 = 1e-12;
  var a;
  var b;
  var c;
  var A;
  var B2;
  var G;
  while (i--) {
    if (vertices[i].y < ymin) {
      ymin = vertices[i].y;
    }
    if (vertices[i].y > ymax) {
      ymax = vertices[i].y;
    }
  }
  var dx = xmax - xmin;
  var dy = ymax - ymin;
  var dmax = dx > dy ? dx : dy;
  var xmid = (xmax + xmin) * 0.5;
  var ymid = (ymax + ymin) * 0.5;
  var open = [
    new Triangle$2({
      __sentinel: true,
      x: xmid - 20 * dmax,
      y: ymid - dmax
    }, {
      __sentinel: true,
      x: xmid,
      y: ymid + 20 * dmax
    }, {
      __sentinel: true,
      x: xmid + 20 * dmax,
      y: ymid - dmax
    })
  ];
  var closed = [];
  var edges2 = [];
  var j;
  i = vertices.length;
  while (i--) {
    edges2.length = 0;
    j = open.length;
    while (j--) {
      dx = vertices[i].x - open[j].x;
      if (dx > 0 && dx * dx > open[j].r) {
        closed.push(open[j]);
        open.splice(j, 1);
        continue;
      }
      dy = vertices[i].y - open[j].y;
      if (dx * dx + dy * dy > open[j].r) {
        continue;
      }
      edges2.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
      open.splice(j, 1);
    }
    dedup$1(edges2);
    j = edges2.length;
    while (j) {
      b = edges2[--j];
      a = edges2[--j];
      c = vertices[i];
      A = b.x - a.x;
      B2 = b.y - a.y;
      G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
      if (Math.abs(G) > epsilon3) {
        open.push(new Triangle$2(a, b, c));
      }
    }
  }
  Array.prototype.push.apply(closed, open);
  i = closed.length;
  while (i--) {
    if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
      closed.splice(i, 1);
    }
  }
  return closed;
}
function clone$5(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
}
function cloneProperties(properties) {
  var cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map(function(item) {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map(function(feature2) {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry2) {
  var geom = { type: geometry2.type };
  if (geometry2.bbox) {
    geom.bbox = geometry2.bbox;
  }
  if (geometry2.type === "GeometryCollection") {
    geom.geometries = geometry2.geometries.map(function(g) {
      return cloneGeometry(g);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry2.coordinates);
  return geom;
}
function deepSlice(coords) {
  var cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map(function(coord) {
    return deepSlice(coord);
  });
}
function lineDissolve(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject$5(options)) {
    throw new Error("options is invalid");
  }
  var mutate = options.mutate;
  if (getType$1(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (mutate === false || mutate === void 0) {
    geojson = clone$5(geojson);
  }
  var result = [];
  var lastLine = lineReduce(geojson, function(previousLine, currentLine) {
    var merged = mergeLineStrings(previousLine, currentLine);
    if (merged) {
      return merged;
    } else {
      result.push(previousLine);
      return currentLine;
    }
  });
  if (lastLine) {
    result.push(lastLine);
  }
  if (!result.length) {
    return null;
  } else if (result.length === 1) {
    return result[0];
  } else {
    return multiLineString(result.map(function(line) {
      return line.coordinates;
    }));
  }
}
function coordId(coord) {
  return coord[0].toString() + "," + coord[1].toString();
}
function mergeLineStrings(a, b) {
  var coords1 = a.geometry.coordinates;
  var coords2 = b.geometry.coordinates;
  var s1 = coordId(coords1[0]);
  var e1 = coordId(coords1[coords1.length - 1]);
  var s2 = coordId(coords2[0]);
  var e2 = coordId(coords2[coords2.length - 1]);
  var coords;
  if (s1 === e2) {
    coords = coords2.concat(coords1.slice(1));
  } else if (s2 === e1) {
    coords = coords1.concat(coords2.slice(1));
  } else if (s1 === s2) {
    coords = coords1.slice(1).reverse().concat(coords2);
  } else if (e1 === e2) {
    coords = coords1.concat(coords2.reverse().slice(1));
  } else {
    return null;
  }
  return lineString(coords);
}
function identity$2(x2) {
  return x2;
}
function transform(transform4) {
  if (transform4 == null)
    return identity$2;
  var x02, y02, kx = transform4.scale[0], ky = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i)
      x02 = y02 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x02 += input[0]) * kx + dx;
    output[1] = (y02 += input[1]) * ky + dy;
    while (j < n)
      output[j] = input[j], ++j;
    return output;
  };
}
function reverse$2(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j)
    t = array[i], array[i++] = array[j], array[j] = t;
}
function object(topology2, o) {
  var transformPoint2 = transform(topology2.transform), arcs = topology2.arcs;
  function arc(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points2.push(transformPoint2(a[k], k));
    }
    if (i < 0)
      reverse$2(points2, n);
  }
  function point4(p) {
    return transformPoint2(p);
  }
  function line(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon4(arcs2) {
    return arcs2.map(ring);
  }
  function geometry2(o2) {
    var type = o2.type, coordinates;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o2.geometries.map(geometry2) };
      case "Point":
        coordinates = point4(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point4);
        break;
      case "LineString":
        coordinates = line(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line);
        break;
      case "Polygon":
        coordinates = polygon4(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon4);
        break;
      default:
        return null;
    }
    return { type, coordinates };
  }
  return geometry2(o);
}
function stitch(topology2, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc = topology2.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e2 = ends(i), start2 = e2[0], end2 = e2[1], f, g;
    if (f = fragmentByEnd[start2]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end2;
      if (g = fragmentByStart[end2]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end2]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start2;
      if (g = fragmentByEnd[start2]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start2] = fragmentByEnd[f.end = end2] = f;
    }
  });
  function ends(i) {
    var arc = topology2.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology2.transform)
      p1 = [0, 0], arc.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}
function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area5 = 0;
  while (++i < n)
    a = b, b = ring[i], area5 += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area5);
}
function merge$4(topology2) {
  return object(topology2, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology2, objects) {
  var polygonsByArc = {}, polygons2 = [], groups = [];
  objects.forEach(geometry2);
  function geometry2(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry2);
        break;
      case "Polygon":
        extract3(o.arcs);
        break;
      case "MultiPolygon":
        o.arcs.forEach(extract3);
        break;
    }
  }
  function extract3(polygon4) {
    polygon4.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon4);
      });
    });
    polygons2.push(polygon4);
  }
  function area5(ring) {
    return planarRingArea(object(topology2, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons2.forEach(function(polygon4) {
    if (!polygon4._) {
      var group = [], neighbors = [polygon4];
      polygon4._ = 1;
      groups.push(group);
      while (polygon4 = neighbors.pop()) {
        group.push(polygon4);
        polygon4.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon5) {
              if (!polygon5._) {
                polygon5._ = 1;
                neighbors.push(polygon5);
              }
            });
          });
        });
      }
    }
  });
  polygons2.forEach(function(polygon4) {
    delete polygon4._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons3) {
      var arcs = [], n;
      polygons3.forEach(function(polygon4) {
        polygon4.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch(topology2, arcs);
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area5(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area5(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }
      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function bounds(objects) {
  var x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
  function boundGeometry(geometry2) {
    if (geometry2 != null && hasOwnProperty.call(boundGeometryType, geometry2.type))
      boundGeometryType[geometry2.type](geometry2);
  }
  var boundGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(boundGeometry);
    },
    Point: function(o) {
      boundPoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates.forEach(boundPoint);
    },
    LineString: function(o) {
      boundLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs.forEach(boundLine);
    },
    Polygon: function(o) {
      o.arcs.forEach(boundLine);
    },
    MultiPolygon: function(o) {
      o.arcs.forEach(boundMultiLine);
    }
  };
  function boundPoint(coordinates) {
    var x2 = coordinates[0], y2 = coordinates[1];
    if (x2 < x02)
      x02 = x2;
    if (x2 > x12)
      x12 = x2;
    if (y2 < y02)
      y02 = y2;
    if (y2 > y12)
      y12 = y2;
  }
  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }
  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }
  for (var key in objects) {
    boundGeometry(objects[key]);
  }
  return x12 >= x02 && y12 >= y02 ? [x02, y02, x12, y12] : void 0;
}
function hashset(size11, hash, equal2, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }
  var store = new type(size11 = 1 << Math.max(4, Math.ceil(Math.log(size11) / Math.LN2))), mask2 = size11 - 1;
  for (var i = 0; i < size11; ++i) {
    store[i] = empty;
  }
  function add16(value) {
    var index2 = hash(value) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal2(match, value))
        return true;
      if (++collisions >= size11)
        throw new Error("full hashset");
      match = store[index2 = index2 + 1 & mask2];
    }
    store[index2] = value;
    return true;
  }
  function has2(value) {
    var index2 = hash(value) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal2(match, value))
        return true;
      if (++collisions >= size11)
        break;
      match = store[index2 = index2 + 1 & mask2];
    }
    return false;
  }
  function values3() {
    var values4 = [];
    for (var i2 = 0, n = store.length; i2 < n; ++i2) {
      var match = store[i2];
      if (match != empty)
        values4.push(match);
    }
    return values4;
  }
  return {
    add: add16,
    has: has2,
    values: values3
  };
}
function hashmap(size11, hash, equal2, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }
  var keystore = new keyType(size11 = 1 << Math.max(4, Math.ceil(Math.log(size11) / Math.LN2))), valstore = new valueType(size11), mask2 = size11 - 1;
  for (var i = 0; i < size11; ++i) {
    keystore[i] = keyEmpty;
  }
  function set2(key, value) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal2(matchKey, key))
        return valstore[index2] = value;
      if (++collisions >= size11)
        throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key;
    valstore[index2] = value;
    return value;
  }
  function maybeSet(key, value) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal2(matchKey, key))
        return valstore[index2];
      if (++collisions >= size11)
        throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key;
    valstore[index2] = value;
    return value;
  }
  function get5(key, missingValue) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal2(matchKey, key))
        return valstore[index2];
      if (++collisions >= size11)
        break;
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    return missingValue;
  }
  function keys3() {
    var keys4 = [];
    for (var i2 = 0, n = keystore.length; i2 < n; ++i2) {
      var matchKey = keystore[i2];
      if (matchKey != keyEmpty)
        keys4.push(matchKey);
    }
    return keys4;
  }
  return {
    set: set2,
    maybeSet,
    get: get5,
    keys: keys3
  };
}
function equalPoint(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}
var buffer$1 = new ArrayBuffer(16), floats = new Float64Array(buffer$1), uints = new Uint32Array(buffer$1);
function hashPoint(point4) {
  floats[0] = point4[0];
  floats[1] = point4[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 2147483647;
}
function join(topology2) {
  var coordinates = topology2.coordinates, lines = topology2.lines, rings = topology2.rings, indexes = index2(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i, n, previousIndex, currentIndex, nextIndex;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
  }
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineStart = line[0], lineEnd = line[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1;
    while (++lineStart <= lineEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1;
  }
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = -1;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0] + 1, ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }
  function sequence(i2, previousIndex2, currentIndex2, nextIndex2) {
    if (visitedByIndex[currentIndex2] === i2)
      return;
    visitedByIndex[currentIndex2] = i2;
    var leftIndex = leftByIndex[currentIndex2];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex2];
      if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
        ++junctionCount, junctionByIndex[currentIndex2] = 1;
      }
    } else {
      leftByIndex[currentIndex2] = previousIndex2;
      rightByIndex[currentIndex2] = nextIndex2;
    }
  }
  function index2() {
    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
    for (var i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
      indexes2[i2] = indexByPoint.maybeSet(i2, i2);
    }
    return indexes2;
  }
  function hashIndex(i2) {
    return hashPoint(coordinates[i2]);
  }
  function equalIndex(i2, j2) {
    return equalPoint(coordinates[i2], coordinates[j2]);
  }
  visitedByIndex = leftByIndex = rightByIndex = null;
  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    if (junctionByIndex[j = indexes[i]]) {
      junctionByPoint.add(coordinates[j]);
    }
  }
  return junctionByPoint;
}
function cut(topology2) {
  var junctions = join(topology2), coordinates = topology2.coordinates, lines = topology2.lines, rings = topology2.rings, next3, i, n;
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineMid = line[0], lineEnd = line[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next3 = { 0: lineMid, 1: line[1] };
        line[1] = lineMid;
        line = line.next = next3;
      }
    }
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next3 = { 0: ringMid, 1: ring[1] };
          ring[1] = ringMid;
          ring = ring.next = next3;
        } else {
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart;
        }
      }
    }
  }
  return topology2;
}
function rotateArray(array, start2, end2, offset) {
  reverse$1(array, start2, end2);
  reverse$1(array, start2, start2 + offset);
  reverse$1(array, start2 + offset, end2);
}
function reverse$1(array, start2, end2) {
  for (var mid = start2 + (end2-- - start2 >> 1), t; start2 < mid; ++start2, --end2) {
    t = array[start2], array[start2] = array[end2], array[end2] = t;
  }
}
function dedup(topology2) {
  var coordinates = topology2.coordinates, lines = topology2.lines, line, rings = topology2.rings, ring, arcCount = lines.length + rings.length, i, n;
  delete topology2.lines;
  delete topology2.rings;
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    while (line = line.next)
      ++arcCount;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    while (ring = ring.next)
      ++arcCount;
  }
  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint), arcs = topology2.arcs = [];
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    do {
      dedupLine(line);
    } while (line = line.next);
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    if (ring.next) {
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }
  function dedupLine(arc) {
    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i2, n2;
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = startArcs.length; i2 < n2; ++i2) {
        startArc = startArcs[i2];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }
    if (startArcs)
      startArcs.push(arc);
    else
      arcsByEnd.set(startPoint, [arc]);
    if (endArcs)
      endArcs.push(arc);
    else
      arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function dedupRing(arc) {
    var endPoint, endArcs, endArc, i2, n2;
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs)
      endArcs.push(arc);
    else
      arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb)
      return false;
    for (; ia <= ja; ++ia, ++ib)
      if (!equalPoint(coordinates[ia], coordinates[ib]))
        return false;
    return true;
  }
  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb)
      return false;
    for (; ia <= ja; ++ia, --jb)
      if (!equalPoint(coordinates[ia], coordinates[jb]))
        return false;
    return true;
  }
  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib)
      return false;
    var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!equalPoint(coordinates[ia + (i2 + ka) % n2], coordinates[ib + (i2 + kb) % n2]))
        return false;
    }
    return true;
  }
  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib)
      return false;
    var ka = findMinimumOffset(arcA), kb = n2 - findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!equalPoint(coordinates[ia + (i2 + ka) % n2], coordinates[jb - (i2 + kb) % n2]))
        return false;
    }
    return true;
  }
  function findMinimumOffset(arc) {
    var start2 = arc[0], end2 = arc[1], mid = start2, minimum = mid, minimumPoint = coordinates[mid];
    while (++mid < end2) {
      var point4 = coordinates[mid];
      if (point4[0] < minimumPoint[0] || point4[0] === minimumPoint[0] && point4[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point4;
      }
    }
    return minimum - start2;
  }
  return topology2;
}
function delta(arcs) {
  var i = -1, n = arcs.length;
  while (++i < n) {
    var arc = arcs[i], j = 0, k = 1, m2 = arc.length, point4 = arc[0], x02 = point4[0], y02 = point4[1], x12, y12;
    while (++j < m2) {
      point4 = arc[j], x12 = point4[0], y12 = point4[1];
      if (x12 !== x02 || y12 !== y02)
        arc[k++] = [x12 - x02, y12 - y02], x02 = x12, y02 = y12;
    }
    if (k === 1)
      arc[k++] = [0, 0];
    arc.length = k;
  }
  return arcs;
}
function extract$2(objects) {
  var index2 = -1, lines = [], rings = [], coordinates = [];
  function extractGeometry2(geometry2) {
    if (geometry2 && hasOwnProperty.call(extractGeometryType, geometry2.type))
      extractGeometryType[geometry2.type](geometry2);
  }
  var extractGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(extractGeometry2);
    },
    LineString: function(o) {
      o.arcs = extractLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(extractLine);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(extractRing);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(extractMultiRing);
    }
  };
  function extractLine(line) {
    for (var i = 0, n = line.length; i < n; ++i)
      coordinates[++index2] = line[i];
    var arc = { 0: index2 - n + 1, 1: index2 };
    lines.push(arc);
    return arc;
  }
  function extractRing(ring) {
    for (var i = 0, n = ring.length; i < n; ++i)
      coordinates[++index2] = ring[i];
    var arc = { 0: index2 - n + 1, 1: index2 };
    rings.push(arc);
    return arc;
  }
  function extractMultiRing(rings2) {
    return rings2.map(extractRing);
  }
  for (var key in objects) {
    extractGeometry2(objects[key]);
  }
  return {
    type: "Topology",
    coordinates,
    lines,
    rings,
    objects
  };
}
function geometry(inputs) {
  var outputs = {}, key;
  for (key in inputs)
    outputs[key] = geomifyObject(inputs[key]);
  return outputs;
}
function geomifyObject(input) {
  return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
  var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}
function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key;
  if (input.id != null)
    output.id = input.id;
  if (input.bbox != null)
    output.bbox = input.bbox;
  for (key in input.properties) {
    output.properties = input.properties;
    break;
  }
  return output;
}
function geomifyGeometry(input) {
  if (input == null)
    return { type: null };
  var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}
function prequantize(objects, bbox2, n) {
  var x02 = bbox2[0], y02 = bbox2[1], x12 = bbox2[2], y12 = bbox2[3], kx = x12 - x02 ? (n - 1) / (x12 - x02) : 1, ky = y12 - y02 ? (n - 1) / (y12 - y02) : 1;
  function quantizePoint(input) {
    return [Math.round((input[0] - x02) * kx), Math.round((input[1] - y02) * ky)];
  }
  function quantizePoints(input, m2) {
    var i = -1, j = 0, n2 = input.length, output = new Array(n2), pi2, px, py, x2, y2;
    while (++i < n2) {
      pi2 = input[i];
      x2 = Math.round((pi2[0] - x02) * kx);
      y2 = Math.round((pi2[1] - y02) * ky);
      if (x2 !== px || y2 !== py)
        output[j++] = [px = x2, py = y2];
    }
    output.length = j;
    while (j < m2)
      j = output.push([output[0][0], output[0][1]]);
    return output;
  }
  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }
  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }
  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }
  function quantizeGeometry(o) {
    if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type))
      quantizeGeometryType[o.type](o);
  }
  var quantizeGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(quantizeGeometry);
    },
    Point: function(o) {
      o.coordinates = quantizePoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates = o.coordinates.map(quantizePoint);
    },
    LineString: function(o) {
      o.arcs = quantizeLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(quantizeLine);
    },
    Polygon: function(o) {
      o.arcs = quantizePolygon(o.arcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(quantizePolygon);
    }
  };
  for (var key in objects) {
    quantizeGeometry(objects[key]);
  }
  return {
    scale: [1 / kx, 1 / ky],
    translate: [x02, y02]
  };
}
function topology(objects, quantization) {
  var bbox2 = bounds(objects = geometry(objects)), transform4 = quantization > 0 && bbox2 && prequantize(objects, bbox2, quantization), topology2 = dedup(cut(extract$2(objects))), coordinates = topology2.coordinates, indexByArc = hashmap(topology2.arcs.length * 1.4, hashArc, equalArc);
  objects = topology2.objects;
  topology2.bbox = bbox2;
  topology2.arcs = topology2.arcs.map(function(arc, i) {
    indexByArc.set(arc, i);
    return coordinates.slice(arc[0], arc[1] + 1);
  });
  delete topology2.coordinates;
  coordinates = null;
  function indexGeometry(geometry2) {
    if (geometry2 && hasOwnProperty.call(indexGeometryType, geometry2.type))
      indexGeometryType[geometry2.type](geometry2);
  }
  var indexGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(indexGeometry);
    },
    LineString: function(o) {
      o.arcs = indexArcs(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(indexMultiArcs);
    }
  };
  function indexArcs(arc) {
    var indexes = [];
    do {
      var index2 = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index2 : ~index2);
    } while (arc = arc.next);
    return indexes;
  }
  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }
  for (var key in objects) {
    indexGeometry(objects[key]);
  }
  if (transform4) {
    topology2.transform = transform4;
    topology2.arcs = delta(topology2.arcs);
  }
  return topology2;
}
function hashArc(arc) {
  var i = arc[0], j = arc[1], t;
  if (j < i)
    t = i, i = j, j = t;
  return i + 31 * j;
}
function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t;
  if (ja < ia)
    t = ia, ia = ja, ja = t;
  if (jb < ib)
    t = ib, ib = jb, jb = t;
  return ia === ib && ja === jb;
}
function polygonDissolve(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  if (getType$1(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (options.mutate === false || options.mutate === void 0) {
    geojson = clone$5(geojson);
  }
  var geoms = [];
  flattenEach(geojson, function(feature2) {
    geoms.push(feature2.geometry);
  });
  var topo = topology({ geoms: geometryCollection(geoms).geometry });
  var merged = merge$4(topo, topo.objects.geoms.geometries);
  return merged;
}
function dissolve$1(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject$5(options)) {
    throw new Error("options is invalid");
  }
  var mutate = options.mutate;
  if (getType$1(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (mutate === false || mutate === void 0) {
    geojson = clone$5(geojson);
  }
  var type = getHomogenousType(geojson);
  if (!type) {
    throw new Error("geojson must be homogenous");
  }
  var data = geojson;
  switch (type) {
    case "LineString":
      return lineDissolve(data, options);
    case "Polygon":
      return polygonDissolve(data, options);
    default:
      throw new Error(type + " is not supported");
  }
}
function getHomogenousType(geojson) {
  var types = {};
  flattenEach(geojson, function(feature2) {
    types[feature2.geometry.type] = true;
  });
  var keys3 = Object.keys(types);
  if (keys3.length === 1) {
    return keys3[0];
  }
  return null;
}
function concave(points2, options) {
  if (options === void 0) {
    options = {};
  }
  var maxEdge = options.maxEdge || Infinity;
  var cleaned = removeDuplicates(points2);
  var tinPolys = tin(cleaned);
  tinPolys.features = tinPolys.features.filter(function(triangle) {
    var pt12 = triangle.geometry.coordinates[0][0];
    var pt22 = triangle.geometry.coordinates[0][1];
    var pt3 = triangle.geometry.coordinates[0][2];
    var dist1 = distance$2(pt12, pt22, options);
    var dist22 = distance$2(pt22, pt3, options);
    var dist3 = distance$2(pt12, pt3, options);
    return dist1 <= maxEdge && dist22 <= maxEdge && dist3 <= maxEdge;
  });
  if (tinPolys.features.length < 1) {
    return null;
  }
  var dissolved = dissolve$1(tinPolys);
  if (dissolved.coordinates.length === 1) {
    dissolved.coordinates = dissolved.coordinates[0];
    dissolved.type = "Polygon";
  }
  return feature(dissolved);
}
function removeDuplicates(points2) {
  var cleaned = [];
  var existing = {};
  featureEach$1(points2, function(pt) {
    if (!pt.geometry) {
      return;
    }
    var key = pt.geometry.coordinates.join("-");
    if (!Object.prototype.hasOwnProperty.call(existing, key)) {
      cleaned.push(pt);
      existing[key] = true;
    }
  });
  return featureCollection$1(cleaned);
}
var rbush$4 = { exports: {} };
var quickselect$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function quickselect2(arr, k, left, right, compare11) {
      quickselectStep(arr, k, left || 0, right || arr.length - 1, compare11 || defaultCompare2);
    }
    function quickselectStep(arr, k, left, right, compare11) {
      while (right > left) {
        if (right - left > 600) {
          var n = right - left + 1;
          var m2 = k - left + 1;
          var z = Math.log(n);
          var s = 0.5 * Math.exp(2 * z / 3);
          var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
          var newLeft = Math.max(left, Math.floor(k - m2 * s / n + sd));
          var newRight = Math.min(right, Math.floor(k + (n - m2) * s / n + sd));
          quickselectStep(arr, k, newLeft, newRight, compare11);
        }
        var t = arr[k];
        var i = left;
        var j = right;
        swap2(arr, left, k);
        if (compare11(arr[right], t) > 0)
          swap2(arr, left, right);
        while (i < j) {
          swap2(arr, i, j);
          i++;
          j--;
          while (compare11(arr[i], t) < 0)
            i++;
          while (compare11(arr[j], t) > 0)
            j--;
        }
        if (compare11(arr[left], t) === 0)
          swap2(arr, left, j);
        else {
          j++;
          swap2(arr, j, right);
        }
        if (j <= k)
          left = j + 1;
        if (k <= j)
          right = j - 1;
      }
    }
    function swap2(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    function defaultCompare2(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    return quickselect2;
  });
})(quickselect$1);
rbush$4.exports = rbush$2;
rbush$4.exports.default = rbush$2;
var quickselect = quickselect$1.exports;
function rbush$2(maxEntries, format2) {
  if (!(this instanceof rbush$2))
    return new rbush$2(maxEntries, format2);
  this._maxEntries = Math.max(4, maxEntries || 9);
  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
  if (format2) {
    this._initFormat(format2);
  }
  this.clear();
}
rbush$2.prototype = {
  all: function() {
    return this._all(this.data, []);
  },
  search: function(bbox2) {
    var node = this.data, result = [], toBBox = this.toBBox;
    if (!intersects$2(bbox2, node))
      return result;
    var nodesToSearch = [], i, len2, child, childBBox;
    while (node) {
      for (i = 0, len2 = node.children.length; i < len2; i++) {
        child = node.children[i];
        childBBox = node.leaf ? toBBox(child) : child;
        if (intersects$2(bbox2, childBBox)) {
          if (node.leaf)
            result.push(child);
          else if (contains(bbox2, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  },
  collides: function(bbox2) {
    var node = this.data, toBBox = this.toBBox;
    if (!intersects$2(bbox2, node))
      return false;
    var nodesToSearch = [], i, len2, child, childBBox;
    while (node) {
      for (i = 0, len2 = node.children.length; i < len2; i++) {
        child = node.children[i];
        childBBox = node.leaf ? toBBox(child) : child;
        if (intersects$2(bbox2, childBBox)) {
          if (node.leaf || contains(bbox2, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  },
  load: function(data) {
    if (!(data && data.length))
      return this;
    if (data.length < this._minEntries) {
      for (var i = 0, len2 = data.length; i < len2; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    var node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        var tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  },
  insert: function(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  },
  clear: function() {
    this.data = createNode([]);
    return this;
  },
  remove: function(item, equalsFn) {
    if (!item)
      return this;
    var node = this.data, bbox2 = this.toBBox(item), path = [], indexes = [], i, parent, index2, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        index2 = findItem(item, node.children, equalsFn);
        if (index2 !== -1) {
          node.children.splice(index2, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox2)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else
        node = null;
    }
    return this;
  },
  toBBox: function(item) {
    return item;
  },
  compareMinX: compareNodeMinX,
  compareMinY: compareNodeMinY,
  toJSON: function() {
    return this.data;
  },
  fromJSON: function(data) {
    this.data = data;
    return this;
  },
  _all: function(node, result) {
    var nodesToSearch = [];
    while (node) {
      if (node.leaf)
        result.push.apply(result, node.children);
      else
        nodesToSearch.push.apply(nodesToSearch, node.children);
      node = nodesToSearch.pop();
    }
    return result;
  },
  _build: function(items, left, right, height) {
    var N = right - left + 1, M = this._maxEntries, node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
    multiSelect(items, left, right, N1, this.compareMinX);
    for (i = left; i <= right; i += N1) {
      right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (j = i; j <= right2; j += N2) {
        right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  },
  _chooseSubtree: function(bbox2, node, level, path) {
    var i, len2, child, targetNode, area5, enlargement, minArea, minEnlargement;
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level)
        break;
      minArea = minEnlargement = Infinity;
      for (i = 0, len2 = node.children.length; i < len2; i++) {
        child = node.children[i];
        area5 = bboxArea(child);
        enlargement = enlargedArea(bbox2, child) - area5;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area5 < minArea ? area5 : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area5 < minArea) {
            minArea = area5;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  },
  _insert: function(item, level, isNode) {
    var toBBox = this.toBBox, bbox2 = isNode ? item : toBBox(item), insertPath = [];
    var node = this._chooseSubtree(bbox2, this.data, level, insertPath);
    node.children.push(item);
    extend$2(node, bbox2);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox2, insertPath, level);
  },
  _split: function(insertPath, level) {
    var node = insertPath[level], M = node.children.length, m2 = this._minEntries;
    this._chooseSplitAxis(node, m2, M);
    var splitIndex = this._chooseSplitIndex(node, m2, M);
    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node, newNode);
  },
  _splitRoot: function(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  },
  _chooseSplitIndex: function(node, m2, M) {
    var i, bbox1, bbox2, overlap2, area5, minOverlap, minArea, index2;
    minOverlap = minArea = Infinity;
    for (i = m2; i <= M - m2; i++) {
      bbox1 = distBBox(node, 0, i, this.toBBox);
      bbox2 = distBBox(node, i, M, this.toBBox);
      overlap2 = intersectionArea(bbox1, bbox2);
      area5 = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap2 < minOverlap) {
        minOverlap = overlap2;
        index2 = i;
        minArea = area5 < minArea ? area5 : minArea;
      } else if (overlap2 === minOverlap) {
        if (area5 < minArea) {
          minArea = area5;
          index2 = i;
        }
      }
    }
    return index2;
  },
  _chooseSplitAxis: function(node, m2, M) {
    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m2, M, compareMinX), yMargin = this._allDistMargin(node, m2, M, compareMinY);
    if (xMargin < yMargin)
      node.children.sort(compareMinX);
  },
  _allDistMargin: function(node, m2, M, compare11) {
    node.children.sort(compare11);
    var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m2, toBBox), rightBBox = distBBox(node, M - m2, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
    for (i = m2; i < M - m2; i++) {
      child = node.children[i];
      extend$2(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (i = M - m2 - 1; i >= m2; i--) {
      child = node.children[i];
      extend$2(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  },
  _adjustParentBBoxes: function(bbox2, path, level) {
    for (var i = level; i >= 0; i--) {
      extend$2(path[i], bbox2);
    }
  },
  _condense: function(path) {
    for (var i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else
          this.clear();
      } else
        calcBBox(path[i], this.toBBox);
    }
  },
  _initFormat: function(format2) {
    var compareArr = ["return a", " - b", ";"];
    this.compareMinX = new Function("a", "b", compareArr.join(format2[0]));
    this.compareMinY = new Function("a", "b", compareArr.join(format2[1]));
    this.toBBox = new Function(
      "a",
      "return {minX: a" + format2[0] + ", minY: a" + format2[1] + ", maxX: a" + format2[2] + ", maxY: a" + format2[3] + "};"
    );
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (var i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (var i = k, child; i < p; i++) {
    child = node.children[i];
    extend$2(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend$2(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  var minX2 = Math.max(a.minX, b.minX), minY2 = Math.max(a.minY, b.minY), maxX2 = Math.min(a.maxX, b.maxX), maxY2 = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX2 - minX2) * Math.max(0, maxY2 - minY2);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects$2(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare11) {
  var stack = [left, right], mid;
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare11);
    stack.push(left, mid, mid, right);
  }
}
var rbush$3 = rbush$4.exports;
function collect$1(polygons2, points2, inProperty, outProperty) {
  var rtree = rbush$3(6);
  var treeItems = points2.features.map(function(item) {
    var _a2;
    return {
      minX: item.geometry.coordinates[0],
      minY: item.geometry.coordinates[1],
      maxX: item.geometry.coordinates[0],
      maxY: item.geometry.coordinates[1],
      property: (_a2 = item.properties) === null || _a2 === void 0 ? void 0 : _a2[inProperty]
    };
  });
  rtree.load(treeItems);
  polygons2.features.forEach(function(poly) {
    if (!poly.properties) {
      poly.properties = {};
    }
    var bbox2 = bbox$1(poly);
    var potentialPoints = rtree.search({
      minX: bbox2[0],
      minY: bbox2[1],
      maxX: bbox2[2],
      maxY: bbox2[3]
    });
    var values3 = [];
    potentialPoints.forEach(function(pt) {
      if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {
        values3.push(pt.property);
      }
    });
    poly.properties[outProperty] = values3;
  });
  return polygons2;
}
function flip(geojson, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (mutate === false || mutate === void 0)
    geojson = clone$5(geojson);
  coordEach(geojson, function(coord) {
    var x2 = coord[0];
    var y2 = coord[1];
    coord[0] = y2;
    coord[1] = x2;
  });
  return geojson;
}
function cleanCoords(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var mutate = typeof options === "object" ? options.mutate : options;
  if (!geojson)
    throw new Error("geojson is required");
  var type = getType$1(geojson);
  var newCoords = [];
  switch (type) {
    case "LineString":
      newCoords = cleanLine(geojson);
      break;
    case "MultiLineString":
    case "Polygon":
      getCoords(geojson).forEach(function(line) {
        newCoords.push(cleanLine(line));
      });
      break;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(polygons2) {
        var polyPoints = [];
        polygons2.forEach(function(ring) {
          polyPoints.push(cleanLine(ring));
        });
        newCoords.push(polyPoints);
      });
      break;
    case "Point":
      return geojson;
    case "MultiPoint":
      var existing = {};
      getCoords(geojson).forEach(function(coord) {
        var key = coord.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
          newCoords.push(coord);
          existing[key] = true;
        }
      });
      break;
    default:
      throw new Error(type + " geometry not supported");
  }
  if (geojson.coordinates) {
    if (mutate === true) {
      geojson.coordinates = newCoords;
      return geojson;
    }
    return { type, coordinates: newCoords };
  } else {
    if (mutate === true) {
      geojson.geometry.coordinates = newCoords;
      return geojson;
    }
    return feature({ type, coordinates: newCoords }, geojson.properties, {
      bbox: geojson.bbox,
      id: geojson.id
    });
  }
}
function cleanLine(line) {
  var points2 = getCoords(line);
  if (points2.length === 2 && !equals$1(points2[0], points2[1]))
    return points2;
  var newPoints = [];
  var secondToLast = points2.length - 1;
  var newPointsLength = newPoints.length;
  newPoints.push(points2[0]);
  for (var i = 1; i < secondToLast; i++) {
    var prevAddedPoint = newPoints[newPoints.length - 1];
    if (points2[i][0] === prevAddedPoint[0] && points2[i][1] === prevAddedPoint[1])
      continue;
    else {
      newPoints.push(points2[i]);
      newPointsLength = newPoints.length;
      if (newPointsLength > 2) {
        if (isPointOnLineSegment$3(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
          newPoints.splice(newPoints.length - 2, 1);
      }
    }
  }
  newPoints.push(points2[points2.length - 1]);
  newPointsLength = newPoints.length;
  if (equals$1(points2[0], points2[points2.length - 1]) && newPointsLength < 4)
    throw new Error("invalid polygon");
  if (isPointOnLineSegment$3(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
    newPoints.splice(newPoints.length - 2, 1);
  return newPoints;
}
function equals$1(pt12, pt22) {
  return pt12[0] === pt22[0] && pt12[1] === pt22[1];
}
function isPointOnLineSegment$3(start2, end2, point4) {
  var x2 = point4[0], y2 = point4[1];
  var startX = start2[0], startY = start2[1];
  var endX = end2[0], endY = end2[1];
  var dxc = x2 - startX;
  var dyc = y2 - startY;
  var dxl = endX - startX;
  var dyl = endY - startY;
  var cross2 = dxc * dyl - dyc * dxl;
  if (cross2 !== 0)
    return false;
  else if (Math.abs(dxl) >= Math.abs(dyl))
    return dxl > 0 ? startX <= x2 && x2 <= endX : endX <= x2 && x2 <= startX;
  else
    return dyl > 0 ? startY <= y2 && y2 <= endY : endY <= y2 && y2 <= startY;
}
function getSqDist(p1, p2) {
  var dx = p1.x - p2.x, dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
  var x2 = p1.x, y2 = p1.y, dx = p2.x - x2, dy = p2.y - y2;
  if (dx !== 0 || dy !== 0) {
    var t = ((p.x - x2) * dx + (p.y - y2) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x2 = p2.x;
      y2 = p2.y;
    } else if (t > 0) {
      x2 += dx * t;
      y2 += dy * t;
    }
  }
  dx = p.x - x2;
  dy = p.y - y2;
  return dx * dx + dy * dy;
}
function simplifyRadialDist(points2, sqTolerance) {
  var prevPoint = points2[0], newPoints = [prevPoint], point4;
  for (var i = 1, len2 = points2.length; i < len2; i++) {
    point4 = points2[i];
    if (getSqDist(point4, prevPoint) > sqTolerance) {
      newPoints.push(point4);
      prevPoint = point4;
    }
  }
  if (prevPoint !== point4)
    newPoints.push(point4);
  return newPoints;
}
function simplifyDPStep(points2, first, last, sqTolerance, simplified) {
  var maxSqDist = sqTolerance, index2;
  for (var i = first + 1; i < last; i++) {
    var sqDist = getSqSegDist(points2[i], points2[first], points2[last]);
    if (sqDist > maxSqDist) {
      index2 = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index2 - first > 1)
      simplifyDPStep(points2, first, index2, sqTolerance, simplified);
    simplified.push(points2[index2]);
    if (last - index2 > 1)
      simplifyDPStep(points2, index2, last, sqTolerance, simplified);
  }
}
function simplifyDouglasPeucker(points2, sqTolerance) {
  var last = points2.length - 1;
  var simplified = [points2[0]];
  simplifyDPStep(points2, 0, last, sqTolerance, simplified);
  simplified.push(points2[last]);
  return simplified;
}
function simplify(points2, tolerance, highestQuality) {
  if (points2.length <= 2)
    return points2;
  var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  points2 = highestQuality ? points2 : simplifyRadialDist(points2, sqTolerance);
  points2 = simplifyDouglasPeucker(points2, sqTolerance);
  return points2;
}
function simplify$1(geojson, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var tolerance = options.tolerance !== void 0 ? options.tolerance : 1;
  var highQuality = options.highQuality || false;
  var mutate = options.mutate || false;
  if (!geojson)
    throw new Error("geojson is required");
  if (tolerance && tolerance < 0)
    throw new Error("invalid tolerance");
  if (mutate !== true)
    geojson = clone$5(geojson);
  geomEach(geojson, function(geom) {
    simplifyGeom(geom, tolerance, highQuality);
  });
  return geojson;
}
function simplifyGeom(geometry2, tolerance, highQuality) {
  var type = geometry2.type;
  if (type === "Point" || type === "MultiPoint")
    return geometry2;
  cleanCoords(geometry2, true);
  var coordinates = geometry2.coordinates;
  switch (type) {
    case "LineString":
      geometry2["coordinates"] = simplifyLine(
        coordinates,
        tolerance,
        highQuality
      );
      break;
    case "MultiLineString":
      geometry2["coordinates"] = coordinates.map(function(lines) {
        return simplifyLine(lines, tolerance, highQuality);
      });
      break;
    case "Polygon":
      geometry2["coordinates"] = simplifyPolygon(
        coordinates,
        tolerance,
        highQuality
      );
      break;
    case "MultiPolygon":
      geometry2["coordinates"] = coordinates.map(function(rings) {
        return simplifyPolygon(rings, tolerance, highQuality);
      });
  }
  return geometry2;
}
function simplifyLine(coordinates, tolerance, highQuality) {
  return simplify(
    coordinates.map(function(coord) {
      return { x: coord[0], y: coord[1], z: coord[2] };
    }),
    tolerance,
    highQuality
  ).map(function(coords) {
    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
  });
}
function simplifyPolygon(coordinates, tolerance, highQuality) {
  return coordinates.map(function(ring) {
    var pts = ring.map(function(coord) {
      return { x: coord[0], y: coord[1] };
    });
    if (pts.length < 4) {
      throw new Error("invalid polygon");
    }
    var simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
      return [coords.x, coords.y];
    });
    while (!checkValidity(simpleRing)) {
      tolerance -= tolerance * 0.01;
      simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
        return [coords.x, coords.y];
      });
    }
    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
      simpleRing.push(simpleRing[0]);
    }
    return simpleRing;
  });
}
function checkValidity(ring) {
  if (ring.length < 3)
    return false;
  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
}
var Spline = function() {
  function Spline2(options) {
    this.points = options.points || [];
    this.duration = options.duration || 1e4;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    for (var i = 0; i < this.length; i++) {
      this.points[i].z = this.points[i].z || 0;
    }
    for (var i = 0; i < this.length - 1; i++) {
      var p1 = this.points[i];
      var p2 = this.points[i + 1];
      this.centers.push({
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2,
        z: (p1.z + p2.z) / 2
      });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (var i = 0; i < this.centers.length - 1; i++) {
      var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
      var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
      var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
      this.controls.push([
        {
          x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
          y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
          z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
        },
        {
          x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
          y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
          z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
        }
      ]);
    }
    this.controls.push([
      this.points[this.length - 1],
      this.points[this.length - 1]
    ]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
  }
  Spline2.prototype.cacheSteps = function(mindist) {
    var steps = [];
    var laststep = this.pos(0);
    steps.push(0);
    for (var t = 0; t < this.duration; t += 10) {
      var step = this.pos(t);
      var dist3 = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
      if (dist3 > mindist) {
        steps.push(t);
        laststep = step;
      }
    }
    return steps;
  };
  Spline2.prototype.vector = function(t) {
    var p1 = this.pos(t + 10);
    var p2 = this.pos(t - 10);
    return {
      angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
      speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
    };
  };
  Spline2.prototype.pos = function(time) {
    var t = time - this.delay;
    if (t < 0) {
      t = 0;
    }
    if (t > this.duration) {
      t = this.duration - 1;
    }
    var t2 = t / this.duration;
    if (t2 >= 1) {
      return this.points[this.length - 1];
    }
    var n = Math.floor((this.points.length - 1) * t2);
    var t1 = (this.length - 1) * t2 - n;
    return bezier$1(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
  };
  return Spline2;
}();
var Spline$1 = Spline;
function bezier$1(t, p1, c1, c2, p2) {
  var b = B(t);
  var pos = {
    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
  };
  return pos;
}
function B(t) {
  var t2 = t * t;
  var t3 = t2 * t;
  return [
    t3,
    3 * t2 * (1 - t),
    3 * t * (1 - t) * (1 - t),
    (1 - t) * (1 - t) * (1 - t)
  ];
}
function bezier(line, options) {
  if (options === void 0) {
    options = {};
  }
  var resolution = options.resolution || 1e4;
  var sharpness = options.sharpness || 0.85;
  var coords = [];
  var points2 = getGeom(line).coordinates.map(function(pt) {
    return { x: pt[0], y: pt[1] };
  });
  var spline = new Spline$1({
    duration: resolution,
    points: points2,
    sharpness
  });
  var pushCoord = function(time) {
    var pos = spline.pos(time);
    if (Math.floor(time / 100) % 2 === 0) {
      coords.push([pos.x, pos.y]);
    }
  };
  for (var i = 0; i < spline.duration; i += 10) {
    pushCoord(i);
  }
  pushCoord(spline.duration);
  return lineString(coords, options.properties);
}
function tag(points2, polygons2, field, outField) {
  points2 = clone$5(points2);
  polygons2 = clone$5(polygons2);
  featureEach$1(points2, function(pt) {
    if (!pt.properties)
      pt.properties = {};
    featureEach$1(polygons2, function(poly) {
      if (pt.properties[outField] === void 0) {
        if (booleanPointInPolygon(pt, poly))
          pt.properties[outField] = poly.properties[field];
      }
    });
  });
  return points2;
}
function sample(featurecollection, num) {
  if (!featurecollection)
    throw new Error("featurecollection is required");
  if (num === null || num === void 0)
    throw new Error("num is required");
  if (typeof num !== "number")
    throw new Error("num must be a number");
  var outFC = featureCollection$1(
    getRandomSubarray(featurecollection.features, num)
  );
  return outFC;
}
function getRandomSubarray(arr, size11) {
  var shuffled = arr.slice(0), i = arr.length, min5 = i - size11, temp2, index2;
  while (i-- > min5) {
    index2 = Math.floor((i + 1) * Math.random());
    temp2 = shuffled[index2];
    shuffled[index2] = shuffled[i];
    shuffled[i] = temp2;
  }
  return shuffled.slice(min5);
}
function bboxPolygon(bbox2, options) {
  if (options === void 0) {
    options = {};
  }
  var west = Number(bbox2[0]);
  var south = Number(bbox2[1]);
  var east = Number(bbox2[2]);
  var north = Number(bbox2[3]);
  if (bbox2.length === 6) {
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  }
  var lowLeft = [west, south];
  var topLeft = [west, north];
  var topRight = [east, north];
  var lowRight = [east, south];
  return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox2, id: options.id });
}
function envelope(geojson) {
  return bboxPolygon(bbox$1(geojson));
}
function square(bbox2) {
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  var horizontalDistance = distance$2(bbox2.slice(0, 2), [east, south]);
  var verticalDistance = distance$2(bbox2.slice(0, 2), [west, north]);
  if (horizontalDistance >= verticalDistance) {
    var verticalMidpoint = (south + north) / 2;
    return [
      west,
      verticalMidpoint - (east - west) / 2,
      east,
      verticalMidpoint + (east - west) / 2
    ];
  } else {
    var horizontalMidpoint = (west + east) / 2;
    return [
      horizontalMidpoint - (north - south) / 2,
      south,
      horizontalMidpoint + (north - south) / 2,
      north
    ];
  }
}
function destination(origin, distance11, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(origin);
  var longitude1 = degreesToRadians(coordinates1[0]);
  var latitude1 = degreesToRadians(coordinates1[1]);
  var bearingRad = degreesToRadians(bearing2);
  var radians2 = lengthToRadians(distance11, options.units);
  var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad));
  var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1), Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2));
  var lng = radiansToDegrees(longitude2);
  var lat2 = radiansToDegrees(latitude2);
  return point([lng, lat2], options.properties);
}
function circle(center2, radius, options) {
  if (options === void 0) {
    options = {};
  }
  var steps = options.steps || 64;
  var properties = options.properties ? options.properties : !Array.isArray(center2) && center2.type === "Feature" && center2.properties ? center2.properties : {};
  var coordinates = [];
  for (var i = 0; i < steps; i++) {
    coordinates.push(destination(center2, radius, i * -360 / steps, options).geometry.coordinates);
  }
  coordinates.push(coordinates[0]);
  return polygon([coordinates], properties);
}
function bearing(start2, end2, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.final === true) {
    return calculateFinalBearing(start2, end2);
  }
  var coordinates1 = getCoord(start2);
  var coordinates2 = getCoord(end2);
  var lon1 = degreesToRadians(coordinates1[0]);
  var lon2 = degreesToRadians(coordinates2[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start2, end2) {
  var bear = bearing(end2, start2);
  bear = (bear + 180) % 360;
  return bear;
}
function midpoint(point1, point22) {
  var dist3 = distance$2(point1, point22);
  var heading = bearing(point1, point22);
  var midpoint2 = destination(point1, dist3 / 2, heading);
  return midpoint2;
}
function center$2(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var ext = bbox$1(geojson);
  var x2 = (ext[0] + ext[2]) / 2;
  var y2 = (ext[1] + ext[3]) / 2;
  return point([x2, y2], options.properties, options);
}
function centroid$2(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var xSum = 0;
  var ySum = 0;
  var len2 = 0;
  coordEach(geojson, function(coord) {
    xSum += coord[0];
    ySum += coord[1];
    len2++;
  }, true);
  return point([xSum / len2, ySum / len2], options.properties);
}
function centerOfMass(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  switch (getType$1(geojson)) {
    case "Point":
      return point(getCoord(geojson), options.properties);
    case "Polygon":
      var coords = [];
      coordEach(geojson, function(coord) {
        coords.push(coord);
      });
      var centre2 = centroid$2(geojson, { properties: options.properties });
      var translation = centre2.geometry.coordinates;
      var sx = 0;
      var sy = 0;
      var sArea = 0;
      var i, pi2, pj, xi, xj, yi, yj, a;
      var neutralizedPoints = coords.map(function(point4) {
        return [point4[0] - translation[0], point4[1] - translation[1]];
      });
      for (i = 0; i < coords.length - 1; i++) {
        pi2 = neutralizedPoints[i];
        xi = pi2[0];
        yi = pi2[1];
        pj = neutralizedPoints[i + 1];
        xj = pj[0];
        yj = pj[1];
        a = xi * yj - xj * yi;
        sArea += a;
        sx += (xi + xj) * a;
        sy += (yi + yj) * a;
      }
      if (sArea === 0) {
        return centre2;
      } else {
        var area5 = sArea * 0.5;
        var areaFactor = 1 / (6 * area5);
        return point([translation[0] + areaFactor * sx, translation[1] + areaFactor * sy], options.properties);
      }
    default:
      var hull = convex(geojson);
      if (hull)
        return centerOfMass(hull, { properties: options.properties });
      else
        return centroid$2(geojson, { properties: options.properties });
  }
}
function combine(fc) {
  var groups = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  featureEach$1(fc, function(feature2) {
    var _a2, _b2, _c2;
    var _d;
    switch ((_d = feature2.geometry) === null || _d === void 0 ? void 0 : _d.type) {
      case "Point":
        groups.MultiPoint.coordinates.push(feature2.geometry.coordinates);
        groups.MultiPoint.properties.push(feature2.properties);
        break;
      case "MultiPoint":
        (_a2 = groups.MultiPoint.coordinates).push.apply(_a2, feature2.geometry.coordinates);
        groups.MultiPoint.properties.push(feature2.properties);
        break;
      case "LineString":
        groups.MultiLineString.coordinates.push(feature2.geometry.coordinates);
        groups.MultiLineString.properties.push(feature2.properties);
        break;
      case "MultiLineString":
        (_b2 = groups.MultiLineString.coordinates).push.apply(_b2, feature2.geometry.coordinates);
        groups.MultiLineString.properties.push(feature2.properties);
        break;
      case "Polygon":
        groups.MultiPolygon.coordinates.push(feature2.geometry.coordinates);
        groups.MultiPolygon.properties.push(feature2.properties);
        break;
      case "MultiPolygon":
        (_c2 = groups.MultiPolygon.coordinates).push.apply(_c2, feature2.geometry.coordinates);
        groups.MultiPolygon.properties.push(feature2.properties);
        break;
    }
  });
  return featureCollection$1(Object.keys(groups).filter(function(key) {
    return groups[key].coordinates.length;
  }).sort().map(function(key) {
    var geometry2 = { type: key, coordinates: groups[key].coordinates };
    var properties = { collectedProperties: groups[key].properties };
    return feature(geometry2, properties);
  }));
}
function explode$1(geojson) {
  var points2 = [];
  if (geojson.type === "FeatureCollection") {
    featureEach$1(geojson, function(feature2) {
      coordEach(feature2, function(coord) {
        points2.push(point(coord, feature2.properties));
      });
    });
  } else {
    coordEach(geojson, function(coord) {
      points2.push(point(coord, geojson.properties));
    });
  }
  return featureCollection$1(points2);
}
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX2, minY2, maxX2, maxY2, x2, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX2 = maxX2 = data[0];
    minY2 = maxY2 = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x2 = data[i];
      y2 = data[i + 1];
      if (x2 < minX2)
        minX2 = x2;
      if (y2 < minY2)
        minY2 = y2;
      if (x2 > maxX2)
        maxX2 = x2;
      if (y2 > maxY2)
        maxY2 = y2;
    }
    invSize = Math.max(maxX2 - minX2, maxY2 - minY2);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX2, minY2, invSize, 0);
  return triangles;
}
function linkedList(data, start2, end2, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start2, end2, dim) > 0) {
    for (i = start2; i < end2; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end2 - dim; i >= start2; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode$1(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end2) {
  if (!start2)
    return start2;
  if (!end2)
    end2 = start2;
  var p = start2, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area$1(p.prev, p, p.next) === 0)) {
      removeNode$1(p);
      p = end2 = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end2);
  return end2;
}
function earcutLinked(ear, triangles, dim, minX2, minY2, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX2, minY2, invSize);
  var stop2 = ear, prev, next3;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next3 = ear.next;
    if (invSize ? isEarHashed(ear, minX2, minY2, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next3.i / dim | 0);
      removeNode$1(ear);
      ear = next3.next;
      stop2 = next3.next;
      continue;
    }
    ear = next3;
    if (ear === stop2) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX2, minY2, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX2, minY2, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX2, minY2, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area$1(a, b, c) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y02 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y12 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c.next;
  while (p !== a) {
    if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area$1(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX2, minY2, invSize) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area$1(a, b, c) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y02 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y12 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x02, y02, minX2, minY2, invSize), maxZ = zOrder(x12, y12, minX2, minY2, invSize);
  var p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area$1(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n.x >= x02 && n.x <= x12 && n.y >= y02 && n.y <= y12 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area$1(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area$1(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x02 && n.x <= x12 && n.y >= y02 && n.y <= y12 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area$1(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  var p = start2;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects$1(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode$1(p);
      removeNode$1(p.next);
      p = start2 = b;
    }
    p = p.next;
  } while (p !== start2);
  return filterPoints(p);
}
function splitEarcut(start2, triangles, dim, minX2, minY2, invSize) {
  var a = start2;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX2, minY2, invSize, 0);
        earcutLinked(c, triangles, dim, minX2, minY2, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len2, start2, end2, list;
  for (i = 0, len2 = holeIndices.length; i < len2; i++) {
    start2 = holeIndices[i] * dim;
    end2 = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start2, end2, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p.x < p.next.x ? p : p.next;
        if (x2 === hx)
          return m2;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m2)
    return null;
  var stop2 = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p = m2;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
        m2 = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop2);
  return m2;
}
function sectorContainsSector(m2, p) {
  return area$1(m2.prev, m2, p.prev) < 0 && area$1(p.next, m2, m2.next) < 0;
}
function indexCurve(start2, minX2, minY2, invSize) {
  var p = start2;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX2, minY2, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start2);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX2, minY2, invSize) {
  x2 = (x2 - minX2) * invSize | 0;
  y2 = (y2 - minY2) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start2) {
  var p = start2, leftmost = start2;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area$1(a.prev, a, b.prev) || area$1(a, b.prev, b)) || equals(a, b) && area$1(a.prev, a, a.next) > 0 && area$1(b.prev, b, b.next) > 0);
}
function area$1(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects$1(p1, q1, p2, q2) {
  var o1 = sign$1(area$1(p1, q1, p2));
  var o2 = sign$1(area$1(p1, q1, q2));
  var o3 = sign$1(area$1(p2, q2, p1));
  var o4 = sign$1(area$1(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects$1(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area$1(a.prev, a, a.next) < 0 ? area$1(a, b, a.next) >= 0 && area$1(a, a.prev, b) >= 0 : area$1(a, b, a.prev) < 0 || area$1(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside2 = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside2 = !inside2;
    p = p.next;
  } while (p !== a);
  return inside2;
}
function splitPolygon(a, b) {
  var a2 = new Node$4(a.i, a.x, a.y), b2 = new Node$4(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x2, y2, last) {
  var p = new Node$4(i, x2, y2);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode$1(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node$4(i, x2, y2) {
  this.i = i;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea2 = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len2 = holeIndices.length; i < len2; i++) {
      var start2 = holeIndices[i] * dim;
      var end2 = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea2 -= Math.abs(signedArea(data, start2, end2, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs(
      (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
    );
  }
  return polygonArea2 === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea2) / polygonArea2);
};
function signedArea(data, start2, end2, dim) {
  var sum2 = 0;
  for (var i = start2, j = end2 - dim; i < end2; i += dim) {
    sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum2;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcut$1 = earcut$2.exports;
function tesselate(poly) {
  if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
    throw new Error("input must be a Polygon or MultiPolygon");
  }
  var fc = { type: "FeatureCollection", features: [] };
  if (poly.geometry.type === "Polygon") {
    fc.features = processPolygon$2(poly.geometry.coordinates);
  } else {
    poly.geometry.coordinates.forEach(function(coordinates) {
      fc.features = fc.features.concat(processPolygon$2(coordinates));
    });
  }
  return fc;
}
function processPolygon$2(coordinates) {
  var data = flattenCoords(coordinates);
  var dim = 2;
  var result = earcut$1(data.vertices, data.holes, dim);
  var features2 = [];
  var vertices = [];
  result.forEach(function(vert, i2) {
    var index2 = result[i2];
    vertices.push([data.vertices[index2 * dim], data.vertices[index2 * dim + 1]]);
  });
  for (var i = 0; i < vertices.length; i += 3) {
    var coords = vertices.slice(i, i + 3);
    coords.push(vertices[i]);
    features2.push(polygon([coords]));
  }
  return features2;
}
function flattenCoords(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
}
function nearestPoint(targetPoint, points2) {
  if (!targetPoint)
    throw new Error("targetPoint is required");
  if (!points2)
    throw new Error("points is required");
  var nearest;
  var minDist = Infinity;
  var bestFeatureIndex = 0;
  featureEach$1(points2, function(pt, featureIndex) {
    var distanceToPoint = distance$2(targetPoint, pt);
    if (distanceToPoint < minDist) {
      bestFeatureIndex = featureIndex;
      minDist = distanceToPoint;
    }
  });
  nearest = clone$5(points2.features[bestFeatureIndex]);
  nearest.properties.featureIndex = bestFeatureIndex;
  nearest.properties.distanceToPoint = minDist;
  return nearest;
}
function lineSegment(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  var results = [];
  flattenEach(geojson, function(feature2) {
    lineSegmentFeature(feature2, results);
  });
  return featureCollection$1(results);
}
function lineSegmentFeature(geojson, results) {
  var coords = [];
  var geometry2 = geojson.geometry;
  if (geometry2 !== null) {
    switch (geometry2.type) {
      case "Polygon":
        coords = getCoords(geometry2);
        break;
      case "LineString":
        coords = [getCoords(geometry2)];
    }
    coords.forEach(function(coord) {
      var segments = createSegments(coord, geojson.properties);
      segments.forEach(function(segment) {
        segment.id = results.length;
        results.push(segment);
      });
    });
  }
}
function createSegments(coords, properties) {
  var segments = [];
  coords.reduce(function(previousCoords, currentCoords) {
    var segment = lineString([previousCoords, currentCoords], properties);
    segment.bbox = bbox(previousCoords, currentCoords);
    segments.push(segment);
    return currentCoords;
  });
  return segments;
}
function bbox(coords1, coords2) {
  var x12 = coords1[0];
  var y12 = coords1[1];
  var x2 = coords2[0];
  var y2 = coords2[1];
  var west = x12 < x2 ? x12 : x2;
  var south = y12 < y2 ? y12 : y2;
  var east = x12 > x2 ? x12 : x2;
  var north = y12 > y2 ? y12 : y2;
  return [west, south, east, north];
}
var geojsonRbush$1 = { exports: {} };
var rbush_min = { exports: {} };
(function(module, exports) {
  !function(t, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    function t(t2, r2, e3, a2, h2) {
      !function t3(n2, r3, e4, a3, h3) {
        for (; a3 > e4; ) {
          if (a3 - e4 > 600) {
            var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m3 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
            t3(n2, r3, m3, c2, h3);
          }
          var p2 = n2[r3], d2 = e4, x2 = a3;
          for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
            for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
              d2++;
            for (; h3(n2[x2], p2) > 0; )
              x2--;
          }
          0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
        }
      }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
    }
    function i(t2, i2, n2) {
      var r2 = t2[i2];
      t2[i2] = t2[n2], t2[n2] = r2;
    }
    function n(t2, i2) {
      return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
    }
    var r = function(t2) {
      void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function e2(t2, i2, n2) {
      if (!n2)
        return i2.indexOf(t2);
      for (var r2 = 0; r2 < i2.length; r2++)
        if (n2(t2, i2[r2]))
          return r2;
      return -1;
    }
    function a(t2, i2) {
      h(t2, 0, t2.children.length, i2, t2);
    }
    function h(t2, i2, n2, r2, e3) {
      e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
      for (var a2 = i2; a2 < n2; a2++) {
        var h2 = t2.children[a2];
        o(e3, t2.leaf ? r2(h2) : h2);
      }
      return e3;
    }
    function o(t2, i2) {
      return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
    }
    function s(t2, i2) {
      return t2.minX - i2.minX;
    }
    function l(t2, i2) {
      return t2.minY - i2.minY;
    }
    function f(t2) {
      return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
    }
    function u(t2) {
      return t2.maxX - t2.minX + (t2.maxY - t2.minY);
    }
    function m2(t2, i2) {
      return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
    }
    function c(t2, i2) {
      return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
    }
    function p(t2) {
      return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    function d(i2, n2, r2, e3, a2) {
      for (var h2 = [n2, r2]; h2.length; )
        if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
          var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
          t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
        }
    }
    return r.prototype.all = function() {
      return this._all(this.data, []);
    }, r.prototype.search = function(t2) {
      var i2 = this.data, n2 = [];
      if (!c(t2, i2))
        return n2;
      for (var r2 = this.toBBox, e3 = []; i2; ) {
        for (var a2 = 0; a2 < i2.children.length; a2++) {
          var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
          c(t2, o2) && (i2.leaf ? n2.push(h2) : m2(t2, o2) ? this._all(h2, n2) : e3.push(h2));
        }
        i2 = e3.pop();
      }
      return n2;
    }, r.prototype.collides = function(t2) {
      var i2 = this.data;
      if (!c(t2, i2))
        return false;
      for (var n2 = []; i2; ) {
        for (var r2 = 0; r2 < i2.children.length; r2++) {
          var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
          if (c(t2, a2)) {
            if (i2.leaf || m2(t2, a2))
              return true;
            n2.push(e3);
          }
        }
        i2 = n2.pop();
      }
      return false;
    }, r.prototype.load = function(t2) {
      if (!t2 || !t2.length)
        return this;
      if (t2.length < this._minEntries) {
        for (var i2 = 0; i2 < t2.length; i2++)
          this.insert(t2[i2]);
        return this;
      }
      var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
      if (this.data.children.length)
        if (this.data.height === n2.height)
          this._splitRoot(this.data, n2);
        else {
          if (this.data.height < n2.height) {
            var r2 = this.data;
            this.data = n2, n2 = r2;
          }
          this._insert(n2, this.data.height - n2.height - 1, true);
        }
      else
        this.data = n2;
      return this;
    }, r.prototype.insert = function(t2) {
      return t2 && this._insert(t2, this.data.height - 1), this;
    }, r.prototype.clear = function() {
      return this.data = p([]), this;
    }, r.prototype.remove = function(t2, i2) {
      if (!t2)
        return this;
      for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
        if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
          var f2 = e2(t2, h2.children, i2);
          if (-1 !== f2)
            return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
        }
        a2 || h2.leaf || !m2(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
      }
      return this;
    }, r.prototype.toBBox = function(t2) {
      return t2;
    }, r.prototype.compareMinX = function(t2, i2) {
      return t2.minX - i2.minX;
    }, r.prototype.compareMinY = function(t2, i2) {
      return t2.minY - i2.minY;
    }, r.prototype.toJSON = function() {
      return this.data;
    }, r.prototype.fromJSON = function(t2) {
      return this.data = t2, this;
    }, r.prototype._all = function(t2, i2) {
      for (var n2 = []; t2; )
        t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
      return i2;
    }, r.prototype._build = function(t2, i2, n2, r2) {
      var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
      if (h2 <= o2)
        return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
      r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
      var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
      d(t2, i2, n2, l2, this.compareMinX);
      for (var f2 = i2; f2 <= n2; f2 += l2) {
        var u2 = Math.min(f2 + l2 - 1, n2);
        d(t2, f2, u2, s2, this.compareMinY);
        for (var m3 = f2; m3 <= u2; m3 += s2) {
          var c2 = Math.min(m3 + s2 - 1, u2);
          e3.children.push(this._build(t2, m3, c2, r2 - 1));
        }
      }
      return a(e3, this.toBBox), e3;
    }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
      for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
        for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
          var s2 = i2.children[o2], l2 = f(s2), u2 = (m3 = t2, c2 = s2, (Math.max(c2.maxX, m3.maxX) - Math.min(c2.minX, m3.minX)) * (Math.max(c2.maxY, m3.maxY) - Math.min(c2.minY, m3.minY)) - l2);
          u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
        }
        i2 = h2 || i2.children[0];
      }
      var m3, c2;
      return i2;
    }, r.prototype._insert = function(t2, i2, n2) {
      var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
      for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
        this._split(e3, i2), i2--;
      this._adjustParentBBoxes(r2, e3, i2);
    }, r.prototype._split = function(t2, i2) {
      var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
      this._chooseSplitAxis(n2, e3, r2);
      var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
      o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
    }, r.prototype._splitRoot = function(t2, i2) {
      this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
      for (var r2, e3, a2, o2, s2, l2, u2, m3 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
        var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
        v < m3 ? (m3 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m3 && M < c2 && (c2 = M, r2 = p2);
      }
      return r2 || n2 - i2;
    }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
      var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
      this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
    }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
      t2.children.sort(r2);
      for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
        var m3 = t2.children[f2];
        o(a2, t2.leaf ? e3(m3) : m3), l2 += u(a2);
      }
      for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
        var p2 = t2.children[c2];
        o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
      }
      return l2;
    }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
      for (var r2 = n2; r2 >= 0; r2--)
        o(i2[r2], t2);
    }, r.prototype._condense = function(t2) {
      for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
        0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
    }, r;
  });
})(rbush_min);
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(es$2);
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(es$1);
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(es);
var rbush = rbush_min.exports;
var helpers = require$$1;
var meta = require$$2;
var turfBBox = require$$3.default;
var featureEach = meta.featureEach;
meta.coordEach;
helpers.polygon;
var featureCollection = helpers.featureCollection;
function geojsonRbush(maxEntries) {
  var tree = new rbush(maxEntries);
  tree.insert = function(feature2) {
    if (feature2.type !== "Feature")
      throw new Error("invalid feature");
    feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
    return rbush.prototype.insert.call(this, feature2);
  };
  tree.load = function(features2) {
    var load = [];
    if (Array.isArray(features2)) {
      features2.forEach(function(feature2) {
        if (feature2.type !== "Feature")
          throw new Error("invalid features");
        feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
        load.push(feature2);
      });
    } else {
      featureEach(features2, function(feature2) {
        if (feature2.type !== "Feature")
          throw new Error("invalid features");
        feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
        load.push(feature2);
      });
    }
    return rbush.prototype.load.call(this, load);
  };
  tree.remove = function(feature2, equals10) {
    if (feature2.type !== "Feature")
      throw new Error("invalid feature");
    feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
    return rbush.prototype.remove.call(this, feature2, equals10);
  };
  tree.clear = function() {
    return rbush.prototype.clear.call(this);
  };
  tree.search = function(geojson) {
    var features2 = rbush.prototype.search.call(this, this.toBBox(geojson));
    return featureCollection(features2);
  };
  tree.collides = function(geojson) {
    return rbush.prototype.collides.call(this, this.toBBox(geojson));
  };
  tree.all = function() {
    var features2 = rbush.prototype.all.call(this);
    return featureCollection(features2);
  };
  tree.toJSON = function() {
    return rbush.prototype.toJSON.call(this);
  };
  tree.fromJSON = function(json) {
    return rbush.prototype.fromJSON.call(this, json);
  };
  tree.toBBox = function(geojson) {
    var bbox2;
    if (geojson.bbox)
      bbox2 = geojson.bbox;
    else if (Array.isArray(geojson) && geojson.length === 4)
      bbox2 = geojson;
    else if (Array.isArray(geojson) && geojson.length === 6)
      bbox2 = [geojson[0], geojson[1], geojson[3], geojson[4]];
    else if (geojson.type === "Feature")
      bbox2 = turfBBox(geojson);
    else if (geojson.type === "FeatureCollection")
      bbox2 = turfBBox(geojson);
    else
      throw new Error("invalid geojson");
    return {
      minX: bbox2[0],
      minY: bbox2[1],
      maxX: bbox2[2],
      maxY: bbox2[3]
    };
  };
  return tree;
}
geojsonRbush$1.exports = geojsonRbush;
geojsonRbush$1.exports.default = geojsonRbush;
var rbush$1 = geojsonRbush$1.exports;
function lineIntersect(line1, line2) {
  var unique = {};
  var results = [];
  if (line1.type === "LineString") {
    line1 = feature(line1);
  }
  if (line2.type === "LineString") {
    line2 = feature(line2);
  }
  if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
    var intersect2 = intersects(line1, line2);
    if (intersect2) {
      results.push(intersect2);
    }
    return featureCollection$1(results);
  }
  var tree = rbush$1();
  tree.load(lineSegment(line2));
  featureEach$1(lineSegment(line1), function(segment) {
    featureEach$1(tree.search(segment), function(match) {
      var intersect3 = intersects(segment, match);
      if (intersect3) {
        var key = getCoords(intersect3).join(",");
        if (!unique[key]) {
          unique[key] = true;
          results.push(intersect3);
        }
      }
    });
  });
  return featureCollection$1(results);
}
function intersects(line1, line2) {
  var coords1 = getCoords(line1);
  var coords2 = getCoords(line2);
  if (coords1.length !== 2) {
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  }
  if (coords2.length !== 2) {
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  }
  var x12 = coords1[0][0];
  var y12 = coords1[0][1];
  var x2 = coords1[1][0];
  var y2 = coords1[1][1];
  var x3 = coords2[0][0];
  var y3 = coords2[0][1];
  var x4 = coords2[1][0];
  var y4 = coords2[1][1];
  var denom = (y4 - y3) * (x2 - x12) - (x4 - x3) * (y2 - y12);
  var numeA = (x4 - x3) * (y12 - y3) - (y4 - y3) * (x12 - x3);
  var numeB = (x2 - x12) * (y12 - y3) - (y2 - y12) * (x12 - x3);
  if (denom === 0) {
    if (numeA === 0 && numeB === 0) {
      return null;
    }
    return null;
  }
  var uA = numeA / denom;
  var uB = numeB / denom;
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    var x5 = x12 + uA * (x2 - x12);
    var y5 = y12 + uA * (y2 - y12);
    return point([x5, y5]);
  }
  return null;
}
function nearestPointOnLine(lines, pt, options) {
  if (options === void 0) {
    options = {};
  }
  var closestPt = point([Infinity, Infinity], {
    dist: Infinity
  });
  var length3 = 0;
  flattenEach(lines, function(line) {
    var coords = getCoords(line);
    for (var i = 0; i < coords.length - 1; i++) {
      var start2 = point(coords[i]);
      start2.properties.dist = distance$2(pt, start2, options);
      var stop_1 = point(coords[i + 1]);
      stop_1.properties.dist = distance$2(pt, stop_1, options);
      var sectionLength = distance$2(start2, stop_1, options);
      var heightDistance = Math.max(start2.properties.dist, stop_1.properties.dist);
      var direction = bearing(start2, stop_1);
      var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);
      var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);
      var intersect2 = lineIntersect(lineString([
        perpendicularPt1.geometry.coordinates,
        perpendicularPt2.geometry.coordinates
      ]), lineString([start2.geometry.coordinates, stop_1.geometry.coordinates]));
      var intersectPt = null;
      if (intersect2.features.length > 0) {
        intersectPt = intersect2.features[0];
        intersectPt.properties.dist = distance$2(pt, intersectPt, options);
        intersectPt.properties.location = length3 + distance$2(start2, intersectPt, options);
      }
      if (start2.properties.dist < closestPt.properties.dist) {
        closestPt = start2;
        closestPt.properties.index = i;
        closestPt.properties.location = length3;
      }
      if (stop_1.properties.dist < closestPt.properties.dist) {
        closestPt = stop_1;
        closestPt.properties.index = i + 1;
        closestPt.properties.location = length3 + sectionLength;
      }
      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
        closestPt = intersectPt;
        closestPt.properties.index = i;
      }
      length3 += sectionLength;
    }
  });
  return closestPt;
}
function rhumbDistance(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var origin = getCoord(from);
  var destination2 = getCoord(to);
  destination2[0] += destination2[0] - origin[0] > 180 ? -360 : origin[0] - destination2[0] > 180 ? 360 : 0;
  var distanceInMeters = calculateRhumbDistance(origin, destination2);
  var distance11 = convertLength(distanceInMeters, "meters", options.units);
  return distance11;
}
function calculateRhumbDistance(origin, destination2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  var R = radius;
  var phi1 = origin[1] * Math.PI / 180;
  var phi2 = destination2[1] * Math.PI / 180;
  var DeltaPhi = phi2 - phi1;
  var DeltaLambda = Math.abs(destination2[0] - origin[0]) * Math.PI / 180;
  if (DeltaLambda > Math.PI) {
    DeltaLambda -= 2 * Math.PI;
  }
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var delta2 = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
  var dist3 = delta2 * R;
  return dist3;
}
function pointToLineDistance(pt, line, options) {
  if (options === void 0) {
    options = {};
  }
  if (!options.method) {
    options.method = "geodesic";
  }
  if (!options.units) {
    options.units = "kilometers";
  }
  if (!pt) {
    throw new Error("pt is required");
  }
  if (Array.isArray(pt)) {
    pt = point(pt);
  } else if (pt.type === "Point") {
    pt = feature(pt);
  } else {
    featureOf(pt, "Point", "point");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (Array.isArray(line)) {
    line = lineString(line);
  } else if (line.type === "LineString") {
    line = feature(line);
  } else {
    featureOf(line, "LineString", "line");
  }
  var distance11 = Infinity;
  var p = pt.geometry.coordinates;
  segmentEach(line, function(segment) {
    var a = segment.geometry.coordinates[0];
    var b = segment.geometry.coordinates[1];
    var d = distanceToSegment(p, a, b, options);
    if (d < distance11) {
      distance11 = d;
    }
  });
  return convertLength(distance11, "degrees", options.units);
}
function distanceToSegment(p, a, b, options) {
  var v = [b[0] - a[0], b[1] - a[1]];
  var w = [p[0] - a[0], p[1] - a[1]];
  var c1 = dot(w, v);
  if (c1 <= 0) {
    return calcDistance(p, a, { method: options.method, units: "degrees" });
  }
  var c2 = dot(v, v);
  if (c2 <= c1) {
    return calcDistance(p, b, { method: options.method, units: "degrees" });
  }
  var b2 = c1 / c2;
  var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
  return calcDistance(p, Pb, { method: options.method, units: "degrees" });
}
function dot(u, v) {
  return u[0] * v[0] + u[1] * v[1];
}
function calcDistance(a, b, options) {
  return options.method === "planar" ? rhumbDistance(a, b, options) : distance$2(a, b, options);
}
function nearestPointToLine(points2, line, options) {
  if (options === void 0) {
    options = {};
  }
  var units = options.units;
  var properties = options.properties || {};
  var pts = normalize$5(points2);
  if (!pts.features.length) {
    throw new Error("points must contain features");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (getType$1(line) !== "LineString") {
    throw new Error("line must be a LineString");
  }
  var dist3 = Infinity;
  var pt = null;
  featureEach$1(pts, function(point4) {
    var d = pointToLineDistance(point4, line, { units });
    if (d < dist3) {
      dist3 = d;
      pt = point4;
    }
  });
  if (pt) {
    pt.properties = objectAssign({ dist: dist3 }, pt.properties, properties);
  }
  return pt;
}
function normalize$5(points2) {
  var features2 = [];
  var type = points2.geometry ? points2.geometry.type : points2.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(points2, function(geom) {
        if (geom.type === "Point") {
          features2.push({ type: "Feature", properties: {}, geometry: geom });
        }
      });
      return { type: "FeatureCollection", features: features2 };
    case "FeatureCollection":
      points2.features = points2.features.filter(function(feature2) {
        return feature2.geometry.type === "Point";
      });
      return points2;
    default:
      throw new Error("points must be a Point Collection");
  }
}
function planepoint(point4, triangle) {
  var coord = getCoord(point4);
  var geom = getGeom(triangle);
  var coords = geom.coordinates;
  var outer = coords[0];
  if (outer.length < 4)
    throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
  var properties = triangle.properties || {};
  var a = properties.a;
  var b = properties.b;
  var c = properties.c;
  var x2 = coord[0];
  var y2 = coord[1];
  var x12 = outer[0][0];
  var y12 = outer[0][1];
  var z1 = a !== void 0 ? a : outer[0][2];
  var x22 = outer[1][0];
  var y22 = outer[1][1];
  var z2 = b !== void 0 ? b : outer[1][2];
  var x3 = outer[2][0];
  var y3 = outer[2][1];
  var z3 = c !== void 0 ? c : outer[2][2];
  var z = (z3 * (x2 - x12) * (y2 - y22) + z1 * (x2 - x22) * (y2 - y3) + z2 * (x2 - x3) * (y2 - y12) - z2 * (x2 - x12) * (y2 - y3) - z3 * (x2 - x22) * (y2 - y12) - z1 * (x2 - x3) * (y2 - y22)) / ((x2 - x12) * (y2 - y22) + (x2 - x22) * (y2 - y3) + (x2 - x3) * (y2 - y12) - (x2 - x12) * (y2 - y3) - (x2 - x22) * (y2 - y12) - (x2 - x3) * (y2 - y22));
  return z;
}
function kinks(featureIn) {
  var coordinates;
  var feature2;
  var results = {
    type: "FeatureCollection",
    features: []
  };
  if (featureIn.type === "Feature") {
    feature2 = featureIn.geometry;
  } else {
    feature2 = featureIn;
  }
  if (feature2.type === "LineString") {
    coordinates = [feature2.coordinates];
  } else if (feature2.type === "MultiLineString") {
    coordinates = feature2.coordinates;
  } else if (feature2.type === "MultiPolygon") {
    coordinates = [].concat.apply([], feature2.coordinates);
  } else if (feature2.type === "Polygon") {
    coordinates = feature2.coordinates;
  } else {
    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
  }
  coordinates.forEach(function(line1) {
    coordinates.forEach(function(line2) {
      for (var i = 0; i < line1.length - 1; i++) {
        for (var k = i; k < line2.length - 1; k++) {
          if (line1 === line2) {
            if (Math.abs(i - k) === 1) {
              continue;
            }
            if (i === 0 && k === line1.length - 2 && line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {
              continue;
            }
          }
          var intersection11 = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
          if (intersection11) {
            results.features.push(point([intersection11[0], intersection11[1]]));
          }
        }
      }
    });
  });
  return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  var denominator;
  var a;
  var b;
  var numerator1;
  var numerator2;
  var result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
  if (denominator === 0) {
    if (result.x !== null && result.y !== null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;
  result.x = line1StartX + a * (line1EndX - line1StartX);
  result.y = line1StartY + a * (line1EndY - line1StartY);
  if (a >= 0 && a <= 1) {
    result.onLine1 = true;
  }
  if (b >= 0 && b <= 1) {
    result.onLine2 = true;
  }
  if (result.onLine1 && result.onLine2) {
    return [result.x, result.y];
  } else {
    return false;
  }
}
function pointOnFeature(geojson) {
  var fc = normalize$4(geojson);
  var cent = center$2(fc);
  var onSurface = false;
  var i = 0;
  while (!onSurface && i < fc.features.length) {
    var geom = fc.features[i].geometry;
    var x2, y2, x12, y12, x22, y22, k;
    var onLine = false;
    if (geom.type === "Point") {
      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
        onSurface = true;
      }
    } else if (geom.type === "MultiPoint") {
      var onMultiPoint = false;
      k = 0;
      while (!onMultiPoint && k < geom.coordinates.length) {
        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
          onSurface = true;
          onMultiPoint = true;
        }
        k++;
      }
    } else if (geom.type === "LineString") {
      k = 0;
      while (!onLine && k < geom.coordinates.length - 1) {
        x2 = cent.geometry.coordinates[0];
        y2 = cent.geometry.coordinates[1];
        x12 = geom.coordinates[k][0];
        y12 = geom.coordinates[k][1];
        x22 = geom.coordinates[k + 1][0];
        y22 = geom.coordinates[k + 1][1];
        if (pointOnSegment(x2, y2, x12, y12, x22, y22)) {
          onLine = true;
          onSurface = true;
        }
        k++;
      }
    } else if (geom.type === "MultiLineString") {
      var j = 0;
      while (j < geom.coordinates.length) {
        onLine = false;
        k = 0;
        var line = geom.coordinates[j];
        while (!onLine && k < line.length - 1) {
          x2 = cent.geometry.coordinates[0];
          y2 = cent.geometry.coordinates[1];
          x12 = line[k][0];
          y12 = line[k][1];
          x22 = line[k + 1][0];
          y22 = line[k + 1][1];
          if (pointOnSegment(x2, y2, x12, y12, x22, y22)) {
            onLine = true;
            onSurface = true;
          }
          k++;
        }
        j++;
      }
    } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
      if (booleanPointInPolygon(cent, geom)) {
        onSurface = true;
      }
    }
    i++;
  }
  if (onSurface) {
    return cent;
  } else {
    var vertices = featureCollection$1([]);
    for (i = 0; i < fc.features.length; i++) {
      vertices.features = vertices.features.concat(
        explode$1(fc.features[i]).features
      );
    }
    return point(nearestPoint(cent, vertices).geometry.coordinates);
  }
}
function normalize$4(geojson) {
  if (geojson.type !== "FeatureCollection") {
    if (geojson.type !== "Feature") {
      return featureCollection$1([feature(geojson)]);
    }
    return featureCollection$1([geojson]);
  }
  return geojson;
}
function pointOnSegment(x2, y2, x12, y12, x22, y22) {
  var ab2 = Math.sqrt((x22 - x12) * (x22 - x12) + (y22 - y12) * (y22 - y12));
  var ap = Math.sqrt((x2 - x12) * (x2 - x12) + (y2 - y12) * (y2 - y12));
  var pb = Math.sqrt((x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2));
  return ab2 === ap + pb;
}
var RADIUS = 6378137;
function area(geojson) {
  return geomReduce(geojson, function(value, geom) {
    return value + calculateArea$1(geom);
  }, 0);
}
function calculateArea$1(geom) {
  var total = 0;
  var i;
  switch (geom.type) {
    case "Polygon":
      return polygonArea(geom.coordinates);
    case "MultiPolygon":
      for (i = 0; i < geom.coordinates.length; i++) {
        total += polygonArea(geom.coordinates[i]);
      }
      return total;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function polygonArea(coords) {
  var total = 0;
  if (coords && coords.length > 0) {
    total += Math.abs(ringArea(coords[0]));
    for (var i = 1; i < coords.length; i++) {
      total -= Math.abs(ringArea(coords[i]));
    }
  }
  return total;
}
function ringArea(coords) {
  var p1;
  var p2;
  var p3;
  var lowerIndex;
  var middleIndex;
  var upperIndex;
  var i;
  var total = 0;
  var coordsLength = coords.length;
  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }
      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }
    total = total * RADIUS * RADIUS / 2;
  }
  return total;
}
function rad(num) {
  return num * Math.PI / 180;
}
function along(line, distance11, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var travelled = 0;
  for (var i = 0; i < coords.length; i++) {
    if (distance11 >= travelled && i === coords.length - 1) {
      break;
    } else if (travelled >= distance11) {
      var overshot = distance11 - travelled;
      if (!overshot) {
        return point(coords[i]);
      } else {
        var direction = bearing(coords[i], coords[i - 1]) - 180;
        var interpolated = destination(coords[i], overshot, direction, options);
        return interpolated;
      }
    } else {
      travelled += distance$2(coords[i], coords[i + 1], options);
    }
  }
  return point(coords[coords.length - 1]);
}
function length$1(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return segmentReduce(geojson, function(previousValue, segment) {
    var coords = segment.geometry.coordinates;
    return previousValue + distance$2(coords[0], coords[1], options);
  }, 0);
}
function lineSlice(startPt, stopPt, line) {
  var coords = getCoords(line);
  if (getType$1(line) !== "LineString")
    throw new Error("line must be a LineString");
  var startVertex = nearestPointOnLine(line, startPt);
  var stopVertex = nearestPointOnLine(line, stopPt);
  var ends;
  if (startVertex.properties.index <= stopVertex.properties.index) {
    ends = [startVertex, stopVertex];
  } else {
    ends = [stopVertex, startVertex];
  }
  var clipCoords = [ends[0].geometry.coordinates];
  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
    clipCoords.push(coords[i]);
  }
  clipCoords.push(ends[1].geometry.coordinates);
  return lineString(clipCoords, line.properties);
}
function lineSliceAlong(line, startDist, stopDist, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var coords;
  var slice2 = [];
  if (line.type === "Feature")
    coords = line.geometry.coordinates;
  else if (line.type === "LineString")
    coords = line.coordinates;
  else
    throw new Error("input must be a LineString Feature or Geometry");
  var origCoordsLength = coords.length;
  var travelled = 0;
  var overshot, direction, interpolated;
  for (var i = 0; i < coords.length; i++) {
    if (startDist >= travelled && i === coords.length - 1)
      break;
    else if (travelled > startDist && slice2.length === 0) {
      overshot = startDist - travelled;
      if (!overshot) {
        slice2.push(coords[i]);
        return lineString(slice2);
      }
      direction = bearing(coords[i], coords[i - 1]) - 180;
      interpolated = destination(coords[i], overshot, direction, options);
      slice2.push(interpolated.geometry.coordinates);
    }
    if (travelled >= stopDist) {
      overshot = stopDist - travelled;
      if (!overshot) {
        slice2.push(coords[i]);
        return lineString(slice2);
      }
      direction = bearing(coords[i], coords[i - 1]) - 180;
      interpolated = destination(coords[i], overshot, direction, options);
      slice2.push(interpolated.geometry.coordinates);
      return lineString(slice2);
    }
    if (travelled >= startDist) {
      slice2.push(coords[i]);
    }
    if (i === coords.length - 1) {
      return lineString(slice2);
    }
    travelled += distance$2(coords[i], coords[i + 1], options);
  }
  if (travelled < startDist && coords.length === origCoordsLength)
    throw new Error("Start position is beyond line");
  var last = coords[coords.length - 1];
  return lineString([last, last]);
}
function booleanPointOnLine(pt, line, options) {
  if (options === void 0) {
    options = {};
  }
  var ptCoords = getCoord(pt);
  var lineCoords = getCoords(line);
  for (var i = 0; i < lineCoords.length - 1; i++) {
    var ignoreBoundary = false;
    if (options.ignoreEndVertices) {
      if (i === 0) {
        ignoreBoundary = "start";
      }
      if (i === lineCoords.length - 2) {
        ignoreBoundary = "end";
      }
      if (i === 0 && i + 1 === lineCoords.length - 1) {
        ignoreBoundary = "both";
      }
    }
    if (isPointOnLineSegment$2(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
      return true;
    }
  }
  return false;
}
function isPointOnLineSegment$2(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon3) {
  var x2 = pt[0];
  var y2 = pt[1];
  var x12 = lineSegmentStart[0];
  var y12 = lineSegmentStart[1];
  var x22 = lineSegmentEnd[0];
  var y22 = lineSegmentEnd[1];
  var dxc = pt[0] - x12;
  var dyc = pt[1] - y12;
  var dxl = x22 - x12;
  var dyl = y22 - y12;
  var cross2 = dxc * dyl - dyc * dxl;
  if (epsilon3 !== null) {
    if (Math.abs(cross2) > epsilon3) {
      return false;
    }
  } else if (cross2 !== 0) {
    return false;
  }
  if (!excludeBoundary) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 <= x2 && x2 <= x22 : x22 <= x2 && x2 <= x12;
    }
    return dyl > 0 ? y12 <= y2 && y2 <= y22 : y22 <= y2 && y2 <= y12;
  } else if (excludeBoundary === "start") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 < x2 && x2 <= x22 : x22 <= x2 && x2 < x12;
    }
    return dyl > 0 ? y12 < y2 && y2 <= y22 : y22 <= y2 && y2 < y12;
  } else if (excludeBoundary === "end") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 <= x2 && x2 < x22 : x22 < x2 && x2 <= x12;
    }
    return dyl > 0 ? y12 <= y2 && y2 < y22 : y22 < y2 && y2 <= y12;
  } else if (excludeBoundary === "both") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 < x2 && x2 < x22 : x22 < x2 && x2 < x12;
    }
    return dyl > 0 ? y12 < y2 && y2 < y22 : y22 < y2 && y2 < y12;
  }
  return false;
}
function booleanWithin(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "MultiPoint":
          return isPointInMultiPoint$1(geom1, geom2);
        case "LineString":
          return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });
        case "Polygon":
        case "MultiPolygon":
          return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "MultiPoint":
          return isMultiPointInMultiPoint$1(geom1, geom2);
        case "LineString":
          return isMultiPointOnLine$1(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isMultiPointInPoly$1(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "LineString":
          return isLineOnLine$2(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isLineInPoly$2(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Polygon":
        case "MultiPolygon":
          return isPolyInPoly$2(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointInMultiPoint$1(point4, multiPoint2) {
  var i;
  var output = false;
  for (i = 0; i < multiPoint2.coordinates.length; i++) {
    if (compareCoords$2(multiPoint2.coordinates[i], point4.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint$1(multiPoint1, multiPoint2) {
  for (var i = 0; i < multiPoint1.coordinates.length; i++) {
    var anyMatch = false;
    for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
      if (compareCoords$2(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
        anyMatch = true;
      }
    }
    if (!anyMatch) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine$1(multiPoint2, lineString2) {
  var foundInsidePoint = false;
  for (var i = 0; i < multiPoint2.coordinates.length; i++) {
    if (!booleanPointOnLine(multiPoint2.coordinates[i], lineString2)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointOnLine(multiPoint2.coordinates[i], lineString2, { ignoreEndVertices: true });
    }
  }
  return foundInsidePoint;
}
function isMultiPointInPoly$1(multiPoint2, polygon4) {
  var output = true;
  var isInside2 = false;
  for (var i = 0; i < multiPoint2.coordinates.length; i++) {
    isInside2 = booleanPointInPolygon(multiPoint2.coordinates[1], polygon4);
    if (!isInside2) {
      output = false;
      break;
    }
    {
      isInside2 = booleanPointInPolygon(multiPoint2.coordinates[1], polygon4, {
        ignoreBoundary: true
      });
    }
  }
  return output && isInside2;
}
function isLineOnLine$2(lineString1, lineString2) {
  for (var i = 0; i < lineString1.coordinates.length; i++) {
    if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {
      return false;
    }
  }
  return true;
}
function isLineInPoly$2(linestring3, polygon4) {
  var polyBbox = bbox$1(polygon4);
  var lineBbox = bbox$1(linestring3);
  if (!doBBoxOverlap$1(polyBbox, lineBbox)) {
    return false;
  }
  var foundInsidePoint = false;
  for (var i = 0; i < linestring3.coordinates.length - 1; i++) {
    if (!booleanPointInPolygon(linestring3.coordinates[i], polygon4)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointInPolygon(linestring3.coordinates[i], polygon4, { ignoreBoundary: true });
    }
    if (!foundInsidePoint) {
      var midpoint2 = getMidpoint$1(linestring3.coordinates[i], linestring3.coordinates[i + 1]);
      foundInsidePoint = booleanPointInPolygon(midpoint2, polygon4, {
        ignoreBoundary: true
      });
    }
  }
  return foundInsidePoint;
}
function isPolyInPoly$2(geometry1, geometry2) {
  var poly1Bbox = bbox$1(geometry1);
  var poly2Bbox = bbox$1(geometry2);
  if (!doBBoxOverlap$1(poly2Bbox, poly1Bbox)) {
    return false;
  }
  for (var i = 0; i < geometry1.coordinates[0].length; i++) {
    if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
      return false;
    }
  }
  return true;
}
function doBBoxOverlap$1(bbox1, bbox2) {
  if (bbox1[0] > bbox2[0])
    return false;
  if (bbox1[2] < bbox2[2])
    return false;
  if (bbox1[1] > bbox2[1])
    return false;
  if (bbox1[3] < bbox2[3])
    return false;
  return true;
}
function compareCoords$2(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint$1(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
function pointGrid(bbox2, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.mask && !options.units)
    options.units = "kilometers";
  var results = [];
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  var xFraction = cellSide / distance$2([west, south], [east, south], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = cellSide / distance$2([west, south], [west, north], options);
  var cellHeight = yFraction * (north - south);
  var bboxWidth = east - west;
  var bboxHeight = north - south;
  var columns = Math.floor(bboxWidth / cellWidth);
  var rows = Math.floor(bboxHeight / cellHeight);
  var deltaX = (bboxWidth - columns * cellWidth) / 2;
  var deltaY = (bboxHeight - rows * cellHeight) / 2;
  var currentX = west + deltaX;
  while (currentX <= east) {
    var currentY = south + deltaY;
    while (currentY <= north) {
      var cellPt = point([currentX, currentY], options.properties);
      if (options.mask) {
        if (booleanWithin(cellPt, options.mask))
          results.push(cellPt);
      } else {
        results.push(cellPt);
      }
      currentY += cellHeight;
    }
    currentX += cellWidth;
  }
  return featureCollection$1(results);
}
function truncate(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var precision = options.precision;
  var coordinates = options.coordinates;
  var mutate = options.mutate;
  precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
  coordinates = coordinates === void 0 || coordinates === null || isNaN(coordinates) ? 3 : coordinates;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof precision !== "number")
    throw new Error("<precision> must be a number");
  if (typeof coordinates !== "number")
    throw new Error("<coordinates> must be a number");
  if (mutate === false || mutate === void 0)
    geojson = JSON.parse(JSON.stringify(geojson));
  var factor = Math.pow(10, precision);
  coordEach(geojson, function(coords) {
    truncateCoords(coords, factor, coordinates);
  });
  return geojson;
}
function truncateCoords(coords, factor, coordinates) {
  if (coords.length > coordinates)
    coords.splice(coordinates, coords.length);
  for (var i = 0; i < coords.length; i++) {
    coords[i] = Math.round(coords[i] * factor) / factor;
  }
  return coords;
}
function flatten(geojson) {
  if (!geojson)
    throw new Error("geojson is required");
  var results = [];
  flattenEach(geojson, function(feature2) {
    results.push(feature2);
  });
  return featureCollection$1(results);
}
function lineChunk(geojson, segmentLength, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var units = options.units;
  var reverse5 = options.reverse;
  if (!geojson)
    throw new Error("geojson is required");
  if (segmentLength <= 0)
    throw new Error("segmentLength must be greater than 0");
  var results = [];
  flattenEach(geojson, function(feature2) {
    if (reverse5)
      feature2.geometry.coordinates = feature2.geometry.coordinates.reverse();
    sliceLineSegments(feature2, segmentLength, units, function(segment) {
      results.push(segment);
    });
  });
  return featureCollection$1(results);
}
function sliceLineSegments(line, segmentLength, units, callback) {
  var lineLength = length$1(line, { units });
  if (lineLength <= segmentLength)
    return callback(line);
  var numberOfSegments = lineLength / segmentLength;
  if (!Number.isInteger(numberOfSegments)) {
    numberOfSegments = Math.floor(numberOfSegments) + 1;
  }
  for (var i = 0; i < numberOfSegments; i++) {
    var outline = lineSliceAlong(
      line,
      segmentLength * i,
      segmentLength * (i + 1),
      { units }
    );
    callback(outline, i);
  }
}
function isects(feature2, filterFn, useSpatialIndex) {
  if (feature2.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  if (useSpatialIndex === void 0)
    useSpatialIndex = 1;
  var coord = feature2.geometry.coordinates;
  var output = [];
  var seen = {};
  if (useSpatialIndex) {
    var allEdgesAsRbushTreeItems = [];
    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
      }
    }
    var tree = rbush$3();
    tree.load(allEdgesAsRbushTreeItems);
  }
  for (var ringA = 0; ringA < coord.length; ringA++) {
    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
      if (useSpatialIndex) {
        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
        bboxOverlaps.forEach(function(bboxIsect) {
          var ring12 = bboxIsect.ring;
          var edge12 = bboxIsect.edge;
          ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
        });
      } else {
        for (var ring1 = 0; ring1 < coord.length; ring1++) {
          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
          }
        }
      }
    }
  }
  if (!filterFn)
    output = {
      type: "Feature",
      geometry: { type: "MultiPoint", coordinates: output }
    };
  return output;
  function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
    var start0 = coord[ring02][edge02];
    var end0 = coord[ring02][edge02 + 1];
    var start1 = coord[ring12][edge12];
    var end1 = coord[ring12][edge12 + 1];
    var isect = intersect$3(start0, end0, start1, end1);
    if (isect === null)
      return;
    var frac0;
    var frac1;
    if (end0[0] !== start0[0]) {
      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
    } else {
      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
    }
    if (end1[0] !== start1[0]) {
      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
    } else {
      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
    }
    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0)
      return;
    var key = isect;
    var unique = !seen[key];
    if (unique) {
      seen[key] = true;
    }
    if (filterFn) {
      output.push(
        filterFn(
          isect,
          ring02,
          edge02,
          start0,
          end0,
          frac0,
          ring12,
          edge12,
          start1,
          end1,
          frac1,
          unique
        )
      );
    } else {
      output.push(isect);
    }
  }
  function rbushTreeItem(ring, edge) {
    var start2 = coord[ring][edge];
    var end2 = coord[ring][edge + 1];
    var minX2;
    var maxX2;
    var minY2;
    var maxY2;
    if (start2[0] < end2[0]) {
      minX2 = start2[0];
      maxX2 = end2[0];
    } else {
      minX2 = end2[0];
      maxX2 = start2[0];
    }
    if (start2[1] < end2[1]) {
      minY2 = start2[1];
      maxY2 = end2[1];
    } else {
      minY2 = end2[1];
      maxY2 = start2[1];
    }
    return {
      minX: minX2,
      minY: minY2,
      maxX: maxX2,
      maxY: maxY2,
      ring,
      edge
    };
  }
}
function intersect$3(start0, end0, start1, end1) {
  if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1))
    return null;
  var x02 = start0[0], y02 = start0[1], x12 = end0[0], y12 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
  var denom = (x02 - x12) * (y2 - y3) - (y02 - y12) * (x2 - x3);
  if (denom === 0)
    return null;
  var x4 = ((x02 * y12 - y02 * x12) * (x2 - x3) - (x02 - x12) * (x2 * y3 - y2 * x3)) / denom;
  var y4 = ((x02 * y12 - y02 * x12) * (y2 - y3) - (y02 - y12) * (x2 * y3 - y2 * x3)) / denom;
  return [x4, y4];
}
function equalArrays(array1, array2) {
  if (!array1 || !array2)
    return false;
  if (array1.length !== array2.length)
    return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays(array1[i], array2[i]))
        return false;
    } else if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function simplepolygon(feature2) {
  if (feature2.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (feature2.geometry === void 0 || feature2.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (feature2.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  var numRings = feature2.geometry.coordinates.length;
  var vertices = [];
  for (var i = 0; i < numRings; i++) {
    var ring = feature2.geometry.coordinates[i];
    if (!equalArrays$1(ring[0], ring[ring.length - 1])) {
      ring.push(ring[0]);
    }
    vertices.push.apply(vertices, ring.slice(0, ring.length - 1));
  }
  if (!isUnique(vertices))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var numvertices = vertices.length;
  var selfIsectsData = isects(
    feature2,
    function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
      return [
        isect,
        ring0,
        edge0,
        start0,
        end0,
        frac0,
        ring1,
        edge1,
        start1,
        end1,
        frac1,
        unique
      ];
    }
  );
  var numSelfIsect = selfIsectsData.length;
  if (numSelfIsect == 0) {
    var outputFeatureArray = [];
    for (var i = 0; i < numRings; i++) {
      outputFeatureArray.push(
        polygon([feature2.geometry.coordinates[i]], {
          parent: -1,
          winding: windingOfRing(feature2.geometry.coordinates[i])
        })
      );
    }
    var output = featureCollection$1(outputFeatureArray);
    determineParents();
    setNetWinding();
    return output;
  }
  var pseudoVtxListByRingAndEdge = [];
  var isectList = [];
  for (var i = 0; i < numRings; i++) {
    pseudoVtxListByRingAndEdge.push([]);
    for (var j = 0; j < feature2.geometry.coordinates[i].length - 1; j++) {
      pseudoVtxListByRingAndEdge[i].push([
        new PseudoVtx(
          feature2.geometry.coordinates[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          1,
          [i, j],
          [i, modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          void 0
        )
      ]);
      isectList.push(
        new Isect(
          feature2.geometry.coordinates[i][j],
          [i, modulo(j - 1, feature2.geometry.coordinates[i].length - 1)],
          [i, j],
          void 0,
          void 0,
          false,
          true
        )
      );
    }
  }
  for (var i = 0; i < numSelfIsect; i++) {
    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
      new PseudoVtx(
        selfIsectsData[i][0],
        selfIsectsData[i][5],
        [selfIsectsData[i][1], selfIsectsData[i][2]],
        [selfIsectsData[i][6], selfIsectsData[i][7]],
        void 0
      )
    );
    if (selfIsectsData[i][11])
      isectList.push(
        new Isect(
          selfIsectsData[i][0],
          [selfIsectsData[i][1], selfIsectsData[i][2]],
          [selfIsectsData[i][6], selfIsectsData[i][7]],
          void 0,
          void 0,
          true,
          true
        )
      );
  }
  var numIsect = isectList.length;
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
        return a.param < b.param ? -1 : 1;
      });
    }
  }
  var allIsectsAsIsectRbushTreeItem = [];
  for (var i = 0; i < numIsect; i++) {
    allIsectsAsIsectRbushTreeItem.push({
      minX: isectList[i].coord[0],
      minY: isectList[i].coord[1],
      maxX: isectList[i].coord[0],
      maxY: isectList[i].coord[1],
      index: i
    });
  }
  var isectRbushTree = rbush$3();
  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind;
        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
          coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)][0].coord;
        } else {
          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
        }
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
      }
    }
  }
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        var l = IsectRbushTreeItemFound.index;
        if (l < numvertices) {
          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
        } else {
          if (equalArrays$1(
            isectList[l].ringAndEdge1,
            pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
          )) {
            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          }
        }
      }
    }
  }
  var queue = [];
  var i = 0;
  for (var j = 0; j < numRings; j++) {
    var leftIsect = i;
    for (var k = 0; k < feature2.geometry.coordinates[j].length - 1; k++) {
      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
        leftIsect = i;
      }
      i++;
    }
    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
    for (var k = 0; k < isectList.length; k++) {
      if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
        var isectBeforeLeftIsect = k;
        break;
      }
    }
    var windingAtIsect = isConvex(
      [
        isectList[isectBeforeLeftIsect].coord,
        isectList[leftIsect].coord,
        isectList[isectAfterLeftIsect].coord
      ],
      true
    ) ? 1 : -1;
    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
  }
  queue.sort(function(a, b) {
    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
  });
  var outputFeatureArray = [];
  while (queue.length > 0) {
    var popped = queue.pop();
    var startIsect = popped.isect;
    var currentOutputRingParent = popped.parent;
    var currentOutputRingWinding = popped.winding;
    var currentOutputRing = outputFeatureArray.length;
    var currentOutputRingCoords = [isectList[startIsect].coord];
    var currentIsect = startIsect;
    if (isectList[startIsect].ringAndEdge1Walkable) {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
    } else {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
    }
    while (!equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)) {
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      var nxtIsectInQueue = void 0;
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].isect == nxtIsect) {
          nxtIsectInQueue = i;
          break;
        }
      }
      if (nxtIsectInQueue != void 0) {
        queue.splice(nxtIsectInQueue, 1);
      }
      if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
        isectList[nxtIsect].ringAndEdge2Walkable = false;
        if (isectList[nxtIsect].ringAndEdge1Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
      } else {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
        isectList[nxtIsect].ringAndEdge1Walkable = false;
        if (isectList[nxtIsect].ringAndEdge2Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
      }
    }
    currentOutputRingCoords.push(isectList[nxtIsect].coord);
    outputFeatureArray.push(
      polygon([currentOutputRingCoords], {
        index: currentOutputRing,
        parent: currentOutputRingParent,
        winding: currentOutputRingWinding,
        netWinding: void 0
      })
    );
  }
  var output = featureCollection$1(outputFeatureArray);
  determineParents();
  setNetWinding();
  function determineParents() {
    var featuresWithoutParent = [];
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1)
        featuresWithoutParent.push(i2);
    }
    if (featuresWithoutParent.length > 1) {
      for (var i2 = 0; i2 < featuresWithoutParent.length; i2++) {
        var parent = -1;
        var parentArea = Infinity;
        for (var j2 = 0; j2 < output.features.length; j2++) {
          if (featuresWithoutParent[i2] == j2)
            continue;
          if (booleanPointInPolygon(
            output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0],
            output.features[j2],
            { ignoreBoundary: true }
          )) {
            if (area(output.features[j2]) < parentArea) {
              parent = j2;
            }
          }
        }
        output.features[featuresWithoutParent[i2]].properties.parent = parent;
      }
    }
  }
  function setNetWinding() {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1) {
        var netWinding = output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  function setNetWindingOfChildren(parent, ParentNetWinding) {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == parent) {
        var netWinding = ParentNetWinding + output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  return output;
}
var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
  this.coord = coord;
  this.param = param;
  this.ringAndEdgeIn = ringAndEdgeIn;
  this.ringAndEdgeOut = ringAndEdgeOut;
  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
};
var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
  this.coord = coord;
  this.ringAndEdge1 = ringAndEdge1;
  this.ringAndEdge2 = ringAndEdge2;
  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
  this.ringAndEdge1Walkable = ringAndEdge1Walkable;
  this.ringAndEdge2Walkable = ringAndEdge2Walkable;
};
function isConvex(pts, righthanded) {
  if (typeof righthanded === "undefined")
    righthanded = true;
  if (pts.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
  return d >= 0 == righthanded;
}
function windingOfRing(ring) {
  var leftVtx = 0;
  for (var i = 0; i < ring.length - 1; i++) {
    if (ring[i][0] < ring[leftVtx][0])
      leftVtx = i;
  }
  if (isConvex(
    [
      ring[modulo(leftVtx - 1, ring.length - 1)],
      ring[leftVtx],
      ring[modulo(leftVtx + 1, ring.length - 1)]
    ],
    true
  )) {
    var winding = 1;
  } else {
    var winding = -1;
  }
  return winding;
}
function equalArrays$1(array1, array2) {
  if (!array1 || !array2)
    return false;
  if (array1.length != array2.length)
    return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays$1(array1[i], array2[i]))
        return false;
    } else if (array1[i] != array2[i]) {
      return false;
    }
  }
  return true;
}
function modulo(n, m2) {
  return (n % m2 + m2) % m2;
}
function isUnique(array) {
  var u = {};
  var isUnique2 = 1;
  for (var i = 0, l = array.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(u, array[i])) {
      isUnique2 = 0;
      break;
    }
    u[array[i]] = 1;
  }
  return isUnique2;
}
function unkinkPolygon(geojson) {
  var features2 = [];
  flattenEach(geojson, function(feature2) {
    if (feature2.geometry.type !== "Polygon")
      return;
    featureEach$1(simplepolygon(feature2), function(poly) {
      features2.push(polygon(poly.geometry.coordinates, feature2.properties));
    });
  });
  return featureCollection$1(features2);
}
var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;
var Coord = function(lon2, lat2) {
  this.lon = lon2;
  this.lat = lat2;
  this.x = D2R * lon2;
  this.y = D2R * lat2;
};
Coord.prototype.view = function() {
  return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
Coord.prototype.antipode = function() {
  var anti_lat = -1 * this.lat;
  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
  return new Coord(anti_lon, anti_lat);
};
var LineString$1 = function() {
  this.coords = [];
  this.length = 0;
};
LineString$1.prototype.move_to = function(coord) {
  this.length++;
  this.coords.push(coord);
};
var Arc$2 = function(properties) {
  this.properties = properties || {};
  this.geometries = [];
};
Arc$2.prototype.json = function() {
  if (this.geometries.length <= 0) {
    return {
      geometry: { type: "LineString", coordinates: null },
      type: "Feature",
      properties: this.properties
    };
  } else if (this.geometries.length === 1) {
    return {
      geometry: { type: "LineString", coordinates: this.geometries[0].coords },
      type: "Feature",
      properties: this.properties
    };
  } else {
    var multiline = [];
    for (var i = 0; i < this.geometries.length; i++) {
      multiline.push(this.geometries[i].coords);
    }
    return {
      geometry: { type: "MultiLineString", coordinates: multiline },
      type: "Feature",
      properties: this.properties
    };
  }
};
Arc$2.prototype.wkt = function() {
  var wkt_string = "";
  var wkt = "LINESTRING(";
  var collect2 = function(c) {
    wkt += c[0] + " " + c[1] + ",";
  };
  for (var i = 0; i < this.geometries.length; i++) {
    if (this.geometries[i].coords.length === 0) {
      return "LINESTRING(empty)";
    } else {
      var coords = this.geometries[i].coords;
      coords.forEach(collect2);
      wkt_string += wkt.substring(0, wkt.length - 1) + ")";
    }
  }
  return wkt_string;
};
var GreatCircle = function(start2, end2, properties) {
  if (!start2 || start2.x === void 0 || start2.y === void 0) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  if (!end2 || end2.x === void 0 || end2.y === void 0) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  this.start = new Coord(start2.x, start2.y);
  this.end = new Coord(end2.x, end2.y);
  this.properties = properties || {};
  var w = this.start.x - this.end.x;
  var h = this.start.y - this.end.y;
  var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
  this.g = 2 * Math.asin(Math.sqrt(z));
  if (this.g === Math.PI) {
    throw new Error(
      "it appears " + start2.view() + " and " + end2.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
    );
  } else if (isNaN(this.g)) {
    throw new Error(
      "could not calculate great circle between " + start2 + " and " + end2
    );
  }
};
GreatCircle.prototype.interpolate = function(f) {
  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
  var B2 = Math.sin(f * this.g) / Math.sin(this.g);
  var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
  var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
  var z = A * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
  var lat2 = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
  var lon2 = R2D * Math.atan2(y2, x2);
  return [lon2, lat2];
};
GreatCircle.prototype.Arc = function(npoints, options) {
  var first_pass = [];
  if (!npoints || npoints <= 2) {
    first_pass.push([this.start.lon, this.start.lat]);
    first_pass.push([this.end.lon, this.end.lat]);
  } else {
    var delta2 = 1 / (npoints - 1);
    for (var i = 0; i < npoints; ++i) {
      var step = delta2 * i;
      var pair = this.interpolate(step);
      first_pass.push(pair);
    }
  }
  var bHasBigDiff = false;
  var dfMaxSmallDiffLong = 0;
  var dfDateLineOffset = options && options.offset ? options.offset : 10;
  var dfLeftBorderX = 180 - dfDateLineOffset;
  var dfRightBorderX = -180 + dfDateLineOffset;
  var dfDiffSpace = 360 - dfDateLineOffset;
  for (var j = 1; j < first_pass.length; ++j) {
    var dfPrevX = first_pass[j - 1][0];
    var dfX = first_pass[j][0];
    var dfDiffLong = Math.abs(dfX - dfPrevX);
    if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
      bHasBigDiff = true;
    } else if (dfDiffLong > dfMaxSmallDiffLong) {
      dfMaxSmallDiffLong = dfDiffLong;
    }
  }
  var poMulti = [];
  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
    var poNewLS = [];
    poMulti.push(poNewLS);
    for (var k = 0; k < first_pass.length; ++k) {
      var dfX0 = parseFloat(first_pass[k][0]);
      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
        var dfX1 = parseFloat(first_pass[k - 1][0]);
        var dfY1 = parseFloat(first_pass[k - 1][1]);
        var dfX2 = parseFloat(first_pass[k][0]);
        var dfY2 = parseFloat(first_pass[k][1]);
        if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
          poNewLS.push([-180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
          poNewLS.push([180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        }
        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
          var tmpX = dfX1;
          dfX1 = dfX2;
          dfX2 = tmpX;
          var tmpY = dfY1;
          dfY1 = dfY2;
          dfY2 = tmpY;
        }
        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
          dfX2 += 360;
        }
        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
            dfY
          ]);
          poNewLS = [];
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
            dfY
          ]);
          poMulti.push(poNewLS);
        } else {
          poNewLS = [];
          poMulti.push(poNewLS);
        }
        poNewLS.push([dfX0, first_pass[k][1]]);
      } else {
        poNewLS.push([first_pass[k][0], first_pass[k][1]]);
      }
    }
  } else {
    var poNewLS0 = [];
    poMulti.push(poNewLS0);
    for (var l = 0; l < first_pass.length; ++l) {
      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
    }
  }
  var arc = new Arc$2(this.properties);
  for (var m2 = 0; m2 < poMulti.length; ++m2) {
    var line = new LineString$1();
    arc.geometries.push(line);
    var points2 = poMulti[m2];
    for (var j0 = 0; j0 < points2.length; ++j0) {
      line.move_to(points2[j0]);
    }
  }
  return arc;
};
function greatCircle(start2, end2, options) {
  options = options || {};
  if (typeof options !== "object")
    throw new Error("options is invalid");
  var properties = options.properties;
  var npoints = options.npoints;
  var offset = options.offset;
  start2 = getCoord(start2);
  end2 = getCoord(end2);
  properties = properties || {};
  npoints = npoints || 100;
  offset = offset || 10;
  var generator = new GreatCircle(
    { x: start2[0], y: start2[1] },
    { x: end2[0], y: end2[1] },
    properties
  );
  var line = generator.Arc(npoints, { offset });
  return line.json();
}
function lineSplit(line, splitter) {
  if (!line)
    throw new Error("line is required");
  if (!splitter)
    throw new Error("splitter is required");
  var lineType = getType$1(line);
  var splitterType = getType$1(splitter);
  if (lineType !== "LineString")
    throw new Error("line must be LineString");
  if (splitterType === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (splitterType === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var truncatedSplitter = truncate(splitter, { precision: 7 });
  switch (splitterType) {
    case "Point":
      return splitLineWithPoint(line, truncatedSplitter);
    case "MultiPoint":
      return splitLineWithPoints(line, truncatedSplitter);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));
  }
}
function splitLineWithPoints(line, splitter) {
  var results = [];
  var tree = rbush$1();
  flattenEach(splitter, function(point4) {
    results.forEach(function(feature2, index2) {
      feature2.id = index2;
    });
    if (!results.length) {
      results = splitLineWithPoint(line, point4).features;
      results.forEach(function(feature2) {
        if (!feature2.bbox)
          feature2.bbox = square(bbox$1(feature2));
      });
      tree.load(featureCollection$1(results));
    } else {
      var search = tree.search(point4);
      if (search.features.length) {
        var closestLine = findClosestFeature(point4, search);
        results = results.filter(function(feature2) {
          return feature2.id !== closestLine.id;
        });
        tree.remove(closestLine);
        featureEach$1(splitLineWithPoint(closestLine, point4), function(line2) {
          results.push(line2);
          tree.insert(line2);
        });
      }
    }
  });
  return featureCollection$1(results);
}
function splitLineWithPoint(line, splitter) {
  var results = [];
  var startPoint = getCoords(line)[0];
  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];
  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter)))
    return featureCollection$1([line]);
  var tree = rbush$1();
  var segments = lineSegment(line);
  tree.load(segments);
  var search = tree.search(splitter);
  if (!search.features.length)
    return featureCollection$1([line]);
  var closestSegment = findClosestFeature(splitter, search);
  var initialValue = [startPoint];
  var lastCoords = featureReduce(
    segments,
    function(previous, current, index2) {
      var currentCoords = getCoords(current)[1];
      var splitterCoords = getCoord(splitter);
      if (index2 === closestSegment.id) {
        previous.push(splitterCoords);
        results.push(lineString(previous));
        if (pointsEquals(splitterCoords, currentCoords))
          return [splitterCoords];
        return [splitterCoords, currentCoords];
      } else {
        previous.push(currentCoords);
        return previous;
      }
    },
    initialValue
  );
  if (lastCoords.length > 1) {
    results.push(lineString(lastCoords));
  }
  return featureCollection$1(results);
}
function findClosestFeature(point4, lines) {
  if (!lines.features.length)
    throw new Error("lines must contain features");
  if (lines.features.length === 1)
    return lines.features[0];
  var closestFeature;
  var closestDistance = Infinity;
  featureEach$1(lines, function(segment) {
    var pt = nearestPointOnLine(segment, point4);
    var dist3 = pt.properties.dist;
    if (dist3 < closestDistance) {
      closestFeature = segment;
      closestDistance = dist3;
    }
  });
  return closestFeature;
}
function pointsEquals(pt12, pt22) {
  return pt12[0] === pt22[0] && pt12[1] === pt22[1];
}
function lineArc(center2, radius, bearing1, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var steps = options.steps || 64;
  var angle1 = convertAngleTo360$1(bearing1);
  var angle22 = convertAngleTo360$1(bearing2);
  var properties = !Array.isArray(center2) && center2.type === "Feature" ? center2.properties : {};
  if (angle1 === angle22) {
    return lineString(circle(center2, radius, options).geometry.coordinates[0], properties);
  }
  var arcStartDegree = angle1;
  var arcEndDegree = angle1 < angle22 ? angle22 : angle22 + 360;
  var alfa = arcStartDegree;
  var coordinates = [];
  var i = 0;
  while (alfa < arcEndDegree) {
    coordinates.push(destination(center2, radius, alfa, options).geometry.coordinates);
    i++;
    alfa = arcStartDegree + i * 360 / steps;
  }
  if (alfa > arcEndDegree) {
    coordinates.push(destination(center2, radius, arcEndDegree, options).geometry.coordinates);
  }
  return lineString(coordinates, properties);
}
function convertAngleTo360$1(alfa) {
  var beta = alfa % 360;
  if (beta < 0) {
    beta += 360;
  }
  return beta;
}
function polygonToLine(poly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(poly);
  if (!options.properties && poly.type === "Feature") {
    options.properties = poly.properties;
  }
  switch (geom.type) {
    case "Polygon":
      return polygonToLine$1(geom, options);
    case "MultiPolygon":
      return multiPolygonToLine(geom, options);
    default:
      throw new Error("invalid poly");
  }
}
function polygonToLine$1(poly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(poly);
  var coords = geom.coordinates;
  var properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
  return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(multiPoly);
  var coords = geom.coordinates;
  var properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
  var lines = [];
  coords.forEach(function(coord) {
    lines.push(coordsToLine(coord, properties));
  });
  return featureCollection$1(lines);
}
function coordsToLine(coords, properties) {
  if (coords.length > 1) {
    return multiLineString(coords, properties);
  }
  return lineString(coords[0], properties);
}
function lineToPolygon(lines, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2, _b2, _c2;
  var properties = options.properties;
  var autoComplete = (_a2 = options.autoComplete) !== null && _a2 !== void 0 ? _a2 : true;
  var orderCoords = (_b2 = options.orderCoords) !== null && _b2 !== void 0 ? _b2 : true;
  var mutate = (_c2 = options.mutate) !== null && _c2 !== void 0 ? _c2 : false;
  if (!mutate) {
    lines = clone$5(lines);
  }
  switch (lines.type) {
    case "FeatureCollection":
      var coords = [];
      lines.features.forEach(function(line) {
        coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
      });
      return multiPolygon(coords, properties);
    default:
      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
  }
}
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
  properties = properties ? properties : line.type === "Feature" ? line.properties : {};
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var type = geom.type;
  if (!coords.length)
    throw new Error("line must contain coordinates");
  switch (type) {
    case "LineString":
      if (autoComplete)
        coords = autoCompleteCoords(coords);
      return polygon([coords], properties);
    case "MultiLineString":
      var multiCoords = [];
      var largestArea = 0;
      coords.forEach(function(coord) {
        if (autoComplete)
          coord = autoCompleteCoords(coord);
        if (orderCoords) {
          var area5 = calculateArea(bbox$1(lineString(coord)));
          if (area5 > largestArea) {
            multiCoords.unshift(coord);
            largestArea = area5;
          } else
            multiCoords.push(coord);
        } else {
          multiCoords.push(coord);
        }
      });
      return polygon(multiCoords, properties);
    default:
      throw new Error("geometry type " + type + " is not supported");
  }
}
function autoCompleteCoords(coords) {
  var first = coords[0];
  var x12 = first[0];
  var y12 = first[1];
  var last = coords[coords.length - 1];
  var x2 = last[0];
  var y2 = last[1];
  if (x12 !== x2 || y12 !== y2) {
    coords.push(first);
  }
  return coords;
}
function calculateArea(bbox2) {
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  return Math.abs(west - east) * Math.abs(south - north);
}
function lineclip(points2, bbox2, result) {
  var len2 = points2.length, codeA = bitCode(points2[0], bbox2), part = [], i, codeB, lastCode;
  var a;
  var b;
  if (!result)
    result = [];
  for (i = 1; i < len2; i++) {
    a = points2[i - 1];
    b = points2[i];
    codeB = lastCode = bitCode(b, bbox2);
    while (true) {
      if (!(codeA | codeB)) {
        part.push(a);
        if (codeB !== lastCode) {
          part.push(b);
          if (i < len2 - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === len2 - 1) {
          part.push(b);
        }
        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        a = intersect$2(a, b, codeA, bbox2);
        codeA = bitCode(a, bbox2);
      } else {
        b = intersect$2(a, b, codeB, bbox2);
        codeB = bitCode(b, bbox2);
      }
    }
    codeA = lastCode;
  }
  if (part.length)
    result.push(part);
  return result;
}
function polygonclip(points2, bbox2) {
  var result, edge, prev, prevInside, i, p, inside2;
  for (edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = points2[points2.length - 1];
    prevInside = !(bitCode(prev, bbox2) & edge);
    for (i = 0; i < points2.length; i++) {
      p = points2[i];
      inside2 = !(bitCode(p, bbox2) & edge);
      if (inside2 !== prevInside)
        result.push(intersect$2(prev, p, edge, bbox2));
      if (inside2)
        result.push(p);
      prev = p;
      prevInside = inside2;
    }
    points2 = result;
    if (!points2.length)
      break;
  }
  return result;
}
function intersect$2(a, b, edge, bbox2) {
  return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox2[3] - a[1]) / (b[1] - a[1]), bbox2[3]] : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox2[1] - a[1]) / (b[1] - a[1]), bbox2[1]] : edge & 2 ? [bbox2[2], a[1] + (b[1] - a[1]) * (bbox2[2] - a[0]) / (b[0] - a[0])] : edge & 1 ? [bbox2[0], a[1] + (b[1] - a[1]) * (bbox2[0] - a[0]) / (b[0] - a[0])] : null;
}
function bitCode(p, bbox2) {
  var code = 0;
  if (p[0] < bbox2[0])
    code |= 1;
  else if (p[0] > bbox2[2])
    code |= 2;
  if (p[1] < bbox2[1])
    code |= 4;
  else if (p[1] > bbox2[3])
    code |= 8;
  return code;
}
function bboxClip(feature2, bbox2) {
  var geom = getGeom(feature2);
  var type = geom.type;
  var properties = feature2.type === "Feature" ? feature2.properties : {};
  var coords = geom.coordinates;
  switch (type) {
    case "LineString":
    case "MultiLineString": {
      var lines_1 = [];
      if (type === "LineString") {
        coords = [coords];
      }
      coords.forEach(function(line) {
        lineclip(line, bbox2, lines_1);
      });
      if (lines_1.length === 1) {
        return lineString(lines_1[0], properties);
      }
      return multiLineString(lines_1, properties);
    }
    case "Polygon":
      return polygon(clipPolygon$1(coords, bbox2), properties);
    case "MultiPolygon":
      return multiPolygon(coords.map(function(poly) {
        return clipPolygon$1(poly, bbox2);
      }), properties);
    default:
      throw new Error("geometry " + type + " not supported");
  }
}
function clipPolygon$1(rings, bbox2) {
  var outRings = [];
  for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
    var ring = rings_1[_i];
    var clipped = polygonclip(ring, bbox2);
    if (clipped.length > 0) {
      if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
        clipped.push(clipped[0]);
      }
      if (clipped.length >= 4) {
        outRings.push(clipped);
      }
    }
  }
  return outRings;
}
var toStr$4 = Object.prototype.toString;
var isArguments$2 = function isArguments(value) {
  var str = toStr$4.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$4.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var keysShim$1;
if (!Object.keys) {
  var has$3 = Object.prototype.hasOwnProperty;
  var toStr$3 = Object.prototype.toString;
  var isArgs$1 = isArguments$2;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
  var hasProtoEnumBug = isEnumerable.call(function() {
  }, "prototype");
  var dontEnums = [
    "toString",
    "toLocaleString",
    "valueOf",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "constructor"
  ];
  var equalsConstructorPrototype = function(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys["$" + k] && has$3.call(window, k) && window[k] !== null && typeof window[k] === "object") {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e2) {
            return true;
          }
        }
      } catch (e2) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function(o) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e2) {
      return false;
    }
  };
  keysShim$1 = function keys3(object2) {
    var isObject2 = object2 !== null && typeof object2 === "object";
    var isFunction2 = toStr$3.call(object2) === "[object Function]";
    var isArguments5 = isArgs$1(object2);
    var isString2 = isObject2 && toStr$3.call(object2) === "[object String]";
    var theKeys = [];
    if (!isObject2 && !isFunction2 && !isArguments5) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction2;
    if (isString2 && object2.length > 0 && !has$3.call(object2, 0)) {
      for (var i = 0; i < object2.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments5 && object2.length > 0) {
      for (var j = 0; j < object2.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name2 in object2) {
        if (!(skipProto && name2 === "prototype") && has$3.call(object2, name2)) {
          theKeys.push(String(name2));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === "constructor") && has$3.call(object2, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
var implementation$8 = keysShim$1;
var slice$2 = Array.prototype.slice;
var isArgs = isArguments$2;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : implementation$8;
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object2) {
        if (isArgs(object2)) {
          return originalKeys(slice$2.call(object2));
        }
        return originalKeys(object2);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim;
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var hasSymbols$3 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$3() && !!Symbol.toStringTag;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$2 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$2 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$7 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$2.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$1.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args.concat(slice$1.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice$1.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation$6 = implementation$7;
var functionBind = Function.prototype.bind || implementation$6;
var bind$6 = functionBind;
var src = bind$6.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols$2();
var getProto$1 = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$5 = functionBind;
var hasOwn$1 = src;
var $concat = bind$5.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$5.call(Function.apply, Array.prototype.splice);
var $replace = bind$5.call(Function.call, String.prototype.replace);
var $strSlice = bind$5.call(Function.call, String.prototype.slice);
var $exec$1 = bind$5.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec$1(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$3 = { exports: {} };
(function(module) {
  var bind4 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind4.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind4, $call, arguments);
    if ($gOPD2 && $defineProperty2) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty2(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind4, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$3);
var GetIntrinsic$1 = getIntrinsic;
var callBind$2 = callBind$3.exports;
var $indexOf = callBind$2(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$2 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind$2(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$2 = shams();
var callBound$1 = callBound$2;
var $toString$1 = callBound$1("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$2 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var GetIntrinsic2 = getIntrinsic;
var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors() {
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
      return true;
    } catch (e2) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var keys$1 = objectKeys$1;
var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$1 = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction$2 = function(fn) {
  return typeof fn === "function" && toStr$1.call(fn) === "[object Function]";
};
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var supportsDescriptors$2 = origDefineProperty && hasPropertyDescriptors2;
var defineProperty$1 = function(object2, name2, value, predicate) {
  if (name2 in object2 && (!isFunction$2(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors$2) {
    origDefineProperty(object2, name2, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object2[name2] = value;
  }
};
var defineProperties = function(object2, map5) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys$1(map5);
  if (hasSymbols2) {
    props = concat.call(props, Object.getOwnPropertySymbols(map5));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty$1(object2, props[i], map5[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors$2;
var defineProperties_1 = defineProperties;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$5 = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};
var implementation$4 = implementation$5;
var polyfill$2 = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$4;
};
var getPolyfill$3 = polyfill$2;
var define$2 = defineProperties_1;
var shim$3 = function shimObjectIs() {
  var polyfill2 = getPolyfill$3();
  define$2(Object, { is: polyfill2 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill2;
    }
  });
  return polyfill2;
};
var define$1 = defineProperties_1;
var callBind$1 = callBind$3.exports;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$2;
var shim$2 = shim$3;
var polyfill$1 = callBind$1(getPolyfill$2(), Object);
define$1(polyfill$1, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$2
});
var objectIs = polyfill$1;
var callBound = callBound$2;
var hasToStringTag$1 = shams();
var has$2;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$1) {
  has$2 = callBound("Object.prototype.hasOwnProperty");
  $exec = callBound("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString = callBound("Object.prototype.toString");
var gOPD$2 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$1 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD$2(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has$2(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e2) {
    return e2 === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString(value) === regexClass;
};
var implementation$2 = { exports: {} };
var functionsHaveNames = function functionsHaveNames2() {
  return typeof function f() {
  }.name === "string";
};
var gOPD$1 = Object.getOwnPropertyDescriptor;
if (gOPD$1) {
  try {
    gOPD$1([], "length");
  } catch (e2) {
    gOPD$1 = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD$1) {
    return false;
  }
  var desc = gOPD$1(function() {
  }, "name");
  return !!desc && !!desc.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === "function" && function f() {
  }.bind().name !== "";
};
var functionsHaveNames_1 = functionsHaveNames;
(function(module) {
  var functionsHaveConfigurableNames2 = functionsHaveNames_1.functionsHaveConfigurableNames();
  var $Object = Object;
  var $TypeError2 = TypeError;
  module.exports = function flags2() {
    if (this != null && this !== $Object(this)) {
      throw new $TypeError2("RegExp.prototype.flags getter called on non-object");
    }
    var result = "";
    if (this.hasIndices) {
      result += "d";
    }
    if (this.global) {
      result += "g";
    }
    if (this.ignoreCase) {
      result += "i";
    }
    if (this.multiline) {
      result += "m";
    }
    if (this.dotAll) {
      result += "s";
    }
    if (this.unicode) {
      result += "u";
    }
    if (this.sticky) {
      result += "y";
    }
    return result;
  };
  if (functionsHaveConfigurableNames2 && Object.defineProperty) {
    Object.defineProperty(module.exports, "name", { value: "get flags" });
  }
})(implementation$2);
var implementation$1 = implementation$2.exports;
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD = Object.getOwnPropertyDescriptor;
var polyfill = function getPolyfill2() {
  if (supportsDescriptors$1 && /a/mig.flags === "gim") {
    var descriptor = $gOPD(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
      var calls = "";
      var o = {};
      Object.defineProperty(o, "hasIndices", {
        get: function() {
          calls += "d";
        }
      });
      Object.defineProperty(o, "sticky", {
        get: function() {
          calls += "y";
        }
      });
      if (calls === "dy") {
        return descriptor.get;
      }
    }
  }
  return implementation$1;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var getPolyfill$1 = polyfill;
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;
var shim$1 = function shimFlags() {
  if (!supportsDescriptors || !getProto) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill2 = getPolyfill$1();
  var proto2 = getProto(regex);
  var descriptor = gOPD(proto2, "flags");
  if (!descriptor || descriptor.get !== polyfill2) {
    defineProperty(proto2, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill2
    });
  }
  return polyfill2;
};
var define = defineProperties_1;
var callBind = callBind$3.exports;
var implementation = implementation$2.exports;
var getPolyfill3 = polyfill;
var shim = shim$1;
var flagsBound = callBind(getPolyfill3());
define(flagsBound, {
  getPolyfill: getPolyfill3,
  implementation,
  shim
});
var regexp_prototype_flags = flagsBound;
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};
var objectKeys = objectKeys$1;
var isArguments4 = isArguments$1;
var is2 = objectIs;
var isRegex3 = isRegex$1;
var flags = regexp_prototype_flags;
var isDate$1 = isDateObject;
var getTime$1 = Date.prototype.getTime;
function deepEqual$1(actual, expected, options) {
  var opts = options || {};
  if (opts.strict ? is2(actual, expected) : actual === expected) {
    return true;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? is2(actual, expected) : actual == expected;
  }
  return objEquiv(actual, expected, opts);
}
function isUndefinedOrNull(value) {
  return value === null || value === void 0;
}
function isBuffer$1(x2) {
  if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
    return false;
  }
  if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
    return false;
  }
  if (x2.length > 0 && typeof x2[0] !== "number") {
    return false;
  }
  return true;
}
function objEquiv(a, b, opts) {
  var i, key;
  if (typeof a !== typeof b) {
    return false;
  }
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
    return false;
  }
  if (a.prototype !== b.prototype) {
    return false;
  }
  if (isArguments4(a) !== isArguments4(b)) {
    return false;
  }
  var aIsRegex = isRegex3(a);
  var bIsRegex = isRegex3(b);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if (aIsRegex || bIsRegex) {
    return a.source === b.source && flags(a) === flags(b);
  }
  if (isDate$1(a) && isDate$1(b)) {
    return getTime$1.call(a) === getTime$1.call(b);
  }
  var aIsBuffer = isBuffer$1(a);
  var bIsBuffer = isBuffer$1(b);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  try {
    var ka = objectKeys(a);
    var kb = objectKeys(b);
  } catch (e2) {
    return false;
  }
  if (ka.length !== kb.length) {
    return false;
  }
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    }
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual$1(a[key], b[key], opts)) {
      return false;
    }
  }
  return true;
}
var deepEqual_1 = deepEqual$1;
function lineOverlap(line1, line2, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var tolerance = options.tolerance || 0;
  var features2 = [];
  var tree = rbush$1();
  var line = lineSegment(line1);
  tree.load(line);
  var overlapSegment;
  segmentEach(line2, function(segment) {
    var doesOverlaps = false;
    if (!segment) {
      return;
    }
    featureEach$1(tree.search(segment), function(match) {
      if (doesOverlaps === false) {
        var coordsSegment = getCoords(segment).sort();
        var coordsMatch = getCoords(match).sort();
        if (deepEqual_1(coordsSegment, coordsMatch)) {
          doesOverlaps = true;
          if (overlapSegment)
            overlapSegment = concatSegment(overlapSegment, segment);
          else
            overlapSegment = segment;
        } else if (tolerance === 0 ? booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) : nearestPointOnLine(match, coordsSegment[0]).properties.dist <= tolerance && nearestPointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {
          doesOverlaps = true;
          if (overlapSegment)
            overlapSegment = concatSegment(overlapSegment, segment);
          else
            overlapSegment = segment;
        } else if (tolerance === 0 ? booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance && nearestPointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {
          if (overlapSegment)
            overlapSegment = concatSegment(overlapSegment, match);
          else
            overlapSegment = match;
        }
      }
    });
    if (doesOverlaps === false && overlapSegment) {
      features2.push(overlapSegment);
      overlapSegment = void 0;
    }
  });
  if (overlapSegment)
    features2.push(overlapSegment);
  return featureCollection$1(features2);
}
function concatSegment(line, segment) {
  var coords = getCoords(segment);
  var lineCoords = getCoords(line);
  var start2 = lineCoords[0];
  var end2 = lineCoords[lineCoords.length - 1];
  var geom = line.geometry.coordinates;
  if (deepEqual_1(coords[0], start2))
    geom.unshift(coords[1]);
  else if (deepEqual_1(coords[0], end2))
    geom.push(coords[1]);
  else if (deepEqual_1(coords[1], start2))
    geom.unshift(coords[0]);
  else if (deepEqual_1(coords[1], end2))
    geom.push(coords[0]);
  return line;
}
function sector(center2, radius, bearing1, bearing2, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var properties = options.properties;
  if (!center2)
    throw new Error("center is required");
  if (bearing1 === void 0 || bearing1 === null)
    throw new Error("bearing1 is required");
  if (bearing2 === void 0 || bearing2 === null)
    throw new Error("bearing2 is required");
  if (!radius)
    throw new Error("radius is required");
  if (typeof options !== "object")
    throw new Error("options must be an object");
  if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {
    return circle(center2, radius, options);
  }
  var coords = getCoords(center2);
  var arc = lineArc(center2, radius, bearing1, bearing2, options);
  var sliceCoords = [[coords]];
  coordEach(arc, function(currentCoords) {
    sliceCoords[0].push(currentCoords);
  });
  sliceCoords[0].push(coords);
  return polygon(sliceCoords, properties);
}
function convertAngleTo360(alfa) {
  var beta = alfa % 360;
  if (beta < 0)
    beta += 360;
  return beta;
}
function rhumbBearing(start2, end2, options) {
  if (options === void 0) {
    options = {};
  }
  var bear360;
  if (options.final) {
    bear360 = calculateRhumbBearing(getCoord(end2), getCoord(start2));
  } else {
    bear360 = calculateRhumbBearing(getCoord(start2), getCoord(end2));
  }
  var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
  return bear180;
}
function calculateRhumbBearing(from, to) {
  var phi1 = degreesToRadians(from[1]);
  var phi2 = degreesToRadians(to[1]);
  var deltaLambda = degreesToRadians(to[0] - from[0]);
  if (deltaLambda > Math.PI) {
    deltaLambda -= 2 * Math.PI;
  }
  if (deltaLambda < -Math.PI) {
    deltaLambda += 2 * Math.PI;
  }
  var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var theta = Math.atan2(deltaLambda, deltaPsi);
  return (radiansToDegrees(theta) + 360) % 360;
}
function rhumbDestination(origin, distance11, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var wasNegativeDistance = distance11 < 0;
  var distanceInMeters = convertLength(Math.abs(distance11), options.units, "meters");
  if (wasNegativeDistance)
    distanceInMeters = -Math.abs(distanceInMeters);
  var coords = getCoord(origin);
  var destination2 = calculateRhumbDestination(coords, distanceInMeters, bearing2);
  destination2[0] += destination2[0] - coords[0] > 180 ? -360 : coords[0] - destination2[0] > 180 ? 360 : 0;
  return point(destination2, options.properties);
}
function calculateRhumbDestination(origin, distance11, bearing2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  var delta2 = distance11 / radius;
  var lambda1 = origin[0] * Math.PI / 180;
  var phi1 = degreesToRadians(origin[1]);
  var theta = degreesToRadians(bearing2);
  var DeltaPhi = delta2 * Math.cos(theta);
  var phi2 = phi1 + DeltaPhi;
  if (Math.abs(phi2) > Math.PI / 2) {
    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
  }
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var DeltaLambda = delta2 * Math.sin(theta) / q;
  var lambda2 = lambda1 + DeltaLambda;
  return [
    (lambda2 * 180 / Math.PI + 540) % 360 - 180,
    phi2 * 180 / Math.PI
  ];
}
function polygonTangents(pt, polygon4) {
  var pointCoords = getCoords(pt);
  var polyCoords = getCoords(polygon4);
  var rtan;
  var ltan;
  var enext;
  var eprev;
  var bbox2 = bbox$1(polygon4);
  var nearestPtIndex = 0;
  var nearest = null;
  if (pointCoords[0] > bbox2[0] && pointCoords[0] < bbox2[2] && pointCoords[1] > bbox2[1] && pointCoords[1] < bbox2[3]) {
    nearest = nearestPoint(pt, explode$1(polygon4));
    nearestPtIndex = nearest.properties.featureIndex;
  }
  var type = getType$1(polygon4);
  switch (type) {
    case "Polygon":
      rtan = polyCoords[0][nearestPtIndex];
      ltan = polyCoords[0][0];
      if (nearest !== null) {
        if (nearest.geometry.coordinates[1] < pointCoords[1])
          ltan = polyCoords[0][nearestPtIndex];
      }
      eprev = isLeft(
        polyCoords[0][0],
        polyCoords[0][polyCoords[0].length - 1],
        pointCoords
      );
      var out2 = processPolygon$1(
        polyCoords[0],
        pointCoords,
        eprev,
        enext,
        rtan,
        ltan
      );
      rtan = out2[0];
      ltan = out2[1];
      break;
    case "MultiPolygon":
      var closestFeature = 0;
      var closestVertex = 0;
      var verticesCounted = 0;
      for (var i = 0; i < polyCoords[0].length; i++) {
        closestFeature = i;
        var verticeFound = false;
        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {
          closestVertex = i2;
          if (verticesCounted === nearestPtIndex) {
            verticeFound = true;
            break;
          }
          verticesCounted++;
        }
        if (verticeFound)
          break;
      }
      rtan = polyCoords[0][closestFeature][closestVertex];
      ltan = polyCoords[0][closestFeature][closestVertex];
      eprev = isLeft(
        polyCoords[0][0][0],
        polyCoords[0][0][polyCoords[0][0].length - 1],
        pointCoords
      );
      polyCoords.forEach(function(ring) {
        var out3 = processPolygon$1(
          ring[0],
          pointCoords,
          eprev,
          enext,
          rtan,
          ltan
        );
        rtan = out3[0];
        ltan = out3[1];
      });
      break;
  }
  return featureCollection$1([point(rtan), point(ltan)]);
}
function processPolygon$1(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {
  for (var i = 0; i < polygonCoords.length; i++) {
    var currentCoords = polygonCoords[i];
    var nextCoordPair = polygonCoords[i + 1];
    if (i === polygonCoords.length - 1) {
      nextCoordPair = polygonCoords[0];
    }
    enext = isLeft(currentCoords, nextCoordPair, ptCoords);
    if (eprev <= 0 && enext > 0) {
      if (!isBelow(ptCoords, currentCoords, rtan)) {
        rtan = currentCoords;
      }
    } else if (eprev > 0 && enext <= 0) {
      if (!isAbove(ptCoords, currentCoords, ltan)) {
        ltan = currentCoords;
      }
    }
    eprev = enext;
  }
  return [rtan, ltan];
}
function isAbove(point1, point22, point32) {
  return isLeft(point1, point22, point32) > 0;
}
function isBelow(point1, point22, point32) {
  return isLeft(point1, point22, point32) < 0;
}
function isLeft(point1, point22, point32) {
  return (point22[0] - point1[0]) * (point32[1] - point1[1]) - (point32[0] - point1[0]) * (point22[1] - point1[1]);
}
function booleanClockwise(line) {
  var ring = getCoords(line);
  var sum2 = 0;
  var i = 1;
  var prev;
  var cur;
  while (i < ring.length) {
    prev = cur || ring[0];
    cur = ring[i];
    sum2 += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i++;
  }
  return sum2 > 0;
}
function rewind(geojson, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var reverse5 = options.reverse || false;
  var mutate = options.mutate || false;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof reverse5 !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (mutate === false)
    geojson = clone$5(geojson);
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        rewindFeature(geometry2, reverse5);
      });
      return geojson;
    case "FeatureCollection":
      featureEach$1(geojson, function(feature2) {
        featureEach$1(rewindFeature(feature2, reverse5), function(result) {
          results.push(result);
        });
      });
      return featureCollection$1(results);
  }
  return rewindFeature(geojson, reverse5);
}
function rewindFeature(geojson, reverse5) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        rewindFeature(geometry2, reverse5);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse5);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse5);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse5);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse5);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse5) {
  if (booleanClockwise(coords) === reverse5)
    coords.reverse();
}
function rewindPolygon(coords, reverse5) {
  if (booleanClockwise(coords[0]) !== reverse5) {
    coords[0].reverse();
  }
  for (var i = 1; i < coords.length; i++) {
    if (booleanClockwise(coords[i]) === reverse5) {
      coords[i].reverse();
    }
  }
}
function gridToMatrix(grid, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip4 = options.flip;
  var flags2 = options.flags;
  collectionOf(grid, "Point", "input must contain Points");
  var pointsMatrix = sortPointsByLatLng(grid, flip4);
  var matrix = [];
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point4 = pointRow[c];
      if (point4.properties[zProperty])
        row.push(point4.properties[zProperty]);
      else
        row.push(0);
      if (flags2 === true)
        point4.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }
  return matrix;
}
function sortPointsByLatLng(points2, flip4) {
  var pointsByLatitude = {};
  featureEach$1(points2, function(point4) {
    var lat2 = getCoords(point4)[1];
    if (!pointsByLatitude[lat2])
      pointsByLatitude[lat2] = [];
    pointsByLatitude[lat2].push(point4);
  });
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat2) {
    var row = pointsByLatitude[lat2];
    var rowOrderedByLongitude = row.sort(function(a, b) {
      return getCoords(a)[0] - getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });
  var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
    if (flip4)
      return getCoords(a[0])[1] - getCoords(b[0])[1];
    else
      return getCoords(b[0])[1] - getCoords(a[0])[1];
  });
  return pointMatrix;
}
/*!
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
var defaultSettings = {
  successCallback: null,
  verbose: false,
  polygons: false
};
var settings = {};
function isoBands(data, minV, bandwidth, options) {
  options = options ? options : {};
  var optionKeys = Object.keys(defaultSettings);
  for (var i = 0; i < optionKeys.length; i++) {
    var key = optionKeys[i];
    var val = options[key];
    val = typeof val !== "undefined" && val !== null ? val : defaultSettings[key];
    settings[key] = val;
  }
  if (settings.verbose)
    console.log(
      "MarchingSquaresJS-isoBands: computing isobands for [" + minV + ":" + (minV + bandwidth) + "]"
    );
  var grid = computeBandGrid(data, minV, bandwidth);
  var ret;
  if (settings.polygons) {
    if (settings.verbose)
      console.log(
        "MarchingSquaresJS-isoBands: returning single polygons for each grid cell"
      );
    ret = BandGrid2Areas(grid);
  } else {
    if (settings.verbose)
      console.log(
        "MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"
      );
    ret = BandGrid2AreaPaths(grid);
  }
  if (typeof settings.successCallback === "function")
    settings.successCallback(ret);
  return ret;
}
var Node0 = 64, Node1 = 16, Node2 = 4, Node3 = 1;
var isoBandNextXTL = [];
var isoBandNextYTL = [];
var isoBandNextOTL = [];
var isoBandNextXTR = [];
var isoBandNextYTR = [];
var isoBandNextOTR = [];
var isoBandNextXRT = [];
var isoBandNextYRT = [];
var isoBandNextORT = [];
var isoBandNextXRB = [];
var isoBandNextYRB = [];
var isoBandNextORB = [];
var isoBandNextXBL = [];
var isoBandNextYBL = [];
var isoBandNextOBL = [];
var isoBandNextXBR = [];
var isoBandNextYBR = [];
var isoBandNextOBR = [];
var isoBandNextXLT = [];
var isoBandNextYLT = [];
var isoBandNextOLT = [];
var isoBandNextXLB = [];
var isoBandNextYLB = [];
var isoBandNextOLB = [];
isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
isoBandNextORT[85] = isoBandNextORB[85] = 1;
isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
isoBandNextORB[4] = isoBandNextORB[166] = 1;
isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
isoBandNextORT[16] = isoBandNextORT[154] = 1;
isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
isoBandNextORT[8] = isoBandNextORT[162] = 0;
isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
isoBandNextORB[8] = isoBandNextORB[162] = 1;
isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
isoBandNextORT[32] = isoBandNextORT[138] = 1;
isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
isoBandNextORB[32] = isoBandNextORB[138] = 0;
isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
isoBandNextORB[5] = isoBandNextORB[165] = 0;
isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
isoBandNextORT[80] = isoBandNextORT[90] = 1;
isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
isoBandNextORT[160] = isoBandNextORT[10] = 1;
isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
isoBandNextORB[160] = isoBandNextORB[10] = 0;
isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
isoBandNextORB[37] = isoBandNextORB[133] = 1;
isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
isoBandNextORT[82] = isoBandNextORT[88] = 1;
isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
isoBandNextORT[73] = isoBandNextORT[97] = 0;
isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
isoBandNextORB[73] = isoBandNextORB[97] = 0;
isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
isoBandNextORT[145] = isoBandNextORT[25] = 0;
isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
isoBandNextORB[70] = isoBandNextORB[100] = 0;
isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
isoBandNextORB[101] = isoBandNextORB[69] = 0;
isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
isoBandNextORT[89] = isoBandNextORT[81] = 0;
isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
isoBandNextORT[96] = isoBandNextORT[74] = 0;
isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
isoBandNextORB[96] = isoBandNextORB[74] = 1;
isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
isoBandNextORT[24] = isoBandNextORT[146] = 1;
isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
isoBandNextORB[6] = isoBandNextORB[164] = 1;
isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
isoBandNextORT[144] = isoBandNextORT[26] = 0;
isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
isoBandNextORB[36] = isoBandNextORB[134] = 1;
isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
isoBandNextORT[9] = isoBandNextORT[161] = 0;
isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
isoBandNextORB[9] = isoBandNextORB[161] = 0;
isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
isoBandNextXRT[136] = 0;
isoBandNextYRT[136] = 1;
isoBandNextORT[136] = 1;
isoBandNextXRB[136] = 0;
isoBandNextYRB[136] = 1;
isoBandNextORB[136] = 0;
isoBandNextXBR[136] = -1;
isoBandNextYBR[136] = 0;
isoBandNextOBR[136] = 1;
isoBandNextXBL[136] = -1;
isoBandNextYBL[136] = 0;
isoBandNextOBL[136] = 0;
isoBandNextXLB[136] = 0;
isoBandNextYLB[136] = -1;
isoBandNextOLB[136] = 0;
isoBandNextXLT[136] = 0;
isoBandNextYLT[136] = -1;
isoBandNextOLT[136] = 1;
isoBandNextXTL[136] = 1;
isoBandNextYTL[136] = 0;
isoBandNextOTL[136] = 0;
isoBandNextXTR[136] = 1;
isoBandNextYTR[136] = 0;
isoBandNextOTR[136] = 1;
isoBandNextXRT[34] = 0;
isoBandNextYRT[34] = -1;
isoBandNextORT[34] = 0;
isoBandNextXRB[34] = 0;
isoBandNextYRB[34] = -1;
isoBandNextORB[34] = 1;
isoBandNextXBR[34] = 1;
isoBandNextYBR[34] = 0;
isoBandNextOBR[34] = 0;
isoBandNextXBL[34] = 1;
isoBandNextYBL[34] = 0;
isoBandNextOBL[34] = 1;
isoBandNextXLB[34] = 0;
isoBandNextYLB[34] = 1;
isoBandNextOLB[34] = 1;
isoBandNextXLT[34] = 0;
isoBandNextYLT[34] = 1;
isoBandNextOLT[34] = 0;
isoBandNextXTL[34] = -1;
isoBandNextYTL[34] = 0;
isoBandNextOTL[34] = 1;
isoBandNextXTR[34] = -1;
isoBandNextYTR[34] = 0;
isoBandNextOTR[34] = 0;
isoBandNextXRT[35] = 0;
isoBandNextYRT[35] = 1;
isoBandNextORT[35] = 1;
isoBandNextXRB[35] = 0;
isoBandNextYRB[35] = -1;
isoBandNextORB[35] = 1;
isoBandNextXBR[35] = 1;
isoBandNextYBR[35] = 0;
isoBandNextOBR[35] = 0;
isoBandNextXBL[35] = -1;
isoBandNextYBL[35] = 0;
isoBandNextOBL[35] = 0;
isoBandNextXLB[35] = 0;
isoBandNextYLB[35] = -1;
isoBandNextOLB[35] = 0;
isoBandNextXLT[35] = 0;
isoBandNextYLT[35] = 1;
isoBandNextOLT[35] = 0;
isoBandNextXTL[35] = -1;
isoBandNextYTL[35] = 0;
isoBandNextOTL[35] = 1;
isoBandNextXTR[35] = 1;
isoBandNextYTR[35] = 0;
isoBandNextOTR[35] = 1;
isoBandNextXRT[153] = 0;
isoBandNextYRT[153] = 1;
isoBandNextORT[153] = 1;
isoBandNextXBL[153] = -1;
isoBandNextYBL[153] = 0;
isoBandNextOBL[153] = 0;
isoBandNextXLB[153] = 0;
isoBandNextYLB[153] = -1;
isoBandNextOLB[153] = 0;
isoBandNextXTR[153] = 1;
isoBandNextYTR[153] = 0;
isoBandNextOTR[153] = 1;
isoBandNextXRB[102] = 0;
isoBandNextYRB[102] = -1;
isoBandNextORB[102] = 1;
isoBandNextXBR[102] = 1;
isoBandNextYBR[102] = 0;
isoBandNextOBR[102] = 0;
isoBandNextXLT[102] = 0;
isoBandNextYLT[102] = 1;
isoBandNextOLT[102] = 0;
isoBandNextXTL[102] = -1;
isoBandNextYTL[102] = 0;
isoBandNextOTL[102] = 1;
isoBandNextXRT[155] = 0;
isoBandNextYRT[155] = -1;
isoBandNextORT[155] = 0;
isoBandNextXBL[155] = 1;
isoBandNextYBL[155] = 0;
isoBandNextOBL[155] = 1;
isoBandNextXLB[155] = 0;
isoBandNextYLB[155] = 1;
isoBandNextOLB[155] = 1;
isoBandNextXTR[155] = -1;
isoBandNextYTR[155] = 0;
isoBandNextOTR[155] = 0;
isoBandNextXRB[103] = 0;
isoBandNextYRB[103] = 1;
isoBandNextORB[103] = 0;
isoBandNextXBR[103] = -1;
isoBandNextYBR[103] = 0;
isoBandNextOBR[103] = 1;
isoBandNextXLT[103] = 0;
isoBandNextYLT[103] = -1;
isoBandNextOLT[103] = 1;
isoBandNextXTL[103] = 1;
isoBandNextYTL[103] = 0;
isoBandNextOTL[103] = 0;
isoBandNextXRT[152] = 0;
isoBandNextYRT[152] = 1;
isoBandNextORT[152] = 1;
isoBandNextXBR[152] = -1;
isoBandNextYBR[152] = 0;
isoBandNextOBR[152] = 1;
isoBandNextXBL[152] = -1;
isoBandNextYBL[152] = 0;
isoBandNextOBL[152] = 0;
isoBandNextXLB[152] = 0;
isoBandNextYLB[152] = -1;
isoBandNextOLB[152] = 0;
isoBandNextXLT[152] = 0;
isoBandNextYLT[152] = -1;
isoBandNextOLT[152] = 1;
isoBandNextXTR[152] = 1;
isoBandNextYTR[152] = 0;
isoBandNextOTR[152] = 1;
isoBandNextXRT[156] = 0;
isoBandNextYRT[156] = -1;
isoBandNextORT[156] = 1;
isoBandNextXBR[156] = 1;
isoBandNextYBR[156] = 0;
isoBandNextOBR[156] = 1;
isoBandNextXBL[156] = -1;
isoBandNextYBL[156] = 0;
isoBandNextOBL[156] = 0;
isoBandNextXLB[156] = 0;
isoBandNextYLB[156] = -1;
isoBandNextOLB[156] = 0;
isoBandNextXLT[156] = 0;
isoBandNextYLT[156] = 1;
isoBandNextOLT[156] = 1;
isoBandNextXTR[156] = -1;
isoBandNextYTR[156] = 0;
isoBandNextOTR[156] = 1;
isoBandNextXRT[137] = 0;
isoBandNextYRT[137] = 1;
isoBandNextORT[137] = 1;
isoBandNextXRB[137] = 0;
isoBandNextYRB[137] = 1;
isoBandNextORB[137] = 0;
isoBandNextXBL[137] = -1;
isoBandNextYBL[137] = 0;
isoBandNextOBL[137] = 0;
isoBandNextXLB[137] = 0;
isoBandNextYLB[137] = -1;
isoBandNextOLB[137] = 0;
isoBandNextXTL[137] = 1;
isoBandNextYTL[137] = 0;
isoBandNextOTL[137] = 0;
isoBandNextXTR[137] = 1;
isoBandNextYTR[137] = 0;
isoBandNextOTR[137] = 1;
isoBandNextXRT[139] = 0;
isoBandNextYRT[139] = 1;
isoBandNextORT[139] = 1;
isoBandNextXRB[139] = 0;
isoBandNextYRB[139] = -1;
isoBandNextORB[139] = 0;
isoBandNextXBL[139] = 1;
isoBandNextYBL[139] = 0;
isoBandNextOBL[139] = 0;
isoBandNextXLB[139] = 0;
isoBandNextYLB[139] = 1;
isoBandNextOLB[139] = 0;
isoBandNextXTL[139] = -1;
isoBandNextYTL[139] = 0;
isoBandNextOTL[139] = 0;
isoBandNextXTR[139] = 1;
isoBandNextYTR[139] = 0;
isoBandNextOTR[139] = 1;
isoBandNextXRT[98] = 0;
isoBandNextYRT[98] = -1;
isoBandNextORT[98] = 0;
isoBandNextXRB[98] = 0;
isoBandNextYRB[98] = -1;
isoBandNextORB[98] = 1;
isoBandNextXBR[98] = 1;
isoBandNextYBR[98] = 0;
isoBandNextOBR[98] = 0;
isoBandNextXBL[98] = 1;
isoBandNextYBL[98] = 0;
isoBandNextOBL[98] = 1;
isoBandNextXLT[98] = 0;
isoBandNextYLT[98] = 1;
isoBandNextOLT[98] = 0;
isoBandNextXTL[98] = -1;
isoBandNextYTL[98] = 0;
isoBandNextOTL[98] = 1;
isoBandNextXRT[99] = 0;
isoBandNextYRT[99] = 1;
isoBandNextORT[99] = 0;
isoBandNextXRB[99] = 0;
isoBandNextYRB[99] = -1;
isoBandNextORB[99] = 1;
isoBandNextXBR[99] = 1;
isoBandNextYBR[99] = 0;
isoBandNextOBR[99] = 0;
isoBandNextXBL[99] = -1;
isoBandNextYBL[99] = 0;
isoBandNextOBL[99] = 1;
isoBandNextXLT[99] = 0;
isoBandNextYLT[99] = -1;
isoBandNextOLT[99] = 0;
isoBandNextXTL[99] = 1;
isoBandNextYTL[99] = 0;
isoBandNextOTL[99] = 1;
isoBandNextXRB[38] = 0;
isoBandNextYRB[38] = -1;
isoBandNextORB[38] = 1;
isoBandNextXBR[38] = 1;
isoBandNextYBR[38] = 0;
isoBandNextOBR[38] = 0;
isoBandNextXLB[38] = 0;
isoBandNextYLB[38] = 1;
isoBandNextOLB[38] = 1;
isoBandNextXLT[38] = 0;
isoBandNextYLT[38] = 1;
isoBandNextOLT[38] = 0;
isoBandNextXTL[38] = -1;
isoBandNextYTL[38] = 0;
isoBandNextOTL[38] = 1;
isoBandNextXTR[38] = -1;
isoBandNextYTR[38] = 0;
isoBandNextOTR[38] = 0;
isoBandNextXRB[39] = 0;
isoBandNextYRB[39] = 1;
isoBandNextORB[39] = 1;
isoBandNextXBR[39] = -1;
isoBandNextYBR[39] = 0;
isoBandNextOBR[39] = 0;
isoBandNextXLB[39] = 0;
isoBandNextYLB[39] = -1;
isoBandNextOLB[39] = 1;
isoBandNextXLT[39] = 0;
isoBandNextYLT[39] = 1;
isoBandNextOLT[39] = 0;
isoBandNextXTL[39] = -1;
isoBandNextYTL[39] = 0;
isoBandNextOTL[39] = 1;
isoBandNextXTR[39] = 1;
isoBandNextYTR[39] = 0;
isoBandNextOTR[39] = 0;
var p00 = function(cell) {
  return [
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom]
  ];
};
var p01 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0]
  ];
};
var p02 = function(cell) {
  return [
    [cell.topright, 1],
    [1, 1],
    [1, cell.righttop]
  ];
};
var p03 = function(cell) {
  return [
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p04 = function(cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop]
  ];
};
var p05 = function(cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [1, cell.righttop],
    [1, cell.rightbottom]
  ];
};
var p06 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p07 = function(cell) {
  return [
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p08 = function(cell) {
  return [
    [0, 0],
    [0, cell.leftbottom],
    [1, cell.rightbottom],
    [1, 0]
  ];
};
var p09 = function(cell) {
  return [
    [1, 0],
    [cell.bottomright, 0],
    [cell.topright, 1],
    [1, 1]
  ];
};
var p10 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [0, cell.lefttop],
    [0, 1]
  ];
};
var p11 = function(cell) {
  return [
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p12 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [0, cell.leftbottom],
    [0, cell.lefttop]
  ];
};
var p13 = function(cell) {
  return [
    [cell.topleft, 1],
    [cell.topright, 1],
    [cell.bottomright, 0],
    [cell.bottomleft, 0]
  ];
};
var p14 = function() {
  return [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
};
var p15 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p16 = function(cell) {
  return [
    [cell.topright, 1],
    [1, 1],
    [1, 0],
    [0, 0],
    [0, cell.leftbottom]
  ];
};
var p17 = function(cell) {
  return [
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [1, 1]
  ];
};
var p18 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1]
  ];
};
var p19 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p20 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [cell.topright, 1]
  ];
};
var p21 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop]
  ];
};
var p22 = function(cell) {
  return [
    [cell.topright, 1],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1]
  ];
};
var p23 = function(cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p24 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1]
  ];
};
var p25 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p26 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom]
  ];
};
var p27 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p28 = function(cell) {
  return [
    [1, 1],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1]
  ];
};
var p29 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1]
  ];
};
var p30 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p31 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topright, 1]
  ];
};
var p32 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p33 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p34 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topright, 1]
  ];
};
var p35 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p36 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1]
  ];
};
var p37 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p38 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p39 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var isoBandEdgeRT = [];
var isoBandEdgeRB = [];
var isoBandEdgeBR = [];
var isoBandEdgeBL = [];
var isoBandEdgeLB = [];
var isoBandEdgeLT = [];
var isoBandEdgeTL = [];
var isoBandEdgeTR = [];
isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
var polygon_table = [];
polygon_table[1] = polygon_table[169] = p00;
polygon_table[4] = polygon_table[166] = p01;
polygon_table[16] = polygon_table[154] = p02;
polygon_table[64] = polygon_table[106] = p03;
polygon_table[168] = polygon_table[2] = p04;
polygon_table[162] = polygon_table[8] = p05;
polygon_table[138] = polygon_table[32] = p06;
polygon_table[42] = polygon_table[128] = p07;
polygon_table[5] = polygon_table[165] = p08;
polygon_table[20] = polygon_table[150] = p09;
polygon_table[80] = polygon_table[90] = p10;
polygon_table[65] = polygon_table[105] = p11;
polygon_table[160] = polygon_table[10] = p12;
polygon_table[130] = polygon_table[40] = p13;
polygon_table[85] = p14;
polygon_table[101] = polygon_table[69] = p15;
polygon_table[149] = polygon_table[21] = p16;
polygon_table[86] = polygon_table[84] = p17;
polygon_table[89] = polygon_table[81] = p18;
polygon_table[96] = polygon_table[74] = p19;
polygon_table[24] = polygon_table[146] = p20;
polygon_table[6] = polygon_table[164] = p21;
polygon_table[129] = polygon_table[41] = p22;
polygon_table[66] = polygon_table[104] = p23;
polygon_table[144] = polygon_table[26] = p24;
polygon_table[36] = polygon_table[134] = p25;
polygon_table[9] = polygon_table[161] = p26;
polygon_table[37] = polygon_table[133] = p27;
polygon_table[148] = polygon_table[22] = p28;
polygon_table[82] = polygon_table[88] = p29;
polygon_table[73] = polygon_table[97] = p30;
polygon_table[145] = polygon_table[25] = p31;
polygon_table[70] = polygon_table[100] = p32;
polygon_table[34] = function(c) {
  return [p07(c), p05(c)];
};
polygon_table[35] = p33;
polygon_table[136] = function(c) {
  return [p06(c), p04(c)];
};
polygon_table[153] = function(c) {
  return [p02(c), p00(c)];
};
polygon_table[102] = function(c) {
  return [p01(c), p03(c)];
};
polygon_table[155] = p34;
polygon_table[103] = p35;
polygon_table[152] = function(c) {
  return [p02(c), p04(c)];
};
polygon_table[156] = p36;
polygon_table[137] = function(c) {
  return [p06(c), p00(c)];
};
polygon_table[139] = p37;
polygon_table[98] = function(c) {
  return [p05(c), p03(c)];
};
polygon_table[99] = p38;
polygon_table[38] = function(c) {
  return [p01(c), p07(c)];
};
polygon_table[39] = p39;
function interpolateX(y2, y02, y12) {
  return (y2 - y02) / (y12 - y02);
}
function isArray$3(myArray) {
  return myArray.constructor.toString().indexOf("Array") > -1;
}
function computeBandGrid(data, minV, bandwidth) {
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var BandGrid = { rows, cols, cells: [] };
  var maxV = minV + Math.abs(bandwidth);
  for (var j = 0; j < rows; ++j) {
    BandGrid.cells[j] = [];
    for (var i = 0; i < cols; ++i) {
      var cval = 0;
      var tl = data[j + 1][i];
      var tr = data[j + 1][i + 1];
      var br = data[j][i + 1];
      var bl = data[j][i];
      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
        continue;
      }
      cval |= tl < minV ? 0 : tl > maxV ? 128 : 64;
      cval |= tr < minV ? 0 : tr > maxV ? 32 : 16;
      cval |= br < minV ? 0 : br > maxV ? 8 : 4;
      cval |= bl < minV ? 0 : bl > maxV ? 2 : 1;
      var cval_real = +cval;
      var flipped = 0;
      if (cval === 17 || cval === 18 || cval === 33 || cval === 34 || cval === 38 || cval === 68 || cval === 72 || cval === 98 || cval === 102 || cval === 132 || cval === 136 || cval === 137 || cval === 152 || cval === 153) {
        var average2 = (tl + tr + br + bl) / 4;
        flipped = average2 > maxV ? 2 : average2 < minV ? 0 : 1;
        if (cval === 34) {
          if (flipped === 1) {
            cval = 35;
          } else if (flipped === 0) {
            cval = 136;
          }
        } else if (cval === 136) {
          if (flipped === 1) {
            cval = 35;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 34;
          }
        } else if (cval === 17) {
          if (flipped === 1) {
            cval = 155;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 153;
          }
        } else if (cval === 68) {
          if (flipped === 1) {
            cval = 103;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 102;
          }
        } else if (cval === 153) {
          if (flipped === 1)
            cval = 155;
        } else if (cval === 102) {
          if (flipped === 1)
            cval = 103;
        } else if (cval === 152) {
          if (flipped < 2) {
            cval = 156;
            flipped = 1;
          }
        } else if (cval === 137) {
          if (flipped < 2) {
            cval = 139;
            flipped = 1;
          }
        } else if (cval === 98) {
          if (flipped < 2) {
            cval = 99;
            flipped = 1;
          }
        } else if (cval === 38) {
          if (flipped < 2) {
            cval = 39;
            flipped = 1;
          }
        } else if (cval === 18) {
          if (flipped > 0) {
            cval = 156;
            flipped = 4;
          } else {
            cval = 152;
          }
        } else if (cval === 33) {
          if (flipped > 0) {
            cval = 139;
            flipped = 4;
          } else {
            cval = 137;
          }
        } else if (cval === 72) {
          if (flipped > 0) {
            cval = 99;
            flipped = 4;
          } else {
            cval = 98;
          }
        } else if (cval === 132) {
          if (flipped > 0) {
            cval = 39;
            flipped = 4;
          } else {
            cval = 38;
          }
        }
      }
      if (cval != 0 && cval != 170) {
        var topleft, topright, bottomleft, bottomright, righttop, rightbottom, lefttop, leftbottom;
        topleft = topright = bottomleft = bottomright = righttop = rightbottom = lefttop = leftbottom = 0.5;
        var edges2 = [];
        if (cval === 1) {
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 169) {
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = interpolateX(maxV, bl, tl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 4) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = interpolateX(minV, bl, br);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 166) {
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = 1 - interpolateX(maxV, br, bl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 16) {
          righttop = interpolateX(minV, br, tr);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 154) {
          righttop = 1 - interpolateX(maxV, tr, br);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 64) {
          lefttop = interpolateX(minV, bl, tl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 106) {
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 168) {
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 2) {
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 162) {
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 8) {
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 138) {
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 32) {
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 42) {
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 128) {
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        }
        if (cval === 5) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 165) {
          rightbottom = interpolateX(maxV, br, tr);
          leftbottom = interpolateX(maxV, bl, tl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 20) {
          bottomright = interpolateX(minV, bl, br);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 150) {
          bottomright = 1 - interpolateX(maxV, br, bl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 80) {
          righttop = interpolateX(minV, br, tr);
          lefttop = interpolateX(minV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 90) {
          righttop = 1 - interpolateX(maxV, tr, br);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 65) {
          bottomleft = 1 - interpolateX(minV, br, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 105) {
          bottomleft = interpolateX(maxV, bl, br);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 160) {
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 10) {
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 130) {
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 40) {
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 101) {
          rightbottom = interpolateX(maxV, br, tr);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 69) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 149) {
          leftbottom = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 21) {
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 86) {
          bottomright = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 84) {
          bottomright = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 89) {
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 81) {
          righttop = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 96) {
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          lefttop = interpolateX(minV, bl, tl);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 74) {
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 24) {
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 146) {
          righttop = interpolateX(minV, br, tr);
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 6) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = 1 - interpolateX(maxV, br, bl);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 164) {
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = interpolateX(minV, bl, br);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 129) {
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = interpolateX(maxV, bl, tl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 41) {
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 66) {
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 104) {
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeTL[cval]);
        } else if (cval === 144) {
          righttop = interpolateX(minV, br, tr);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 26) {
          righttop = 1 - interpolateX(maxV, tr, br);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 36) {
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = interpolateX(minV, bl, br);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 134) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = 1 - interpolateX(maxV, br, bl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 9) {
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 161) {
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = interpolateX(maxV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 37) {
          rightbottom = interpolateX(maxV, br, tr);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topleft = interpolateX(minV, tl, tr);
          topright = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 133) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          leftbottom = interpolateX(maxV, bl, tl);
          topleft = 1 - interpolateX(maxV, tr, tl);
          topright = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 148) {
          bottomright = interpolateX(minV, bl, br);
          leftbottom = interpolateX(minV, bl, tl);
          lefttop = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 22) {
          bottomright = 1 - interpolateX(maxV, br, bl);
          leftbottom = 1 - interpolateX(maxV, tl, bl);
          lefttop = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 82) {
          righttop = interpolateX(minV, br, tr);
          bottomright = 1 - interpolateX(minV, br, bl);
          bottomleft = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 88) {
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomright = interpolateX(maxV, bl, br);
          bottomleft = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 73) {
          righttop = 1 - interpolateX(minV, tr, br);
          rightbottom = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 97) {
          righttop = interpolateX(maxV, br, tr);
          rightbottom = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 145) {
          righttop = interpolateX(minV, br, tr);
          bottomleft = 1 - interpolateX(minV, br, bl);
          leftbottom = interpolateX(maxV, bl, tl);
          topright = 1 - interpolateX(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 25) {
          righttop = 1 - interpolateX(maxV, tr, br);
          bottomleft = interpolateX(maxV, bl, br);
          leftbottom = 1 - interpolateX(minV, tl, bl);
          topright = interpolateX(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 70) {
          rightbottom = 1 - interpolateX(minV, tr, br);
          bottomright = 1 - interpolateX(maxV, br, bl);
          lefttop = 1 - interpolateX(maxV, tl, bl);
          topleft = 1 - interpolateX(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 100) {
          rightbottom = interpolateX(maxV, br, tr);
          bottomright = interpolateX(minV, bl, br);
          lefttop = interpolateX(minV, bl, tl);
          topleft = interpolateX(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 34) {
          if (flipped === 0) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 35) {
          if (flipped === 4) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 136) {
          if (flipped === 0) {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 153) {
          if (flipped === 0) {
            righttop = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 102) {
          if (flipped === 0) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 155) {
          if (flipped === 4) {
            righttop = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 103) {
          if (flipped === 4) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 152) {
          if (flipped === 0) {
            righttop = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 156) {
          if (flipped === 4) {
            righttop = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topright = interpolateX(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topright = 1 - interpolateX(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 137) {
          if (flipped === 0) {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 139) {
          if (flipped === 4) {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomleft = 1 - interpolateX(minV, br, bl);
            leftbottom = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomleft = interpolateX(maxV, bl, br);
            leftbottom = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 98) {
          if (flipped === 0) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 99) {
          if (flipped === 4) {
            righttop = 1 - interpolateX(minV, tr, br);
            rightbottom = 1 - interpolateX(maxV, tr, br);
            bottomright = interpolateX(maxV, bl, br);
            bottomleft = interpolateX(minV, bl, br);
            lefttop = interpolateX(minV, bl, tl);
            topleft = 1 - interpolateX(minV, tr, tl);
          } else {
            righttop = interpolateX(maxV, br, tr);
            rightbottom = interpolateX(minV, br, tr);
            bottomright = 1 - interpolateX(minV, br, bl);
            bottomleft = 1 - interpolateX(maxV, br, bl);
            lefttop = 1 - interpolateX(maxV, tl, bl);
            topleft = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 38) {
          if (flipped === 0) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 39) {
          if (flipped === 4) {
            rightbottom = 1 - interpolateX(minV, tr, br);
            bottomright = interpolateX(minV, bl, br);
            leftbottom = interpolateX(minV, bl, tl);
            lefttop = interpolateX(maxV, bl, tl);
            topleft = 1 - interpolateX(maxV, tr, tl);
            topright = 1 - interpolateX(minV, tr, tl);
          } else {
            rightbottom = interpolateX(maxV, br, tr);
            bottomright = 1 - interpolateX(maxV, br, bl);
            leftbottom = 1 - interpolateX(maxV, tl, bl);
            lefttop = 1 - interpolateX(minV, tl, bl);
            topleft = interpolateX(minV, tl, tr);
            topright = interpolateX(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 85) {
          righttop = 1;
          rightbottom = 0;
          bottomright = 1;
          bottomleft = 0;
          leftbottom = 0;
          lefttop = 1;
          topleft = 0;
          topright = 1;
        }
        if (topleft < 0 || topleft > 1 || topright < 0 || topright > 1 || righttop < 0 || righttop > 1 || bottomright < 0 || bottomright > 1 || leftbottom < 0 || leftbottom > 1 || lefttop < 0 || lefttop > 1) {
          console.log(
            "MarchingSquaresJS-isoBands: " + cval + " " + cval_real + " " + tl + "," + tr + "," + br + "," + bl + " " + flipped + " " + topleft + " " + topright + " " + righttop + " " + rightbottom + " " + bottomright + " " + bottomleft + " " + leftbottom + " " + lefttop
          );
        }
        BandGrid.cells[j][i] = {
          cval,
          cval_real,
          flipped,
          topleft,
          topright,
          righttop,
          rightbottom,
          bottomright,
          bottomleft,
          leftbottom,
          lefttop,
          edges: edges2
        };
      }
    }
  }
  return BandGrid;
}
function BandGrid2AreaPaths(grid) {
  var areas = [];
  var rows = grid.rows;
  var cols = grid.cols;
  var currentPolygon = [];
  for (var j = 0; j < rows; j++) {
    for (var i = 0; i < cols; i++) {
      if (typeof grid.cells[j][i] !== "undefined" && grid.cells[j][i].edges.length > 0) {
        var cell = grid.cells[j][i];
        var prev = getStartXY(cell), next3 = null, p = i, q = j;
        if (prev !== null) {
          currentPolygon.push([prev.p[0] + p, prev.p[1] + q]);
        }
        do {
          next3 = getExitXY(grid.cells[q][p], prev.x, prev.y, prev.o);
          if (next3 !== null) {
            currentPolygon.push([next3.p[0] + p, next3.p[1] + q]);
            p += next3.x;
            q += next3.y;
            prev = next3;
          } else {
            break;
          }
          if (q < 0 || q >= rows || p < 0 || p >= cols || typeof grid.cells[q][p] === "undefined") {
            p -= next3.x;
            q -= next3.y;
            var missing = traceOutOfGridPath(
              grid,
              p,
              q,
              next3.x,
              next3.y,
              next3.o
            );
            if (missing !== null) {
              missing.path.forEach(function(pp) {
                currentPolygon.push(pp);
              });
              p = missing.i;
              q = missing.j;
              prev = missing;
            } else {
              break;
            }
          }
        } while (typeof grid.cells[q][p] !== "undefined" && grid.cells[q][p].edges.length > 0);
        areas.push(currentPolygon);
        currentPolygon = [];
        if (grid.cells[j][i].edges.length > 0)
          i--;
      }
    }
  }
  return areas;
}
function traceOutOfGridPath(grid, i, j, d_x, d_y, d_o) {
  var cell = grid.cells[j][i];
  var cval = cell.cval_real;
  var p = i + d_x, q = j + d_y;
  var path = [];
  var closed = false;
  while (!closed) {
    if (typeof grid.cells[q] === "undefined" || typeof grid.cells[q][p] === "undefined") {
      q -= d_y;
      p -= d_x;
      cell = grid.cells[q][p];
      cval = cell.cval_real;
      if (d_y === -1) {
        if (d_o === 0) {
          if (cval & Node3) {
            path.push([p, q]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
          } else if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
          } else {
            path.push([p + cell.bottomright, q]);
            d_x = 0;
            d_y = 1;
            d_o = 1;
            closed = true;
            break;
          }
        } else if (cval & Node3) {
          path.push([p, q]);
          d_x = -1;
          d_y = 0;
          d_o = 0;
        } else if (cval & Node2) {
          path.push([p + cell.bottomright, q]);
          d_x = 0;
          d_y = 1;
          d_o = 1;
          closed = true;
          break;
        } else {
          path.push([p + cell.bottomleft, q]);
          d_x = 0;
          d_y = 1;
          d_o = 0;
          closed = true;
          break;
        }
      } else if (d_y === 1) {
        if (d_o === 0) {
          if (cval & Node1) {
            path.push([p + 1, q + 1]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else if (!(cval & Node0)) {
            path.push([p + cell.topright, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
            closed = true;
            break;
          } else {
            path.push([p + cell.topleft, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 0;
            closed = true;
            break;
          }
        } else if (cval & Node1) {
          path.push([p + 1, q + 1]);
          d_x = 1;
          d_y = 0;
          d_o = 1;
        } else {
          path.push([p + 1, q + 1]);
          d_x = 1;
          d_y = 0;
          d_o = 1;
        }
      } else if (d_x === -1) {
        if (d_o === 0) {
          if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else if (!(cval & Node3)) {
            path.push([p, q + cell.lefttop]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
            closed = true;
            break;
          } else {
            path.push([p, q + cell.leftbottom]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else {
            console.log("MarchingSquaresJS-isoBands: wtf");
            break;
          }
        }
      } else if (d_x === 1) {
        if (d_o === 0) {
          if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else {
            path.push([p + 1, q + cell.rightbottom]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else if (!(cval & Node1)) {
            path.push([p + 1, q + cell.rightbottom]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          } else {
            path.push([p + 1, q + cell.righttop]);
            d_x = -1;
            d_y = 0;
            d_o = 1;
            break;
          }
        }
      } else {
        console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
        break;
      }
    } else {
      cell = grid.cells[q][p];
      cval = cell.cval_real;
      if (d_x === -1) {
        if (d_o === 0) {
          if (typeof grid.cells[q - 1] !== "undefined" && typeof grid.cells[q - 1][p] !== "undefined") {
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else if (cval & Node3) {
            path.push([p, q]);
          } else {
            path.push([p + cell.bottomright, q]);
            d_x = 0;
            d_y = 1;
            d_o = 1;
            closed = true;
            break;
          }
        } else if (cval & Node0) {
          console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!");
        } else {
          console.log(
            "MarchingSquaresJS-isoBands: found entry from top at " + p + "," + q
          );
          break;
        }
      } else if (d_x === 1) {
        if (d_o === 0) {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        } else {
          if (typeof grid.cells[q + 1] !== "undefined" && typeof grid.cells[q + 1][p] !== "undefined") {
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else if (cval & Node1) {
            path.push([p + 1, q + 1]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else {
            path.push([p + cell.topleft, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 0;
            closed = true;
            break;
          }
        }
      } else if (d_y === -1) {
        if (d_o === 1) {
          if (typeof grid.cells[q][p + 1] !== "undefined") {
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else {
            path.push([p + 1, q + cell.righttop]);
            d_x = -1;
            d_y = 0;
            d_o = 1;
            closed = true;
            break;
          }
        } else {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      } else if (d_y === 1) {
        if (d_o === 0) {
          if (typeof grid.cells[q][p - 1] !== "undefined") {
            d_x = -1;
            d_y = 0;
            d_o = 0;
          } else if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else {
            path.push([p, q + cell.leftbottom]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      } else {
        console.log("MarchingSquaresJS-isoBands: where did we came from???");
        break;
      }
    }
    p += d_x;
    q += d_y;
    if (p === i && q === j) {
      break;
    }
  }
  return { path, i: p, j: q, x: d_x, y: d_y, o: d_o };
}
function deleteEdge(cell, edgeIdx) {
  delete cell.edges[edgeIdx];
  for (var k = edgeIdx + 1; k < cell.edges.length; k++) {
    cell.edges[k - 1] = cell.edges[k];
  }
  cell.edges.pop();
}
function getStartXY(cell) {
  if (cell.edges.length > 0) {
    var e2 = cell.edges[cell.edges.length - 1];
    var cval = cell.cval_real;
    switch (e2) {
      case 0:
        if (cval & Node1) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        }
      case 1:
        if (cval & Node2) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 2:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        }
      case 3:
        if (cval & Node3) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 4:
        if (cval & Node1) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 5:
        if (cval & Node2) {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 6:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 7:
        if (cval & Node3) {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 8:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        }
      case 9:
        if (cval & Node3) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 10:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        }
      case 11:
        if (cval & Node0) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 12:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 13:
        if (cval & Node3) {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 14:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 15:
        if (cval & Node0) {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 16:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        }
      case 17:
        if (cval & Node0) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 18:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 19:
        if (cval & Node0) {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 20:
        if (cval & Node0) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        }
      case 21:
        if (cval & Node1) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 22:
        if (cval & Node0) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 23:
        if (cval & Node1) {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      default:
        console.log("MarchingSquaresJS-isoBands: edge index out of range!");
        console.log(cell);
        break;
    }
  }
  return null;
}
function getExitXY(cell, x2, y2, o) {
  var e2, id_x, d_x, d_y, cval = cell.cval;
  var d_o;
  switch (x2) {
    case -1:
      switch (o) {
        case 0:
          e2 = isoBandEdgeRB[cval];
          d_x = isoBandNextXRB[cval];
          d_y = isoBandNextYRB[cval];
          d_o = isoBandNextORB[cval];
          break;
        default:
          e2 = isoBandEdgeRT[cval];
          d_x = isoBandNextXRT[cval];
          d_y = isoBandNextYRT[cval];
          d_o = isoBandNextORT[cval];
          break;
      }
      break;
    case 1:
      switch (o) {
        case 0:
          e2 = isoBandEdgeLB[cval];
          d_x = isoBandNextXLB[cval];
          d_y = isoBandNextYLB[cval];
          d_o = isoBandNextOLB[cval];
          break;
        default:
          e2 = isoBandEdgeLT[cval];
          d_x = isoBandNextXLT[cval];
          d_y = isoBandNextYLT[cval];
          d_o = isoBandNextOLT[cval];
          break;
      }
      break;
    default:
      switch (y2) {
        case -1:
          switch (o) {
            case 0:
              e2 = isoBandEdgeTL[cval];
              d_x = isoBandNextXTL[cval];
              d_y = isoBandNextYTL[cval];
              d_o = isoBandNextOTL[cval];
              break;
            default:
              e2 = isoBandEdgeTR[cval];
              d_x = isoBandNextXTR[cval];
              d_y = isoBandNextYTR[cval];
              d_o = isoBandNextOTR[cval];
              break;
          }
          break;
        case 1:
          switch (o) {
            case 0:
              e2 = isoBandEdgeBL[cval];
              d_x = isoBandNextXBL[cval];
              d_y = isoBandNextYBL[cval];
              d_o = isoBandNextOBL[cval];
              break;
            default:
              e2 = isoBandEdgeBR[cval];
              d_x = isoBandNextXBR[cval];
              d_y = isoBandNextYBR[cval];
              d_o = isoBandNextOBR[cval];
              break;
          }
          break;
      }
      break;
  }
  id_x = cell.edges.indexOf(e2);
  if (typeof cell.edges[id_x] !== "undefined") {
    deleteEdge(cell, id_x);
  } else {
    return null;
  }
  cval = cell.cval_real;
  switch (e2) {
    case 0:
      if (cval & Node1) {
        x2 = cell.topleft;
        y2 = 1;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 1:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 2:
      if (cval & Node2) {
        x2 = cell.topleft;
        y2 = 1;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 3:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 4:
      if (cval & Node1) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 5:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = cell.topright;
        y2 = 1;
      }
      break;
    case 6:
      if (cval & Node2) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 7:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = cell.topright;
        y2 = 1;
      }
      break;
    case 8:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.righttop;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 9:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 10:
      if (cval & Node3) {
        x2 = 1;
        y2 = cell.righttop;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 11:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 12:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 13:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = 1;
        y2 = cell.rightbottom;
      }
      break;
    case 14:
      if (cval & Node3) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 15:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = 1;
        y2 = cell.rightbottom;
      }
      break;
    case 16:
      if (cval & Node2) {
        x2 = 0;
        y2 = cell.leftbottom;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 17:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 18:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 19:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = cell.bottomleft;
        y2 = 0;
      }
      break;
    case 20:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.leftbottom;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 21:
      if (cval & Node1) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 22:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 23:
      if (cval & Node1) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = 0;
        y2 = cell.lefttop;
      }
      break;
    default:
      console.log("MarchingSquaresJS-isoBands: edge index out of range!");
      console.log(cell);
      return null;
  }
  if (typeof x2 === "undefined" || typeof y2 === "undefined" || typeof d_x === "undefined" || typeof d_y === "undefined" || typeof d_o === "undefined") {
    console.log("MarchingSquaresJS-isoBands: undefined value!");
    console.log(cell);
    console.log(x2 + " " + y2 + " " + d_x + " " + d_y + " " + d_o);
  }
  return { p: [x2, y2], x: d_x, y: d_y, o: d_o };
}
function BandGrid2Areas(grid) {
  var areas = [];
  var area_idx = 0;
  grid.cells.forEach(function(g, j) {
    g.forEach(function(gg, i) {
      if (typeof gg !== "undefined") {
        var a = polygon_table[gg.cval](gg);
        if (typeof a === "object" && isArray$3(a)) {
          if (typeof a[0] === "object" && isArray$3(a[0])) {
            if (typeof a[0][0] === "object" && isArray$3(a[0][0])) {
              a.forEach(function(aa) {
                aa.forEach(function(aaa) {
                  aaa[0] += i;
                  aaa[1] += j;
                });
                areas[area_idx++] = aa;
              });
            } else {
              a.forEach(function(aa) {
                aa[0] += i;
                aa[1] += j;
              });
              areas[area_idx++] = a;
            }
          } else {
            console.log(
              "MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates"
            );
          }
        } else {
          console.log(
            "MarchingSquaresJS-isoBands: bandcell polygon with null coordinates"
          );
        }
      }
    });
  });
  return areas;
}
function isobands(pointGrid2, breaks, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var commonProperties = options.commonProperties || {};
  var breaksProperties = options.breaksProperties || [];
  collectionOf(pointGrid2, "Point", "Input must contain Points");
  if (!breaks)
    throw new Error("breaks is required");
  if (!Array.isArray(breaks))
    throw new Error("breaks is not an Array");
  if (!isObject$5(commonProperties))
    throw new Error("commonProperties is not an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties is not an Array");
  var matrix = gridToMatrix(pointGrid2, { zProperty, flip: true });
  var contours = createContourLines(matrix, breaks, zProperty);
  contours = rescaleContours(contours, matrix, pointGrid2);
  var multipolygons = contours.map(function(contour, index2) {
    if (breaksProperties[index2] && !isObject$5(breaksProperties[index2])) {
      throw new Error("Each mappedProperty is required to be an Object");
    }
    var contourProperties = objectAssign(
      {},
      commonProperties,
      breaksProperties[index2]
    );
    contourProperties[zProperty] = contour[zProperty];
    var multiP = multiPolygon(contour.groupedRings, contourProperties);
    return multiP;
  });
  return featureCollection$1(multipolygons);
}
function createContourLines(matrix, breaks, property) {
  var contours = [];
  for (var i = 1; i < breaks.length; i++) {
    var lowerBand = +breaks[i - 1];
    var upperBand = +breaks[i];
    var isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
    var nestedRings = orderByArea(isobandsCoords);
    var groupedRings = groupNestedRings(nestedRings);
    var obj = {};
    obj["groupedRings"] = groupedRings;
    obj[property] = lowerBand + "-" + upperBand;
    contours.push(obj);
  }
  return contours;
}
function rescaleContours(contours, matrix, points2) {
  var gridBbox = bbox$1(points2);
  var originalWidth = gridBbox[2] - gridBbox[0];
  var originalHeigth = gridBbox[3] - gridBbox[1];
  var x02 = gridBbox[0];
  var y02 = gridBbox[1];
  var matrixWidth = matrix[0].length - 1;
  var matrixHeight = matrix.length - 1;
  var scaleX = originalWidth / matrixWidth;
  var scaleY = originalHeigth / matrixHeight;
  var resize = function(point4) {
    point4[0] = point4[0] * scaleX + x02;
    point4[1] = point4[1] * scaleY + y02;
  };
  contours.forEach(function(contour) {
    contour.groupedRings.forEach(function(lineRingSet) {
      lineRingSet.forEach(function(lineRing) {
        lineRing.forEach(resize);
      });
    });
  });
  return contours;
}
function orderByArea(ringsCoords) {
  var ringsWithArea = [];
  var areas = [];
  ringsCoords.forEach(function(coords) {
    var ringArea2 = area(polygon([coords]));
    areas.push(ringArea2);
    ringsWithArea.push({ ring: coords, area: ringArea2 });
  });
  areas.sort(function(a, b) {
    return b - a;
  });
  var orderedByArea = [];
  areas.forEach(function(area5) {
    for (var lr = 0; lr < ringsWithArea.length; lr++) {
      if (ringsWithArea[lr].area === area5) {
        orderedByArea.push(ringsWithArea[lr].ring);
        ringsWithArea.splice(lr, 1);
        break;
      }
    }
  });
  return orderedByArea;
}
function groupNestedRings(orderedLinearRings) {
  var lrList = orderedLinearRings.map(function(lr) {
    return { lrCoordinates: lr, grouped: false };
  });
  var groupedLinearRingsCoords = [];
  while (!allGrouped(lrList)) {
    for (var i = 0; i < lrList.length; i++) {
      if (!lrList[i].grouped) {
        var group = [];
        group.push(lrList[i].lrCoordinates);
        lrList[i].grouped = true;
        var outerMostPoly = polygon([lrList[i].lrCoordinates]);
        for (var j = i + 1; j < lrList.length; j++) {
          if (!lrList[j].grouped) {
            var lrPoly = polygon([lrList[j].lrCoordinates]);
            if (isInside$1(lrPoly, outerMostPoly)) {
              group.push(lrList[j].lrCoordinates);
              lrList[j].grouped = true;
            }
          }
        }
        groupedLinearRingsCoords.push(group);
      }
    }
  }
  return groupedLinearRingsCoords;
}
function isInside$1(testPolygon, targetPolygon) {
  var points2 = explode$1(testPolygon);
  for (var i = 0; i < points2.features.length; i++) {
    if (!booleanPointInPolygon(points2.features[i], targetPolygon)) {
      return false;
    }
  }
  return true;
}
function allGrouped(list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].grouped === false) {
      return false;
    }
  }
  return true;
}
function transformRotate(geojson, angle4, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var pivot = options.pivot;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (angle4 === void 0 || angle4 === null || isNaN(angle4))
    throw new Error("angle is required");
  if (angle4 === 0)
    return geojson;
  if (!pivot)
    pivot = centroid$2(geojson);
  if (mutate === false || mutate === void 0)
    geojson = clone$5(geojson);
  coordEach(geojson, function(pointCoords) {
    var initialAngle = rhumbBearing(pivot, pointCoords);
    var finalAngle = initialAngle + angle4;
    var distance11 = rhumbDistance(pivot, pointCoords);
    var newCoords = getCoords(rhumbDestination(pivot, distance11, finalAngle));
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
  });
  return geojson;
}
function transformScale(geojson, factor, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var origin = options.origin;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson required");
  if (typeof factor !== "number" || factor === 0)
    throw new Error("invalid factor");
  var originIsPoint = Array.isArray(origin) || typeof origin === "object";
  if (mutate !== true)
    geojson = clone$5(geojson);
  if (geojson.type === "FeatureCollection" && !originIsPoint) {
    featureEach$1(geojson, function(feature2, index2) {
      geojson.features[index2] = scale$3(feature2, factor, origin);
    });
    return geojson;
  }
  return scale$3(geojson, factor, origin);
}
function scale$3(feature2, factor, origin) {
  var isPoint = getType$1(feature2) === "Point";
  origin = defineOrigin(feature2, origin);
  if (factor === 1 || isPoint)
    return feature2;
  coordEach(feature2, function(coord) {
    var originalDistance = rhumbDistance(origin, coord);
    var bearing2 = rhumbBearing(origin, coord);
    var newDistance = originalDistance * factor;
    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing2));
    coord[0] = newCoord[0];
    coord[1] = newCoord[1];
    if (coord.length === 3)
      coord[2] *= factor;
  });
  return feature2;
}
function defineOrigin(geojson, origin) {
  if (origin === void 0 || origin === null)
    origin = "centroid";
  if (Array.isArray(origin) || typeof origin === "object")
    return getCoord(origin);
  var bbox2 = geojson.bbox ? geojson.bbox : bbox$1(geojson);
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  switch (origin) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return point([west, south]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return point([east, south]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return point([west, north]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return point([east, north]);
    case "center":
      return center$2(geojson);
    case void 0:
    case null:
    case "centroid":
      return centroid$2(geojson);
    default:
      throw new Error("invalid origin");
  }
}
function transformTranslate(geojson, distance11, direction, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var units = options.units;
  var zTranslation = options.zTranslation;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (distance11 === void 0 || distance11 === null || isNaN(distance11))
    throw new Error("distance is required");
  if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
    throw new Error("zTranslation is not a number");
  zTranslation = zTranslation !== void 0 ? zTranslation : 0;
  if (distance11 === 0 && zTranslation === 0)
    return geojson;
  if (direction === void 0 || direction === null || isNaN(direction))
    throw new Error("direction is required");
  if (distance11 < 0) {
    distance11 = -distance11;
    direction = direction + 180;
  }
  if (mutate === false || mutate === void 0)
    geojson = clone$5(geojson);
  coordEach(geojson, function(pointCoords) {
    var newCoords = getCoords(
      rhumbDestination(pointCoords, distance11, direction, { units })
    );
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
    if (zTranslation && pointCoords.length === 3)
      pointCoords[2] += zTranslation;
  });
  return geojson;
}
function ab(segment) {
  var start2 = segment[0];
  var end2 = segment[1];
  return [end2[0] - start2[0], end2[1] - start2[1]];
}
function crossProduct$1(v12, v22) {
  return v12[0] * v22[1] - v22[0] * v12[1];
}
function add$2(v12, v22) {
  return [v12[0] + v22[0], v12[1] + v22[1]];
}
function sub$1(v12, v22) {
  return [v12[0] - v22[0], v12[1] - v22[1]];
}
function scalarMult(s, v) {
  return [s * v[0], s * v[1]];
}
function intersectSegments(a, b) {
  var p = a[0];
  var r = ab(a);
  var q = b[0];
  var s = ab(b);
  var cross2 = crossProduct$1(r, s);
  var qmp = sub$1(q, p);
  var numerator = crossProduct$1(qmp, s);
  var t = numerator / cross2;
  var intersection11 = add$2(p, scalarMult(t, r));
  return intersection11;
}
function isParallel$1(a, b) {
  var r = ab(a);
  var s = ab(b);
  return crossProduct$1(r, s) === 0;
}
function intersection$2(a, b) {
  if (isParallel$1(a, b))
    return false;
  return intersectSegments(a, b);
}
function lineOffset(geojson, distance11, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var units = options.units;
  if (!geojson)
    throw new Error("geojson is required");
  if (distance11 === void 0 || distance11 === null || isNaN(distance11))
    throw new Error("distance is required");
  var type = getType$1(geojson);
  var properties = geojson.properties;
  switch (type) {
    case "LineString":
      return lineOffsetFeature(geojson, distance11, units);
    case "MultiLineString":
      var coords = [];
      flattenEach(geojson, function(feature2) {
        coords.push(
          lineOffsetFeature(feature2, distance11, units).geometry.coordinates
        );
      });
      return multiLineString(coords, properties);
    default:
      throw new Error("geometry " + type + " is not supported");
  }
}
function lineOffsetFeature(line, distance11, units) {
  var segments = [];
  var offsetDegrees = lengthToDegrees(distance11, units);
  var coords = getCoords(line);
  var finalCoords = [];
  coords.forEach(function(currentCoords, index2) {
    if (index2 !== coords.length - 1) {
      var segment = processSegment(
        currentCoords,
        coords[index2 + 1],
        offsetDegrees
      );
      segments.push(segment);
      if (index2 > 0) {
        var seg2Coords = segments[index2 - 1];
        var intersects7 = intersection$2(segment, seg2Coords);
        if (intersects7 !== false) {
          seg2Coords[1] = intersects7;
          segment[0] = intersects7;
        }
        finalCoords.push(seg2Coords[0]);
        if (index2 === coords.length - 2) {
          finalCoords.push(segment[0]);
          finalCoords.push(segment[1]);
        }
      }
      if (coords.length === 2) {
        finalCoords.push(segment[0]);
        finalCoords.push(segment[1]);
      }
    }
  });
  return lineString(finalCoords, line.properties);
}
function processSegment(point1, point22, offset) {
  var L = Math.sqrt(
    (point1[0] - point22[0]) * (point1[0] - point22[0]) + (point1[1] - point22[1]) * (point1[1] - point22[1])
  );
  var out1x = point1[0] + offset * (point22[1] - point1[1]) / L;
  var out2x = point22[0] + offset * (point22[1] - point1[1]) / L;
  var out1y = point1[1] + offset * (point1[0] - point22[0]) / L;
  var out2y = point22[1] + offset * (point1[0] - point22[0]) / L;
  return [
    [out1x, out1y],
    [out2x, out2y]
  ];
}
function mathSign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function orientationIndex(p1, p2, q) {
  var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
  return mathSign(dx1 * dy2 - dx2 * dy1);
}
function envelopeIsEqual(env1, env2) {
  var envX1 = env1.geometry.coordinates[0].map(function(c) {
    return c[0];
  }), envY1 = env1.geometry.coordinates[0].map(function(c) {
    return c[1];
  }), envX2 = env2.geometry.coordinates[0].map(function(c) {
    return c[0];
  }), envY2 = env2.geometry.coordinates[0].map(function(c) {
    return c[1];
  });
  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
}
function envelopeContains(self2, env2) {
  return env2.geometry.coordinates[0].every(function(c) {
    return booleanPointInPolygon(point(c), self2);
  });
}
function coordinatesEqual(coord1, coord2) {
  return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}
var Node$2 = function() {
  function Node4(coordinates) {
    this.id = Node4.buildId(coordinates);
    this.coordinates = coordinates;
    this.innerEdges = [];
    this.outerEdges = [];
    this.outerEdgesSorted = false;
  }
  Node4.buildId = function(coordinates) {
    return coordinates.join(",");
  };
  Node4.prototype.removeInnerEdge = function(edge) {
    this.innerEdges = this.innerEdges.filter(function(e2) {
      return e2.from.id !== edge.from.id;
    });
  };
  Node4.prototype.removeOuterEdge = function(edge) {
    this.outerEdges = this.outerEdges.filter(function(e2) {
      return e2.to.id !== edge.to.id;
    });
  };
  Node4.prototype.addOuterEdge = function(edge) {
    this.outerEdges.push(edge);
    this.outerEdgesSorted = false;
  };
  Node4.prototype.sortOuterEdges = function() {
    var _this = this;
    if (!this.outerEdgesSorted) {
      this.outerEdges.sort(function(a, b) {
        var aNode = a.to, bNode = b.to;
        if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
          return 1;
        if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
          return -1;
        if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
          if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
            return aNode.coordinates[1] - bNode.coordinates[1];
          return bNode.coordinates[1] - aNode.coordinates[1];
        }
        var det2 = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
        if (det2 < 0)
          return 1;
        if (det2 > 0)
          return -1;
        var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
        return d1 - d2;
      });
      this.outerEdgesSorted = true;
    }
  };
  Node4.prototype.getOuterEdges = function() {
    this.sortOuterEdges();
    return this.outerEdges;
  };
  Node4.prototype.getOuterEdge = function(i) {
    this.sortOuterEdges();
    return this.outerEdges[i];
  };
  Node4.prototype.addInnerEdge = function(edge) {
    this.innerEdges.push(edge);
  };
  return Node4;
}();
var Node$3 = Node$2;
var Edge$1 = function() {
  function Edge2(from, to) {
    this.from = from;
    this.to = to;
    this.next = void 0;
    this.label = void 0;
    this.symetric = void 0;
    this.ring = void 0;
    this.from.addOuterEdge(this);
    this.to.addInnerEdge(this);
  }
  Edge2.prototype.getSymetric = function() {
    if (!this.symetric) {
      this.symetric = new Edge2(this.to, this.from);
      this.symetric.symetric = this;
    }
    return this.symetric;
  };
  Edge2.prototype.deleteEdge = function() {
    this.from.removeOuterEdge(this);
    this.to.removeInnerEdge(this);
  };
  Edge2.prototype.isEqual = function(edge) {
    return this.from.id === edge.from.id && this.to.id === edge.to.id;
  };
  Edge2.prototype.toString = function() {
    return "Edge { " + this.from.id + " -> " + this.to.id + " }";
  };
  Edge2.prototype.toLineString = function() {
    return lineString([this.from.coordinates, this.to.coordinates]);
  };
  Edge2.prototype.compareTo = function(edge) {
    return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
  };
  return Edge2;
}();
var Edge$2 = Edge$1;
var EdgeRing$1 = function() {
  function EdgeRing3() {
    this.edges = [];
    this.polygon = void 0;
    this.envelope = void 0;
  }
  EdgeRing3.prototype.push = function(edge) {
    this.edges.push(edge);
    this.polygon = this.envelope = void 0;
  };
  EdgeRing3.prototype.get = function(i) {
    return this.edges[i];
  };
  Object.defineProperty(EdgeRing3.prototype, "length", {
    get: function() {
      return this.edges.length;
    },
    enumerable: true,
    configurable: true
  });
  EdgeRing3.prototype.forEach = function(f) {
    this.edges.forEach(f);
  };
  EdgeRing3.prototype.map = function(f) {
    return this.edges.map(f);
  };
  EdgeRing3.prototype.some = function(f) {
    return this.edges.some(f);
  };
  EdgeRing3.prototype.isValid = function() {
    return true;
  };
  EdgeRing3.prototype.isHole = function() {
    var _this = this;
    var hiIndex = this.edges.reduce(function(high, edge, i) {
      if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
        high = i;
      return high;
    }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
    if (disc === 0)
      return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
    return disc > 0;
  };
  EdgeRing3.prototype.toMultiPoint = function() {
    return multiPoint(this.edges.map(function(edge) {
      return edge.from.coordinates;
    }));
  };
  EdgeRing3.prototype.toPolygon = function() {
    if (this.polygon)
      return this.polygon;
    var coordinates = this.edges.map(function(edge) {
      return edge.from.coordinates;
    });
    coordinates.push(this.edges[0].from.coordinates);
    return this.polygon = polygon([coordinates]);
  };
  EdgeRing3.prototype.getEnvelope = function() {
    if (this.envelope)
      return this.envelope;
    return this.envelope = envelope(this.toPolygon());
  };
  EdgeRing3.findEdgeRingContaining = function(testEdgeRing, shellList) {
    var testEnvelope = testEdgeRing.getEnvelope();
    var minEnvelope, minShell;
    shellList.forEach(function(shell) {
      var tryEnvelope = shell.getEnvelope();
      if (minShell)
        minEnvelope = minShell.getEnvelope();
      if (envelopeIsEqual(tryEnvelope, testEnvelope))
        return;
      if (envelopeContains(tryEnvelope, testEnvelope)) {
        var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
          return edge.from.coordinates;
        });
        var testPoint = void 0;
        var _loop_1 = function(pt3) {
          if (!shell.some(function(edge) {
            return coordinatesEqual(pt3, edge.from.coordinates);
          })) {
            testPoint = pt3;
          }
        };
        for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
          var pt = testEdgeRingCoordinates_1[_i];
          _loop_1(pt);
        }
        if (testPoint && shell.inside(point(testPoint))) {
          if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
            minShell = shell;
        }
      }
    });
    return minShell;
  };
  EdgeRing3.prototype.inside = function(pt) {
    return booleanPointInPolygon(pt, this.toPolygon());
  };
  return EdgeRing3;
}();
var EdgeRing$2 = EdgeRing$1;
function validateGeoJson(geoJson) {
  if (!geoJson)
    throw new Error("No geojson passed");
  if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
    throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
}
var Graph$3 = function() {
  function Graph2() {
    this.edges = [];
    this.nodes = {};
  }
  Graph2.fromGeoJson = function(geoJson) {
    validateGeoJson(geoJson);
    var graph = new Graph2();
    flattenEach(geoJson, function(feature2) {
      featureOf(feature2, "LineString", "Graph::fromGeoJson");
      coordReduce(feature2, function(prev, cur) {
        if (prev) {
          var start2 = graph.getNode(prev), end2 = graph.getNode(cur);
          graph.addEdge(start2, end2);
        }
        return cur;
      });
    });
    return graph;
  };
  Graph2.prototype.getNode = function(coordinates) {
    var id = Node$3.buildId(coordinates);
    var node = this.nodes[id];
    if (!node)
      node = this.nodes[id] = new Node$3(coordinates);
    return node;
  };
  Graph2.prototype.addEdge = function(from, to) {
    var edge = new Edge$2(from, to), symetricEdge = edge.getSymetric();
    this.edges.push(edge);
    this.edges.push(symetricEdge);
  };
  Graph2.prototype.deleteDangles = function() {
    var _this = this;
    Object.keys(this.nodes).map(function(id) {
      return _this.nodes[id];
    }).forEach(function(node) {
      return _this._removeIfDangle(node);
    });
  };
  Graph2.prototype._removeIfDangle = function(node) {
    var _this = this;
    if (node.innerEdges.length <= 1) {
      var outerNodes = node.getOuterEdges().map(function(e2) {
        return e2.to;
      });
      this.removeNode(node);
      outerNodes.forEach(function(n) {
        return _this._removeIfDangle(n);
      });
    }
  };
  Graph2.prototype.deleteCutEdges = function() {
    var _this = this;
    this._computeNextCWEdges();
    this._findLabeledEdgeRings();
    this.edges.forEach(function(edge) {
      if (edge.label === edge.symetric.label) {
        _this.removeEdge(edge.symetric);
        _this.removeEdge(edge);
      }
    });
  };
  Graph2.prototype._computeNextCWEdges = function(node) {
    var _this = this;
    if (typeof node === "undefined") {
      Object.keys(this.nodes).forEach(function(id) {
        return _this._computeNextCWEdges(_this.nodes[id]);
      });
    } else {
      node.getOuterEdges().forEach(function(edge, i) {
        node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
      });
    }
  };
  Graph2.prototype._computeNextCCWEdges = function(node, label) {
    var edges2 = node.getOuterEdges();
    var firstOutDE, prevInDE;
    for (var i = edges2.length - 1; i >= 0; --i) {
      var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
      if (de.label === label)
        outDE = de;
      if (sym.label === label)
        inDE = sym;
      if (!outDE || !inDE)
        continue;
      if (inDE)
        prevInDE = inDE;
      if (outDE) {
        if (prevInDE) {
          prevInDE.next = outDE;
          prevInDE = void 0;
        }
        if (!firstOutDE)
          firstOutDE = outDE;
      }
    }
    if (prevInDE)
      prevInDE.next = firstOutDE;
  };
  Graph2.prototype._findLabeledEdgeRings = function() {
    var edgeRingStarts = [];
    var label = 0;
    this.edges.forEach(function(edge) {
      if (edge.label >= 0)
        return;
      edgeRingStarts.push(edge);
      var e2 = edge;
      do {
        e2.label = label;
        e2 = e2.next;
      } while (!edge.isEqual(e2));
      label++;
    });
    return edgeRingStarts;
  };
  Graph2.prototype.getEdgeRings = function() {
    var _this = this;
    this._computeNextCWEdges();
    this.edges.forEach(function(edge) {
      edge.label = void 0;
    });
    this._findLabeledEdgeRings().forEach(function(edge) {
      _this._findIntersectionNodes(edge).forEach(function(node) {
        _this._computeNextCCWEdges(node, edge.label);
      });
    });
    var edgeRingList = [];
    this.edges.forEach(function(edge) {
      if (edge.ring)
        return;
      edgeRingList.push(_this._findEdgeRing(edge));
    });
    return edgeRingList;
  };
  Graph2.prototype._findIntersectionNodes = function(startEdge) {
    var intersectionNodes = [];
    var edge = startEdge;
    var _loop_1 = function() {
      var degree2 = 0;
      edge.from.getOuterEdges().forEach(function(e2) {
        if (e2.label === startEdge.label)
          ++degree2;
      });
      if (degree2 > 1)
        intersectionNodes.push(edge.from);
      edge = edge.next;
    };
    do {
      _loop_1();
    } while (!startEdge.isEqual(edge));
    return intersectionNodes;
  };
  Graph2.prototype._findEdgeRing = function(startEdge) {
    var edge = startEdge;
    var edgeRing = new EdgeRing$2();
    do {
      edgeRing.push(edge);
      edge.ring = edgeRing;
      edge = edge.next;
    } while (!startEdge.isEqual(edge));
    return edgeRing;
  };
  Graph2.prototype.removeNode = function(node) {
    var _this = this;
    node.getOuterEdges().forEach(function(edge) {
      return _this.removeEdge(edge);
    });
    node.innerEdges.forEach(function(edge) {
      return _this.removeEdge(edge);
    });
    delete this.nodes[node.id];
  };
  Graph2.prototype.removeEdge = function(edge) {
    this.edges = this.edges.filter(function(e2) {
      return !e2.isEqual(edge);
    });
    edge.deleteEdge();
  };
  return Graph2;
}();
var Graph$4 = Graph$3;
function polygonize(geoJson) {
  var graph = Graph$4.fromGeoJson(geoJson);
  graph.deleteDangles();
  graph.deleteCutEdges();
  var holes = [], shells = [];
  graph.getEdgeRings().filter(function(edgeRing) {
    return edgeRing.isValid();
  }).forEach(function(edgeRing) {
    if (edgeRing.isHole())
      holes.push(edgeRing);
    else
      shells.push(edgeRing);
  });
  holes.forEach(function(hole) {
    if (EdgeRing$2.findEdgeRingContaining(hole, shells))
      shells.push(hole);
  });
  return featureCollection$1(shells.map(function(shell) {
    return shell.toPolygon();
  }));
}
function booleanDisjoint(feature1, feature2) {
  var bool = true;
  flattenEach(feature1, function(flatten1) {
    flattenEach(feature2, function(flatten2) {
      if (bool === false) {
        return false;
      }
      bool = disjoint(flatten1.geometry, flatten2.geometry);
    });
  });
  return bool;
}
function disjoint(geom1, geom2) {
  switch (geom1.type) {
    case "Point":
      switch (geom2.type) {
        case "Point":
          return !compareCoords$1(geom1.coordinates, geom2.coordinates);
        case "LineString":
          return !isPointOnLine(geom2, geom1);
        case "Polygon":
          return !booleanPointInPolygon(geom1, geom2);
      }
      break;
    case "LineString":
      switch (geom2.type) {
        case "Point":
          return !isPointOnLine(geom1, geom2);
        case "LineString":
          return !isLineOnLine$1(geom1, geom2);
        case "Polygon":
          return !isLineInPoly$1(geom2, geom1);
      }
      break;
    case "Polygon":
      switch (geom2.type) {
        case "Point":
          return !booleanPointInPolygon(geom2, geom1);
        case "LineString":
          return !isLineInPoly$1(geom1, geom2);
        case "Polygon":
          return !isPolyInPoly$1(geom2, geom1);
      }
  }
  return false;
}
function isPointOnLine(lineString2, pt) {
  for (var i = 0; i < lineString2.coordinates.length - 1; i++) {
    if (isPointOnLineSegment$1(lineString2.coordinates[i], lineString2.coordinates[i + 1], pt.coordinates)) {
      return true;
    }
  }
  return false;
}
function isLineOnLine$1(lineString1, lineString2) {
  var doLinesIntersect = lineIntersect(lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isLineInPoly$1(polygon4, lineString2) {
  for (var _i = 0, _a2 = lineString2.coordinates; _i < _a2.length; _i++) {
    var coord = _a2[_i];
    if (booleanPointInPolygon(coord, polygon4)) {
      return true;
    }
  }
  var doLinesIntersect = lineIntersect(lineString2, polygonToLine(polygon4));
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPolyInPoly$1(feature1, feature2) {
  for (var _i = 0, _a2 = feature1.coordinates[0]; _i < _a2.length; _i++) {
    var coord1 = _a2[_i];
    if (booleanPointInPolygon(coord1, feature2)) {
      return true;
    }
  }
  for (var _b2 = 0, _c2 = feature2.coordinates[0]; _b2 < _c2.length; _b2++) {
    var coord2 = _c2[_b2];
    if (booleanPointInPolygon(coord2, feature1)) {
      return true;
    }
  }
  var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPointOnLineSegment$1(lineSegmentStart, lineSegmentEnd, pt) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross2 = dxc * dyl - dyc * dxl;
  if (cross2 !== 0) {
    return false;
  }
  if (Math.abs(dxl) >= Math.abs(dyl)) {
    if (dxl > 0) {
      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
    } else {
      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
  } else if (dyl > 0) {
    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
  } else {
    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  }
}
function compareCoords$1(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function booleanContains(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  var coords1 = geom1.coordinates;
  var coords2 = geom2.coordinates;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "Point":
          return compareCoords(coords1, coords2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "Point":
          return isPointInMultiPoint(geom1, geom2);
        case "MultiPoint":
          return isMultiPointInMultiPoint(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "Point":
          return booleanPointOnLine(geom2, geom1, { ignoreEndVertices: true });
        case "LineString":
          return isLineOnLine(geom1, geom2);
        case "MultiPoint":
          return isMultiPointOnLine(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Point":
          return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });
        case "LineString":
          return isLineInPoly(geom1, geom2);
        case "Polygon":
          return isPolyInPoly(geom1, geom2);
        case "MultiPoint":
          return isMultiPointInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointInMultiPoint(multiPoint2, pt) {
  var i;
  var output = false;
  for (i = 0; i < multiPoint2.coordinates.length; i++) {
    if (compareCoords(multiPoint2.coordinates[i], pt.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
  for (var _i = 0, _a2 = multiPoint2.coordinates; _i < _a2.length; _i++) {
    var coord2 = _a2[_i];
    var matchFound = false;
    for (var _b2 = 0, _c2 = multiPoint1.coordinates; _b2 < _c2.length; _b2++) {
      var coord1 = _c2[_b2];
      if (compareCoords(coord2, coord1)) {
        matchFound = true;
        break;
      }
    }
    if (!matchFound) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine(lineString2, multiPoint2) {
  var haveFoundInteriorPoint = false;
  for (var _i = 0, _a2 = multiPoint2.coordinates; _i < _a2.length; _i++) {
    var coord = _a2[_i];
    if (booleanPointOnLine(coord, lineString2, { ignoreEndVertices: true })) {
      haveFoundInteriorPoint = true;
    }
    if (!booleanPointOnLine(coord, lineString2)) {
      return false;
    }
  }
  if (haveFoundInteriorPoint) {
    return true;
  }
  return false;
}
function isMultiPointInPoly(polygon4, multiPoint2) {
  for (var _i = 0, _a2 = multiPoint2.coordinates; _i < _a2.length; _i++) {
    var coord = _a2[_i];
    if (!booleanPointInPolygon(coord, polygon4, { ignoreBoundary: true })) {
      return false;
    }
  }
  return true;
}
function isLineOnLine(lineString1, lineString2) {
  var haveFoundInteriorPoint = false;
  for (var _i = 0, _a2 = lineString2.coordinates; _i < _a2.length; _i++) {
    var coords = _a2[_i];
    if (booleanPointOnLine({ type: "Point", coordinates: coords }, lineString1, {
      ignoreEndVertices: true
    })) {
      haveFoundInteriorPoint = true;
    }
    if (!booleanPointOnLine({ type: "Point", coordinates: coords }, lineString1, {
      ignoreEndVertices: false
    })) {
      return false;
    }
  }
  return haveFoundInteriorPoint;
}
function isLineInPoly(polygon4, linestring3) {
  var output = false;
  var i = 0;
  var polyBbox = bbox$1(polygon4);
  var lineBbox = bbox$1(linestring3);
  if (!doBBoxOverlap(polyBbox, lineBbox)) {
    return false;
  }
  for (i; i < linestring3.coordinates.length - 1; i++) {
    var midPoint3 = getMidpoint(linestring3.coordinates[i], linestring3.coordinates[i + 1]);
    if (booleanPointInPolygon({ type: "Point", coordinates: midPoint3 }, polygon4, {
      ignoreBoundary: true
    })) {
      output = true;
      break;
    }
  }
  return output;
}
function isPolyInPoly(feature1, feature2) {
  if (feature1.type === "Feature" && feature1.geometry === null) {
    return false;
  }
  if (feature2.type === "Feature" && feature2.geometry === null) {
    return false;
  }
  var poly1Bbox = bbox$1(feature1);
  var poly2Bbox = bbox$1(feature2);
  if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
    return false;
  }
  var coords = getGeom(feature2).coordinates;
  for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
    var ring = coords_1[_i];
    for (var _a2 = 0, ring_1 = ring; _a2 < ring_1.length; _a2++) {
      var coord = ring_1[_a2];
      if (!booleanPointInPolygon(coord, feature1)) {
        return false;
      }
    }
  }
  return true;
}
function doBBoxOverlap(bbox1, bbox2) {
  if (bbox1[0] > bbox2[0]) {
    return false;
  }
  if (bbox1[2] < bbox2[2]) {
    return false;
  }
  if (bbox1[1] > bbox2[1]) {
    return false;
  }
  if (bbox1[3] < bbox2[3]) {
    return false;
  }
  return true;
}
function compareCoords(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
function booleanCrosses(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "MultiPoint":
      switch (type2) {
        case "LineString":
          return doMultiPointAndLineStringCross(geom1, geom2);
        case "Polygon":
          return doesMultiPointCrossPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "MultiPoint":
          return doMultiPointAndLineStringCross(geom2, geom1);
        case "LineString":
          return doLineStringsCross(geom1, geom2);
        case "Polygon":
          return doLineStringAndPolygonCross(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "MultiPoint":
          return doesMultiPointCrossPoly(geom2, geom1);
        case "LineString":
          return doLineStringAndPolygonCross(geom2, geom1);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function doMultiPointAndLineStringCross(multiPoint2, lineString2) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint2.coordinates.length;
  var i = 0;
  while (i < pointLength && !foundIntPoint && !foundExtPoint) {
    for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
      var incEndVertices = true;
      if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
        incEndVertices = false;
      }
      if (isPointOnLineSegment(lineString2.coordinates[i2], lineString2.coordinates[i2 + 1], multiPoint2.coordinates[i], incEndVertices)) {
        foundIntPoint = true;
      } else {
        foundExtPoint = true;
      }
    }
    i++;
  }
  return foundIntPoint && foundExtPoint;
}
function doLineStringsCross(lineString1, lineString2) {
  var doLinesIntersect = lineIntersect(lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
        var incEndVertices = true;
        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
          incEndVertices = false;
        }
        if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
          return true;
        }
      }
    }
  }
  return false;
}
function doLineStringAndPolygonCross(lineString2, polygon4) {
  var line = polygonToLine$1(polygon4);
  var doLinesIntersect = lineIntersect(lineString2, line);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function doesMultiPointCrossPoly(multiPoint2, polygon4) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint2.coordinates.length;
  for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
    if (booleanPointInPolygon(point(multiPoint2.coordinates[i]), polygon4)) {
      foundIntPoint = true;
    } else {
      foundExtPoint = true;
    }
  }
  return foundExtPoint && foundIntPoint;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross2 = dxc * dyl - dyc * dxl;
  if (cross2 !== 0) {
    return false;
  }
  if (incEnd) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  } else {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
  }
}
var deepEqual = deepEqual_1;
var Equality = function(opt) {
  this.precision = opt && opt.precision ? opt.precision : 17;
  this.direction = opt && opt.direction ? opt.direction : false;
  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
};
Equality.prototype.compare = function(g1, g2) {
  if (g1.type !== g2.type || !sameLength(g1, g2))
    return false;
  switch (g1.type) {
    case "Point":
      return this.compareCoord(g1.coordinates, g2.coordinates);
    case "LineString":
      return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
    case "Polygon":
      return this.comparePolygon(g1, g2);
    case "Feature":
      return this.compareFeature(g1, g2);
    default:
      if (g1.type.indexOf("Multi") === 0) {
        var context = this;
        var g1s = explode(g1);
        var g2s = explode(g2);
        return g1s.every(function(g1part) {
          return this.some(function(g2part) {
            return context.compare(g1part, g2part);
          });
        }, g2s);
      }
  }
  return false;
};
function explode(g) {
  return g.coordinates.map(function(part) {
    return {
      type: g.type.replace("Multi", ""),
      coordinates: part
    };
  });
}
function sameLength(g1, g2) {
  return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
}
Equality.prototype.compareCoord = function(c1, c2) {
  if (c1.length !== c2.length) {
    return false;
  }
  for (var i = 0; i < c1.length; i++) {
    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
      return false;
    }
  }
  return true;
};
Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
  if (!sameLength(path1, path2))
    return false;
  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
  if (isPoly && !this.compareCoord(p1[0], p2[0])) {
    p2 = this.fixStartIndex(p2, p1);
    if (!p2)
      return;
  }
  var sameDirection = this.compareCoord(p1[ind], p2[ind]);
  if (this.direction || sameDirection) {
    return this.comparePath(p1, p2);
  } else {
    if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
      return this.comparePath(p1.slice().reverse(), p2);
    }
    return false;
  }
};
Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
  var correctPath, ind = -1;
  for (var i = 0; i < sourcePath.length; i++) {
    if (this.compareCoord(sourcePath[i], targetPath[0])) {
      ind = i;
      break;
    }
  }
  if (ind >= 0) {
    correctPath = [].concat(
      sourcePath.slice(ind, sourcePath.length),
      sourcePath.slice(1, ind + 1)
    );
  }
  return correctPath;
};
Equality.prototype.comparePath = function(p1, p2) {
  var cont = this;
  return p1.every(function(c, i) {
    return cont.compareCoord(c, this[i]);
  }, p2);
};
Equality.prototype.comparePolygon = function(g1, g2) {
  if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
    var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
    var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
    var cont = this;
    return holes1.every(function(h1) {
      return this.some(function(h2) {
        return cont.compareLine(h1, h2, 1, true);
      });
    }, holes2);
  } else {
    return false;
  }
};
Equality.prototype.compareFeature = function(g1, g2) {
  if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
    return false;
  }
  return this.compare(g1.geometry, g2.geometry);
};
Equality.prototype.compareBBox = function(g1, g2) {
  if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
    return true;
  }
  return false;
};
Equality.prototype.removePseudo = function(path) {
  return path;
};
function objectComparator(obj1, obj2) {
  return deepEqual(obj1, obj2, { strict: true });
}
var geojsonEquality = Equality;
var GeojsonEquality = geojsonEquality;
function booleanOverlap(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  if (type1 === "MultiPoint" && type2 !== "MultiPoint" || (type1 === "LineString" || type1 === "MultiLineString") && type2 !== "LineString" && type2 !== "MultiLineString" || (type1 === "Polygon" || type1 === "MultiPolygon") && type2 !== "Polygon" && type2 !== "MultiPolygon") {
    throw new Error("features must be of the same type");
  }
  if (type1 === "Point")
    throw new Error("Point geometry not supported");
  var equality = new GeojsonEquality({ precision: 6 });
  if (equality.compare(feature1, feature2))
    return false;
  var overlap2 = 0;
  switch (type1) {
    case "MultiPoint":
      for (var i = 0; i < geom1.coordinates.length; i++) {
        for (var j = 0; j < geom2.coordinates.length; j++) {
          var coord1 = geom1.coordinates[i];
          var coord2 = geom2.coordinates[j];
          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
            return true;
          }
        }
      }
      return false;
    case "LineString":
    case "MultiLineString":
      segmentEach(feature1, function(segment1) {
        segmentEach(feature2, function(segment2) {
          if (lineOverlap(segment1, segment2).features.length)
            overlap2++;
        });
      });
      break;
    case "Polygon":
    case "MultiPolygon":
      segmentEach(feature1, function(segment1) {
        segmentEach(feature2, function(segment2) {
          if (lineIntersect(segment1, segment2).features.length)
            overlap2++;
        });
      });
      break;
  }
  return overlap2 > 0;
}
function booleanEqual(feature1, feature2) {
  var type1 = getGeom(feature1).type;
  var type2 = getGeom(feature2).type;
  if (type1 !== type2)
    return false;
  var equality = new GeojsonEquality({ precision: 6 });
  return equality.compare(cleanCoords(feature1), cleanCoords(feature2));
}
function booleanIntersects(feature1, feature2) {
  var bool = false;
  flattenEach(feature1, function(flatten1) {
    flattenEach(feature2, function(flatten2) {
      if (bool === true) {
        return true;
      }
      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);
    });
  });
  return bool;
}
var lib = { exports: {} };
var DBSCAN = { exports: {} };
(function(module) {
  function DBSCAN2(dataset, epsilon3, minPts, distanceFunction) {
    this.dataset = [];
    this.epsilon = 1;
    this.minPts = 2;
    this.distance = this._euclideanDistance;
    this.clusters = [];
    this.noise = [];
    this._visited = [];
    this._assigned = [];
    this._datasetLength = 0;
    this._init(dataset, epsilon3, minPts, distanceFunction);
  }
  DBSCAN2.prototype.run = function(dataset, epsilon3, minPts, distanceFunction) {
    this._init(dataset, epsilon3, minPts, distanceFunction);
    for (var pointId = 0; pointId < this._datasetLength; pointId++) {
      if (this._visited[pointId] !== 1) {
        this._visited[pointId] = 1;
        var neighbors = this._regionQuery(pointId);
        if (neighbors.length < this.minPts) {
          this.noise.push(pointId);
        } else {
          var clusterId = this.clusters.length;
          this.clusters.push([]);
          this._addToCluster(pointId, clusterId);
          this._expandCluster(clusterId, neighbors);
        }
      }
    }
    return this.clusters;
  };
  DBSCAN2.prototype._init = function(dataset, epsilon3, minPts, distance11) {
    if (dataset) {
      if (!(dataset instanceof Array)) {
        throw Error("Dataset must be of type array, " + typeof dataset + " given");
      }
      this.dataset = dataset;
      this.clusters = [];
      this.noise = [];
      this._datasetLength = dataset.length;
      this._visited = new Array(this._datasetLength);
      this._assigned = new Array(this._datasetLength);
    }
    if (epsilon3) {
      this.epsilon = epsilon3;
    }
    if (minPts) {
      this.minPts = minPts;
    }
    if (distance11) {
      this.distance = distance11;
    }
  };
  DBSCAN2.prototype._expandCluster = function(clusterId, neighbors) {
    for (var i = 0; i < neighbors.length; i++) {
      var pointId2 = neighbors[i];
      if (this._visited[pointId2] !== 1) {
        this._visited[pointId2] = 1;
        var neighbors2 = this._regionQuery(pointId2);
        if (neighbors2.length >= this.minPts) {
          neighbors = this._mergeArrays(neighbors, neighbors2);
        }
      }
      if (this._assigned[pointId2] !== 1) {
        this._addToCluster(pointId2, clusterId);
      }
    }
  };
  DBSCAN2.prototype._addToCluster = function(pointId, clusterId) {
    this.clusters[clusterId].push(pointId);
    this._assigned[pointId] = 1;
  };
  DBSCAN2.prototype._regionQuery = function(pointId) {
    var neighbors = [];
    for (var id = 0; id < this._datasetLength; id++) {
      var dist3 = this.distance(this.dataset[pointId], this.dataset[id]);
      if (dist3 < this.epsilon) {
        neighbors.push(id);
      }
    }
    return neighbors;
  };
  DBSCAN2.prototype._mergeArrays = function(a, b) {
    var len2 = b.length;
    for (var i = 0; i < len2; i++) {
      var P = b[i];
      if (a.indexOf(P) < 0) {
        a.push(P);
      }
    }
    return a;
  };
  DBSCAN2.prototype._euclideanDistance = function(p, q) {
    var sum2 = 0;
    var i = Math.min(p.length, q.length);
    while (i--) {
      sum2 += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return Math.sqrt(sum2);
  };
  if (module.exports) {
    module.exports = DBSCAN2;
  }
})(DBSCAN);
var KMEANS = { exports: {} };
(function(module) {
  function KMEANS2(dataset, k, distance11) {
    this.k = 3;
    this.dataset = [];
    this.assignments = [];
    this.centroids = [];
    this.init(dataset, k, distance11);
  }
  KMEANS2.prototype.init = function(dataset, k, distance11) {
    this.assignments = [];
    this.centroids = [];
    if (typeof dataset !== "undefined") {
      this.dataset = dataset;
    }
    if (typeof k !== "undefined") {
      this.k = k;
    }
    if (typeof distance11 !== "undefined") {
      this.distance = distance11;
    }
  };
  KMEANS2.prototype.run = function(dataset, k) {
    this.init(dataset, k);
    var len2 = this.dataset.length;
    for (var i = 0; i < this.k; i++) {
      this.centroids[i] = this.randomCentroid();
    }
    var change = true;
    while (change) {
      change = this.assign();
      for (var centroidId = 0; centroidId < this.k; centroidId++) {
        var mean2 = new Array(maxDim);
        var count3 = 0;
        for (var dim = 0; dim < maxDim; dim++) {
          mean2[dim] = 0;
        }
        for (var j = 0; j < len2; j++) {
          var maxDim = this.dataset[j].length;
          if (centroidId === this.assignments[j]) {
            for (var dim = 0; dim < maxDim; dim++) {
              mean2[dim] += this.dataset[j][dim];
            }
            count3++;
          }
        }
        if (count3 > 0) {
          for (var dim = 0; dim < maxDim; dim++) {
            mean2[dim] /= count3;
          }
          this.centroids[centroidId] = mean2;
        } else {
          this.centroids[centroidId] = this.randomCentroid();
          change = true;
        }
      }
    }
    return this.getClusters();
  };
  KMEANS2.prototype.randomCentroid = function() {
    var maxId = this.dataset.length - 1;
    var centroid4;
    var id;
    do {
      id = Math.round(Math.random() * maxId);
      centroid4 = this.dataset[id];
    } while (this.centroids.indexOf(centroid4) >= 0);
    return centroid4;
  };
  KMEANS2.prototype.assign = function() {
    var change = false;
    var len2 = this.dataset.length;
    var closestCentroid;
    for (var i = 0; i < len2; i++) {
      closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
      if (closestCentroid != this.assignments[i]) {
        this.assignments[i] = closestCentroid;
        change = true;
      }
    }
    return change;
  };
  KMEANS2.prototype.getClusters = function() {
    var clusters = new Array(this.k);
    var centroidId;
    for (var pointId = 0; pointId < this.assignments.length; pointId++) {
      centroidId = this.assignments[pointId];
      if (typeof clusters[centroidId] === "undefined") {
        clusters[centroidId] = [];
      }
      clusters[centroidId].push(pointId);
    }
    return clusters;
  };
  KMEANS2.prototype.argmin = function(point4, set2, f) {
    var min5 = Number.MAX_VALUE;
    var arg = 0;
    var len2 = set2.length;
    var d;
    for (var i = 0; i < len2; i++) {
      d = f(point4, set2[i]);
      if (d < min5) {
        min5 = d;
        arg = i;
      }
    }
    return arg;
  };
  KMEANS2.prototype.distance = function(p, q) {
    var sum2 = 0;
    var i = Math.min(p.length, q.length);
    while (i--) {
      var diff2 = p[i] - q[i];
      sum2 += diff2 * diff2;
    }
    return Math.sqrt(sum2);
  };
  if (module.exports) {
    module.exports = KMEANS2;
  }
})(KMEANS);
var OPTICS = { exports: {} };
var PriorityQueue$1 = { exports: {} };
(function(module) {
  function PriorityQueue3(elements, priorities, sorting) {
    this._queue = [];
    this._priorities = [];
    this._sorting = "desc";
    this._init(elements, priorities, sorting);
  }
  PriorityQueue3.prototype.insert = function(ele, priority) {
    var indexToInsert = this._queue.length;
    var index2 = indexToInsert;
    while (index2--) {
      var priority2 = this._priorities[index2];
      if (this._sorting === "desc") {
        if (priority > priority2) {
          indexToInsert = index2;
        }
      } else {
        if (priority < priority2) {
          indexToInsert = index2;
        }
      }
    }
    this._insertAt(ele, priority, indexToInsert);
  };
  PriorityQueue3.prototype.remove = function(ele) {
    var index2 = this._queue.length;
    while (index2--) {
      var ele2 = this._queue[index2];
      if (ele === ele2) {
        this._queue.splice(index2, 1);
        this._priorities.splice(index2, 1);
        break;
      }
    }
  };
  PriorityQueue3.prototype.forEach = function(func) {
    this._queue.forEach(func);
  };
  PriorityQueue3.prototype.getElements = function() {
    return this._queue;
  };
  PriorityQueue3.prototype.getElementPriority = function(index2) {
    return this._priorities[index2];
  };
  PriorityQueue3.prototype.getPriorities = function() {
    return this._priorities;
  };
  PriorityQueue3.prototype.getElementsWithPriorities = function() {
    var result = [];
    for (var i = 0, l = this._queue.length; i < l; i++) {
      result.push([this._queue[i], this._priorities[i]]);
    }
    return result;
  };
  PriorityQueue3.prototype._init = function(elements, priorities, sorting) {
    if (elements && priorities) {
      this._queue = [];
      this._priorities = [];
      if (elements.length !== priorities.length) {
        throw new Error("Arrays must have the same length");
      }
      for (var i = 0; i < elements.length; i++) {
        this.insert(elements[i], priorities[i]);
      }
    }
    if (sorting) {
      this._sorting = sorting;
    }
  };
  PriorityQueue3.prototype._insertAt = function(ele, priority, index2) {
    if (this._queue.length === index2) {
      this._queue.push(ele);
      this._priorities.push(priority);
    } else {
      this._queue.splice(index2, 0, ele);
      this._priorities.splice(index2, 0, priority);
    }
  };
  if (module.exports) {
    module.exports = PriorityQueue3;
  }
})(PriorityQueue$1);
(function(module) {
  if (module.exports) {
    var PriorityQueue3 = PriorityQueue$1.exports;
  }
  function OPTICS2(dataset, epsilon3, minPts, distanceFunction) {
    this.epsilon = 1;
    this.minPts = 1;
    this.distance = this._euclideanDistance;
    this._reachability = [];
    this._processed = [];
    this._coreDistance = 0;
    this._orderedList = [];
    this._init(dataset, epsilon3, minPts, distanceFunction);
  }
  OPTICS2.prototype.run = function(dataset, epsilon3, minPts, distanceFunction) {
    this._init(dataset, epsilon3, minPts, distanceFunction);
    for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
      if (this._processed[pointId] !== 1) {
        this._processed[pointId] = 1;
        this.clusters.push([pointId]);
        var clusterId = this.clusters.length - 1;
        this._orderedList.push(pointId);
        var priorityQueue = new PriorityQueue3(null, null, "asc");
        var neighbors = this._regionQuery(pointId);
        if (this._distanceToCore(pointId) !== void 0) {
          this._updateQueue(pointId, neighbors, priorityQueue);
          this._expandCluster(clusterId, priorityQueue);
        }
      }
    }
    return this.clusters;
  };
  OPTICS2.prototype.getReachabilityPlot = function() {
    var reachabilityPlot = [];
    for (var i = 0, l = this._orderedList.length; i < l; i++) {
      var pointId = this._orderedList[i];
      var distance11 = this._reachability[pointId];
      reachabilityPlot.push([pointId, distance11]);
    }
    return reachabilityPlot;
  };
  OPTICS2.prototype._init = function(dataset, epsilon3, minPts, distance11) {
    if (dataset) {
      if (!(dataset instanceof Array)) {
        throw Error("Dataset must be of type array, " + typeof dataset + " given");
      }
      this.dataset = dataset;
      this.clusters = [];
      this._reachability = new Array(this.dataset.length);
      this._processed = new Array(this.dataset.length);
      this._coreDistance = 0;
      this._orderedList = [];
    }
    if (epsilon3) {
      this.epsilon = epsilon3;
    }
    if (minPts) {
      this.minPts = minPts;
    }
    if (distance11) {
      this.distance = distance11;
    }
  };
  OPTICS2.prototype._updateQueue = function(pointId, neighbors, queue) {
    var self2 = this;
    this._coreDistance = this._distanceToCore(pointId);
    neighbors.forEach(function(pointId2) {
      if (self2._processed[pointId2] === void 0) {
        var dist3 = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
        var newReachableDistance = Math.max(self2._coreDistance, dist3);
        if (self2._reachability[pointId2] === void 0) {
          self2._reachability[pointId2] = newReachableDistance;
          queue.insert(pointId2, newReachableDistance);
        } else {
          if (newReachableDistance < self2._reachability[pointId2]) {
            self2._reachability[pointId2] = newReachableDistance;
            queue.remove(pointId2);
            queue.insert(pointId2, newReachableDistance);
          }
        }
      }
    });
  };
  OPTICS2.prototype._expandCluster = function(clusterId, queue) {
    var queueElements = queue.getElements();
    for (var p = 0, l = queueElements.length; p < l; p++) {
      var pointId = queueElements[p];
      if (this._processed[pointId] === void 0) {
        var neighbors = this._regionQuery(pointId);
        this._processed[pointId] = 1;
        this.clusters[clusterId].push(pointId);
        this._orderedList.push(pointId);
        if (this._distanceToCore(pointId) !== void 0) {
          this._updateQueue(pointId, neighbors, queue);
          this._expandCluster(clusterId, queue);
        }
      }
    }
  };
  OPTICS2.prototype._distanceToCore = function(pointId) {
    var l = this.epsilon;
    for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
      var neighbors = this._regionQuery(pointId, coreDistCand);
      if (neighbors.length >= this.minPts) {
        return coreDistCand;
      }
    }
    return;
  };
  OPTICS2.prototype._regionQuery = function(pointId, epsilon3) {
    epsilon3 = epsilon3 || this.epsilon;
    var neighbors = [];
    for (var id = 0, l = this.dataset.length; id < l; id++) {
      if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon3) {
        neighbors.push(id);
      }
    }
    return neighbors;
  };
  OPTICS2.prototype._euclideanDistance = function(p, q) {
    var sum2 = 0;
    var i = Math.min(p.length, q.length);
    while (i--) {
      sum2 += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return Math.sqrt(sum2);
  };
  if (module.exports) {
    module.exports = OPTICS2;
  }
})(OPTICS);
(function(module) {
  if (module.exports) {
    module.exports = {
      DBSCAN: DBSCAN.exports,
      KMEANS: KMEANS.exports,
      OPTICS: OPTICS.exports,
      PriorityQueue: PriorityQueue$1.exports
    };
  }
})(lib);
var clustering = lib.exports;
function clustersDbscan(points2, maxDistance, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.mutate !== true)
    points2 = clone$5(points2);
  options.minPoints = options.minPoints || 3;
  var dbscan = new clustering.DBSCAN();
  var clusteredIds = dbscan.run(coordAll(points2), convertLength(maxDistance, options.units), options.minPoints, distance$2);
  var clusterId = -1;
  clusteredIds.forEach(function(clusterIds) {
    clusterId++;
    clusterIds.forEach(function(idx) {
      var clusterPoint = points2.features[idx];
      if (!clusterPoint.properties)
        clusterPoint.properties = {};
      clusterPoint.properties.cluster = clusterId;
      clusterPoint.properties.dbscan = "core";
    });
  });
  dbscan.noise.forEach(function(noiseId) {
    var noisePoint = points2.features[noiseId];
    if (!noisePoint.properties)
      noisePoint.properties = {};
    if (noisePoint.properties.cluster)
      noisePoint.properties.dbscan = "edge";
    else
      noisePoint.properties.dbscan = "noise";
  });
  return points2;
}
var distance$1 = {
  eudist: function eudist(v12, v22, sqrt4) {
    var len2 = v12.length;
    var sum2 = 0;
    for (var i = 0; i < len2; i++) {
      var d = (v12[i] || 0) - (v22[i] || 0);
      sum2 += d * d;
    }
    return sqrt4 ? Math.sqrt(sum2) : sum2;
  },
  mandist: function mandist(v12, v22, sqrt4) {
    var len2 = v12.length;
    var sum2 = 0;
    for (var i = 0; i < len2; i++) {
      sum2 += Math.abs((v12[i] || 0) - (v22[i] || 0));
    }
    return sqrt4 ? Math.sqrt(sum2) : sum2;
  },
  dist: function dist(v12, v22, sqrt4) {
    var d = Math.abs(v12 - v22);
    return sqrt4 ? d : d * d;
  }
};
var Distance$1 = distance$1, eudist$1 = Distance$1.eudist, dist$2 = Distance$1.dist;
var kinit = {
  kmrand: function kmrand(data, k) {
    var map5 = {}, ks = [], t = k << 2;
    var len2 = data.length;
    var multi = data[0].length > 0;
    while (ks.length < k && t-- > 0) {
      var d = data[Math.floor(Math.random() * len2)];
      var key = multi ? d.join("_") : "" + d;
      if (!map5[key]) {
        map5[key] = true;
        ks.push(d);
      }
    }
    if (ks.length < k)
      throw new Error("Error initializating clusters");
    else
      return ks;
  },
  kmpp: function kmpp(data, k) {
    var distance11 = data[0].length ? eudist$1 : dist$2;
    var ks = [], len2 = data.length;
    var multi = data[0].length > 0;
    var c = data[Math.floor(Math.random() * len2)];
    multi ? c.join("_") : "" + c;
    ks.push(c);
    while (ks.length < k) {
      var dists = [], lk = ks.length;
      var dsum = 0, prs = [];
      for (var i = 0; i < len2; i++) {
        var min5 = Infinity;
        for (var j = 0; j < lk; j++) {
          var _dist = distance11(data[i], ks[j]);
          if (_dist <= min5)
            min5 = _dist;
        }
        dists[i] = min5;
      }
      for (var _i = 0; _i < len2; _i++) {
        dsum += dists[_i];
      }
      for (var _i2 = 0; _i2 < len2; _i2++) {
        prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
      }
      prs.sort(function(a, b) {
        return a.pr - b.pr;
      });
      prs[0].cs = prs[0].pr;
      for (var _i3 = 1; _i3 < len2; _i3++) {
        prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
      }
      var rnd2 = Math.random();
      var idx = 0;
      while (idx < len2 - 1 && prs[idx++].cs < rnd2) {
      }
      ks.push(prs[idx - 1].v);
    }
    return ks;
  }
};
var Distance = distance$1, ClusterInit = kinit, eudist2 = Distance.eudist, kmrand2 = ClusterInit.kmrand, kmpp2 = ClusterInit.kmpp;
var MAX = 1e4;
function init$2(len2, val, v) {
  v = v || [];
  for (var i = 0; i < len2; i++) {
    v[i] = val;
  }
  return v;
}
function skmeans(data, k, initial, maxit) {
  var ks = [], old = [], idxs = [], dist3 = [];
  var conv = false, it = maxit || MAX;
  var len2 = data.length, vlen = data[0].length, multi = vlen > 0;
  var count3 = [];
  if (!initial) {
    var _idxs = {};
    while (ks.length < k) {
      var idx = Math.floor(Math.random() * len2);
      if (!_idxs[idx]) {
        _idxs[idx] = true;
        ks.push(data[idx]);
      }
    }
  } else if (initial == "kmrand") {
    ks = kmrand2(data, k);
  } else if (initial == "kmpp") {
    ks = kmpp2(data, k);
  } else {
    ks = initial;
  }
  do {
    init$2(k, 0, count3);
    for (var i = 0; i < len2; i++) {
      var min5 = Infinity, _idx = 0;
      for (var j = 0; j < k; j++) {
        var dist3 = multi ? eudist2(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
        if (dist3 <= min5) {
          min5 = dist3;
          _idx = j;
        }
      }
      idxs[i] = _idx;
      count3[_idx]++;
    }
    var sum2 = [], old = [];
    for (var _j = 0; _j < k; _j++) {
      sum2[_j] = multi ? init$2(vlen, 0, sum2[_j]) : 0;
      old[_j] = ks[_j];
    }
    if (multi) {
      for (var _j2 = 0; _j2 < k; _j2++) {
        ks[_j2] = [];
      }
      for (var _i = 0; _i < len2; _i++) {
        var _idx2 = idxs[_i], vsum = sum2[_idx2], vect = data[_i];
        for (var h = 0; h < vlen; h++) {
          vsum[h] += vect[h];
        }
      }
      conv = true;
      for (var _j3 = 0; _j3 < k; _j3++) {
        var ksj = ks[_j3], sumj = sum2[_j3], oldj = old[_j3], cj = count3[_j3];
        for (var _h = 0; _h < vlen; _h++) {
          ksj[_h] = sumj[_h] / cj || 0;
        }
        if (conv) {
          for (var _h2 = 0; _h2 < vlen; _h2++) {
            if (oldj[_h2] != ksj[_h2]) {
              conv = false;
              break;
            }
          }
        }
      }
    } else {
      for (var _i2 = 0; _i2 < len2; _i2++) {
        var _idx3 = idxs[_i2];
        sum2[_idx3] += data[_i2];
      }
      for (var _j4 = 0; _j4 < k; _j4++) {
        ks[_j4] = sum2[_j4] / count3[_j4] || 0;
      }
      conv = true;
      for (var _j5 = 0; _j5 < k; _j5++) {
        if (old[_j5] != ks[_j5]) {
          conv = false;
          break;
        }
      }
    }
    conv = conv || --it <= 0;
  } while (!conv);
  return {
    it: MAX - it,
    k,
    idxs,
    centroids: ks
  };
}
var main$1 = skmeans;
function clustersKmeans(points2, options) {
  if (options === void 0) {
    options = {};
  }
  var count3 = points2.features.length;
  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count3 / 2));
  if (options.numberOfClusters > count3)
    options.numberOfClusters = count3;
  if (options.mutate !== true)
    points2 = clone$5(points2);
  var data = coordAll(points2);
  var initialCentroids = data.slice(0, options.numberOfClusters);
  var skmeansResult = main$1(data, options.numberOfClusters, initialCentroids);
  var centroids = {};
  skmeansResult.centroids.forEach(function(coord, idx) {
    centroids[idx] = coord;
  });
  featureEach$1(points2, function(point4, index2) {
    var clusterId = skmeansResult.idxs[index2];
    point4.properties.cluster = clusterId;
    point4.properties.centroid = centroids[clusterId];
  });
  return points2;
}
function booleanParallel(line1, line2) {
  if (!line1)
    throw new Error("line1 is required");
  if (!line2)
    throw new Error("line2 is required");
  var type1 = getType(line1, "line1");
  if (type1 !== "LineString")
    throw new Error("line1 must be a LineString");
  var type2 = getType(line2, "line2");
  if (type2 !== "LineString")
    throw new Error("line2 must be a LineString");
  var segments1 = lineSegment(cleanCoords(line1)).features;
  var segments2 = lineSegment(cleanCoords(line2)).features;
  for (var i = 0; i < segments1.length; i++) {
    var segment1 = segments1[i].geometry.coordinates;
    if (!segments2[i])
      break;
    var segment2 = segments2[i].geometry.coordinates;
    if (!isParallel(segment1, segment2))
      return false;
  }
  return true;
}
function isParallel(segment1, segment2) {
  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));
  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));
  return slope1 === slope2;
}
function getType(geojson, name2) {
  if (geojson.geometry && geojson.geometry.type)
    return geojson.geometry.type;
  if (geojson.type)
    return geojson.type;
  throw new Error("Invalid GeoJSON object for " + name2);
}
function pathTo(node) {
  var curr = node, path = [];
  while (curr.parent) {
    path.unshift(curr);
    curr = curr.parent;
  }
  return path;
}
function getHeap() {
  return new BinaryHeap(function(node) {
    return node.f;
  });
}
var astar = {
  search: function(graph, start2, end2, options) {
    graph.cleanDirty();
    options = options || {};
    var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
    var openHeap = getHeap(), closestNode = start2;
    start2.h = heuristic(start2, end2);
    openHeap.push(start2);
    while (openHeap.size() > 0) {
      var currentNode = openHeap.pop();
      if (currentNode === end2) {
        return pathTo(currentNode);
      }
      currentNode.closed = true;
      var neighbors = graph.neighbors(currentNode);
      for (var i = 0, il = neighbors.length; i < il; ++i) {
        var neighbor = neighbors[i];
        if (neighbor.closed || neighbor.isWall()) {
          continue;
        }
        var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
        if (!beenVisited || gScore < neighbor.g) {
          neighbor.visited = true;
          neighbor.parent = currentNode;
          neighbor.h = neighbor.h || heuristic(neighbor, end2);
          neighbor.g = gScore;
          neighbor.f = neighbor.g + neighbor.h;
          graph.markDirty(neighbor);
          if (closest) {
            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
              closestNode = neighbor;
            }
          }
          if (!beenVisited) {
            openHeap.push(neighbor);
          } else {
            openHeap.rescoreElement(neighbor);
          }
        }
      }
    }
    if (closest) {
      return pathTo(closestNode);
    }
    return [];
  },
  heuristics: {
    manhattan: function(pos0, pos1) {
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return d1 + d2;
    },
    diagonal: function(pos0, pos1) {
      var D = 1;
      var D2 = Math.sqrt(2);
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
    }
  },
  cleanNode: function(node) {
    node.f = 0;
    node.g = 0;
    node.h = 0;
    node.visited = false;
    node.closed = false;
    node.parent = null;
  }
};
function Graph$2(gridIn, options) {
  options = options || {};
  this.nodes = [];
  this.diagonal = !!options.diagonal;
  this.grid = [];
  for (var x2 = 0; x2 < gridIn.length; x2++) {
    this.grid[x2] = [];
    for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
      var node = new GridNode(x2, y2, row[y2]);
      this.grid[x2][y2] = node;
      this.nodes.push(node);
    }
  }
  this.init();
}
Graph$2.prototype.init = function() {
  this.dirtyNodes = [];
  for (var i = 0; i < this.nodes.length; i++) {
    astar.cleanNode(this.nodes[i]);
  }
};
Graph$2.prototype.cleanDirty = function() {
  for (var i = 0; i < this.dirtyNodes.length; i++) {
    astar.cleanNode(this.dirtyNodes[i]);
  }
  this.dirtyNodes = [];
};
Graph$2.prototype.markDirty = function(node) {
  this.dirtyNodes.push(node);
};
Graph$2.prototype.neighbors = function(node) {
  var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
  if (grid[x2 - 1] && grid[x2 - 1][y2]) {
    ret.push(grid[x2 - 1][y2]);
  }
  if (grid[x2 + 1] && grid[x2 + 1][y2]) {
    ret.push(grid[x2 + 1][y2]);
  }
  if (grid[x2] && grid[x2][y2 - 1]) {
    ret.push(grid[x2][y2 - 1]);
  }
  if (grid[x2] && grid[x2][y2 + 1]) {
    ret.push(grid[x2][y2 + 1]);
  }
  if (this.diagonal) {
    if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
      ret.push(grid[x2 - 1][y2 - 1]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
      ret.push(grid[x2 + 1][y2 - 1]);
    }
    if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
      ret.push(grid[x2 - 1][y2 + 1]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
      ret.push(grid[x2 + 1][y2 + 1]);
    }
  }
  return ret;
};
Graph$2.prototype.toString = function() {
  var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
  for (var x2 = 0, len2 = nodes.length; x2 < len2; x2++) {
    rowDebug = [];
    row = nodes[x2];
    for (y2 = 0, l = row.length; y2 < l; y2++) {
      rowDebug.push(row[y2].weight);
    }
    graphString.push(rowDebug.join(" "));
  }
  return graphString.join("\n");
};
function GridNode(x2, y2, weight) {
  this.x = x2;
  this.y = y2;
  this.weight = weight;
}
GridNode.prototype.toString = function() {
  return "[" + this.x + " " + this.y + "]";
};
GridNode.prototype.getCost = function(fromNeighbor) {
  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
    return this.weight * 1.41421;
  }
  return this.weight;
};
GridNode.prototype.isWall = function() {
  return this.weight === 0;
};
function BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
  push: function(element) {
    this.content.push(element);
    this.sinkDown(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end2 = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end2;
      this.bubbleUp(0);
    }
    return result;
  },
  remove: function(node) {
    var i = this.content.indexOf(node);
    var end2 = this.content.pop();
    if (i !== this.content.length - 1) {
      this.content[i] = end2;
      if (this.scoreFunction(end2) < this.scoreFunction(node)) {
        this.sinkDown(i);
      } else {
        this.bubbleUp(i);
      }
    }
  },
  size: function() {
    return this.content.length;
  },
  rescoreElement: function(node) {
    this.sinkDown(this.content.indexOf(node));
  },
  sinkDown: function(n) {
    var element = this.content[n];
    while (n > 0) {
      var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  },
  bubbleUp: function(n) {
    var length3 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
    while (true) {
      var child2N = n + 1 << 1, child1N = child2N - 1;
      var swap2 = null, child1Score;
      if (child1N < length3) {
        var child1 = this.content[child1N];
        child1Score = this.scoreFunction(child1);
        if (child1Score < elemScore) {
          swap2 = child1N;
        }
      }
      if (child2N < length3) {
        var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
        if (child2Score < (swap2 === null ? elemScore : child1Score)) {
          swap2 = child2N;
        }
      }
      if (swap2 !== null) {
        this.content[n] = this.content[swap2];
        this.content[swap2] = element;
        n = swap2;
      } else {
        break;
      }
    }
  }
};
function shortestPath(start2, end2, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var resolution = options.resolution;
  var minDistance = options.minDistance;
  var obstacles = options.obstacles || featureCollection$1([]);
  if (!start2)
    throw new Error("start is required");
  if (!end2)
    throw new Error("end is required");
  if (resolution && !isNumber$2(resolution) || resolution <= 0)
    throw new Error("options.resolution must be a number, greater than 0");
  if (minDistance)
    throw new Error("options.minDistance is not yet implemented");
  var startCoord = getCoord(start2);
  var endCoord = getCoord(end2);
  start2 = point(startCoord);
  end2 = point(endCoord);
  switch (getType$1(obstacles)) {
    case "FeatureCollection":
      if (obstacles.features.length === 0)
        return lineString([startCoord, endCoord]);
      break;
    case "Polygon":
      obstacles = featureCollection$1([feature(getGeom(obstacles))]);
      break;
    default:
      throw new Error("invalid obstacles");
  }
  var collection = obstacles;
  collection.features.push(start2);
  collection.features.push(end2);
  var box2 = bbox$1(transformScale(bboxPolygon(bbox$1(collection)), 1.15));
  if (!resolution) {
    var width = distance$2([box2[0], box2[1]], [box2[2], box2[1]], options);
    resolution = width / 100;
  }
  collection.features.pop();
  collection.features.pop();
  var west = box2[0];
  var south = box2[1];
  var east = box2[2];
  var north = box2[3];
  var xFraction = resolution / distance$2([west, south], [east, south], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = resolution / distance$2([west, south], [west, north], options);
  var cellHeight = yFraction * (north - south);
  var bboxHorizontalSide = east - west;
  var bboxVerticalSide = north - south;
  var columns = Math.floor(bboxHorizontalSide / cellWidth);
  var rows = Math.floor(bboxVerticalSide / cellHeight);
  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
  var pointMatrix = [];
  var matrix = [];
  var closestToStart = [];
  var closestToEnd = [];
  var minDistStart = Infinity;
  var minDistEnd = Infinity;
  var currentY = north - deltaY;
  var r = 0;
  while (currentY >= south) {
    var matrixRow = [];
    var pointMatrixRow = [];
    var currentX = west + deltaX;
    var c = 0;
    while (currentX <= east) {
      var pt = point([currentX, currentY]);
      var isInsideObstacle = isInside(pt, obstacles);
      matrixRow.push(isInsideObstacle ? 0 : 1);
      pointMatrixRow.push(currentX + "|" + currentY);
      var distStart = distance$2(pt, start2);
      if (!isInsideObstacle && distStart < minDistStart) {
        minDistStart = distStart;
        closestToStart = { x: c, y: r };
      }
      var distEnd = distance$2(pt, end2);
      if (!isInsideObstacle && distEnd < minDistEnd) {
        minDistEnd = distEnd;
        closestToEnd = { x: c, y: r };
      }
      currentX += cellWidth;
      c++;
    }
    matrix.push(matrixRow);
    pointMatrix.push(pointMatrixRow);
    currentY -= cellHeight;
    r++;
  }
  var graph = new Graph$2(matrix, { diagonal: true });
  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
  var result = astar.search(graph, startOnMatrix, endOnMatrix);
  var path = [startCoord];
  result.forEach(function(coord) {
    var coords = pointMatrix[coord.x][coord.y].split("|");
    path.push([+coords[0], +coords[1]]);
  });
  path.push(endCoord);
  return cleanCoords(lineString(path));
}
function isInside(pt, polygons2) {
  for (var i = 0; i < polygons2.features.length; i++) {
    if (booleanPointInPolygon(pt, polygons2.features[i])) {
      return true;
    }
  }
  return false;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
function x(d) {
  return d[0];
}
function y(d) {
  return d[1];
}
function RedBlackTree() {
  this._ = null;
}
function RedBlackNode(node) {
  node.U = node.C = node.L = node.R = node.P = node.N = null;
}
RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function(after, node) {
    var parent, grandpa, uncle;
    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N)
        after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L)
          after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;
    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },
  remove: function(node) {
    if (node.N)
      node.N.P = node.P;
    if (node.P)
      node.P.N = node.N;
    node.N = node.P = null;
    var parent = node.U, sibling, left = node.L, right = node.R, next3, red;
    if (!left)
      next3 = right;
    else if (!right)
      next3 = left;
    else
      next3 = RedBlackFirst(right);
    if (parent) {
      if (parent.L === node)
        parent.L = next3;
      else
        parent.R = next3;
    } else {
      this._ = next3;
    }
    if (left && right) {
      red = next3.C;
      next3.C = node.C;
      next3.L = left;
      left.U = next3;
      if (next3 !== right) {
        parent = next3.U;
        next3.U = node.U;
        node = next3.R;
        parent.L = node;
        next3.R = right;
        right.U = next3;
      } else {
        next3.U = parent;
        parent = next3;
        node = next3.R;
      }
    } else {
      red = node.C;
      node = next3;
    }
    if (node)
      node.U = parent;
    if (red)
      return;
    if (node && node.C) {
      node.C = false;
      return;
    }
    do {
      if (node === this._)
        break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);
    if (node)
      node.C = false;
  }
};
function RedBlackRotateLeft(tree, node) {
  var p = node, q = node.R, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree._ = q;
  }
  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R)
    p.R.U = p;
  q.L = p;
}
function RedBlackRotateRight(tree, node) {
  var p = node, q = node.L, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree._ = q;
  }
  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L)
    p.L.U = p;
  q.R = p;
}
function RedBlackFirst(node) {
  while (node.L)
    node = node.L;
  return node;
}
function createEdge(left, right, v0, v12) {
  var edge = [null, null], index2 = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0)
    setEdgeEnd(edge, left, right, v0);
  if (v12)
    setEdgeEnd(edge, right, left, v12);
  cells[left.index].halfedges.push(index2);
  cells[right.index].halfedges.push(index2);
  return edge;
}
function createBorderEdge(left, v0, v12) {
  var edge = [v0, v12];
  edge.left = left;
  return edge;
}
function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}
function clipEdge(edge, x02, y02, x12, y12) {
  var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dx > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dx > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dy > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dy > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  if (!(t0 > 0) && !(t1 < 1))
    return true;
  if (t0 > 0)
    edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1)
    edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}
function connectEdge(edge, x02, y02, x12, y12) {
  var v12 = edge[1];
  if (v12)
    return true;
  var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
  if (ry === ly) {
    if (fx < x02 || fx >= x12)
      return;
    if (lx > rx) {
      if (!v0)
        v0 = [fx, y02];
      else if (v0[1] >= y12)
        return;
      v12 = [fx, y12];
    } else {
      if (!v0)
        v0 = [fx, y12];
      else if (v0[1] < y02)
        return;
      v12 = [fx, y02];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0)
          v0 = [(y02 - fb) / fm, y02];
        else if (v0[1] >= y12)
          return;
        v12 = [(y12 - fb) / fm, y12];
      } else {
        if (!v0)
          v0 = [(y12 - fb) / fm, y12];
        else if (v0[1] < y02)
          return;
        v12 = [(y02 - fb) / fm, y02];
      }
    } else {
      if (ly < ry) {
        if (!v0)
          v0 = [x02, fm * x02 + fb];
        else if (v0[0] >= x12)
          return;
        v12 = [x12, fm * x12 + fb];
      } else {
        if (!v0)
          v0 = [x12, fm * x12 + fb];
        else if (v0[0] < x02)
          return;
        v12 = [x02, fm * x02 + fb];
      }
    }
  }
  edge[0] = v0;
  edge[1] = v12;
  return true;
}
function clipEdges(x02, y02, x12, y12) {
  var i = edges.length, edge;
  while (i--) {
    if (!connectEdge(edge = edges[i], x02, y02, x12, y12) || !clipEdge(edge, x02, y02, x12, y12) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$2 || Math.abs(edge[0][1] - edge[1][1]) > epsilon$2)) {
      delete edges[i];
    }
  }
}
function createCell(site) {
  return cells[site.index] = {
    site,
    halfedges: []
  };
}
function cellHalfedgeAngle(cell, edge) {
  var site = cell.site, va = edge.left, vb = edge.right;
  if (site === vb)
    vb = va, va = site;
  if (vb)
    return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va)
    va = edge[1], vb = edge[0];
  else
    va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m2; i < n; ++i) {
    if ((cell = cells[i]) && (m2 = (halfedges = cell.halfedges).length)) {
      var index2 = new Array(m2), array = new Array(m2);
      for (j = 0; j < m2; ++j)
        index2[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index2.sort(function(i2, j2) {
        return array[j2] - array[i2];
      });
      for (j = 0; j < m2; ++j)
        array[j] = halfedges[index2[j]];
      for (j = 0; j < m2; ++j)
        halfedges[j] = array[j];
    }
  }
}
function clipCells(x02, y02, x12, y12) {
  var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start2, startX, startY, end2, endX, endY, cover = true;
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end2 = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end2[0], endY = end2[1];
        start2 = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start2[0], startY = start2[1];
        if (Math.abs(endX - startX) > epsilon$2 || Math.abs(endY - startY) > epsilon$2) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
            site,
            end2,
            Math.abs(endX - x02) < epsilon$2 && y12 - endY > epsilon$2 ? [x02, Math.abs(startX - x02) < epsilon$2 ? startY : y12] : Math.abs(endY - y12) < epsilon$2 && x12 - endX > epsilon$2 ? [Math.abs(startY - y12) < epsilon$2 ? startX : x12, y12] : Math.abs(endX - x12) < epsilon$2 && endY - y02 > epsilon$2 ? [x12, Math.abs(startX - x12) < epsilon$2 ? startY : y02] : Math.abs(endY - y02) < epsilon$2 && endX - x02 > epsilon$2 ? [Math.abs(startY - y02) < epsilon$2 ? startX : x02, y02] : null
          )) - 1);
          ++nHalfedges;
        }
      }
      if (nHalfedges)
        cover = false;
    }
  }
  if (cover) {
    var dx, dy, d2, dc = Infinity;
    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x02;
        dy = site[1] - y02;
        d2 = dx * dx + dy * dy;
        if (d2 < dc)
          dc = d2, cover = cell;
      }
    }
    if (cover) {
      var v00 = [x02, y02], v01 = [x02, y12], v11 = [x12, y12], v10 = [x12, y02];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}
var circlePool = [];
var firstCircle;
function Circle$2() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc) {
  var lArc = arc.P, rArc = arc.N;
  if (!lArc || !rArc)
    return;
  var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
  if (lSite === rSite)
    return;
  var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2)
    return;
  var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
  var circle2 = circlePool.pop() || new Circle$2();
  circle2.arc = arc;
  circle2.site = cSite;
  circle2.x = x2 + bx;
  circle2.y = (circle2.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
  arc.circle = circle2;
  var before = null, node = circles._;
  while (node) {
    if (circle2.y < node.y || circle2.y === node.y && circle2.x <= node.x) {
      if (node.L)
        node = node.L;
      else {
        before = node.P;
        break;
      }
    } else {
      if (node.R)
        node = node.R;
      else {
        before = node;
        break;
      }
    }
  }
  circles.insert(before, circle2);
  if (!before)
    firstCircle = circle2;
}
function detachCircle(arc) {
  var circle2 = arc.circle;
  if (circle2) {
    if (!circle2.P)
      firstCircle = circle2.N;
    circles.remove(circle2);
    circlePool.push(circle2);
    RedBlackNode(circle2);
    arc.circle = null;
  }
}
var beachPool = [];
function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}
function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}
function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}
function removeBeach(beach) {
  var circle2 = beach.circle, x2 = circle2.x, y2 = circle2.cy, vertex = [x2, y2], previous = beach.P, next3 = beach.N, disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;
  while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon$2 && Math.abs(y2 - lArc.circle.cy) < epsilon$2) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }
  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next3;
  while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon$2 && Math.abs(y2 - rArc.circle.cy) < epsilon$2) {
    next3 = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next3;
  }
  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length, iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }
  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
  while (node) {
    dxl = leftBreakPoint(node, directrix) - x2;
    if (dxl > epsilon$2)
      node = node.L;
    else {
      dxr = x2 - rightBreakPoint(node, directrix);
      if (dxr > epsilon$2) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon$2) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$2) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }
  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc)
    return;
  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }
  if (!rArc) {
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }
  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function leftBreakPoint(arc, directrix) {
  var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
  if (!pby2)
    return rfocx;
  var lArc = arc.P;
  if (!lArc)
    return -Infinity;
  site = lArc.site;
  var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
  if (!plby2)
    return lfocx;
  var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
  if (aby2)
    return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc)
    return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}
var epsilon$2 = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;
function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}
function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}
function Diagram(sites, extent3) {
  var site = sites.sort(lexicographic).pop(), x2, y2, circle2;
  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree();
  circles = new RedBlackTree();
  while (true) {
    circle2 = firstCircle;
    if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
      if (site[0] !== x2 || site[1] !== y2) {
        addBeach(site);
        x2 = site[0], y2 = site[1];
      }
      site = sites.pop();
    } else if (circle2) {
      removeBeach(circle2.arc);
    } else {
      break;
    }
  }
  sortCellHalfedges();
  if (extent3) {
    var x02 = +extent3[0][0], y02 = +extent3[0][1], x12 = +extent3[1][0], y12 = +extent3[1][1];
    clipEdges(x02, y02, x12, y12);
    clipCells(x02, y02, x12, y12);
  }
  this.edges = edges;
  this.cells = cells;
  beaches = circles = edges = cells = null;
}
Diagram.prototype = {
  constructor: Diagram,
  polygons: function() {
    var edges2 = this.edges;
    return this.cells.map(function(cell) {
      var polygon4 = cell.halfedges.map(function(i) {
        return cellHalfedgeStart(cell, edges2[i]);
      });
      polygon4.data = cell.site.data;
      return polygon4;
    });
  },
  triangles: function() {
    var triangles = [], edges2 = this.edges;
    this.cells.forEach(function(cell, i) {
      if (!(m2 = (halfedges = cell.halfedges).length))
        return;
      var site = cell.site, halfedges, j = -1, m2, s0, e1 = edges2[halfedges[m2 - 1]], s1 = e1.left === site ? e1.right : e1.left;
      while (++j < m2) {
        s0 = s1;
        e1 = edges2[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function(x2, y2, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
    while (!(cell = that.cells[i1]))
      if (++i1 >= n)
        return null;
    var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e2) {
        var edge = that.edges[e2], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right))
          return;
        var vx = x2 - v[0], vy = y2 - v[1], v22 = vx * vx + vy * vy;
        if (v22 < d2)
          d2 = v22, i1 = v.index;
      });
    } while (i1 !== null);
    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};
function voronoi$1() {
  var x$1 = x, y$1 = y, extent3 = null;
  function voronoi2(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$1(d, i, data) / epsilon$2) * epsilon$2, Math.round(y$1(d, i, data) / epsilon$2) * epsilon$2];
      s.index = i;
      s.data = d;
      return s;
    }), extent3);
  }
  voronoi2.polygons = function(data) {
    return voronoi2(data).polygons();
  };
  voronoi2.links = function(data) {
    return voronoi2(data).links();
  };
  voronoi2.triangles = function(data) {
    return voronoi2(data).triangles();
  };
  voronoi2.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : x$1;
  };
  voronoi2.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : y$1;
  };
  voronoi2.extent = function(_) {
    return arguments.length ? (extent3 = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi2) : extent3 && [[extent3[0][0], extent3[0][1]], [extent3[1][0], extent3[1][1]]];
  };
  voronoi2.size = function(_) {
    return arguments.length ? (extent3 = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi2) : extent3 && [extent3[1][0] - extent3[0][0], extent3[1][1] - extent3[0][1]];
  };
  return voronoi2;
}
function coordsToPolygon(coords) {
  coords = coords.slice();
  coords.push(coords[0]);
  return polygon([coords]);
}
function voronoi(points2, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var bbox2 = options.bbox || [-180, -85, 180, 85];
  if (!points2)
    throw new Error("points is required");
  if (!Array.isArray(bbox2))
    throw new Error("bbox is invalid");
  collectionOf(points2, "Point", "points");
  return featureCollection$1(
    voronoi$1().x(function(feature2) {
      return feature2.geometry.coordinates[0];
    }).y(function(feature2) {
      return feature2.geometry.coordinates[1];
    }).extent([
      [bbox2[0], bbox2[1]],
      [bbox2[2], bbox2[3]]
    ]).polygons(points2.features).map(coordsToPolygon)
  );
}
function ellipse(center2, xSemiAxis, ySemiAxis, options) {
  options = options || {};
  var steps = options.steps || 64;
  var units = options.units || "kilometers";
  var angle4 = options.angle || 0;
  var pivot = options.pivot || center2;
  var properties = options.properties || center2.properties || {};
  if (!center2)
    throw new Error("center is required");
  if (!xSemiAxis)
    throw new Error("xSemiAxis is required");
  if (!ySemiAxis)
    throw new Error("ySemiAxis is required");
  if (!isObject$5(options))
    throw new Error("options must be an object");
  if (!isNumber$2(steps))
    throw new Error("steps must be a number");
  if (!isNumber$2(angle4))
    throw new Error("angle must be a number");
  var centerCoords = getCoord(center2);
  if (units === "degrees") {
    var angleRad = degreesToRadians(angle4);
  } else {
    xSemiAxis = rhumbDestination(center2, xSemiAxis, 90, { units });
    ySemiAxis = rhumbDestination(center2, ySemiAxis, 0, { units });
    xSemiAxis = getCoord(xSemiAxis)[0] - centerCoords[0];
    ySemiAxis = getCoord(ySemiAxis)[1] - centerCoords[1];
  }
  var coordinates = [];
  for (var i = 0; i < steps; i += 1) {
    var stepAngle = i * -360 / steps;
    var x2 = xSemiAxis * ySemiAxis / Math.sqrt(
      Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
    );
    var y2 = xSemiAxis * ySemiAxis / Math.sqrt(
      Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
    );
    if (stepAngle < -90 && stepAngle >= -270)
      x2 = -x2;
    if (stepAngle < -180 && stepAngle >= -360)
      y2 = -y2;
    if (units === "degrees") {
      var newx = x2 * Math.cos(angleRad) + y2 * Math.sin(angleRad);
      var newy = y2 * Math.cos(angleRad) - x2 * Math.sin(angleRad);
      x2 = newx;
      y2 = newy;
    }
    coordinates.push([x2 + centerCoords[0], y2 + centerCoords[1]]);
  }
  coordinates.push(coordinates[0]);
  if (units === "degrees") {
    return polygon([coordinates], properties);
  } else {
    return transformRotate(polygon([coordinates], properties), angle4, {
      pivot
    });
  }
}
function getTanDeg(deg) {
  var rad2 = deg * Math.PI / 180;
  return Math.tan(rad2);
}
function centerMean(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var sumXs = 0;
  var sumYs = 0;
  var sumNs = 0;
  geomEach(geojson, function(geom, featureIndex, properties) {
    var weight = options.weight ? properties === null || properties === void 0 ? void 0 : properties[options.weight] : void 0;
    weight = weight === void 0 || weight === null ? 1 : weight;
    if (!isNumber$2(weight))
      throw new Error("weight value must be a number for feature index " + featureIndex);
    weight = Number(weight);
    if (weight > 0) {
      coordEach(geom, function(coord) {
        sumXs += coord[0] * weight;
        sumYs += coord[1] * weight;
        sumNs += weight;
      });
    }
  });
  return point([sumXs / sumNs, sumYs / sumNs], options.properties, options);
}
function centerMedian(features2, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var counter = options.counter || 10;
  if (!isNumber$2(counter))
    throw new Error("counter must be a number");
  var weightTerm = options.weight;
  var meanCenter = centerMean(features2, { weight: options.weight });
  var centroids = featureCollection$1([]);
  featureEach$1(features2, function(feature2) {
    var _a2;
    centroids.features.push(centroid$2(feature2, {
      properties: { weight: (_a2 = feature2.properties) === null || _a2 === void 0 ? void 0 : _a2[weightTerm] }
    }));
  });
  var properties = {
    tolerance: options.tolerance,
    medianCandidates: []
  };
  return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);
}
function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
  var tolerance = properties.tolerance || 1e-3;
  var candidateXsum = 0;
  var candidateYsum = 0;
  var kSum = 0;
  var centroidCount = 0;
  featureEach$1(centroids, function(theCentroid) {
    var _a2;
    var weightValue = (_a2 = theCentroid.properties) === null || _a2 === void 0 ? void 0 : _a2.weight;
    var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;
    weight = Number(weight);
    if (!isNumber$2(weight))
      throw new Error("weight value must be a number");
    if (weight > 0) {
      centroidCount += 1;
      var distanceFromCandidate = weight * distance$2(theCentroid, candidateMedian);
      if (distanceFromCandidate === 0)
        distanceFromCandidate = 1;
      var k = weight / distanceFromCandidate;
      candidateXsum += theCentroid.geometry.coordinates[0] * k;
      candidateYsum += theCentroid.geometry.coordinates[1] * k;
      kSum += k;
    }
  });
  if (centroidCount < 1)
    throw new Error("no features to measure");
  var candidateX = candidateXsum / kSum;
  var candidateY = candidateYsum / kSum;
  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {
    return point([candidateX, candidateY], {
      medianCandidates: properties.medianCandidates
    });
  } else {
    properties.medianCandidates.push([candidateX, candidateY]);
    return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);
  }
}
function standardDeviationalEllipse(points2, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var steps = options.steps || 64;
  var weightTerm = options.weight;
  var properties = options.properties || {};
  if (!isNumber$2(steps))
    throw new Error("steps must be a number");
  if (!isObject$5(properties))
    throw new Error("properties must be a number");
  var numberOfFeatures = coordAll(points2).length;
  var meanCenter = centerMean(points2, { weight: weightTerm });
  var xDeviationSquaredSum = 0;
  var yDeviationSquaredSum = 0;
  var xyDeviationSum = 0;
  featureEach$1(points2, function(point4) {
    var weight = point4.properties[weightTerm] || 1;
    var deviation = getDeviations(getCoords(point4), getCoords(meanCenter));
    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
    xyDeviationSum += deviation.x * deviation.y * weight;
  });
  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
  var bigC = 2 * xyDeviationSum;
  var theta = Math.atan((bigA + bigB) / bigC);
  var thetaDeg = theta * 180 / Math.PI;
  var sigmaXsum = 0;
  var sigmaYsum = 0;
  var weightsum = 0;
  featureEach$1(points2, function(point4) {
    var weight = point4.properties[weightTerm] || 1;
    var deviation = getDeviations(getCoords(point4), getCoords(meanCenter));
    sigmaXsum += Math.pow(
      deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
      2
    ) * weight;
    sigmaYsum += Math.pow(
      deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
      2
    ) * weight;
    weightsum += weight;
  });
  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {
    units: "degrees",
    angle: thetaDeg,
    steps,
    properties
  });
  var pointsWithinEllipse = pointsWithinPolygon(
    points2,
    featureCollection$1([theEllipse])
  );
  var standardDeviationalEllipseProperties = {
    meanCenterCoordinates: getCoords(meanCenter),
    semiMajorAxis: sigmaX,
    semiMinorAxis: sigmaY,
    numberOfFeatures,
    angle: thetaDeg,
    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures
  };
  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
  return theEllipse;
}
function getDeviations(coordinates, center2) {
  return {
    x: coordinates[0] - center2[0],
    y: coordinates[1] - center2[1]
  };
}
function angle(startPoint, midPoint3, endPoint, options) {
  if (options === void 0) {
    options = {};
  }
  if (!isObject$5(options)) {
    throw new Error("options is invalid");
  }
  if (!startPoint) {
    throw new Error("startPoint is required");
  }
  if (!midPoint3) {
    throw new Error("midPoint is required");
  }
  if (!endPoint) {
    throw new Error("endPoint is required");
  }
  var A = startPoint;
  var O = midPoint3;
  var B2 = endPoint;
  var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));
  var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B2, O) : rhumbBearing(B2, O));
  var angleAO = Math.abs(azimuthAO - azimuthBO);
  if (options.explementary === true) {
    return 360 - angleAO;
  }
  return angleAO;
}
function polygonSmooth(inputPolys, options) {
  var outPolys = [];
  var iterations = options.iterations || 1;
  if (!inputPolys)
    throw new Error("inputPolys is required");
  geomEach(inputPolys, function(geom, geomIndex, properties) {
    var outCoords;
    var poly;
    var tempOutput;
    switch (geom.type) {
      case "Polygon":
        outCoords = [[]];
        for (var i = 0; i < iterations; i++) {
          tempOutput = [[]];
          poly = geom;
          if (i > 0)
            poly = polygon(outCoords).geometry;
          processPolygon(poly, tempOutput);
          outCoords = tempOutput.slice(0);
        }
        outPolys.push(polygon(outCoords, properties));
        break;
      case "MultiPolygon":
        outCoords = [[[]]];
        for (var y2 = 0; y2 < iterations; y2++) {
          tempOutput = [[[]]];
          poly = geom;
          if (y2 > 0)
            poly = multiPolygon(outCoords).geometry;
          processMultiPolygon(poly, tempOutput);
          outCoords = tempOutput.slice(0);
        }
        outPolys.push(multiPolygon(outCoords, properties));
        break;
      default:
        throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
    }
  });
  return featureCollection$1(outPolys);
}
function processPolygon(poly, tempOutput) {
  var prevGeomIndex = 0;
  var subtractCoordIndex = 0;
  coordEach(
    poly,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (geometryIndex > prevGeomIndex) {
        prevGeomIndex = geometryIndex;
        subtractCoordIndex = coordIndex;
        tempOutput.push([]);
      }
      var realCoordIndex = coordIndex - subtractCoordIndex;
      var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];
      var p0x = currentCoord[0];
      var p0y = currentCoord[1];
      var p1x = p1[0];
      var p1y = p1[1];
      tempOutput[geometryIndex].push([
        0.75 * p0x + 0.25 * p1x,
        0.75 * p0y + 0.25 * p1y
      ]);
      tempOutput[geometryIndex].push([
        0.25 * p0x + 0.75 * p1x,
        0.25 * p0y + 0.75 * p1y
      ]);
    },
    true
  );
  tempOutput.forEach(function(ring) {
    ring.push(ring[0]);
  });
}
function processMultiPolygon(poly, tempOutput) {
  var prevGeomIndex = 0;
  var subtractCoordIndex = 0;
  var prevMultiIndex = 0;
  coordEach(
    poly,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (multiFeatureIndex > prevMultiIndex) {
        prevMultiIndex = multiFeatureIndex;
        subtractCoordIndex = coordIndex;
        tempOutput.push([[]]);
      }
      if (geometryIndex > prevGeomIndex) {
        prevGeomIndex = geometryIndex;
        subtractCoordIndex = coordIndex;
        tempOutput[multiFeatureIndex].push([]);
      }
      var realCoordIndex = coordIndex - subtractCoordIndex;
      var p1 = poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];
      var p0x = currentCoord[0];
      var p0y = currentCoord[1];
      var p1x = p1[0];
      var p1y = p1[1];
      tempOutput[multiFeatureIndex][geometryIndex].push([
        0.75 * p0x + 0.25 * p1x,
        0.75 * p0y + 0.25 * p1y
      ]);
      tempOutput[multiFeatureIndex][geometryIndex].push([
        0.25 * p0x + 0.75 * p1x,
        0.25 * p0y + 0.75 * p1y
      ]);
    },
    true
  );
  tempOutput.forEach(function(poly2) {
    poly2.forEach(function(ring) {
      ring.push(ring[0]);
    });
  });
}
function pNormDistance(feature1, feature2, p) {
  if (p === void 0) {
    p = 2;
  }
  var coordinate1 = getCoord(feature1);
  var coordinate2 = getCoord(feature2);
  var xDiff = coordinate1[0] - coordinate2[0];
  var yDiff = coordinate1[1] - coordinate2[1];
  if (p === 1) {
    return Math.abs(xDiff) + Math.abs(yDiff);
  }
  return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
}
function distanceWeight(fc, options) {
  options = options || {};
  var threshold = options.threshold || 1e4;
  var p = options.p || 2;
  var binary = options.binary || false;
  var alpha = options.alpha || -1;
  var rowTransform = options.standardization || false;
  var features2 = [];
  featureEach$1(fc, function(feature2) {
    features2.push(centroid$2(feature2));
  });
  var weights = [];
  for (var i = 0; i < features2.length; i++) {
    weights[i] = [];
  }
  for (var i = 0; i < features2.length; i++) {
    for (var j = i; j < features2.length; j++) {
      if (i === j) {
        weights[i][j] = 0;
      }
      var dis = pNormDistance(features2[i], features2[j], p);
      weights[i][j] = dis;
      weights[j][i] = dis;
    }
  }
  for (var i = 0; i < features2.length; i++) {
    for (var j = 0; j < features2.length; j++) {
      var dis = weights[i][j];
      if (dis === 0) {
        continue;
      }
      if (binary) {
        if (dis <= threshold) {
          weights[i][j] = 1;
        } else {
          weights[i][j] = 0;
        }
      } else {
        if (dis <= threshold) {
          weights[i][j] = Math.pow(dis, alpha);
        } else {
          weights[i][j] = 0;
        }
      }
    }
  }
  if (rowTransform) {
    for (var i = 0; i < features2.length; i++) {
      var rowSum = weights[i].reduce(function(sum2, currentVal) {
        return sum2 + currentVal;
      }, 0);
      for (var j = 0; j < features2.length; j++) {
        weights[i][j] = weights[i][j] / rowSum;
      }
    }
  }
  return weights;
}
function index$4(fc, options) {
  var inputField = options.inputField;
  var threshold = options.threshold || 1e5;
  var p = options.p || 2;
  var binary = options.binary || false;
  var alpha = options.alpha || -1;
  var standardization = options.standardization || true;
  var weight = distanceWeight(fc, {
    alpha,
    binary,
    p,
    standardization,
    threshold
  });
  var y2 = [];
  featureEach$1(fc, function(feature2) {
    var feaProperties = feature2.properties || {};
    y2.push(feaProperties[inputField]);
  });
  var yMean = mean(y2);
  var yVar = variance(y2);
  var weightSum = 0;
  var s0 = 0;
  var s1 = 0;
  var s2 = 0;
  var n = weight.length;
  for (var i = 0; i < n; i++) {
    var subS2 = 0;
    for (var j = 0; j < n; j++) {
      weightSum += weight[i][j] * (y2[i] - yMean) * (y2[j] - yMean);
      s0 += weight[i][j];
      s1 += Math.pow(weight[i][j] + weight[j][i], 2);
      subS2 += weight[i][j] + weight[j][i];
    }
    s2 += Math.pow(subS2, 2);
  }
  s1 = 0.5 * s1;
  var moranIndex = weightSum / s0 / yVar;
  var expectedMoranIndex = -1 / (n - 1);
  var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
  var vDen = (n - 1) * (n + 1) * (s0 * s0);
  var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
  var stdNorm = Math.sqrt(vNorm);
  var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;
  return {
    expectedMoranIndex,
    moranIndex,
    stdNorm,
    zNorm
  };
}
function mean(y2) {
  var sum2 = 0;
  for (var _i = 0, y_1 = y2; _i < y_1.length; _i++) {
    var item = y_1[_i];
    sum2 += item;
  }
  return sum2 / y2.length;
}
function variance(y2) {
  var yMean = mean(y2);
  var sum2 = 0;
  for (var _i = 0, y_2 = y2; _i < y_2.length; _i++) {
    var item = y_2[_i];
    sum2 += Math.pow(item - yMean, 2);
  }
  return sum2 / y2.length;
}
function toMercator(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return convert(geojson, "mercator", options);
}
function toWgs84(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return convert(geojson, "wgs84", options);
}
function convert(geojson, projection2, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (Array.isArray(geojson) && isNumber$2(geojson[0]))
    geojson = projection2 === "mercator" ? convertToMercator(geojson) : convertToWgs84(geojson);
  else {
    if (mutate !== true)
      geojson = clone$5(geojson);
    coordEach(geojson, function(coord) {
      var newCoord = projection2 === "mercator" ? convertToMercator(coord) : convertToWgs84(coord);
      coord[0] = newCoord[0];
      coord[1] = newCoord[1];
    });
  }
  return geojson;
}
function convertToMercator(lonLat) {
  var D2R2 = Math.PI / 180, A = 6378137, MAXEXTENT = 20037508342789244e-9;
  var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
  var xy = [
    A * adjusted * D2R2,
    A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R2))
  ];
  if (xy[0] > MAXEXTENT)
    xy[0] = MAXEXTENT;
  if (xy[0] < -MAXEXTENT)
    xy[0] = -MAXEXTENT;
  if (xy[1] > MAXEXTENT)
    xy[1] = MAXEXTENT;
  if (xy[1] < -MAXEXTENT)
    xy[1] = -MAXEXTENT;
  return xy;
}
function convertToWgs84(xy) {
  var R2D2 = 180 / Math.PI;
  var A = 6378137;
  return [
    xy[0] * R2D2 / A,
    (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D2
  ];
}
function sign(x2) {
  return x2 < 0 ? -1 : x2 > 0 ? 1 : 0;
}
var index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  toMercator,
  toWgs84
}, Symbol.toStringTag, { value: "Module" }));
var __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
function randomPosition(bbox2) {
  if (Array.isArray(bbox2)) {
    return coordInBBox(bbox2);
  }
  if (bbox2 && bbox2.bbox) {
    return coordInBBox(bbox2.bbox);
  }
  return [lon(), lat()];
}
function randomPoint(count3, options) {
  if (options === void 0) {
    options = {};
  }
  if (count3 === void 0 || count3 === null) {
    count3 = 1;
  }
  var features2 = [];
  for (var i = 0; i < count3; i++) {
    features2.push(point(randomPosition(options.bbox)));
  }
  return featureCollection$1(features2);
}
function randomPolygon(count3, options) {
  if (options === void 0) {
    options = {};
  }
  if (count3 === void 0 || count3 === null) {
    count3 = 1;
  }
  if (!isNumber$2(options.num_vertices) || options.num_vertices === void 0) {
    options.num_vertices = 10;
  }
  if (!isNumber$2(options.max_radial_length) || options.max_radial_length === void 0) {
    options.max_radial_length = 10;
  }
  var features2 = [];
  var _loop_1 = function(i2) {
    var vertices = [];
    var circleOffsets = __spreadArrays(Array(options.num_vertices + 1)).map(Math.random);
    circleOffsets.forEach(function(cur, index2, arr) {
      arr[index2] = index2 > 0 ? cur + arr[index2 - 1] : cur;
    });
    circleOffsets.forEach(function(cur) {
      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
      var radialScaler = Math.random();
      vertices.push([
        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
        radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
      ]);
    });
    vertices[vertices.length - 1] = vertices[0];
    vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));
    features2.push(polygon([vertices]));
  };
  for (var i = 0; i < count3; i++) {
    _loop_1();
  }
  return featureCollection$1(features2);
}
function randomLineString(count3, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject$5(options)) {
    throw new Error("options is invalid");
  }
  var bbox2 = options.bbox;
  var num_vertices = options.num_vertices;
  var max_length = options.max_length;
  var max_rotation = options.max_rotation;
  if (count3 === void 0 || count3 === null) {
    count3 = 1;
  }
  if (!isNumber$2(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
    num_vertices = 10;
  }
  if (!isNumber$2(max_length) || max_length === void 0) {
    max_length = 1e-4;
  }
  if (!isNumber$2(max_rotation) || max_rotation === void 0) {
    max_rotation = Math.PI / 8;
  }
  var features2 = [];
  for (var i = 0; i < count3; i++) {
    var startingPoint = randomPosition(bbox2);
    var vertices = [startingPoint];
    for (var j = 0; j < num_vertices - 1; j++) {
      var priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));
      var angle4 = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
      var distance11 = Math.random() * max_length;
      vertices.push([
        vertices[j][0] + distance11 * Math.cos(angle4),
        vertices[j][1] + distance11 * Math.sin(angle4)
      ]);
    }
    features2.push(lineString(vertices));
  }
  return featureCollection$1(features2);
}
function vertexToCoordinate(hub) {
  return function(cur) {
    return [cur[0] + hub[0], cur[1] + hub[1]];
  };
}
function rnd() {
  return Math.random() - 0.5;
}
function lon() {
  return rnd() * 360;
}
function lat() {
  return rnd() * 180;
}
function coordInBBox(bbox2) {
  return [
    Math.random() * (bbox2[2] - bbox2[0]) + bbox2[0],
    Math.random() * (bbox2[3] - bbox2[1]) + bbox2[1]
  ];
}
var index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomPosition,
  randomPoint,
  randomPolygon,
  randomLineString
}, Symbol.toStringTag, { value: "Module" }));
function getCluster(geojson, filter18) {
  if (!geojson)
    throw new Error("geojson is required");
  if (geojson.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (filter18 === void 0 || filter18 === null)
    throw new Error("filter is required");
  var features2 = [];
  featureEach$1(geojson, function(feature2) {
    if (applyFilter(feature2.properties, filter18))
      features2.push(feature2);
  });
  return featureCollection$1(features2);
}
function clusterEach(geojson, property, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  if (geojson.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (property === void 0 || property === null)
    throw new Error("property is required");
  var bins = createBins(geojson, property);
  var values3 = Object.keys(bins);
  for (var index2 = 0; index2 < values3.length; index2++) {
    var value = values3[index2];
    var bin = bins[value];
    var features2 = [];
    for (var i = 0; i < bin.length; i++) {
      features2.push(geojson.features[bin[i]]);
    }
    callback(featureCollection$1(features2), value, index2);
  }
}
function clusterReduce(geojson, property, callback, initialValue) {
  var previousValue = initialValue;
  clusterEach(geojson, property, function(cluster, clusterValue, currentIndex) {
    if (currentIndex === 0 && initialValue === void 0)
      previousValue = cluster;
    else
      previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
  });
  return previousValue;
}
function createBins(geojson, property) {
  var bins = {};
  featureEach$1(geojson, function(feature2, i) {
    var properties = feature2.properties || {};
    if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
      var value = properties[property];
      if (Object.prototype.hasOwnProperty.call(bins, value))
        bins[value].push(i);
      else
        bins[value] = [i];
    }
  });
  return bins;
}
function applyFilter(properties, filter18) {
  if (properties === void 0)
    return false;
  var filterType = typeof filter18;
  if (filterType === "number" || filterType === "string")
    return Object.prototype.hasOwnProperty.call(properties, filter18);
  else if (Array.isArray(filter18)) {
    for (var i = 0; i < filter18.length; i++) {
      if (!applyFilter(properties, filter18[i]))
        return false;
    }
    return true;
  } else {
    return propertiesContainsFilter(properties, filter18);
  }
}
function propertiesContainsFilter(properties, filter18) {
  var keys3 = Object.keys(filter18);
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (properties[key] !== filter18[key])
      return false;
  }
  return true;
}
function filterProperties(properties, keys3) {
  if (!keys3)
    return {};
  if (!keys3.length)
    return {};
  var newProperties = {};
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (Object.prototype.hasOwnProperty.call(properties, key))
      newProperties[key] = properties[key];
  }
  return newProperties;
}
var index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getCluster,
  clusterEach,
  clusterReduce,
  createBins,
  applyFilter,
  propertiesContainsFilter,
  filterProperties
}, Symbol.toStringTag, { value: "Module" }));
/**
 * splaytree v3.1.1
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
          return t;
        if (y2 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var Node$1 = function() {
  function Node4(key, data) {
    this.next = null;
    this.key = key;
    this.data = data;
    this.left = null;
    this.right = null;
  }
  return Node4;
}();
function DEFAULT_COMPARE(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function splay(i, t, comparator) {
  var N = new Node$1(null, null);
  var l = N;
  var r = N;
  while (true) {
    var cmp3 = comparator(i, t.key);
    if (cmp3 < 0) {
      if (t.left === null)
        break;
      if (comparator(i, t.left.key) < 0) {
        var y2 = t.left;
        t.left = y2.right;
        y2.right = t;
        t = y2;
        if (t.left === null)
          break;
      }
      r.left = t;
      r = t;
      t = t.left;
    } else if (cmp3 > 0) {
      if (t.right === null)
        break;
      if (comparator(i, t.right.key) > 0) {
        var y2 = t.right;
        t.right = y2.left;
        y2.left = t;
        t = y2;
        if (t.right === null)
          break;
      }
      l.right = t;
      l = t;
      t = t.right;
    } else
      break;
  }
  l.right = t.left;
  r.left = t.right;
  t.left = N.right;
  t.right = N.left;
  return t;
}
function insert(i, data, t, comparator) {
  var node = new Node$1(i, data);
  if (t === null) {
    node.left = node.right = null;
    return node;
  }
  t = splay(i, t, comparator);
  var cmp3 = comparator(i, t.key);
  if (cmp3 < 0) {
    node.left = t.left;
    node.right = t;
    t.left = null;
  } else if (cmp3 >= 0) {
    node.right = t.right;
    node.left = t;
    t.right = null;
  }
  return node;
}
function split$1(key, v, comparator) {
  var left = null;
  var right = null;
  if (v) {
    v = splay(key, v, comparator);
    var cmp3 = comparator(v.key, key);
    if (cmp3 === 0) {
      left = v.left;
      right = v.right;
    } else if (cmp3 < 0) {
      right = v.right;
      v.right = null;
      left = v;
    } else {
      left = v.left;
      v.left = null;
      right = v;
    }
  }
  return { left, right };
}
function merge$3(left, right, comparator) {
  if (right === null)
    return left;
  if (left === null)
    return right;
  right = splay(left.key, right, comparator);
  right.left = left;
  return right;
}
function printRow(root, prefix, isTail, out2, printNode2) {
  if (root) {
    out2("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode2(root) + "\n");
    var indent = prefix + (isTail ? "    " : "\u2502   ");
    if (root.left)
      printRow(root.left, indent, false, out2, printNode2);
    if (root.right)
      printRow(root.right, indent, true, out2, printNode2);
  }
}
var Tree$2 = function() {
  function Tree2(comparator) {
    if (comparator === void 0) {
      comparator = DEFAULT_COMPARE;
    }
    this._root = null;
    this._size = 0;
    this._comparator = comparator;
  }
  Tree2.prototype.insert = function(key, data) {
    this._size++;
    return this._root = insert(key, data, this._root, this._comparator);
  };
  Tree2.prototype.add = function(key, data) {
    var node = new Node$1(key, data);
    if (this._root === null) {
      node.left = node.right = null;
      this._size++;
      this._root = node;
    }
    var comparator = this._comparator;
    var t = splay(key, this._root, comparator);
    var cmp3 = comparator(key, t.key);
    if (cmp3 === 0)
      this._root = t;
    else {
      if (cmp3 < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
      } else if (cmp3 > 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
      }
      this._size++;
      this._root = node;
    }
    return this._root;
  };
  Tree2.prototype.remove = function(key) {
    this._root = this._remove(key, this._root, this._comparator);
  };
  Tree2.prototype._remove = function(i, t, comparator) {
    var x2;
    if (t === null)
      return null;
    t = splay(i, t, comparator);
    var cmp3 = comparator(i, t.key);
    if (cmp3 === 0) {
      if (t.left === null) {
        x2 = t.right;
      } else {
        x2 = splay(i, t.left, comparator);
        x2.right = t.right;
      }
      this._size--;
      return x2;
    }
    return t;
  };
  Tree2.prototype.pop = function() {
    var node = this._root;
    if (node) {
      while (node.left)
        node = node.left;
      this._root = splay(node.key, this._root, this._comparator);
      this._root = this._remove(node.key, this._root, this._comparator);
      return { key: node.key, data: node.data };
    }
    return null;
  };
  Tree2.prototype.findStatic = function(key) {
    var current = this._root;
    var compare11 = this._comparator;
    while (current) {
      var cmp3 = compare11(key, current.key);
      if (cmp3 === 0)
        return current;
      else if (cmp3 < 0)
        current = current.left;
      else
        current = current.right;
    }
    return null;
  };
  Tree2.prototype.find = function(key) {
    if (this._root) {
      this._root = splay(key, this._root, this._comparator);
      if (this._comparator(key, this._root.key) !== 0)
        return null;
    }
    return this._root;
  };
  Tree2.prototype.contains = function(key) {
    var current = this._root;
    var compare11 = this._comparator;
    while (current) {
      var cmp3 = compare11(key, current.key);
      if (cmp3 === 0)
        return true;
      else if (cmp3 < 0)
        current = current.left;
      else
        current = current.right;
    }
    return false;
  };
  Tree2.prototype.forEach = function(visitor, ctx) {
    var current = this._root;
    var Q = [];
    var done = false;
    while (!done) {
      if (current !== null) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length !== 0) {
          current = Q.pop();
          visitor.call(ctx, current);
          current = current.right;
        } else
          done = true;
      }
    }
    return this;
  };
  Tree2.prototype.range = function(low, high, fn, ctx) {
    var Q = [];
    var compare11 = this._comparator;
    var node = this._root;
    var cmp3;
    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp3 = compare11(node.key, high);
        if (cmp3 > 0) {
          break;
        } else if (compare11(node.key, low) >= 0) {
          if (fn.call(ctx, node))
            return this;
        }
        node = node.right;
      }
    }
    return this;
  };
  Tree2.prototype.keys = function() {
    var keys3 = [];
    this.forEach(function(_a2) {
      var key = _a2.key;
      return keys3.push(key);
    });
    return keys3;
  };
  Tree2.prototype.values = function() {
    var values3 = [];
    this.forEach(function(_a2) {
      var data = _a2.data;
      return values3.push(data);
    });
    return values3;
  };
  Tree2.prototype.min = function() {
    if (this._root)
      return this.minNode(this._root).key;
    return null;
  };
  Tree2.prototype.max = function() {
    if (this._root)
      return this.maxNode(this._root).key;
    return null;
  };
  Tree2.prototype.minNode = function(t) {
    if (t === void 0) {
      t = this._root;
    }
    if (t)
      while (t.left)
        t = t.left;
    return t;
  };
  Tree2.prototype.maxNode = function(t) {
    if (t === void 0) {
      t = this._root;
    }
    if (t)
      while (t.right)
        t = t.right;
    return t;
  };
  Tree2.prototype.at = function(index2) {
    var current = this._root;
    var done = false;
    var i = 0;
    var Q = [];
    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = Q.pop();
          if (i === index2)
            return current;
          i++;
          current = current.right;
        } else
          done = true;
      }
    }
    return null;
  };
  Tree2.prototype.next = function(d) {
    var root = this._root;
    var successor = null;
    if (d.right) {
      successor = d.right;
      while (successor.left)
        successor = successor.left;
      return successor;
    }
    var comparator = this._comparator;
    while (root) {
      var cmp3 = comparator(d.key, root.key);
      if (cmp3 === 0)
        break;
      else if (cmp3 < 0) {
        successor = root;
        root = root.left;
      } else
        root = root.right;
    }
    return successor;
  };
  Tree2.prototype.prev = function(d) {
    var root = this._root;
    var predecessor = null;
    if (d.left !== null) {
      predecessor = d.left;
      while (predecessor.right)
        predecessor = predecessor.right;
      return predecessor;
    }
    var comparator = this._comparator;
    while (root) {
      var cmp3 = comparator(d.key, root.key);
      if (cmp3 === 0)
        break;
      else if (cmp3 < 0)
        root = root.left;
      else {
        predecessor = root;
        root = root.right;
      }
    }
    return predecessor;
  };
  Tree2.prototype.clear = function() {
    this._root = null;
    this._size = 0;
    return this;
  };
  Tree2.prototype.toList = function() {
    return toList(this._root);
  };
  Tree2.prototype.load = function(keys3, values3, presort) {
    if (values3 === void 0) {
      values3 = [];
    }
    if (presort === void 0) {
      presort = false;
    }
    var size11 = keys3.length;
    var comparator = this._comparator;
    if (presort)
      sort$3(keys3, values3, 0, size11 - 1, comparator);
    if (this._root === null) {
      this._root = loadRecursive(keys3, values3, 0, size11);
      this._size = size11;
    } else {
      var mergedList = mergeLists(this.toList(), createList$2(keys3, values3), comparator);
      size11 = this._size + size11;
      this._root = sortedListToBST({ head: mergedList }, 0, size11);
    }
    return this;
  };
  Tree2.prototype.isEmpty = function() {
    return this._root === null;
  };
  Object.defineProperty(Tree2.prototype, "size", {
    get: function() {
      return this._size;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Tree2.prototype, "root", {
    get: function() {
      return this._root;
    },
    enumerable: true,
    configurable: true
  });
  Tree2.prototype.toString = function(printNode2) {
    if (printNode2 === void 0) {
      printNode2 = function(n) {
        return String(n.key);
      };
    }
    var out2 = [];
    printRow(this._root, "", true, function(v) {
      return out2.push(v);
    }, printNode2);
    return out2.join("");
  };
  Tree2.prototype.update = function(key, newKey, newData) {
    var comparator = this._comparator;
    var _a2 = split$1(key, this._root, comparator), left = _a2.left, right = _a2.right;
    if (comparator(key, newKey) < 0) {
      right = insert(newKey, newData, right, comparator);
    } else {
      left = insert(newKey, newData, left, comparator);
    }
    this._root = merge$3(left, right, comparator);
  };
  Tree2.prototype.split = function(key) {
    return split$1(key, this._root, this._comparator);
  };
  Tree2.prototype[Symbol.iterator] = function() {
    var n;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          n = this.minNode();
          _a2.label = 1;
        case 1:
          if (!n)
            return [3, 3];
          return [4, n];
        case 2:
          _a2.sent();
          n = this.next(n);
          return [3, 1];
        case 3:
          return [2];
      }
    });
  };
  return Tree2;
}();
function loadRecursive(keys3, values3, start2, end2) {
  var size11 = end2 - start2;
  if (size11 > 0) {
    var middle = start2 + Math.floor(size11 / 2);
    var key = keys3[middle];
    var data = values3[middle];
    var node = new Node$1(key, data);
    node.left = loadRecursive(keys3, values3, start2, middle);
    node.right = loadRecursive(keys3, values3, middle + 1, end2);
    return node;
  }
  return null;
}
function createList$2(keys3, values3) {
  var head = new Node$1(null, null);
  var p = head;
  for (var i = 0; i < keys3.length; i++) {
    p = p.next = new Node$1(keys3[i], values3[i]);
  }
  p.next = null;
  return head.next;
}
function toList(root) {
  var current = root;
  var Q = [];
  var done = false;
  var head = new Node$1(null, null);
  var p = head;
  while (!done) {
    if (current) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length > 0) {
        current = p = p.next = Q.pop();
        current = current.right;
      } else
        done = true;
    }
  }
  p.next = null;
  return head.next;
}
function sortedListToBST(list, start2, end2) {
  var size11 = end2 - start2;
  if (size11 > 0) {
    var middle = start2 + Math.floor(size11 / 2);
    var left = sortedListToBST(list, start2, middle);
    var root = list.head;
    root.left = left;
    list.head = list.head.next;
    root.right = sortedListToBST(list, middle + 1, end2);
    return root;
  }
  return null;
}
function mergeLists(l1, l2, compare11) {
  var head = new Node$1(null, null);
  var p = head;
  var p1 = l1;
  var p2 = l2;
  while (p1 !== null && p2 !== null) {
    if (compare11(p1.key, p2.key) < 0) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  if (p1 !== null) {
    p.next = p1;
  } else if (p2 !== null) {
    p.next = p2;
  }
  return head.next;
}
function sort$3(keys3, values3, left, right, compare11) {
  if (left >= right)
    return;
  var pivot = keys3[left + right >> 1];
  var i = left - 1;
  var j = right + 1;
  while (true) {
    do
      i++;
    while (compare11(keys3[i], pivot) < 0);
    do
      j--;
    while (compare11(keys3[j], pivot) > 0);
    if (i >= j)
      break;
    var tmp = keys3[i];
    keys3[i] = keys3[j];
    keys3[j] = tmp;
    tmp = values3[i];
    values3[i] = values3[j];
    values3[j] = tmp;
  }
  sort$3(keys3, values3, left, j, compare11);
  sort$3(keys3, values3, j + 1, right, compare11);
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var isInBbox = function isInBbox2(bbox2, point4) {
  return bbox2.ll.x <= point4.x && point4.x <= bbox2.ur.x && bbox2.ll.y <= point4.y && point4.y <= bbox2.ur.y;
};
var getBboxOverlap = function getBboxOverlap2(b1, b2) {
  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
    return null;
  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
  return {
    ll: {
      x: lowerX,
      y: lowerY
    },
    ur: {
      x: upperX,
      y: upperY
    }
  };
};
var epsilon$1 = Number.EPSILON;
if (epsilon$1 === void 0)
  epsilon$1 = Math.pow(2, -52);
var EPSILON_SQ = epsilon$1 * epsilon$1;
var cmp = function cmp2(a, b) {
  if (-epsilon$1 < a && a < epsilon$1) {
    if (-epsilon$1 < b && b < epsilon$1) {
      return 0;
    }
  }
  var ab2 = a - b;
  if (ab2 * ab2 < EPSILON_SQ * a * b) {
    return 0;
  }
  return a < b ? -1 : 1;
};
var PtRounder = /* @__PURE__ */ function() {
  function PtRounder2() {
    _classCallCheck(this, PtRounder2);
    this.reset();
  }
  _createClass(PtRounder2, [{
    key: "reset",
    value: function reset() {
      this.xRounder = new CoordRounder();
      this.yRounder = new CoordRounder();
    }
  }, {
    key: "round",
    value: function round2(x2, y2) {
      return {
        x: this.xRounder.round(x2),
        y: this.yRounder.round(y2)
      };
    }
  }]);
  return PtRounder2;
}();
var CoordRounder = /* @__PURE__ */ function() {
  function CoordRounder2() {
    _classCallCheck(this, CoordRounder2);
    this.tree = new Tree$2();
    this.round(0);
  }
  _createClass(CoordRounder2, [{
    key: "round",
    value: function round2(coord) {
      var node = this.tree.add(coord);
      var prevNode = this.tree.prev(node);
      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
        this.tree.remove(coord);
        return prevNode.key;
      }
      var nextNode = this.tree.next(node);
      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
        this.tree.remove(coord);
        return nextNode.key;
      }
      return coord;
    }
  }]);
  return CoordRounder2;
}();
var rounder = new PtRounder();
var crossProduct = function crossProduct2(a, b) {
  return a.x * b.y - a.y * b.x;
};
var dotProduct = function dotProduct2(a, b) {
  return a.x * b.x + a.y * b.y;
};
var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
  var v12 = {
    x: endPt1.x - basePt.x,
    y: endPt1.y - basePt.y
  };
  var v22 = {
    x: endPt2.x - basePt.x,
    y: endPt2.y - basePt.y
  };
  var kross = crossProduct(v12, v22);
  return cmp(kross, 0);
};
var length = function length2(v) {
  return Math.sqrt(dotProduct(v, v));
};
var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
  var vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  var vAngle2 = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return crossProduct(vAngle2, vBase) / length(vAngle2) / length(vBase);
};
var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
  var vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  var vAngle2 = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return dotProduct(vAngle2, vBase) / length(vAngle2) / length(vBase);
};
var horizontalIntersection = function horizontalIntersection2(pt, v, y2) {
  if (v.y === 0)
    return null;
  return {
    x: pt.x + v.x / v.y * (y2 - pt.y),
    y: y2
  };
};
var verticalIntersection = function verticalIntersection2(pt, v, x2) {
  if (v.x === 0)
    return null;
  return {
    x: x2,
    y: pt.y + v.y / v.x * (x2 - pt.x)
  };
};
var intersection = function intersection2(pt12, v12, pt22, v22) {
  if (v12.x === 0)
    return verticalIntersection(pt22, v22, pt12.x);
  if (v22.x === 0)
    return verticalIntersection(pt12, v12, pt22.x);
  if (v12.y === 0)
    return horizontalIntersection(pt22, v22, pt12.y);
  if (v22.y === 0)
    return horizontalIntersection(pt12, v12, pt22.y);
  var kross = crossProduct(v12, v22);
  if (kross == 0)
    return null;
  var ve = {
    x: pt22.x - pt12.x,
    y: pt22.y - pt12.y
  };
  var d1 = crossProduct(ve, v12) / kross;
  var d2 = crossProduct(ve, v22) / kross;
  var x12 = pt12.x + d2 * v12.x, x2 = pt22.x + d1 * v22.x;
  var y12 = pt12.y + d2 * v12.y, y2 = pt22.y + d1 * v22.y;
  var x3 = (x12 + x2) / 2;
  var y3 = (y12 + y2) / 2;
  return {
    x: x3,
    y: y3
  };
};
var SweepEvent = /* @__PURE__ */ function() {
  _createClass(SweepEvent2, null, [{
    key: "compare",
    value: function compare11(a, b) {
      var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
      if (ptCmp !== 0)
        return ptCmp;
      if (a.point !== b.point)
        a.link(b);
      if (a.isLeft !== b.isLeft)
        return a.isLeft ? 1 : -1;
      return Segment.compare(a.segment, b.segment);
    }
  }, {
    key: "comparePoints",
    value: function comparePoints(aPt, bPt) {
      if (aPt.x < bPt.x)
        return -1;
      if (aPt.x > bPt.x)
        return 1;
      if (aPt.y < bPt.y)
        return -1;
      if (aPt.y > bPt.y)
        return 1;
      return 0;
    }
  }]);
  function SweepEvent2(point4, isLeft2) {
    _classCallCheck(this, SweepEvent2);
    if (point4.events === void 0)
      point4.events = [this];
    else
      point4.events.push(this);
    this.point = point4;
    this.isLeft = isLeft2;
  }
  _createClass(SweepEvent2, [{
    key: "link",
    value: function link2(other) {
      if (other.point === this.point) {
        throw new Error("Tried to link already linked events");
      }
      var otherEvents = other.point.events;
      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
        var evt = otherEvents[i];
        this.point.events.push(evt);
        evt.point = this.point;
      }
      this.checkForConsuming();
    }
  }, {
    key: "checkForConsuming",
    value: function checkForConsuming() {
      var numEvents = this.point.events.length;
      for (var i = 0; i < numEvents; i++) {
        var evt1 = this.point.events[i];
        if (evt1.segment.consumedBy !== void 0)
          continue;
        for (var j = i + 1; j < numEvents; j++) {
          var evt2 = this.point.events[j];
          if (evt2.consumedBy !== void 0)
            continue;
          if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
            continue;
          evt1.segment.consume(evt2.segment);
        }
      }
    }
  }, {
    key: "getAvailableLinkedEvents",
    value: function getAvailableLinkedEvents() {
      var events = [];
      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
        var evt = this.point.events[i];
        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
          events.push(evt);
        }
      }
      return events;
    }
  }, {
    key: "getLeftmostComparator",
    value: function getLeftmostComparator(baseEvent) {
      var _this = this;
      var cache = /* @__PURE__ */ new Map();
      var fillCache = function fillCache2(linkedEvent) {
        var nextEvent = linkedEvent.otherSE;
        cache.set(linkedEvent, {
          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
        });
      };
      return function(a, b) {
        if (!cache.has(a))
          fillCache(a);
        if (!cache.has(b))
          fillCache(b);
        var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
        var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
        if (asine >= 0 && bsine >= 0) {
          if (acosine < bcosine)
            return 1;
          if (acosine > bcosine)
            return -1;
          return 0;
        }
        if (asine < 0 && bsine < 0) {
          if (acosine < bcosine)
            return -1;
          if (acosine > bcosine)
            return 1;
          return 0;
        }
        if (bsine < asine)
          return -1;
        if (bsine > asine)
          return 1;
        return 0;
      };
    }
  }]);
  return SweepEvent2;
}();
var segmentId = 0;
var Segment = /* @__PURE__ */ function() {
  _createClass(Segment2, null, [{
    key: "compare",
    value: function compare11(a, b) {
      var alx = a.leftSE.point.x;
      var blx = b.leftSE.point.x;
      var arx = a.rightSE.point.x;
      var brx = b.rightSE.point.x;
      if (brx < alx)
        return 1;
      if (arx < blx)
        return -1;
      var aly = a.leftSE.point.y;
      var bly = b.leftSE.point.y;
      var ary = a.rightSE.point.y;
      var bry = b.rightSE.point.y;
      if (alx < blx) {
        if (bly < aly && bly < ary)
          return 1;
        if (bly > aly && bly > ary)
          return -1;
        var aCmpBLeft = a.comparePoint(b.leftSE.point);
        if (aCmpBLeft < 0)
          return 1;
        if (aCmpBLeft > 0)
          return -1;
        var bCmpARight = b.comparePoint(a.rightSE.point);
        if (bCmpARight !== 0)
          return bCmpARight;
        return -1;
      }
      if (alx > blx) {
        if (aly < bly && aly < bry)
          return -1;
        if (aly > bly && aly > bry)
          return 1;
        var bCmpALeft = b.comparePoint(a.leftSE.point);
        if (bCmpALeft !== 0)
          return bCmpALeft;
        var aCmpBRight = a.comparePoint(b.rightSE.point);
        if (aCmpBRight < 0)
          return 1;
        if (aCmpBRight > 0)
          return -1;
        return 1;
      }
      if (aly < bly)
        return -1;
      if (aly > bly)
        return 1;
      if (arx < brx) {
        var _bCmpARight = b.comparePoint(a.rightSE.point);
        if (_bCmpARight !== 0)
          return _bCmpARight;
      }
      if (arx > brx) {
        var _aCmpBRight = a.comparePoint(b.rightSE.point);
        if (_aCmpBRight < 0)
          return 1;
        if (_aCmpBRight > 0)
          return -1;
      }
      if (arx !== brx) {
        var ay = ary - aly;
        var ax = arx - alx;
        var by = bry - bly;
        var bx = brx - blx;
        if (ay > ax && by < bx)
          return 1;
        if (ay < ax && by > bx)
          return -1;
      }
      if (arx > brx)
        return 1;
      if (arx < brx)
        return -1;
      if (ary < bry)
        return -1;
      if (ary > bry)
        return 1;
      if (a.id < b.id)
        return -1;
      if (a.id > b.id)
        return 1;
      return 0;
    }
  }]);
  function Segment2(leftSE, rightSE, rings, windings) {
    _classCallCheck(this, Segment2);
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  _createClass(Segment2, [{
    key: "replaceRightSE",
    value: function replaceRightSE(newRightSE) {
      this.rightSE = newRightSE;
      this.rightSE.segment = this;
      this.rightSE.otherSE = this.leftSE;
      this.leftSE.otherSE = this.rightSE;
    }
  }, {
    key: "bbox",
    value: function bbox2() {
      var y12 = this.leftSE.point.y;
      var y2 = this.rightSE.point.y;
      return {
        ll: {
          x: this.leftSE.point.x,
          y: y12 < y2 ? y12 : y2
        },
        ur: {
          x: this.rightSE.point.x,
          y: y12 > y2 ? y12 : y2
        }
      };
    }
  }, {
    key: "vector",
    value: function vector() {
      return {
        x: this.rightSE.point.x - this.leftSE.point.x,
        y: this.rightSE.point.y - this.leftSE.point.y
      };
    }
  }, {
    key: "isAnEndpoint",
    value: function isAnEndpoint(pt) {
      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
    }
  }, {
    key: "comparePoint",
    value: function comparePoint(point4) {
      if (this.isAnEndpoint(point4))
        return 0;
      var lPt = this.leftSE.point;
      var rPt = this.rightSE.point;
      var v = this.vector();
      if (lPt.x === rPt.x) {
        if (point4.x === lPt.x)
          return 0;
        return point4.x < lPt.x ? 1 : -1;
      }
      var yDist = (point4.y - lPt.y) / v.y;
      var xFromYDist = lPt.x + yDist * v.x;
      if (point4.x === xFromYDist)
        return 0;
      var xDist = (point4.x - lPt.x) / v.x;
      var yFromXDist = lPt.y + xDist * v.y;
      if (point4.y === yFromXDist)
        return 0;
      return point4.y < yFromXDist ? -1 : 1;
    }
  }, {
    key: "getIntersection",
    value: function getIntersection2(other) {
      var tBbox = this.bbox();
      var oBbox = other.bbox();
      var bboxOverlap = getBboxOverlap(tBbox, oBbox);
      if (bboxOverlap === null)
        return null;
      var tlp = this.leftSE.point;
      var trp = this.rightSE.point;
      var olp = other.leftSE.point;
      var orp = other.rightSE.point;
      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
      if (touchesThisLSE && touchesOtherLSE) {
        if (touchesThisRSE && !touchesOtherRSE)
          return trp;
        if (!touchesThisRSE && touchesOtherRSE)
          return orp;
        return null;
      }
      if (touchesThisLSE) {
        if (touchesOtherRSE) {
          if (tlp.x === orp.x && tlp.y === orp.y)
            return null;
        }
        return tlp;
      }
      if (touchesOtherLSE) {
        if (touchesThisRSE) {
          if (trp.x === olp.x && trp.y === olp.y)
            return null;
        }
        return olp;
      }
      if (touchesThisRSE && touchesOtherRSE)
        return null;
      if (touchesThisRSE)
        return trp;
      if (touchesOtherRSE)
        return orp;
      var pt = intersection(tlp, this.vector(), olp, other.vector());
      if (pt === null)
        return null;
      if (!isInBbox(bboxOverlap, pt))
        return null;
      return rounder.round(pt.x, pt.y);
    }
  }, {
    key: "split",
    value: function split3(point4) {
      var newEvents = [];
      var alreadyLinked = point4.events !== void 0;
      var newLeftSE = new SweepEvent(point4, true);
      var newRightSE = new SweepEvent(point4, false);
      var oldRightSE = this.rightSE;
      this.replaceRightSE(newRightSE);
      newEvents.push(newRightSE);
      newEvents.push(newLeftSE);
      var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
        newSeg.swapEvents();
      }
      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
        this.swapEvents();
      }
      if (alreadyLinked) {
        newLeftSE.checkForConsuming();
        newRightSE.checkForConsuming();
      }
      return newEvents;
    }
  }, {
    key: "swapEvents",
    value: function swapEvents() {
      var tmpEvt = this.rightSE;
      this.rightSE = this.leftSE;
      this.leftSE = tmpEvt;
      this.leftSE.isLeft = true;
      this.rightSE.isLeft = false;
      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
        this.windings[i] *= -1;
      }
    }
  }, {
    key: "consume",
    value: function consume(other) {
      var consumer = this;
      var consumee = other;
      while (consumer.consumedBy) {
        consumer = consumer.consumedBy;
      }
      while (consumee.consumedBy) {
        consumee = consumee.consumedBy;
      }
      var cmp3 = Segment2.compare(consumer, consumee);
      if (cmp3 === 0)
        return;
      if (cmp3 > 0) {
        var tmp = consumer;
        consumer = consumee;
        consumee = tmp;
      }
      if (consumer.prev === consumee) {
        var _tmp = consumer;
        consumer = consumee;
        consumee = _tmp;
      }
      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
        var ring = consumee.rings[i];
        var winding = consumee.windings[i];
        var index2 = consumer.rings.indexOf(ring);
        if (index2 === -1) {
          consumer.rings.push(ring);
          consumer.windings.push(winding);
        } else
          consumer.windings[index2] += winding;
      }
      consumee.rings = null;
      consumee.windings = null;
      consumee.consumedBy = consumer;
      consumee.leftSE.consumedBy = consumer.leftSE;
      consumee.rightSE.consumedBy = consumer.rightSE;
    }
  }, {
    key: "prevInResult",
    value: function prevInResult() {
      if (this._prevInResult !== void 0)
        return this._prevInResult;
      if (!this.prev)
        this._prevInResult = null;
      else if (this.prev.isInResult())
        this._prevInResult = this.prev;
      else
        this._prevInResult = this.prev.prevInResult();
      return this._prevInResult;
    }
  }, {
    key: "beforeState",
    value: function beforeState() {
      if (this._beforeState !== void 0)
        return this._beforeState;
      if (!this.prev)
        this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };
      else {
        var seg = this.prev.consumedBy || this.prev;
        this._beforeState = seg.afterState();
      }
      return this._beforeState;
    }
  }, {
    key: "afterState",
    value: function afterState() {
      if (this._afterState !== void 0)
        return this._afterState;
      var beforeState = this.beforeState();
      this._afterState = {
        rings: beforeState.rings.slice(0),
        windings: beforeState.windings.slice(0),
        multiPolys: []
      };
      var ringsAfter = this._afterState.rings;
      var windingsAfter = this._afterState.windings;
      var mpsAfter = this._afterState.multiPolys;
      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
        var ring = this.rings[i];
        var winding = this.windings[i];
        var index2 = ringsAfter.indexOf(ring);
        if (index2 === -1) {
          ringsAfter.push(ring);
          windingsAfter.push(winding);
        } else
          windingsAfter[index2] += winding;
      }
      var polysAfter = [];
      var polysExclude = [];
      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
        if (windingsAfter[_i] === 0)
          continue;
        var _ring = ringsAfter[_i];
        var poly = _ring.poly;
        if (polysExclude.indexOf(poly) !== -1)
          continue;
        if (_ring.isExterior)
          polysAfter.push(poly);
        else {
          if (polysExclude.indexOf(poly) === -1)
            polysExclude.push(poly);
          var _index = polysAfter.indexOf(_ring.poly);
          if (_index !== -1)
            polysAfter.splice(_index, 1);
        }
      }
      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
        var mp = polysAfter[_i2].multiPoly;
        if (mpsAfter.indexOf(mp) === -1)
          mpsAfter.push(mp);
      }
      return this._afterState;
    }
  }, {
    key: "isInResult",
    value: function isInResult2() {
      if (this.consumedBy)
        return false;
      if (this._isInResult !== void 0)
        return this._isInResult;
      var mpsBefore = this.beforeState().multiPolys;
      var mpsAfter = this.afterState().multiPolys;
      switch (operation.type) {
        case "union": {
          var noBefores = mpsBefore.length === 0;
          var noAfters = mpsAfter.length === 0;
          this._isInResult = noBefores !== noAfters;
          break;
        }
        case "intersection": {
          var least;
          var most;
          if (mpsBefore.length < mpsAfter.length) {
            least = mpsBefore.length;
            most = mpsAfter.length;
          } else {
            least = mpsAfter.length;
            most = mpsBefore.length;
          }
          this._isInResult = most === operation.numMultiPolys && least < most;
          break;
        }
        case "xor": {
          var diff2 = Math.abs(mpsBefore.length - mpsAfter.length);
          this._isInResult = diff2 % 2 === 1;
          break;
        }
        case "difference": {
          var isJustSubject = function isJustSubject2(mps) {
            return mps.length === 1 && mps[0].isSubject;
          };
          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
          break;
        }
        default:
          throw new Error("Unrecognized operation type found ".concat(operation.type));
      }
      return this._isInResult;
    }
  }], [{
    key: "fromRing",
    value: function fromRing(pt12, pt22, ring) {
      var leftPt, rightPt, winding;
      var cmpPts = SweepEvent.comparePoints(pt12, pt22);
      if (cmpPts < 0) {
        leftPt = pt12;
        rightPt = pt22;
        winding = 1;
      } else if (cmpPts > 0) {
        leftPt = pt22;
        rightPt = pt12;
        winding = -1;
      } else
        throw new Error("Tried to create degenerate segment at [".concat(pt12.x, ", ").concat(pt12.y, "]"));
      var leftSE = new SweepEvent(leftPt, true);
      var rightSE = new SweepEvent(rightPt, false);
      return new Segment2(leftSE, rightSE, [ring], [winding]);
    }
  }]);
  return Segment2;
}();
var RingIn = /* @__PURE__ */ function() {
  function RingIn2(geomRing, poly, isExterior) {
    _classCallCheck(this, RingIn2);
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
    this.bbox = {
      ll: {
        x: firstPoint.x,
        y: firstPoint.y
      },
      ur: {
        x: firstPoint.x,
        y: firstPoint.y
      }
    };
    var prevPoint = firstPoint;
    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      var point4 = rounder.round(geomRing[i][0], geomRing[i][1]);
      if (point4.x === prevPoint.x && point4.y === prevPoint.y)
        continue;
      this.segments.push(Segment.fromRing(prevPoint, point4, this));
      if (point4.x < this.bbox.ll.x)
        this.bbox.ll.x = point4.x;
      if (point4.y < this.bbox.ll.y)
        this.bbox.ll.y = point4.y;
      if (point4.x > this.bbox.ur.x)
        this.bbox.ur.x = point4.x;
      if (point4.y > this.bbox.ur.y)
        this.bbox.ur.y = point4.y;
      prevPoint = point4;
    }
    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
    }
  }
  _createClass(RingIn2, [{
    key: "getSweepEvents",
    value: function getSweepEvents() {
      var sweepEvents = [];
      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
        var segment = this.segments[i];
        sweepEvents.push(segment.leftSE);
        sweepEvents.push(segment.rightSE);
      }
      return sweepEvents;
    }
  }]);
  return RingIn2;
}();
var PolyIn = /* @__PURE__ */ function() {
  function PolyIn2(geomPoly, multiPoly) {
    _classCallCheck(this, PolyIn2);
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    };
    this.interiorRings = [];
    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
      var ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x < this.bbox.ll.x)
        this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y < this.bbox.ll.y)
        this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x > this.bbox.ur.x)
        this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y > this.bbox.ur.y)
        this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  _createClass(PolyIn2, [{
    key: "getSweepEvents",
    value: function getSweepEvents() {
      var sweepEvents = this.exteriorRing.getSweepEvents();
      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
        var ringSweepEvents = this.interiorRings[i].getSweepEvents();
        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
          sweepEvents.push(ringSweepEvents[j]);
        }
      }
      return sweepEvents;
    }
  }]);
  return PolyIn2;
}();
var MultiPolyIn = /* @__PURE__ */ function() {
  function MultiPolyIn2(geom, isSubject) {
    _classCallCheck(this, MultiPolyIn2);
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number")
        geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (var i = 0, iMax = geom.length; i < iMax; i++) {
      var poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x < this.bbox.ll.x)
        this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y < this.bbox.ll.y)
        this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x > this.bbox.ur.x)
        this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y > this.bbox.ur.y)
        this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  _createClass(MultiPolyIn2, [{
    key: "getSweepEvents",
    value: function getSweepEvents() {
      var sweepEvents = [];
      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
        var polySweepEvents = this.polys[i].getSweepEvents();
        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
          sweepEvents.push(polySweepEvents[j]);
        }
      }
      return sweepEvents;
    }
  }]);
  return MultiPolyIn2;
}();
var RingOut = /* @__PURE__ */ function() {
  _createClass(RingOut2, null, [{
    key: "factory",
    value: function factory(allSegments) {
      var ringsOut = [];
      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
        var segment = allSegments[i];
        if (!segment.isInResult() || segment.ringOut)
          continue;
        var prevEvent = null;
        var event = segment.leftSE;
        var nextEvent = segment.rightSE;
        var events = [event];
        var startingPoint = event.point;
        var intersectionLEs = [];
        while (true) {
          prevEvent = event;
          event = nextEvent;
          events.push(event);
          if (event.point === startingPoint)
            break;
          while (true) {
            var availableLEs = event.getAvailableLinkedEvents();
            if (availableLEs.length === 0) {
              var firstPt = events[0].point;
              var lastPt = events[events.length - 1].point;
              throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
            }
            if (availableLEs.length === 1) {
              nextEvent = availableLEs[0].otherSE;
              break;
            }
            var indexLE = null;
            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
              if (intersectionLEs[j].point === event.point) {
                indexLE = j;
                break;
              }
            }
            if (indexLE !== null) {
              var intersectionLE = intersectionLEs.splice(indexLE)[0];
              var ringEvents = events.splice(intersectionLE.index);
              ringEvents.unshift(ringEvents[0].otherSE);
              ringsOut.push(new RingOut2(ringEvents.reverse()));
              continue;
            }
            intersectionLEs.push({
              index: events.length,
              point: event.point
            });
            var comparator = event.getLeftmostComparator(prevEvent);
            nextEvent = availableLEs.sort(comparator)[0].otherSE;
            break;
          }
        }
        ringsOut.push(new RingOut2(events));
      }
      return ringsOut;
    }
  }]);
  function RingOut2(events) {
    _classCallCheck(this, RingOut2);
    this.events = events;
    for (var i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  _createClass(RingOut2, [{
    key: "getGeom",
    value: function getGeom2() {
      var prevPt = this.events[0].point;
      var points2 = [prevPt];
      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
        var _pt = this.events[i].point;
        var _nextPt = this.events[i + 1].point;
        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
          continue;
        points2.push(_pt);
        prevPt = _pt;
      }
      if (points2.length === 1)
        return null;
      var pt = points2[0];
      var nextPt = points2[1];
      if (compareVectorAngles(pt, prevPt, nextPt) === 0)
        points2.shift();
      points2.push(points2[0]);
      var step = this.isExteriorRing() ? 1 : -1;
      var iStart = this.isExteriorRing() ? 0 : points2.length - 1;
      var iEnd = this.isExteriorRing() ? points2.length : -1;
      var orderedPoints = [];
      for (var _i = iStart; _i != iEnd; _i += step) {
        orderedPoints.push([points2[_i].x, points2[_i].y]);
      }
      return orderedPoints;
    }
  }, {
    key: "isExteriorRing",
    value: function isExteriorRing() {
      if (this._isExteriorRing === void 0) {
        var enclosing = this.enclosingRing();
        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
      }
      return this._isExteriorRing;
    }
  }, {
    key: "enclosingRing",
    value: function enclosingRing() {
      if (this._enclosingRing === void 0) {
        this._enclosingRing = this._calcEnclosingRing();
      }
      return this._enclosingRing;
    }
  }, {
    key: "_calcEnclosingRing",
    value: function _calcEnclosingRing() {
      var leftMostEvt = this.events[0];
      for (var i = 1, iMax = this.events.length; i < iMax; i++) {
        var evt = this.events[i];
        if (SweepEvent.compare(leftMostEvt, evt) > 0)
          leftMostEvt = evt;
      }
      var prevSeg = leftMostEvt.segment.prevInResult();
      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      while (true) {
        if (!prevSeg)
          return null;
        if (!prevPrevSeg)
          return prevSeg.ringOut;
        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
            return prevSeg.ringOut;
          } else
            return prevSeg.ringOut.enclosingRing();
        }
        prevSeg = prevPrevSeg.prevInResult();
        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      }
    }
  }]);
  return RingOut2;
}();
var PolyOut = /* @__PURE__ */ function() {
  function PolyOut2(exteriorRing) {
    _classCallCheck(this, PolyOut2);
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  _createClass(PolyOut2, [{
    key: "addInterior",
    value: function addInterior(ring) {
      this.interiorRings.push(ring);
      ring.poly = this;
    }
  }, {
    key: "getGeom",
    value: function getGeom2() {
      var geom = [this.exteriorRing.getGeom()];
      if (geom[0] === null)
        return null;
      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
        var ringGeom = this.interiorRings[i].getGeom();
        if (ringGeom === null)
          continue;
        geom.push(ringGeom);
      }
      return geom;
    }
  }]);
  return PolyOut2;
}();
var MultiPolyOut = /* @__PURE__ */ function() {
  function MultiPolyOut2(rings) {
    _classCallCheck(this, MultiPolyOut2);
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  _createClass(MultiPolyOut2, [{
    key: "getGeom",
    value: function getGeom2() {
      var geom = [];
      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
        var polyGeom = this.polys[i].getGeom();
        if (polyGeom === null)
          continue;
        geom.push(polyGeom);
      }
      return geom;
    }
  }, {
    key: "_composePolys",
    value: function _composePolys(rings) {
      var polys = [];
      for (var i = 0, iMax = rings.length; i < iMax; i++) {
        var ring = rings[i];
        if (ring.poly)
          continue;
        if (ring.isExteriorRing())
          polys.push(new PolyOut(ring));
        else {
          var enclosingRing = ring.enclosingRing();
          if (!enclosingRing.poly)
            polys.push(new PolyOut(enclosingRing));
          enclosingRing.poly.addInterior(ring);
        }
      }
      return polys;
    }
  }]);
  return MultiPolyOut2;
}();
var SweepLine = /* @__PURE__ */ function() {
  function SweepLine2(queue) {
    var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
    _classCallCheck(this, SweepLine2);
    this.queue = queue;
    this.tree = new Tree$2(comparator);
    this.segments = [];
  }
  _createClass(SweepLine2, [{
    key: "process",
    value: function process2(event) {
      var segment = event.segment;
      var newEvents = [];
      if (event.consumedBy) {
        if (event.isLeft)
          this.queue.remove(event.otherSE);
        else
          this.tree.remove(segment);
        return newEvents;
      }
      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
      if (!node)
        throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
      var prevNode = node;
      var nextNode = node;
      var prevSeg = void 0;
      var nextSeg = void 0;
      while (prevSeg === void 0) {
        prevNode = this.tree.prev(prevNode);
        if (prevNode === null)
          prevSeg = null;
        else if (prevNode.key.consumedBy === void 0)
          prevSeg = prevNode.key;
      }
      while (nextSeg === void 0) {
        nextNode = this.tree.next(nextNode);
        if (nextNode === null)
          nextSeg = null;
        else if (nextNode.key.consumedBy === void 0)
          nextSeg = nextNode.key;
      }
      if (event.isLeft) {
        var prevMySplitter = null;
        if (prevSeg) {
          var prevInter = prevSeg.getIntersection(segment);
          if (prevInter !== null) {
            if (!segment.isAnEndpoint(prevInter))
              prevMySplitter = prevInter;
            if (!prevSeg.isAnEndpoint(prevInter)) {
              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                newEvents.push(newEventsFromSplit[i]);
              }
            }
          }
        }
        var nextMySplitter = null;
        if (nextSeg) {
          var nextInter = nextSeg.getIntersection(segment);
          if (nextInter !== null) {
            if (!segment.isAnEndpoint(nextInter))
              nextMySplitter = nextInter;
            if (!nextSeg.isAnEndpoint(nextInter)) {
              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                newEvents.push(_newEventsFromSplit[_i]);
              }
            }
          }
        }
        if (prevMySplitter !== null || nextMySplitter !== null) {
          var mySplitter = null;
          if (prevMySplitter === null)
            mySplitter = nextMySplitter;
          else if (nextMySplitter === null)
            mySplitter = prevMySplitter;
          else {
            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
          }
          this.queue.remove(segment.rightSE);
          newEvents.push(segment.rightSE);
          var _newEventsFromSplit2 = segment.split(mySplitter);
          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
            newEvents.push(_newEventsFromSplit2[_i2]);
          }
        }
        if (newEvents.length > 0) {
          this.tree.remove(segment);
          newEvents.push(event);
        } else {
          this.segments.push(segment);
          segment.prev = prevSeg;
        }
      } else {
        if (prevSeg && nextSeg) {
          var inter = prevSeg.getIntersection(nextSeg);
          if (inter !== null) {
            if (!prevSeg.isAnEndpoint(inter)) {
              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                newEvents.push(_newEventsFromSplit3[_i3]);
              }
            }
            if (!nextSeg.isAnEndpoint(inter)) {
              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                newEvents.push(_newEventsFromSplit4[_i4]);
              }
            }
          }
        }
        this.tree.remove(segment);
      }
      return newEvents;
    }
  }, {
    key: "_splitSafely",
    value: function _splitSafely(seg, pt) {
      this.tree.remove(seg);
      var rightSE = seg.rightSE;
      this.queue.remove(rightSE);
      var newEvents = seg.split(pt);
      newEvents.push(rightSE);
      if (seg.consumedBy === void 0)
        this.tree.insert(seg);
      return newEvents;
    }
  }]);
  return SweepLine2;
}();
var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && {}.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && {}.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
var Operation = /* @__PURE__ */ function() {
  function Operation2() {
    _classCallCheck(this, Operation2);
  }
  _createClass(Operation2, [{
    key: "run",
    value: function run(type, geom, moreGeoms) {
      operation.type = type;
      rounder.reset();
      var multipolys = [new MultiPolyIn(geom, true)];
      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
        multipolys.push(new MultiPolyIn(moreGeoms[i], false));
      }
      operation.numMultiPolys = multipolys.length;
      if (operation.type === "difference") {
        var subject = multipolys[0];
        var _i = 1;
        while (_i < multipolys.length) {
          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
            _i++;
          else
            multipolys.splice(_i, 1);
        }
      }
      if (operation.type === "intersection") {
        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
          var mpA = multipolys[_i2];
          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
              return [];
          }
        }
      }
      var queue = new Tree$2(SweepEvent.compare);
      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
        var sweepEvents = multipolys[_i3].getSweepEvents();
        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
          queue.insert(sweepEvents[_j]);
          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
            throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
          }
        }
      }
      var sweepLine = new SweepLine(queue);
      var prevQueueSize = queue.size;
      var node = queue.pop();
      while (node) {
        var evt = node.key;
        if (queue.size === prevQueueSize) {
          var seg = evt.segment;
          throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
        }
        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
          throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
        }
        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
          throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
        }
        var newEvents = sweepLine.process(evt);
        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
          var _evt = newEvents[_i4];
          if (_evt.consumedBy === void 0)
            queue.insert(_evt);
        }
        prevQueueSize = queue.size;
        node = queue.pop();
      }
      rounder.reset();
      var ringsOut = RingOut.factory(sweepLine.segments);
      var result = new MultiPolyOut(ringsOut);
      return result.getGeom();
    }
  }]);
  return Operation2;
}();
var operation = new Operation();
var union$1 = function union(geom) {
  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    moreGeoms[_key - 1] = arguments[_key];
  }
  return operation.run("union", geom, moreGeoms);
};
var intersection$1 = function intersection3(geom) {
  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    moreGeoms[_key2 - 1] = arguments[_key2];
  }
  return operation.run("intersection", geom, moreGeoms);
};
var xor = function xor2(geom) {
  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    moreGeoms[_key3 - 1] = arguments[_key3];
  }
  return operation.run("xor", geom, moreGeoms);
};
var difference$1 = function difference(subjectGeom) {
  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    clippingGeoms[_key4 - 1] = arguments[_key4];
  }
  return operation.run("difference", subjectGeom, clippingGeoms);
};
var index = {
  union: union$1,
  intersection: intersection$1,
  xor,
  difference: difference$1
};
var polygonClipping = index;
function difference2(polygon1, polygon22) {
  var geom1 = getGeom(polygon1);
  var geom2 = getGeom(polygon22);
  var properties = polygon1.properties || {};
  var differenced = polygonClipping.difference(
    geom1.coordinates,
    geom2.coordinates
  );
  if (differenced.length === 0)
    return null;
  if (differenced.length === 1)
    return polygon(differenced[0], properties);
  return multiPolygon(differenced, properties);
}
if (!("fill" in Array.prototype)) {
  Object.defineProperty(Array.prototype, "fill", {
    configurable: true,
    value: function fill(value) {
      if (this === void 0 || this === null) {
        throw new TypeError(this + " is not an object");
      }
      var arrayLike = Object(this);
      var length3 = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;
      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
      relativeStart = relativeStart < 0 ? Math.max(length3 + relativeStart, 0) : Math.min(relativeStart, length3);
      var relativeEnd = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : length3;
      relativeEnd = relativeEnd < 0 ? Math.max(length3 + arguments[2], 0) : Math.min(relativeEnd, length3);
      while (relativeStart < relativeEnd) {
        arrayLike[relativeStart] = value;
        ++relativeStart;
      }
      return arrayLike;
    },
    writable: true
  });
}
Number.isFinite = Number.isFinite || function(value) {
  return typeof value === "number" && isFinite(value);
};
Number.isInteger = Number.isInteger || function(val) {
  return typeof val === "number" && isFinite(val) && Math.floor(val) === val;
};
Number.parseFloat = Number.parseFloat || parseFloat;
Number.isNaN = Number.isNaN || function(value) {
  return value !== value;
};
Math.trunc = Math.trunc || function(x2) {
  return x2 < 0 ? Math.ceil(x2) : Math.floor(x2);
};
var NumberUtil = function NumberUtil2() {
};
NumberUtil.prototype.interfaces_ = function interfaces_() {
  return [];
};
NumberUtil.prototype.getClass = function getClass() {
  return NumberUtil;
};
NumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance(x12, x2, tolerance) {
  return Math.abs(x12 - x2) <= tolerance;
};
var IllegalArgumentException = function(Error2) {
  function IllegalArgumentException2(message) {
    Error2.call(this, message);
    this.name = "IllegalArgumentException";
    this.message = message;
    this.stack = new Error2().stack;
  }
  if (Error2)
    IllegalArgumentException2.__proto__ = Error2;
  IllegalArgumentException2.prototype = Object.create(Error2 && Error2.prototype);
  IllegalArgumentException2.prototype.constructor = IllegalArgumentException2;
  return IllegalArgumentException2;
}(Error);
var Double = function Double2() {
};
var staticAccessors$1 = { MAX_VALUE: { configurable: true } };
Double.isNaN = function isNaN2(n) {
  return Number.isNaN(n);
};
Double.doubleToLongBits = function doubleToLongBits(n) {
  return n;
};
Double.longBitsToDouble = function longBitsToDouble(n) {
  return n;
};
Double.isInfinite = function isInfinite(n) {
  return !Number.isFinite(n);
};
staticAccessors$1.MAX_VALUE.get = function() {
  return Number.MAX_VALUE;
};
Object.defineProperties(Double, staticAccessors$1);
var Comparable = function Comparable2() {
};
var Clonable = function Clonable2() {
};
var Comparator = function Comparator2() {
};
function Serializable() {
}
var Coordinate = function Coordinate2() {
  this.x = null;
  this.y = null;
  this.z = null;
  if (arguments.length === 0) {
    this.x = 0;
    this.y = 0;
    this.z = Coordinate2.NULL_ORDINATE;
  } else if (arguments.length === 1) {
    var c = arguments[0];
    this.x = c.x;
    this.y = c.y;
    this.z = c.z;
  } else if (arguments.length === 2) {
    this.x = arguments[0];
    this.y = arguments[1];
    this.z = Coordinate2.NULL_ORDINATE;
  } else if (arguments.length === 3) {
    this.x = arguments[0];
    this.y = arguments[1];
    this.z = arguments[2];
  }
};
var staticAccessors = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
Coordinate.prototype.setOrdinate = function setOrdinate(ordinateIndex, value) {
  switch (ordinateIndex) {
    case Coordinate.X:
      this.x = value;
      break;
    case Coordinate.Y:
      this.y = value;
      break;
    case Coordinate.Z:
      this.z = value;
      break;
    default:
      throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
  }
};
Coordinate.prototype.equals2D = function equals2D() {
  if (arguments.length === 1) {
    var other = arguments[0];
    if (this.x !== other.x) {
      return false;
    }
    if (this.y !== other.y) {
      return false;
    }
    return true;
  } else if (arguments.length === 2) {
    var c = arguments[0];
    var tolerance = arguments[1];
    if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
      return false;
    }
    if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
      return false;
    }
    return true;
  }
};
Coordinate.prototype.getOrdinate = function getOrdinate(ordinateIndex) {
  switch (ordinateIndex) {
    case Coordinate.X:
      return this.x;
    case Coordinate.Y:
      return this.y;
    case Coordinate.Z:
      return this.z;
  }
  throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
};
Coordinate.prototype.equals3D = function equals3D(other) {
  return this.x === other.x && this.y === other.y && ((this.z === other.z || Double.isNaN(this.z)) && Double.isNaN(other.z));
};
Coordinate.prototype.equals = function equals2(other) {
  if (!(other instanceof Coordinate)) {
    return false;
  }
  return this.equals2D(other);
};
Coordinate.prototype.equalInZ = function equalInZ(c, tolerance) {
  return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);
};
Coordinate.prototype.compareTo = function compareTo(o) {
  var other = o;
  if (this.x < other.x) {
    return -1;
  }
  if (this.x > other.x) {
    return 1;
  }
  if (this.y < other.y) {
    return -1;
  }
  if (this.y > other.y) {
    return 1;
  }
  return 0;
};
Coordinate.prototype.clone = function clone() {
};
Coordinate.prototype.copy = function copy() {
  return new Coordinate(this);
};
Coordinate.prototype.toString = function toString() {
  return "(" + this.x + ", " + this.y + ", " + this.z + ")";
};
Coordinate.prototype.distance3D = function distance3D(c) {
  var dx = this.x - c.x;
  var dy = this.y - c.y;
  var dz = this.z - c.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
};
Coordinate.prototype.distance = function distance(c) {
  var dx = this.x - c.x;
  var dy = this.y - c.y;
  return Math.sqrt(dx * dx + dy * dy);
};
Coordinate.prototype.hashCode = function hashCode() {
  var result = 17;
  result = 37 * result + Coordinate.hashCode(this.x);
  result = 37 * result + Coordinate.hashCode(this.y);
  return result;
};
Coordinate.prototype.setCoordinate = function setCoordinate(other) {
  this.x = other.x;
  this.y = other.y;
  this.z = other.z;
};
Coordinate.prototype.interfaces_ = function interfaces_2() {
  return [Comparable, Clonable, Serializable];
};
Coordinate.prototype.getClass = function getClass2() {
  return Coordinate;
};
Coordinate.hashCode = function hashCode2() {
  if (arguments.length === 1) {
    var x2 = arguments[0];
    var f = Double.doubleToLongBits(x2);
    return Math.trunc((f ^ f) >>> 32);
  }
};
staticAccessors.DimensionalComparator.get = function() {
  return DimensionalComparator;
};
staticAccessors.serialVersionUID.get = function() {
  return 6683108902428367e3;
};
staticAccessors.NULL_ORDINATE.get = function() {
  return Double.NaN;
};
staticAccessors.X.get = function() {
  return 0;
};
staticAccessors.Y.get = function() {
  return 1;
};
staticAccessors.Z.get = function() {
  return 2;
};
Object.defineProperties(Coordinate, staticAccessors);
var DimensionalComparator = function DimensionalComparator2(dimensionsToTest) {
  this._dimensionsToTest = 2;
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    var dimensionsToTest$1 = arguments[0];
    if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) {
      throw new IllegalArgumentException("only 2 or 3 dimensions may be specified");
    }
    this._dimensionsToTest = dimensionsToTest$1;
  }
};
DimensionalComparator.prototype.compare = function compare(o1, o2) {
  var c1 = o1;
  var c2 = o2;
  var compX = DimensionalComparator.compare(c1.x, c2.x);
  if (compX !== 0) {
    return compX;
  }
  var compY = DimensionalComparator.compare(c1.y, c2.y);
  if (compY !== 0) {
    return compY;
  }
  if (this._dimensionsToTest <= 2) {
    return 0;
  }
  var compZ = DimensionalComparator.compare(c1.z, c2.z);
  return compZ;
};
DimensionalComparator.prototype.interfaces_ = function interfaces_3() {
  return [Comparator];
};
DimensionalComparator.prototype.getClass = function getClass3() {
  return DimensionalComparator;
};
DimensionalComparator.compare = function compare2(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  if (Double.isNaN(a)) {
    if (Double.isNaN(b)) {
      return 0;
    }
    return -1;
  }
  if (Double.isNaN(b)) {
    return 1;
  }
  return 0;
};
var CoordinateSequenceFactory = function CoordinateSequenceFactory2() {
};
CoordinateSequenceFactory.prototype.create = function create() {
};
CoordinateSequenceFactory.prototype.interfaces_ = function interfaces_4() {
  return [];
};
CoordinateSequenceFactory.prototype.getClass = function getClass4() {
  return CoordinateSequenceFactory;
};
var Location = function Location2() {
};
var staticAccessors$4 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
Location.prototype.interfaces_ = function interfaces_5() {
  return [];
};
Location.prototype.getClass = function getClass5() {
  return Location;
};
Location.toLocationSymbol = function toLocationSymbol(locationValue) {
  switch (locationValue) {
    case Location.EXTERIOR:
      return "e";
    case Location.BOUNDARY:
      return "b";
    case Location.INTERIOR:
      return "i";
    case Location.NONE:
      return "-";
  }
  throw new IllegalArgumentException("Unknown location value: " + locationValue);
};
staticAccessors$4.INTERIOR.get = function() {
  return 0;
};
staticAccessors$4.BOUNDARY.get = function() {
  return 1;
};
staticAccessors$4.EXTERIOR.get = function() {
  return 2;
};
staticAccessors$4.NONE.get = function() {
  return -1;
};
Object.defineProperties(Location, staticAccessors$4);
var hasInterface = function(o, i) {
  return o.interfaces_ && o.interfaces_().indexOf(i) > -1;
};
var MathUtil = function MathUtil2() {
};
var staticAccessors$5 = { LOG_10: { configurable: true } };
MathUtil.prototype.interfaces_ = function interfaces_6() {
  return [];
};
MathUtil.prototype.getClass = function getClass6() {
  return MathUtil;
};
MathUtil.log10 = function log10(x2) {
  var ln = Math.log(x2);
  if (Double.isInfinite(ln)) {
    return ln;
  }
  if (Double.isNaN(ln)) {
    return ln;
  }
  return ln / MathUtil.LOG_10;
};
MathUtil.min = function min(v12, v22, v32, v4) {
  var min5 = v12;
  if (v22 < min5) {
    min5 = v22;
  }
  if (v32 < min5) {
    min5 = v32;
  }
  if (v4 < min5) {
    min5 = v4;
  }
  return min5;
};
MathUtil.clamp = function clamp() {
  if (typeof arguments[2] === "number" && (typeof arguments[0] === "number" && typeof arguments[1] === "number")) {
    var x2 = arguments[0];
    var min5 = arguments[1];
    var max4 = arguments[2];
    if (x2 < min5) {
      return min5;
    }
    if (x2 > max4) {
      return max4;
    }
    return x2;
  } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
    var x$1 = arguments[0];
    var min$12 = arguments[1];
    var max$12 = arguments[2];
    if (x$1 < min$12) {
      return min$12;
    }
    if (x$1 > max$12) {
      return max$12;
    }
    return x$1;
  }
};
MathUtil.wrap = function wrap(index2, max4) {
  if (index2 < 0) {
    return max4 - -index2 % max4;
  }
  return index2 % max4;
};
MathUtil.max = function max() {
  if (arguments.length === 3) {
    var v12 = arguments[0];
    var v22 = arguments[1];
    var v32 = arguments[2];
    var max4 = v12;
    if (v22 > max4) {
      max4 = v22;
    }
    if (v32 > max4) {
      max4 = v32;
    }
    return max4;
  } else if (arguments.length === 4) {
    var v1$1 = arguments[0];
    var v2$1 = arguments[1];
    var v3$1 = arguments[2];
    var v4 = arguments[3];
    var max$12 = v1$1;
    if (v2$1 > max$12) {
      max$12 = v2$1;
    }
    if (v3$1 > max$12) {
      max$12 = v3$1;
    }
    if (v4 > max$12) {
      max$12 = v4;
    }
    return max$12;
  }
};
MathUtil.average = function average(x12, x2) {
  return (x12 + x2) / 2;
};
staticAccessors$5.LOG_10.get = function() {
  return Math.log(10);
};
Object.defineProperties(MathUtil, staticAccessors$5);
var StringBuffer = function StringBuffer2(str) {
  this.str = str;
};
StringBuffer.prototype.append = function append(e2) {
  this.str += e2;
};
StringBuffer.prototype.setCharAt = function setCharAt(i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
};
StringBuffer.prototype.toString = function toString2(e2) {
  return this.str;
};
var Integer = function Integer2(value) {
  this.value = value;
};
Integer.prototype.intValue = function intValue() {
  return this.value;
};
Integer.prototype.compareTo = function compareTo2(o) {
  if (this.value < o) {
    return -1;
  }
  if (this.value > o) {
    return 1;
  }
  return 0;
};
Integer.isNaN = function isNaN3(n) {
  return Number.isNaN(n);
};
var Character = function Character2() {
};
Character.isWhitespace = function isWhitespace(c) {
  return c <= 32 && c >= 0 || c === 127;
};
Character.toUpperCase = function toUpperCase(c) {
  return c.toUpperCase();
};
var DD = function DD2() {
  this._hi = 0;
  this._lo = 0;
  if (arguments.length === 0) {
    this.init(0);
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === "number") {
      var x2 = arguments[0];
      this.init(x2);
    } else if (arguments[0] instanceof DD2) {
      var dd = arguments[0];
      this.init(dd);
    } else if (typeof arguments[0] === "string") {
      var str = arguments[0];
      DD2.call(this, DD2.parse(str));
    }
  } else if (arguments.length === 2) {
    var hi = arguments[0];
    var lo = arguments[1];
    this.init(hi, lo);
  }
};
var staticAccessors$7 = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
DD.prototype.le = function le(y2) {
  return (this._hi < y2._hi || this._hi === y2._hi) && this._lo <= y2._lo;
};
DD.prototype.extractSignificantDigits = function extractSignificantDigits(insertDecimalPoint, magnitude2) {
  var y2 = this.abs();
  var mag = DD.magnitude(y2._hi);
  var scale4 = DD.TEN.pow(mag);
  y2 = y2.divide(scale4);
  if (y2.gt(DD.TEN)) {
    y2 = y2.divide(DD.TEN);
    mag += 1;
  } else if (y2.lt(DD.ONE)) {
    y2 = y2.multiply(DD.TEN);
    mag -= 1;
  }
  var decimalPointPos = mag + 1;
  var buf = new StringBuffer();
  var numDigits = DD.MAX_PRINT_DIGITS - 1;
  for (var i = 0; i <= numDigits; i++) {
    if (insertDecimalPoint && i === decimalPointPos) {
      buf.append(".");
    }
    var digit = Math.trunc(y2._hi);
    if (digit < 0) {
      break;
    }
    var rebiasBy10 = false;
    var digitChar = 0;
    if (digit > 9) {
      rebiasBy10 = true;
      digitChar = "9";
    } else {
      digitChar = "0" + digit;
    }
    buf.append(digitChar);
    y2 = y2.subtract(DD.valueOf(digit)).multiply(DD.TEN);
    if (rebiasBy10) {
      y2.selfAdd(DD.TEN);
    }
    var continueExtractingDigits = true;
    var remMag = DD.magnitude(y2._hi);
    if (remMag < 0 && Math.abs(remMag) >= numDigits - i) {
      continueExtractingDigits = false;
    }
    if (!continueExtractingDigits) {
      break;
    }
  }
  magnitude2[0] = mag;
  return buf.toString();
};
DD.prototype.sqr = function sqr() {
  return this.multiply(this);
};
DD.prototype.doubleValue = function doubleValue() {
  return this._hi + this._lo;
};
DD.prototype.subtract = function subtract() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    return this.add(y2.negate());
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    return this.add(-y$1);
  }
};
DD.prototype.equals = function equals3() {
  if (arguments.length === 1) {
    var y2 = arguments[0];
    return this._hi === y2._hi && this._lo === y2._lo;
  }
};
DD.prototype.isZero = function isZero() {
  return this._hi === 0 && this._lo === 0;
};
DD.prototype.selfSubtract = function selfSubtract() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    if (this.isNaN()) {
      return this;
    }
    return this.selfAdd(-y2._hi, -y2._lo);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    if (this.isNaN()) {
      return this;
    }
    return this.selfAdd(-y$1, 0);
  }
};
DD.prototype.getSpecialNumberString = function getSpecialNumberString() {
  if (this.isZero()) {
    return "0.0";
  }
  if (this.isNaN()) {
    return "NaN ";
  }
  return null;
};
DD.prototype.min = function min2(x2) {
  if (this.le(x2)) {
    return this;
  } else {
    return x2;
  }
};
DD.prototype.selfDivide = function selfDivide() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof DD) {
      var y2 = arguments[0];
      return this.selfDivide(y2._hi, y2._lo);
    } else if (typeof arguments[0] === "number") {
      var y$1 = arguments[0];
      return this.selfDivide(y$1, 0);
    }
  } else if (arguments.length === 2) {
    var yhi = arguments[0];
    var ylo = arguments[1];
    var hc = null;
    var tc = null;
    var hy = null;
    var ty = null;
    var C = null;
    var c = null;
    var U = null;
    var u = null;
    C = this._hi / yhi;
    c = DD.SPLIT * C;
    hc = c - C;
    u = DD.SPLIT * yhi;
    hc = c - hc;
    tc = C - hc;
    hy = u - yhi;
    U = C * yhi;
    hy = u - hy;
    ty = yhi - hy;
    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
    c = (this._hi - U - u + this._lo - C * ylo) / yhi;
    u = C + c;
    this._hi = u;
    this._lo = C - u + c;
    return this;
  }
};
DD.prototype.dump = function dump() {
  return "DD<" + this._hi + ", " + this._lo + ">";
};
DD.prototype.divide = function divide() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    var hc = null;
    var tc = null;
    var hy = null;
    var ty = null;
    var C = null;
    var c = null;
    var U = null;
    var u = null;
    C = this._hi / y2._hi;
    c = DD.SPLIT * C;
    hc = c - C;
    u = DD.SPLIT * y2._hi;
    hc = c - hc;
    tc = C - hc;
    hy = u - y2._hi;
    U = C * y2._hi;
    hy = u - hy;
    ty = y2._hi - hy;
    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
    c = (this._hi - U - u + this._lo - C * y2._lo) / y2._hi;
    u = C + c;
    var zhi = u;
    var zlo = C - u + c;
    return new DD(zhi, zlo);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    if (Double.isNaN(y$1)) {
      return DD.createNaN();
    }
    return DD.copy(this).selfDivide(y$1, 0);
  }
};
DD.prototype.ge = function ge(y2) {
  return (this._hi > y2._hi || this._hi === y2._hi) && this._lo >= y2._lo;
};
DD.prototype.pow = function pow(exp) {
  if (exp === 0) {
    return DD.valueOf(1);
  }
  var r = new DD(this);
  var s = DD.valueOf(1);
  var n = Math.abs(exp);
  if (n > 1) {
    while (n > 0) {
      if (n % 2 === 1) {
        s.selfMultiply(r);
      }
      n /= 2;
      if (n > 0) {
        r = r.sqr();
      }
    }
  } else {
    s = r;
  }
  if (exp < 0) {
    return s.reciprocal();
  }
  return s;
};
DD.prototype.ceil = function ceil() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  var fhi = Math.ceil(this._hi);
  var flo = 0;
  if (fhi === this._hi) {
    flo = Math.ceil(this._lo);
  }
  return new DD(fhi, flo);
};
DD.prototype.compareTo = function compareTo3(o) {
  var other = o;
  if (this._hi < other._hi) {
    return -1;
  }
  if (this._hi > other._hi) {
    return 1;
  }
  if (this._lo < other._lo) {
    return -1;
  }
  if (this._lo > other._lo) {
    return 1;
  }
  return 0;
};
DD.prototype.rint = function rint() {
  if (this.isNaN()) {
    return this;
  }
  var plus5 = this.add(0.5);
  return plus5.floor();
};
DD.prototype.setValue = function setValue() {
  if (arguments[0] instanceof DD) {
    var value = arguments[0];
    this.init(value);
    return this;
  } else if (typeof arguments[0] === "number") {
    var value$1 = arguments[0];
    this.init(value$1);
    return this;
  }
};
DD.prototype.max = function max2(x2) {
  if (this.ge(x2)) {
    return this;
  } else {
    return x2;
  }
};
DD.prototype.sqrt = function sqrt() {
  if (this.isZero()) {
    return DD.valueOf(0);
  }
  if (this.isNegative()) {
    return DD.NaN;
  }
  var x2 = 1 / Math.sqrt(this._hi);
  var ax = this._hi * x2;
  var axdd = DD.valueOf(ax);
  var diffSq = this.subtract(axdd.sqr());
  var d2 = diffSq._hi * (x2 * 0.5);
  return axdd.add(d2);
};
DD.prototype.selfAdd = function selfAdd() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof DD) {
      var y2 = arguments[0];
      return this.selfAdd(y2._hi, y2._lo);
    } else if (typeof arguments[0] === "number") {
      var y$1 = arguments[0];
      var H = null;
      var h = null;
      var S = null;
      var s = null;
      var e2 = null;
      var f = null;
      S = this._hi + y$1;
      e2 = S - this._hi;
      s = S - e2;
      s = y$1 - e2 + (this._hi - s);
      f = s + this._lo;
      H = S + f;
      h = f + (S - H);
      this._hi = H + h;
      this._lo = h + (H - this._hi);
      return this;
    }
  } else if (arguments.length === 2) {
    var yhi = arguments[0];
    var ylo = arguments[1];
    var H$1 = null;
    var h$1 = null;
    var T = null;
    var t = null;
    var S$1 = null;
    var s$1 = null;
    var e$1 = null;
    var f$1 = null;
    S$1 = this._hi + yhi;
    T = this._lo + ylo;
    e$1 = S$1 - this._hi;
    f$1 = T - this._lo;
    s$1 = S$1 - e$1;
    t = T - f$1;
    s$1 = yhi - e$1 + (this._hi - s$1);
    t = ylo - f$1 + (this._lo - t);
    e$1 = s$1 + T;
    H$1 = S$1 + e$1;
    h$1 = e$1 + (S$1 - H$1);
    e$1 = t + h$1;
    var zhi = H$1 + e$1;
    var zlo = e$1 + (H$1 - zhi);
    this._hi = zhi;
    this._lo = zlo;
    return this;
  }
};
DD.prototype.selfMultiply = function selfMultiply() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof DD) {
      var y2 = arguments[0];
      return this.selfMultiply(y2._hi, y2._lo);
    } else if (typeof arguments[0] === "number") {
      var y$1 = arguments[0];
      return this.selfMultiply(y$1, 0);
    }
  } else if (arguments.length === 2) {
    var yhi = arguments[0];
    var ylo = arguments[1];
    var hx = null;
    var tx = null;
    var hy = null;
    var ty = null;
    var C = null;
    var c = null;
    C = DD.SPLIT * this._hi;
    hx = C - this._hi;
    c = DD.SPLIT * yhi;
    hx = C - hx;
    tx = this._hi - hx;
    hy = c - yhi;
    C = this._hi * yhi;
    hy = c - hy;
    ty = yhi - hy;
    c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
    var zhi = C + c;
    hx = C - zhi;
    var zlo = c + hx;
    this._hi = zhi;
    this._lo = zlo;
    return this;
  }
};
DD.prototype.selfSqr = function selfSqr() {
  return this.selfMultiply(this);
};
DD.prototype.floor = function floor() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  var fhi = Math.floor(this._hi);
  var flo = 0;
  if (fhi === this._hi) {
    flo = Math.floor(this._lo);
  }
  return new DD(fhi, flo);
};
DD.prototype.negate = function negate() {
  if (this.isNaN()) {
    return this;
  }
  return new DD(-this._hi, -this._lo);
};
DD.prototype.clone = function clone2() {
};
DD.prototype.multiply = function multiply() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    if (y2.isNaN()) {
      return DD.createNaN();
    }
    return DD.copy(this).selfMultiply(y2);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    if (Double.isNaN(y$1)) {
      return DD.createNaN();
    }
    return DD.copy(this).selfMultiply(y$1, 0);
  }
};
DD.prototype.isNaN = function isNaN4() {
  return Double.isNaN(this._hi);
};
DD.prototype.intValue = function intValue2() {
  return Math.trunc(this._hi);
};
DD.prototype.toString = function toString3() {
  var mag = DD.magnitude(this._hi);
  if (mag >= -3 && mag <= 20) {
    return this.toStandardNotation();
  }
  return this.toSciNotation();
};
DD.prototype.toStandardNotation = function toStandardNotation() {
  var specialStr = this.getSpecialNumberString();
  if (specialStr !== null) {
    return specialStr;
  }
  var magnitude2 = new Array(1).fill(null);
  var sigDigits = this.extractSignificantDigits(true, magnitude2);
  var decimalPointPos = magnitude2[0] + 1;
  var num = sigDigits;
  if (sigDigits.charAt(0) === ".") {
    num = "0" + sigDigits;
  } else if (decimalPointPos < 0) {
    num = "0." + DD.stringOfChar("0", -decimalPointPos) + sigDigits;
  } else if (sigDigits.indexOf(".") === -1) {
    var numZeroes = decimalPointPos - sigDigits.length;
    var zeroes = DD.stringOfChar("0", numZeroes);
    num = sigDigits + zeroes + ".0";
  }
  if (this.isNegative()) {
    return "-" + num;
  }
  return num;
};
DD.prototype.reciprocal = function reciprocal() {
  var hc = null;
  var tc = null;
  var hy = null;
  var ty = null;
  var C = null;
  var c = null;
  var U = null;
  var u = null;
  C = 1 / this._hi;
  c = DD.SPLIT * C;
  hc = c - C;
  u = DD.SPLIT * this._hi;
  hc = c - hc;
  tc = C - hc;
  hy = u - this._hi;
  U = C * this._hi;
  hy = u - hy;
  ty = this._hi - hy;
  u = hc * hy - U + hc * ty + tc * hy + tc * ty;
  c = (1 - U - u - C * this._lo) / this._hi;
  var zhi = C + c;
  var zlo = C - zhi + c;
  return new DD(zhi, zlo);
};
DD.prototype.toSciNotation = function toSciNotation() {
  if (this.isZero()) {
    return DD.SCI_NOT_ZERO;
  }
  var specialStr = this.getSpecialNumberString();
  if (specialStr !== null) {
    return specialStr;
  }
  var magnitude2 = new Array(1).fill(null);
  var digits = this.extractSignificantDigits(false, magnitude2);
  var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude2[0];
  if (digits.charAt(0) === "0") {
    throw new Error("Found leading zero: " + digits);
  }
  var trailingDigits = "";
  if (digits.length > 1) {
    trailingDigits = digits.substring(1);
  }
  var digitsWithDecimal = digits.charAt(0) + "." + trailingDigits;
  if (this.isNegative()) {
    return "-" + digitsWithDecimal + expStr;
  }
  return digitsWithDecimal + expStr;
};
DD.prototype.abs = function abs() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  if (this.isNegative()) {
    return this.negate();
  }
  return new DD(this);
};
DD.prototype.isPositive = function isPositive() {
  return (this._hi > 0 || this._hi === 0) && this._lo > 0;
};
DD.prototype.lt = function lt(y2) {
  return (this._hi < y2._hi || this._hi === y2._hi) && this._lo < y2._lo;
};
DD.prototype.add = function add() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    return DD.copy(this).selfAdd(y2);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    return DD.copy(this).selfAdd(y$1);
  }
};
DD.prototype.init = function init() {
  if (arguments.length === 1) {
    if (typeof arguments[0] === "number") {
      var x2 = arguments[0];
      this._hi = x2;
      this._lo = 0;
    } else if (arguments[0] instanceof DD) {
      var dd = arguments[0];
      this._hi = dd._hi;
      this._lo = dd._lo;
    }
  } else if (arguments.length === 2) {
    var hi = arguments[0];
    var lo = arguments[1];
    this._hi = hi;
    this._lo = lo;
  }
};
DD.prototype.gt = function gt(y2) {
  return (this._hi > y2._hi || this._hi === y2._hi) && this._lo > y2._lo;
};
DD.prototype.isNegative = function isNegative() {
  return (this._hi < 0 || this._hi === 0) && this._lo < 0;
};
DD.prototype.trunc = function trunc() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  if (this.isPositive()) {
    return this.floor();
  } else {
    return this.ceil();
  }
};
DD.prototype.signum = function signum() {
  if (this._hi > 0) {
    return 1;
  }
  if (this._hi < 0) {
    return -1;
  }
  if (this._lo > 0) {
    return 1;
  }
  if (this._lo < 0) {
    return -1;
  }
  return 0;
};
DD.prototype.interfaces_ = function interfaces_7() {
  return [Serializable, Comparable, Clonable];
};
DD.prototype.getClass = function getClass7() {
  return DD;
};
DD.sqr = function sqr2(x2) {
  return DD.valueOf(x2).selfMultiply(x2);
};
DD.valueOf = function valueOf() {
  if (typeof arguments[0] === "string") {
    var str = arguments[0];
    return DD.parse(str);
  } else if (typeof arguments[0] === "number") {
    var x2 = arguments[0];
    return new DD(x2);
  }
};
DD.sqrt = function sqrt2(x2) {
  return DD.valueOf(x2).sqrt();
};
DD.parse = function parse(str) {
  var i = 0;
  var strlen = str.length;
  while (Character.isWhitespace(str.charAt(i))) {
    i++;
  }
  var isNegative2 = false;
  if (i < strlen) {
    var signCh = str.charAt(i);
    if (signCh === "-" || signCh === "+") {
      i++;
      if (signCh === "-") {
        isNegative2 = true;
      }
    }
  }
  var val = new DD();
  var numDigits = 0;
  var numBeforeDec = 0;
  var exp = 0;
  while (true) {
    if (i >= strlen) {
      break;
    }
    var ch = str.charAt(i);
    i++;
    if (Character.isDigit(ch)) {
      var d = ch - "0";
      val.selfMultiply(DD.TEN);
      val.selfAdd(d);
      numDigits++;
      continue;
    }
    if (ch === ".") {
      numBeforeDec = numDigits;
      continue;
    }
    if (ch === "e" || ch === "E") {
      var expStr = str.substring(i);
      try {
        exp = Integer.parseInt(expStr);
      } catch (ex) {
        if (ex instanceof Error) {
          throw new Error("Invalid exponent " + expStr + " in string " + str);
        } else {
          throw ex;
        }
      } finally {
      }
      break;
    }
    throw new Error("Unexpected character '" + ch + "' at position " + i + " in string " + str);
  }
  var val2 = val;
  var numDecPlaces = numDigits - numBeforeDec - exp;
  if (numDecPlaces === 0) {
    val2 = val;
  } else if (numDecPlaces > 0) {
    var scale4 = DD.TEN.pow(numDecPlaces);
    val2 = val.divide(scale4);
  } else if (numDecPlaces < 0) {
    var scale$12 = DD.TEN.pow(-numDecPlaces);
    val2 = val.multiply(scale$12);
  }
  if (isNegative2) {
    return val2.negate();
  }
  return val2;
};
DD.createNaN = function createNaN() {
  return new DD(Double.NaN, Double.NaN);
};
DD.copy = function copy2(dd) {
  return new DD(dd);
};
DD.magnitude = function magnitude(x2) {
  var xAbs = Math.abs(x2);
  var xLog10 = Math.log(xAbs) / Math.log(10);
  var xMag = Math.trunc(Math.floor(xLog10));
  var xApprox = Math.pow(10, xMag);
  if (xApprox * 10 <= xAbs) {
    xMag += 1;
  }
  return xMag;
};
DD.stringOfChar = function stringOfChar(ch, len2) {
  var buf = new StringBuffer();
  for (var i = 0; i < len2; i++) {
    buf.append(ch);
  }
  return buf.toString();
};
staticAccessors$7.PI.get = function() {
  return new DD(3.141592653589793, 12246467991473532e-32);
};
staticAccessors$7.TWO_PI.get = function() {
  return new DD(6.283185307179586, 24492935982947064e-32);
};
staticAccessors$7.PI_2.get = function() {
  return new DD(1.5707963267948966, 6123233995736766e-32);
};
staticAccessors$7.E.get = function() {
  return new DD(2.718281828459045, 14456468917292502e-32);
};
staticAccessors$7.NaN.get = function() {
  return new DD(Double.NaN, Double.NaN);
};
staticAccessors$7.EPS.get = function() {
  return 123259516440783e-46;
};
staticAccessors$7.SPLIT.get = function() {
  return 134217729;
};
staticAccessors$7.MAX_PRINT_DIGITS.get = function() {
  return 32;
};
staticAccessors$7.TEN.get = function() {
  return DD.valueOf(10);
};
staticAccessors$7.ONE.get = function() {
  return DD.valueOf(1);
};
staticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function() {
  return "E";
};
staticAccessors$7.SCI_NOT_ZERO.get = function() {
  return "0.0E0";
};
Object.defineProperties(DD, staticAccessors$7);
var CGAlgorithmsDD = function CGAlgorithmsDD2() {
};
var staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };
CGAlgorithmsDD.prototype.interfaces_ = function interfaces_8() {
  return [];
};
CGAlgorithmsDD.prototype.getClass = function getClass8() {
  return CGAlgorithmsDD;
};
CGAlgorithmsDD.orientationIndex = function orientationIndex2(p1, p2, q) {
  var index2 = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
  if (index2 <= 1) {
    return index2;
  }
  var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
  var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
  var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
  var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
};
CGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2(x12, y12, x2, y2) {
  var det2 = x12.multiply(y2).selfSubtract(y12.multiply(x2));
  return det2.signum();
};
CGAlgorithmsDD.intersection = function intersection4(p1, p2, q1, q2) {
  var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
  var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
  var denom = denom1.subtract(denom2);
  var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
  var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
  var numx = numx1.subtract(numx2);
  var fracP = numx.selfDivide(denom).doubleValue();
  var x2 = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
  var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
  var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
  var numy = numy1.subtract(numy2);
  var fracQ = numy.selfDivide(denom).doubleValue();
  var y2 = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
  return new Coordinate(x2, y2);
};
CGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter(pa, pb, pc) {
  var detsum = null;
  var detleft = (pa.x - pc.x) * (pb.y - pc.y);
  var detright = (pa.y - pc.y) * (pb.x - pc.x);
  var det2 = detleft - detright;
  if (detleft > 0) {
    if (detright <= 0) {
      return CGAlgorithmsDD.signum(det2);
    } else {
      detsum = detleft + detright;
    }
  } else if (detleft < 0) {
    if (detright >= 0) {
      return CGAlgorithmsDD.signum(det2);
    } else {
      detsum = -detleft - detright;
    }
  } else {
    return CGAlgorithmsDD.signum(det2);
  }
  var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
  if (det2 >= errbound || -det2 >= errbound) {
    return CGAlgorithmsDD.signum(det2);
  }
  return 2;
};
CGAlgorithmsDD.signum = function signum2(x2) {
  if (x2 > 0) {
    return 1;
  }
  if (x2 < 0) {
    return -1;
  }
  return 0;
};
staticAccessors$6.DP_SAFE_EPSILON.get = function() {
  return 1e-15;
};
Object.defineProperties(CGAlgorithmsDD, staticAccessors$6);
var CoordinateSequence = function CoordinateSequence2() {
};
var staticAccessors$8 = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
staticAccessors$8.X.get = function() {
  return 0;
};
staticAccessors$8.Y.get = function() {
  return 1;
};
staticAccessors$8.Z.get = function() {
  return 2;
};
staticAccessors$8.M.get = function() {
  return 3;
};
CoordinateSequence.prototype.setOrdinate = function setOrdinate2(index2, ordinateIndex, value) {
};
CoordinateSequence.prototype.size = function size() {
};
CoordinateSequence.prototype.getOrdinate = function getOrdinate2(index2, ordinateIndex) {
};
CoordinateSequence.prototype.getCoordinate = function getCoordinate() {
};
CoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {
};
CoordinateSequence.prototype.getDimension = function getDimension() {
};
CoordinateSequence.prototype.getX = function getX(index2) {
};
CoordinateSequence.prototype.clone = function clone3() {
};
CoordinateSequence.prototype.expandEnvelope = function expandEnvelope(env2) {
};
CoordinateSequence.prototype.copy = function copy3() {
};
CoordinateSequence.prototype.getY = function getY(index2) {
};
CoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray() {
};
CoordinateSequence.prototype.interfaces_ = function interfaces_9() {
  return [Clonable];
};
CoordinateSequence.prototype.getClass = function getClass9() {
  return CoordinateSequence;
};
Object.defineProperties(CoordinateSequence, staticAccessors$8);
var Exception = function Exception2() {
};
var NotRepresentableException = function(Exception$$1) {
  function NotRepresentableException2() {
    Exception$$1.call(this, "Projective point not representable on the Cartesian plane.");
  }
  if (Exception$$1)
    NotRepresentableException2.__proto__ = Exception$$1;
  NotRepresentableException2.prototype = Object.create(Exception$$1 && Exception$$1.prototype);
  NotRepresentableException2.prototype.constructor = NotRepresentableException2;
  NotRepresentableException2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  NotRepresentableException2.prototype.getClass = function getClass169() {
    return NotRepresentableException2;
  };
  return NotRepresentableException2;
}(Exception);
var System = function System2() {
};
System.arraycopy = function arraycopy(src2, srcPos, dest, destPos, len2) {
  var c = 0;
  for (var i = srcPos; i < srcPos + len2; i++) {
    dest[destPos + c] = src2[i];
    c++;
  }
};
System.getProperty = function getProperty(name2) {
  return {
    "line.separator": "\n"
  }[name2];
};
var HCoordinate = function HCoordinate2() {
  this.x = null;
  this.y = null;
  this.w = null;
  if (arguments.length === 0) {
    this.x = 0;
    this.y = 0;
    this.w = 1;
  } else if (arguments.length === 1) {
    var p = arguments[0];
    this.x = p.x;
    this.y = p.y;
    this.w = 1;
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
      var _x = arguments[0];
      var _y = arguments[1];
      this.x = _x;
      this.y = _y;
      this.w = 1;
    } else if (arguments[0] instanceof HCoordinate2 && arguments[1] instanceof HCoordinate2) {
      var p1 = arguments[0];
      var p2 = arguments[1];
      this.x = p1.y * p2.w - p2.y * p1.w;
      this.y = p2.x * p1.w - p1.x * p2.w;
      this.w = p1.x * p2.y - p2.x * p1.y;
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      var p1$1 = arguments[0];
      var p2$1 = arguments[1];
      this.x = p1$1.y - p2$1.y;
      this.y = p2$1.x - p1$1.x;
      this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;
    }
  } else if (arguments.length === 3) {
    var _x$1 = arguments[0];
    var _y$1 = arguments[1];
    var _w = arguments[2];
    this.x = _x$1;
    this.y = _y$1;
    this.w = _w;
  } else if (arguments.length === 4) {
    var p1$2 = arguments[0];
    var p2$2 = arguments[1];
    var q1 = arguments[2];
    var q2 = arguments[3];
    var px = p1$2.y - p2$2.y;
    var py = p2$2.x - p1$2.x;
    var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;
    var qx = q1.y - q2.y;
    var qy = q2.x - q1.x;
    var qw = q1.x * q2.y - q2.x * q1.y;
    this.x = py * qw - qy * pw;
    this.y = qx * pw - px * qw;
    this.w = px * qy - qx * py;
  }
};
HCoordinate.prototype.getY = function getY2() {
  var a = this.y / this.w;
  if (Double.isNaN(a) || Double.isInfinite(a)) {
    throw new NotRepresentableException();
  }
  return a;
};
HCoordinate.prototype.getX = function getX2() {
  var a = this.x / this.w;
  if (Double.isNaN(a) || Double.isInfinite(a)) {
    throw new NotRepresentableException();
  }
  return a;
};
HCoordinate.prototype.getCoordinate = function getCoordinate2() {
  var p = new Coordinate();
  p.x = this.getX();
  p.y = this.getY();
  return p;
};
HCoordinate.prototype.interfaces_ = function interfaces_10() {
  return [];
};
HCoordinate.prototype.getClass = function getClass10() {
  return HCoordinate;
};
HCoordinate.intersection = function intersection5(p1, p2, q1, q2) {
  var px = p1.y - p2.y;
  var py = p2.x - p1.x;
  var pw = p1.x * p2.y - p2.x * p1.y;
  var qx = q1.y - q2.y;
  var qy = q2.x - q1.x;
  var qw = q1.x * q2.y - q2.x * q1.y;
  var x2 = py * qw - qy * pw;
  var y2 = qx * pw - px * qw;
  var w = px * qy - qx * py;
  var xInt = x2 / w;
  var yInt = y2 / w;
  if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
    throw new NotRepresentableException();
  }
  return new Coordinate(xInt, yInt);
};
var Envelope = function Envelope2() {
  this._minx = null;
  this._maxx = null;
  this._miny = null;
  this._maxy = null;
  if (arguments.length === 0) {
    this.init();
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      this.init(p.x, p.x, p.y, p.y);
    } else if (arguments[0] instanceof Envelope2) {
      var env2 = arguments[0];
      this.init(env2);
    }
  } else if (arguments.length === 2) {
    var p1 = arguments[0];
    var p2 = arguments[1];
    this.init(p1.x, p2.x, p1.y, p2.y);
  } else if (arguments.length === 4) {
    var x12 = arguments[0];
    var x2 = arguments[1];
    var y12 = arguments[2];
    var y2 = arguments[3];
    this.init(x12, x2, y12, y2);
  }
};
var staticAccessors$9 = { serialVersionUID: { configurable: true } };
Envelope.prototype.getArea = function getArea() {
  return this.getWidth() * this.getHeight();
};
Envelope.prototype.equals = function equals4(other) {
  if (!(other instanceof Envelope)) {
    return false;
  }
  var otherEnvelope = other;
  if (this.isNull()) {
    return otherEnvelope.isNull();
  }
  return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
};
Envelope.prototype.intersection = function intersection6(env2) {
  if (this.isNull() || env2.isNull() || !this.intersects(env2)) {
    return new Envelope();
  }
  var intMinX = this._minx > env2._minx ? this._minx : env2._minx;
  var intMinY = this._miny > env2._miny ? this._miny : env2._miny;
  var intMaxX = this._maxx < env2._maxx ? this._maxx : env2._maxx;
  var intMaxY = this._maxy < env2._maxy ? this._maxy : env2._maxy;
  return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
};
Envelope.prototype.isNull = function isNull() {
  return this._maxx < this._minx;
};
Envelope.prototype.getMaxX = function getMaxX() {
  return this._maxx;
};
Envelope.prototype.covers = function covers() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      return this.covers(p.x, p.y);
    } else if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      if (this.isNull() || other.isNull()) {
        return false;
      }
      return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    if (this.isNull()) {
      return false;
    }
    return x2 >= this._minx && x2 <= this._maxx && y2 >= this._miny && y2 <= this._maxy;
  }
};
Envelope.prototype.intersects = function intersects2() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      if (this.isNull() || other.isNull()) {
        return false;
      }
      return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
    } else if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      return this.intersects(p.x, p.y);
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    if (this.isNull()) {
      return false;
    }
    return !(x2 > this._maxx || x2 < this._minx || y2 > this._maxy || y2 < this._miny);
  }
};
Envelope.prototype.getMinY = function getMinY() {
  return this._miny;
};
Envelope.prototype.getMinX = function getMinX() {
  return this._minx;
};
Envelope.prototype.expandToInclude = function expandToInclude() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      this.expandToInclude(p.x, p.y);
    } else if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      if (other.isNull()) {
        return null;
      }
      if (this.isNull()) {
        this._minx = other.getMinX();
        this._maxx = other.getMaxX();
        this._miny = other.getMinY();
        this._maxy = other.getMaxY();
      } else {
        if (other._minx < this._minx) {
          this._minx = other._minx;
        }
        if (other._maxx > this._maxx) {
          this._maxx = other._maxx;
        }
        if (other._miny < this._miny) {
          this._miny = other._miny;
        }
        if (other._maxy > this._maxy) {
          this._maxy = other._maxy;
        }
      }
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    if (this.isNull()) {
      this._minx = x2;
      this._maxx = x2;
      this._miny = y2;
      this._maxy = y2;
    } else {
      if (x2 < this._minx) {
        this._minx = x2;
      }
      if (x2 > this._maxx) {
        this._maxx = x2;
      }
      if (y2 < this._miny) {
        this._miny = y2;
      }
      if (y2 > this._maxy) {
        this._maxy = y2;
      }
    }
  }
};
Envelope.prototype.minExtent = function minExtent() {
  if (this.isNull()) {
    return 0;
  }
  var w = this.getWidth();
  var h = this.getHeight();
  if (w < h) {
    return w;
  }
  return h;
};
Envelope.prototype.getWidth = function getWidth() {
  if (this.isNull()) {
    return 0;
  }
  return this._maxx - this._minx;
};
Envelope.prototype.compareTo = function compareTo4(o) {
  var env2 = o;
  if (this.isNull()) {
    if (env2.isNull()) {
      return 0;
    }
    return -1;
  } else {
    if (env2.isNull()) {
      return 1;
    }
  }
  if (this._minx < env2._minx) {
    return -1;
  }
  if (this._minx > env2._minx) {
    return 1;
  }
  if (this._miny < env2._miny) {
    return -1;
  }
  if (this._miny > env2._miny) {
    return 1;
  }
  if (this._maxx < env2._maxx) {
    return -1;
  }
  if (this._maxx > env2._maxx) {
    return 1;
  }
  if (this._maxy < env2._maxy) {
    return -1;
  }
  if (this._maxy > env2._maxy) {
    return 1;
  }
  return 0;
};
Envelope.prototype.translate = function translate(transX, transY) {
  if (this.isNull()) {
    return null;
  }
  this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
};
Envelope.prototype.toString = function toString4() {
  return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
};
Envelope.prototype.setToNull = function setToNull() {
  this._minx = 0;
  this._maxx = -1;
  this._miny = 0;
  this._maxy = -1;
};
Envelope.prototype.getHeight = function getHeight() {
  if (this.isNull()) {
    return 0;
  }
  return this._maxy - this._miny;
};
Envelope.prototype.maxExtent = function maxExtent() {
  if (this.isNull()) {
    return 0;
  }
  var w = this.getWidth();
  var h = this.getHeight();
  if (w > h) {
    return w;
  }
  return h;
};
Envelope.prototype.expandBy = function expandBy() {
  if (arguments.length === 1) {
    var distance11 = arguments[0];
    this.expandBy(distance11, distance11);
  } else if (arguments.length === 2) {
    var deltaX = arguments[0];
    var deltaY = arguments[1];
    if (this.isNull()) {
      return null;
    }
    this._minx -= deltaX;
    this._maxx += deltaX;
    this._miny -= deltaY;
    this._maxy += deltaY;
    if (this._minx > this._maxx || this._miny > this._maxy) {
      this.setToNull();
    }
  }
};
Envelope.prototype.contains = function contains2() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      return this.covers(other);
    } else if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      return this.covers(p);
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    return this.covers(x2, y2);
  }
};
Envelope.prototype.centre = function centre() {
  if (this.isNull()) {
    return null;
  }
  return new Coordinate((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
};
Envelope.prototype.init = function init2() {
  if (arguments.length === 0) {
    this.setToNull();
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      this.init(p.x, p.x, p.y, p.y);
    } else if (arguments[0] instanceof Envelope) {
      var env2 = arguments[0];
      this._minx = env2._minx;
      this._maxx = env2._maxx;
      this._miny = env2._miny;
      this._maxy = env2._maxy;
    }
  } else if (arguments.length === 2) {
    var p1 = arguments[0];
    var p2 = arguments[1];
    this.init(p1.x, p2.x, p1.y, p2.y);
  } else if (arguments.length === 4) {
    var x12 = arguments[0];
    var x2 = arguments[1];
    var y12 = arguments[2];
    var y2 = arguments[3];
    if (x12 < x2) {
      this._minx = x12;
      this._maxx = x2;
    } else {
      this._minx = x2;
      this._maxx = x12;
    }
    if (y12 < y2) {
      this._miny = y12;
      this._maxy = y2;
    } else {
      this._miny = y2;
      this._maxy = y12;
    }
  }
};
Envelope.prototype.getMaxY = function getMaxY() {
  return this._maxy;
};
Envelope.prototype.distance = function distance2(env2) {
  if (this.intersects(env2)) {
    return 0;
  }
  var dx = 0;
  if (this._maxx < env2._minx) {
    dx = env2._minx - this._maxx;
  } else if (this._minx > env2._maxx) {
    dx = this._minx - env2._maxx;
  }
  var dy = 0;
  if (this._maxy < env2._miny) {
    dy = env2._miny - this._maxy;
  } else if (this._miny > env2._maxy) {
    dy = this._miny - env2._maxy;
  }
  if (dx === 0) {
    return dy;
  }
  if (dy === 0) {
    return dx;
  }
  return Math.sqrt(dx * dx + dy * dy);
};
Envelope.prototype.hashCode = function hashCode3() {
  var result = 17;
  result = 37 * result + Coordinate.hashCode(this._minx);
  result = 37 * result + Coordinate.hashCode(this._maxx);
  result = 37 * result + Coordinate.hashCode(this._miny);
  result = 37 * result + Coordinate.hashCode(this._maxy);
  return result;
};
Envelope.prototype.interfaces_ = function interfaces_11() {
  return [Comparable, Serializable];
};
Envelope.prototype.getClass = function getClass11() {
  return Envelope;
};
Envelope.intersects = function intersects3() {
  if (arguments.length === 3) {
    var p1 = arguments[0];
    var p2 = arguments[1];
    var q = arguments[2];
    if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
      return true;
    }
    return false;
  } else if (arguments.length === 4) {
    var p1$1 = arguments[0];
    var p2$1 = arguments[1];
    var q1 = arguments[2];
    var q2 = arguments[3];
    var minq = Math.min(q1.x, q2.x);
    var maxq = Math.max(q1.x, q2.x);
    var minp = Math.min(p1$1.x, p2$1.x);
    var maxp = Math.max(p1$1.x, p2$1.x);
    if (minp > maxq) {
      return false;
    }
    if (maxp < minq) {
      return false;
    }
    minq = Math.min(q1.y, q2.y);
    maxq = Math.max(q1.y, q2.y);
    minp = Math.min(p1$1.y, p2$1.y);
    maxp = Math.max(p1$1.y, p2$1.y);
    if (minp > maxq) {
      return false;
    }
    if (maxp < minq) {
      return false;
    }
    return true;
  }
};
staticAccessors$9.serialVersionUID.get = function() {
  return 5873921885273102e3;
};
Object.defineProperties(Envelope, staticAccessors$9);
var regExes = {
  "typeStr": /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  "emptyTypeStr": /^\s*(\w+)\s*EMPTY\s*$/,
  "spaces": /\s+/,
  "parenComma": /\)\s*,\s*\(/,
  "doubleParenComma": /\)\s*\)\s*,\s*\(\s*\(/,
  "trimParens": /^\s*\(?(.*?)\)?\s*$/
};
var WKTParser = function WKTParser2(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
};
WKTParser.prototype.read = function read(wkt) {
  var geometry2, type, str;
  wkt = wkt.replace(/[\n\r]/g, " ");
  var matches = regExes.typeStr.exec(wkt);
  if (wkt.search("EMPTY") !== -1) {
    matches = regExes.emptyTypeStr.exec(wkt);
    matches[2] = void 0;
  }
  if (matches) {
    type = matches[1].toLowerCase();
    str = matches[2];
    if (parse$1[type]) {
      geometry2 = parse$1[type].apply(this, [str]);
    }
  }
  if (geometry2 === void 0) {
    throw new Error("Could not parse WKT " + wkt);
  }
  return geometry2;
};
WKTParser.prototype.write = function write(geometry2) {
  return this.extractGeometry(geometry2);
};
WKTParser.prototype.extractGeometry = function extractGeometry(geometry2) {
  var type = geometry2.getGeometryType().toLowerCase();
  if (!extract$1[type]) {
    return null;
  }
  var wktType = type.toUpperCase();
  var data;
  if (geometry2.isEmpty()) {
    data = wktType + " EMPTY";
  } else {
    data = wktType + "(" + extract$1[type].apply(this, [geometry2]) + ")";
  }
  return data;
};
var extract$1 = {
  coordinate: function coordinate(coordinate$1) {
    return coordinate$1.x + " " + coordinate$1.y;
  },
  point: function point2(point$1) {
    return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0]);
  },
  multipoint: function multipoint(multipoint$1) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = multipoint$1._geometries.length; i < len2; ++i) {
      array.push("(" + extract$1.point.apply(this$1$1, [multipoint$1._geometries[i]]) + ")");
    }
    return array.join(",");
  },
  linestring: function linestring(linestring$1) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = linestring$1._points._coordinates.length; i < len2; ++i) {
      array.push(extract$1.coordinate.apply(this$1$1, [linestring$1._points._coordinates[i]]));
    }
    return array.join(",");
  },
  linearring: function linearring(linearring$1) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = linearring$1._points._coordinates.length; i < len2; ++i) {
      array.push(extract$1.coordinate.apply(this$1$1, [linearring$1._points._coordinates[i]]));
    }
    return array.join(",");
  },
  multilinestring: function multilinestring(multilinestring$1) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = multilinestring$1._geometries.length; i < len2; ++i) {
      array.push("(" + extract$1.linestring.apply(this$1$1, [multilinestring$1._geometries[i]]) + ")");
    }
    return array.join(",");
  },
  polygon: function polygon2(polygon$1) {
    var this$1$1 = this;
    var array = [];
    array.push("(" + extract$1.linestring.apply(this, [polygon$1._shell]) + ")");
    for (var i = 0, len2 = polygon$1._holes.length; i < len2; ++i) {
      array.push("(" + extract$1.linestring.apply(this$1$1, [polygon$1._holes[i]]) + ")");
    }
    return array.join(",");
  },
  multipolygon: function multipolygon(multipolygon$1) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = multipolygon$1._geometries.length; i < len2; ++i) {
      array.push("(" + extract$1.polygon.apply(this$1$1, [multipolygon$1._geometries[i]]) + ")");
    }
    return array.join(",");
  },
  geometrycollection: function geometrycollection(collection) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = collection._geometries.length; i < len2; ++i) {
      array.push(this$1$1.extractGeometry(collection._geometries[i]));
    }
    return array.join(",");
  }
};
var parse$1 = {
  point: function point3(str) {
    if (str === void 0) {
      return this.geometryFactory.createPoint();
    }
    var coords = str.trim().split(regExes.spaces);
    return this.geometryFactory.createPoint(new Coordinate(
      Number.parseFloat(coords[0]),
      Number.parseFloat(coords[1])
    ));
  },
  multipoint: function multipoint2(str) {
    var this$1$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createMultiPoint();
    }
    var point4;
    var points2 = str.trim().split(",");
    var components = [];
    for (var i = 0, len2 = points2.length; i < len2; ++i) {
      point4 = points2[i].replace(regExes.trimParens, "$1");
      components.push(parse$1.point.apply(this$1$1, [point4]));
    }
    return this.geometryFactory.createMultiPoint(components);
  },
  linestring: function linestring2(str) {
    if (str === void 0) {
      return this.geometryFactory.createLineString();
    }
    var points2 = str.trim().split(",");
    var components = [];
    var coords;
    for (var i = 0, len2 = points2.length; i < len2; ++i) {
      coords = points2[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLineString(components);
  },
  linearring: function linearring2(str) {
    if (str === void 0) {
      return this.geometryFactory.createLinearRing();
    }
    var points2 = str.trim().split(",");
    var components = [];
    var coords;
    for (var i = 0, len2 = points2.length; i < len2; ++i) {
      coords = points2[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLinearRing(components);
  },
  multilinestring: function multilinestring2(str) {
    var this$1$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createMultiLineString();
    }
    var line;
    var lines = str.trim().split(regExes.parenComma);
    var components = [];
    for (var i = 0, len2 = lines.length; i < len2; ++i) {
      line = lines[i].replace(regExes.trimParens, "$1");
      components.push(parse$1.linestring.apply(this$1$1, [line]));
    }
    return this.geometryFactory.createMultiLineString(components);
  },
  polygon: function polygon3(str) {
    var this$1$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createPolygon();
    }
    var ring, linestring3, linearring3;
    var rings = str.trim().split(regExes.parenComma);
    var shell;
    var holes = [];
    for (var i = 0, len2 = rings.length; i < len2; ++i) {
      ring = rings[i].replace(regExes.trimParens, "$1");
      linestring3 = parse$1.linestring.apply(this$1$1, [ring]);
      linearring3 = this$1$1.geometryFactory.createLinearRing(linestring3._points);
      if (i === 0) {
        shell = linearring3;
      } else {
        holes.push(linearring3);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },
  multipolygon: function multipolygon2(str) {
    var this$1$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createMultiPolygon();
    }
    var polygon4;
    var polygons2 = str.trim().split(regExes.doubleParenComma);
    var components = [];
    for (var i = 0, len2 = polygons2.length; i < len2; ++i) {
      polygon4 = polygons2[i].replace(regExes.trimParens, "$1");
      components.push(parse$1.polygon.apply(this$1$1, [polygon4]));
    }
    return this.geometryFactory.createMultiPolygon(components);
  },
  geometrycollection: function geometrycollection2(str) {
    var this$1$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createGeometryCollection();
    }
    str = str.replace(/,\s*([A-Za-z])/g, "|$1");
    var wktArray = str.trim().split("|");
    var components = [];
    for (var i = 0, len2 = wktArray.length; i < len2; ++i) {
      components.push(this$1$1.read(wktArray[i]));
    }
    return this.geometryFactory.createGeometryCollection(components);
  }
};
var WKTWriter = function WKTWriter2(geometryFactory) {
  this.parser = new WKTParser(geometryFactory);
};
WKTWriter.prototype.write = function write2(geometry2) {
  return this.parser.write(geometry2);
};
WKTWriter.toLineString = function toLineString(p0, p1) {
  if (arguments.length !== 2) {
    throw new Error("Not implemented");
  }
  return "LINESTRING ( " + p0.x + " " + p0.y + ", " + p1.x + " " + p1.y + " )";
};
var RuntimeException = function(Error2) {
  function RuntimeException2(message) {
    Error2.call(this, message);
    this.name = "RuntimeException";
    this.message = message;
    this.stack = new Error2().stack;
  }
  if (Error2)
    RuntimeException2.__proto__ = Error2;
  RuntimeException2.prototype = Object.create(Error2 && Error2.prototype);
  RuntimeException2.prototype.constructor = RuntimeException2;
  return RuntimeException2;
}(Error);
var AssertionFailedException = function(RuntimeException$$1) {
  function AssertionFailedException2() {
    RuntimeException$$1.call(this);
    if (arguments.length === 0) {
      RuntimeException$$1.call(this);
    } else if (arguments.length === 1) {
      var message = arguments[0];
      RuntimeException$$1.call(this, message);
    }
  }
  if (RuntimeException$$1)
    AssertionFailedException2.__proto__ = RuntimeException$$1;
  AssertionFailedException2.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
  AssertionFailedException2.prototype.constructor = AssertionFailedException2;
  AssertionFailedException2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  AssertionFailedException2.prototype.getClass = function getClass169() {
    return AssertionFailedException2;
  };
  return AssertionFailedException2;
}(RuntimeException);
var Assert = function Assert2() {
};
Assert.prototype.interfaces_ = function interfaces_12() {
  return [];
};
Assert.prototype.getClass = function getClass12() {
  return Assert;
};
Assert.shouldNeverReachHere = function shouldNeverReachHere() {
  if (arguments.length === 0) {
    Assert.shouldNeverReachHere(null);
  } else if (arguments.length === 1) {
    var message = arguments[0];
    throw new AssertionFailedException("Should never reach here" + (message !== null ? ": " + message : ""));
  }
};
Assert.isTrue = function isTrue() {
  var assertion;
  var message;
  if (arguments.length === 1) {
    assertion = arguments[0];
    Assert.isTrue(assertion, null);
  } else if (arguments.length === 2) {
    assertion = arguments[0];
    message = arguments[1];
    if (!assertion) {
      if (message === null) {
        throw new AssertionFailedException();
      } else {
        throw new AssertionFailedException(message);
      }
    }
  }
};
Assert.equals = function equals5() {
  var expectedValue;
  var actualValue;
  var message;
  if (arguments.length === 2) {
    expectedValue = arguments[0];
    actualValue = arguments[1];
    Assert.equals(expectedValue, actualValue, null);
  } else if (arguments.length === 3) {
    expectedValue = arguments[0];
    actualValue = arguments[1];
    message = arguments[2];
    if (!actualValue.equals(expectedValue)) {
      throw new AssertionFailedException("Expected " + expectedValue + " but encountered " + actualValue + (message !== null ? ": " + message : ""));
    }
  }
};
var LineIntersector = function LineIntersector2() {
  this._result = null;
  this._inputLines = Array(2).fill().map(function() {
    return Array(2);
  });
  this._intPt = new Array(2).fill(null);
  this._intLineIndex = null;
  this._isProper = null;
  this._pa = null;
  this._pb = null;
  this._precisionModel = null;
  this._intPt[0] = new Coordinate();
  this._intPt[1] = new Coordinate();
  this._pa = this._intPt[0];
  this._pb = this._intPt[1];
  this._result = 0;
};
var staticAccessors$10 = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
LineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment(segmentIndex, intIndex) {
  this.computeIntLineIndex();
  return this._intLineIndex[segmentIndex][intIndex];
};
LineIntersector.prototype.getTopologySummary = function getTopologySummary() {
  var catBuf = new StringBuffer();
  if (this.isEndPoint()) {
    catBuf.append(" endpoint");
  }
  if (this._isProper) {
    catBuf.append(" proper");
  }
  if (this.isCollinear()) {
    catBuf.append(" collinear");
  }
  return catBuf.toString();
};
LineIntersector.prototype.computeIntersection = function computeIntersection(p1, p2, p3, p4) {
  this._inputLines[0][0] = p1;
  this._inputLines[0][1] = p2;
  this._inputLines[1][0] = p3;
  this._inputLines[1][1] = p4;
  this._result = this.computeIntersect(p1, p2, p3, p4);
};
LineIntersector.prototype.getIntersectionNum = function getIntersectionNum() {
  return this._result;
};
LineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex() {
  if (arguments.length === 0) {
    if (this._intLineIndex === null) {
      this._intLineIndex = Array(2).fill().map(function() {
        return Array(2);
      });
      this.computeIntLineIndex(0);
      this.computeIntLineIndex(1);
    }
  } else if (arguments.length === 1) {
    var segmentIndex = arguments[0];
    var dist0 = this.getEdgeDistance(segmentIndex, 0);
    var dist1 = this.getEdgeDistance(segmentIndex, 1);
    if (dist0 > dist1) {
      this._intLineIndex[segmentIndex][0] = 0;
      this._intLineIndex[segmentIndex][1] = 1;
    } else {
      this._intLineIndex[segmentIndex][0] = 1;
      this._intLineIndex[segmentIndex][1] = 0;
    }
  }
};
LineIntersector.prototype.isProper = function isProper() {
  return this.hasIntersection() && this._isProper;
};
LineIntersector.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {
  this._precisionModel = precisionModel;
};
LineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    if (this.isInteriorIntersection(0)) {
      return true;
    }
    if (this.isInteriorIntersection(1)) {
      return true;
    }
    return false;
  } else if (arguments.length === 1) {
    var inputLineIndex = arguments[0];
    for (var i = 0; i < this._result; i++) {
      if (!(this$1$1._intPt[i].equals2D(this$1$1._inputLines[inputLineIndex][0]) || this$1$1._intPt[i].equals2D(this$1$1._inputLines[inputLineIndex][1]))) {
        return true;
      }
    }
    return false;
  }
};
LineIntersector.prototype.getIntersection = function getIntersection(intIndex) {
  return this._intPt[intIndex];
};
LineIntersector.prototype.isEndPoint = function isEndPoint() {
  return this.hasIntersection() && !this._isProper;
};
LineIntersector.prototype.hasIntersection = function hasIntersection() {
  return this._result !== LineIntersector.NO_INTERSECTION;
};
LineIntersector.prototype.getEdgeDistance = function getEdgeDistance(segmentIndex, intIndex) {
  var dist3 = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
  return dist3;
};
LineIntersector.prototype.isCollinear = function isCollinear() {
  return this._result === LineIntersector.COLLINEAR_INTERSECTION;
};
LineIntersector.prototype.toString = function toString5() {
  return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
};
LineIntersector.prototype.getEndpoint = function getEndpoint(segmentIndex, ptIndex) {
  return this._inputLines[segmentIndex][ptIndex];
};
LineIntersector.prototype.isIntersection = function isIntersection(pt) {
  var this$1$1 = this;
  for (var i = 0; i < this._result; i++) {
    if (this$1$1._intPt[i].equals2D(pt)) {
      return true;
    }
  }
  return false;
};
LineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment(segmentIndex, intIndex) {
  this.computeIntLineIndex();
  return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
};
LineIntersector.prototype.interfaces_ = function interfaces_13() {
  return [];
};
LineIntersector.prototype.getClass = function getClass13() {
  return LineIntersector;
};
LineIntersector.computeEdgeDistance = function computeEdgeDistance(p, p0, p1) {
  var dx = Math.abs(p1.x - p0.x);
  var dy = Math.abs(p1.y - p0.y);
  var dist3 = -1;
  if (p.equals(p0)) {
    dist3 = 0;
  } else if (p.equals(p1)) {
    if (dx > dy) {
      dist3 = dx;
    } else {
      dist3 = dy;
    }
  } else {
    var pdx = Math.abs(p.x - p0.x);
    var pdy = Math.abs(p.y - p0.y);
    if (dx > dy) {
      dist3 = pdx;
    } else {
      dist3 = pdy;
    }
    if (dist3 === 0 && !p.equals(p0)) {
      dist3 = Math.max(pdx, pdy);
    }
  }
  Assert.isTrue(!(dist3 === 0 && !p.equals(p0)), "Bad distance calculation");
  return dist3;
};
LineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance(p, p1, p2) {
  var dx = p.x - p1.x;
  var dy = p.y - p1.y;
  var dist3 = Math.sqrt(dx * dx + dy * dy);
  Assert.isTrue(!(dist3 === 0 && !p.equals(p1)), "Invalid distance calculation");
  return dist3;
};
staticAccessors$10.DONT_INTERSECT.get = function() {
  return 0;
};
staticAccessors$10.DO_INTERSECT.get = function() {
  return 1;
};
staticAccessors$10.COLLINEAR.get = function() {
  return 2;
};
staticAccessors$10.NO_INTERSECTION.get = function() {
  return 0;
};
staticAccessors$10.POINT_INTERSECTION.get = function() {
  return 1;
};
staticAccessors$10.COLLINEAR_INTERSECTION.get = function() {
  return 2;
};
Object.defineProperties(LineIntersector, staticAccessors$10);
var RobustLineIntersector = function(LineIntersector$$1) {
  function RobustLineIntersector2() {
    LineIntersector$$1.apply(this, arguments);
  }
  if (LineIntersector$$1)
    RobustLineIntersector2.__proto__ = LineIntersector$$1;
  RobustLineIntersector2.prototype = Object.create(LineIntersector$$1 && LineIntersector$$1.prototype);
  RobustLineIntersector2.prototype.constructor = RobustLineIntersector2;
  RobustLineIntersector2.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes(intPt) {
    var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
    var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
    return env0.contains(intPt) && env1.contains(intPt);
  };
  RobustLineIntersector2.prototype.computeIntersection = function computeIntersection2() {
    if (arguments.length === 3) {
      var p = arguments[0];
      var p1 = arguments[1];
      var p2 = arguments[2];
      this._isProper = false;
      if (Envelope.intersects(p1, p2, p)) {
        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
          this._isProper = true;
          if (p.equals(p1) || p.equals(p2)) {
            this._isProper = false;
          }
          this._result = LineIntersector$$1.POINT_INTERSECTION;
          return null;
        }
      }
      this._result = LineIntersector$$1.NO_INTERSECTION;
    } else {
      return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments);
    }
  };
  RobustLineIntersector2.prototype.normalizeToMinimum = function normalizeToMinimum(n1, n2, n3, n4, normPt) {
    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
    n1.x -= normPt.x;
    n1.y -= normPt.y;
    n2.x -= normPt.x;
    n2.y -= normPt.y;
    n3.x -= normPt.x;
    n3.y -= normPt.y;
    n4.x -= normPt.x;
    n4.y -= normPt.y;
  };
  RobustLineIntersector2.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection(p1, p2, q1, q2) {
    var intPt = null;
    try {
      intPt = HCoordinate.intersection(p1, p2, q1, q2);
    } catch (e2) {
      if (e2 instanceof NotRepresentableException) {
        intPt = RobustLineIntersector2.nearestEndpoint(p1, p2, q1, q2);
      } else {
        throw e2;
      }
    } finally {
    }
    return intPt;
  };
  RobustLineIntersector2.prototype.intersection = function intersection11(p1, p2, q1, q2) {
    var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
    if (!this.isInSegmentEnvelopes(intPt)) {
      intPt = new Coordinate(RobustLineIntersector2.nearestEndpoint(p1, p2, q1, q2));
    }
    if (this._precisionModel !== null) {
      this._precisionModel.makePrecise(intPt);
    }
    return intPt;
  };
  RobustLineIntersector2.prototype.smallestInAbsValue = function smallestInAbsValue(x12, x2, x3, x4) {
    var x5 = x12;
    var xabs = Math.abs(x5);
    if (Math.abs(x2) < xabs) {
      x5 = x2;
      xabs = Math.abs(x2);
    }
    if (Math.abs(x3) < xabs) {
      x5 = x3;
      xabs = Math.abs(x3);
    }
    if (Math.abs(x4) < xabs) {
      x5 = x4;
    }
    return x5;
  };
  RobustLineIntersector2.prototype.checkDD = function checkDD(p1, p2, q1, q2, intPt) {
    var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
    var isIn = this.isInSegmentEnvelopes(intPtDD);
    System.out.println("DD in env = " + isIn + "  --------------------- " + intPtDD);
    if (intPt.distance(intPtDD) > 1e-4) {
      System.out.println("Distance = " + intPt.distance(intPtDD));
    }
  };
  RobustLineIntersector2.prototype.intersectionWithNormalization = function intersectionWithNormalization(p1, p2, q1, q2) {
    var n1 = new Coordinate(p1);
    var n2 = new Coordinate(p2);
    var n3 = new Coordinate(q1);
    var n4 = new Coordinate(q2);
    var normPt = new Coordinate();
    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
    var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
    intPt.x += normPt.x;
    intPt.y += normPt.y;
    return intPt;
  };
  RobustLineIntersector2.prototype.computeCollinearIntersection = function computeCollinearIntersection(p1, p2, q1, q2) {
    var p1q1p2 = Envelope.intersects(p1, p2, q1);
    var p1q2p2 = Envelope.intersects(p1, p2, q2);
    var q1p1q2 = Envelope.intersects(q1, q2, p1);
    var q1p2q2 = Envelope.intersects(q1, q2, p2);
    if (p1q1p2 && p1q2p2) {
      this._intPt[0] = q1;
      this._intPt[1] = q2;
      return LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (q1p1q2 && q1p2q2) {
      this._intPt[0] = p1;
      this._intPt[1] = p2;
      return LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q1p2 && q1p1q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p1;
      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q1p2 && q1p2q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p2;
      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q2p2 && q1p1q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p1;
      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q2p2 && q1p2q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p2;
      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    return LineIntersector$$1.NO_INTERSECTION;
  };
  RobustLineIntersector2.prototype.normalizeToEnvCentre = function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {
    var minX0 = n00.x < n01.x ? n00.x : n01.x;
    var minY0 = n00.y < n01.y ? n00.y : n01.y;
    var maxX0 = n00.x > n01.x ? n00.x : n01.x;
    var maxY0 = n00.y > n01.y ? n00.y : n01.y;
    var minX1 = n10.x < n11.x ? n10.x : n11.x;
    var minY1 = n10.y < n11.y ? n10.y : n11.y;
    var maxX1 = n10.x > n11.x ? n10.x : n11.x;
    var maxY1 = n10.y > n11.y ? n10.y : n11.y;
    var intMinX = minX0 > minX1 ? minX0 : minX1;
    var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
    var intMinY = minY0 > minY1 ? minY0 : minY1;
    var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
    var intMidX = (intMinX + intMaxX) / 2;
    var intMidY = (intMinY + intMaxY) / 2;
    normPt.x = intMidX;
    normPt.y = intMidY;
    n00.x -= normPt.x;
    n00.y -= normPt.y;
    n01.x -= normPt.x;
    n01.y -= normPt.y;
    n10.x -= normPt.x;
    n10.y -= normPt.y;
    n11.x -= normPt.x;
    n11.y -= normPt.y;
  };
  RobustLineIntersector2.prototype.computeIntersect = function computeIntersect(p1, p2, q1, q2) {
    this._isProper = false;
    if (!Envelope.intersects(p1, p2, q1, q2)) {
      return LineIntersector$$1.NO_INTERSECTION;
    }
    var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
    var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
    if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
      return LineIntersector$$1.NO_INTERSECTION;
    }
    var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
    var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
    if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
      return LineIntersector$$1.NO_INTERSECTION;
    }
    var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
    if (collinear) {
      return this.computeCollinearIntersection(p1, p2, q1, q2);
    }
    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
      this._isProper = false;
      if (p1.equals2D(q1) || p1.equals2D(q2)) {
        this._intPt[0] = p1;
      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
        this._intPt[0] = p2;
      } else if (Pq1 === 0) {
        this._intPt[0] = new Coordinate(q1);
      } else if (Pq2 === 0) {
        this._intPt[0] = new Coordinate(q2);
      } else if (Qp1 === 0) {
        this._intPt[0] = new Coordinate(p1);
      } else if (Qp2 === 0) {
        this._intPt[0] = new Coordinate(p2);
      }
    } else {
      this._isProper = true;
      this._intPt[0] = this.intersection(p1, p2, q1, q2);
    }
    return LineIntersector$$1.POINT_INTERSECTION;
  };
  RobustLineIntersector2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  RobustLineIntersector2.prototype.getClass = function getClass169() {
    return RobustLineIntersector2;
  };
  RobustLineIntersector2.nearestEndpoint = function nearestEndpoint(p1, p2, q1, q2) {
    var nearestPt = p1;
    var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
    var dist3 = CGAlgorithms.distancePointLine(p2, q1, q2);
    if (dist3 < minDist) {
      minDist = dist3;
      nearestPt = p2;
    }
    dist3 = CGAlgorithms.distancePointLine(q1, p1, p2);
    if (dist3 < minDist) {
      minDist = dist3;
      nearestPt = q1;
    }
    dist3 = CGAlgorithms.distancePointLine(q2, p1, p2);
    if (dist3 < minDist) {
      minDist = dist3;
      nearestPt = q2;
    }
    return nearestPt;
  };
  return RobustLineIntersector2;
}(LineIntersector);
var RobustDeterminant = function RobustDeterminant2() {
};
RobustDeterminant.prototype.interfaces_ = function interfaces_14() {
  return [];
};
RobustDeterminant.prototype.getClass = function getClass14() {
  return RobustDeterminant;
};
RobustDeterminant.orientationIndex = function orientationIndex3(p1, p2, q) {
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dx2 = q.x - p2.x;
  var dy2 = q.y - p2.y;
  return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
};
RobustDeterminant.signOfDet2x2 = function signOfDet2x22(x12, y12, x2, y2) {
  var sign2 = null;
  var swap2 = null;
  var k = null;
  sign2 = 1;
  if (x12 === 0 || y2 === 0) {
    if (y12 === 0 || x2 === 0) {
      return 0;
    } else if (y12 > 0) {
      if (x2 > 0) {
        return -sign2;
      } else {
        return sign2;
      }
    } else {
      if (x2 > 0) {
        return sign2;
      } else {
        return -sign2;
      }
    }
  }
  if (y12 === 0 || x2 === 0) {
    if (y2 > 0) {
      if (x12 > 0) {
        return sign2;
      } else {
        return -sign2;
      }
    } else {
      if (x12 > 0) {
        return -sign2;
      } else {
        return sign2;
      }
    }
  }
  if (y12 > 0) {
    if (y2 > 0) {
      if (y12 <= y2)
        ;
      else {
        sign2 = -sign2;
        swap2 = x12;
        x12 = x2;
        x2 = swap2;
        swap2 = y12;
        y12 = y2;
        y2 = swap2;
      }
    } else {
      if (y12 <= -y2) {
        sign2 = -sign2;
        x2 = -x2;
        y2 = -y2;
      } else {
        swap2 = x12;
        x12 = -x2;
        x2 = swap2;
        swap2 = y12;
        y12 = -y2;
        y2 = swap2;
      }
    }
  } else {
    if (y2 > 0) {
      if (-y12 <= y2) {
        sign2 = -sign2;
        x12 = -x12;
        y12 = -y12;
      } else {
        swap2 = -x12;
        x12 = x2;
        x2 = swap2;
        swap2 = -y12;
        y12 = y2;
        y2 = swap2;
      }
    } else {
      if (y12 >= y2) {
        x12 = -x12;
        y12 = -y12;
        x2 = -x2;
        y2 = -y2;
      } else {
        sign2 = -sign2;
        swap2 = -x12;
        x12 = -x2;
        x2 = swap2;
        swap2 = -y12;
        y12 = -y2;
        y2 = swap2;
      }
    }
  }
  if (x12 > 0) {
    if (x2 > 0) {
      if (x12 <= x2)
        ;
      else {
        return sign2;
      }
    } else {
      return sign2;
    }
  } else {
    if (x2 > 0) {
      return -sign2;
    } else {
      if (x12 >= x2) {
        sign2 = -sign2;
        x12 = -x12;
        x2 = -x2;
      } else {
        return -sign2;
      }
    }
  }
  while (true) {
    k = Math.floor(x2 / x12);
    x2 = x2 - k * x12;
    y2 = y2 - k * y12;
    if (y2 < 0) {
      return -sign2;
    }
    if (y2 > y12) {
      return sign2;
    }
    if (x12 > x2 + x2) {
      if (y12 < y2 + y2) {
        return sign2;
      }
    } else {
      if (y12 > y2 + y2) {
        return -sign2;
      } else {
        x2 = x12 - x2;
        y2 = y12 - y2;
        sign2 = -sign2;
      }
    }
    if (y2 === 0) {
      if (x2 === 0) {
        return 0;
      } else {
        return -sign2;
      }
    }
    if (x2 === 0) {
      return sign2;
    }
    k = Math.floor(x12 / x2);
    x12 = x12 - k * x2;
    y12 = y12 - k * y2;
    if (y12 < 0) {
      return sign2;
    }
    if (y12 > y2) {
      return -sign2;
    }
    if (x2 > x12 + x12) {
      if (y2 < y12 + y12) {
        return -sign2;
      }
    } else {
      if (y2 > y12 + y12) {
        return sign2;
      } else {
        x12 = x2 - x12;
        y12 = y2 - y12;
        sign2 = -sign2;
      }
    }
    if (y12 === 0) {
      if (x12 === 0) {
        return 0;
      } else {
        return sign2;
      }
    }
    if (x12 === 0) {
      return -sign2;
    }
  }
};
var RayCrossingCounter = function RayCrossingCounter2() {
  this._p = null;
  this._crossingCount = 0;
  this._isPointOnSegment = false;
  var p = arguments[0];
  this._p = p;
};
RayCrossingCounter.prototype.countSegment = function countSegment(p1, p2) {
  if (p1.x < this._p.x && p2.x < this._p.x) {
    return null;
  }
  if (this._p.x === p2.x && this._p.y === p2.y) {
    this._isPointOnSegment = true;
    return null;
  }
  if (p1.y === this._p.y && p2.y === this._p.y) {
    var minx = p1.x;
    var maxx = p2.x;
    if (minx > maxx) {
      minx = p2.x;
      maxx = p1.x;
    }
    if (this._p.x >= minx && this._p.x <= maxx) {
      this._isPointOnSegment = true;
    }
    return null;
  }
  if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
    var x12 = p1.x - this._p.x;
    var y12 = p1.y - this._p.y;
    var x2 = p2.x - this._p.x;
    var y2 = p2.y - this._p.y;
    var xIntSign = RobustDeterminant.signOfDet2x2(x12, y12, x2, y2);
    if (xIntSign === 0) {
      this._isPointOnSegment = true;
      return null;
    }
    if (y2 < y12) {
      xIntSign = -xIntSign;
    }
    if (xIntSign > 0) {
      this._crossingCount++;
    }
  }
};
RayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon() {
  return this.getLocation() !== Location.EXTERIOR;
};
RayCrossingCounter.prototype.getLocation = function getLocation() {
  if (this._isPointOnSegment) {
    return Location.BOUNDARY;
  }
  if (this._crossingCount % 2 === 1) {
    return Location.INTERIOR;
  }
  return Location.EXTERIOR;
};
RayCrossingCounter.prototype.isOnSegment = function isOnSegment() {
  return this._isPointOnSegment;
};
RayCrossingCounter.prototype.interfaces_ = function interfaces_15() {
  return [];
};
RayCrossingCounter.prototype.getClass = function getClass15() {
  return RayCrossingCounter;
};
RayCrossingCounter.locatePointInRing = function locatePointInRing() {
  if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
    var p = arguments[0];
    var ring = arguments[1];
    var counter = new RayCrossingCounter(p);
    var p1 = new Coordinate();
    var p2 = new Coordinate();
    for (var i = 1; i < ring.size(); i++) {
      ring.getCoordinate(i, p1);
      ring.getCoordinate(i - 1, p2);
      counter.countSegment(p1, p2);
      if (counter.isOnSegment()) {
        return counter.getLocation();
      }
    }
    return counter.getLocation();
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
    var p$1 = arguments[0];
    var ring$1 = arguments[1];
    var counter$1 = new RayCrossingCounter(p$1);
    for (var i$1 = 1; i$1 < ring$1.length; i$1++) {
      var p1$1 = ring$1[i$1];
      var p2$1 = ring$1[i$1 - 1];
      counter$1.countSegment(p1$1, p2$1);
      if (counter$1.isOnSegment()) {
        return counter$1.getLocation();
      }
    }
    return counter$1.getLocation();
  }
};
var CGAlgorithms = function CGAlgorithms2() {
};
var staticAccessors$3 = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
CGAlgorithms.prototype.interfaces_ = function interfaces_16() {
  return [];
};
CGAlgorithms.prototype.getClass = function getClass16() {
  return CGAlgorithms;
};
CGAlgorithms.orientationIndex = function orientationIndex4(p1, p2, q) {
  return CGAlgorithmsDD.orientationIndex(p1, p2, q);
};
CGAlgorithms.signedArea = function signedArea2() {
  if (arguments[0] instanceof Array) {
    var ring = arguments[0];
    if (ring.length < 3) {
      return 0;
    }
    var sum2 = 0;
    var x02 = ring[0].x;
    for (var i = 1; i < ring.length - 1; i++) {
      var x2 = ring[i].x - x02;
      var y12 = ring[i + 1].y;
      var y2 = ring[i - 1].y;
      sum2 += x2 * (y2 - y12);
    }
    return sum2 / 2;
  } else if (hasInterface(arguments[0], CoordinateSequence)) {
    var ring$1 = arguments[0];
    var n = ring$1.size();
    if (n < 3) {
      return 0;
    }
    var p0 = new Coordinate();
    var p1 = new Coordinate();
    var p2 = new Coordinate();
    ring$1.getCoordinate(0, p1);
    ring$1.getCoordinate(1, p2);
    var x0$1 = p1.x;
    p2.x -= x0$1;
    var sum$12 = 0;
    for (var i$1 = 1; i$1 < n - 1; i$1++) {
      p0.y = p1.y;
      p1.x = p2.x;
      p1.y = p2.y;
      ring$1.getCoordinate(i$1 + 1, p2);
      p2.x -= x0$1;
      sum$12 += p1.x * (p0.y - p2.y);
    }
    return sum$12 / 2;
  }
};
CGAlgorithms.distanceLineLine = function distanceLineLine(A, B2, C, D) {
  if (A.equals(B2)) {
    return CGAlgorithms.distancePointLine(A, C, D);
  }
  if (C.equals(D)) {
    return CGAlgorithms.distancePointLine(D, A, B2);
  }
  var noIntersection = false;
  if (!Envelope.intersects(A, B2, C, D)) {
    noIntersection = true;
  } else {
    var denom = (B2.x - A.x) * (D.y - C.y) - (B2.y - A.y) * (D.x - C.x);
    if (denom === 0) {
      noIntersection = true;
    } else {
      var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
      var sNum = (A.y - C.y) * (B2.x - A.x) - (A.x - C.x) * (B2.y - A.y);
      var s = sNum / denom;
      var r = rNumb / denom;
      if (r < 0 || r > 1 || s < 0 || s > 1) {
        noIntersection = true;
      }
    }
  }
  if (noIntersection) {
    return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B2, C, D), CGAlgorithms.distancePointLine(C, A, B2), CGAlgorithms.distancePointLine(D, A, B2));
  }
  return 0;
};
CGAlgorithms.isPointInRing = function isPointInRing(p, ring) {
  return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;
};
CGAlgorithms.computeLength = function computeLength(pts) {
  var n = pts.size();
  if (n <= 1) {
    return 0;
  }
  var len2 = 0;
  var p = new Coordinate();
  pts.getCoordinate(0, p);
  var x02 = p.x;
  var y02 = p.y;
  for (var i = 1; i < n; i++) {
    pts.getCoordinate(i, p);
    var x12 = p.x;
    var y12 = p.y;
    var dx = x12 - x02;
    var dy = y12 - y02;
    len2 += Math.sqrt(dx * dx + dy * dy);
    x02 = x12;
    y02 = y12;
  }
  return len2;
};
CGAlgorithms.isCCW = function isCCW(ring) {
  var nPts = ring.length - 1;
  if (nPts < 3) {
    throw new IllegalArgumentException("Ring has fewer than 4 points, so orientation cannot be determined");
  }
  var hiPt = ring[0];
  var hiIndex = 0;
  for (var i = 1; i <= nPts; i++) {
    var p = ring[i];
    if (p.y > hiPt.y) {
      hiPt = p;
      hiIndex = i;
    }
  }
  var iPrev = hiIndex;
  do {
    iPrev = iPrev - 1;
    if (iPrev < 0) {
      iPrev = nPts;
    }
  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
  var iNext = hiIndex;
  do {
    iNext = (iNext + 1) % nPts;
  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
  var prev = ring[iPrev];
  var next3 = ring[iNext];
  if (prev.equals2D(hiPt) || next3.equals2D(hiPt) || prev.equals2D(next3)) {
    return false;
  }
  var disc = CGAlgorithms.computeOrientation(prev, hiPt, next3);
  var isCCW2 = false;
  if (disc === 0) {
    isCCW2 = prev.x > next3.x;
  } else {
    isCCW2 = disc > 0;
  }
  return isCCW2;
};
CGAlgorithms.locatePointInRing = function locatePointInRing2(p, ring) {
  return RayCrossingCounter.locatePointInRing(p, ring);
};
CGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular(p, A, B2) {
  var len2 = (B2.x - A.x) * (B2.x - A.x) + (B2.y - A.y) * (B2.y - A.y);
  var s = ((A.y - p.y) * (B2.x - A.x) - (A.x - p.x) * (B2.y - A.y)) / len2;
  return Math.abs(s) * Math.sqrt(len2);
};
CGAlgorithms.computeOrientation = function computeOrientation(p1, p2, q) {
  return CGAlgorithms.orientationIndex(p1, p2, q);
};
CGAlgorithms.distancePointLine = function distancePointLine() {
  if (arguments.length === 2) {
    var p = arguments[0];
    var line = arguments[1];
    if (line.length === 0) {
      throw new IllegalArgumentException("Line array must contain at least one vertex");
    }
    var minDistance = p.distance(line[0]);
    for (var i = 0; i < line.length - 1; i++) {
      var dist3 = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
      if (dist3 < minDistance) {
        minDistance = dist3;
      }
    }
    return minDistance;
  } else if (arguments.length === 3) {
    var p$1 = arguments[0];
    var A = arguments[1];
    var B2 = arguments[2];
    if (A.x === B2.x && A.y === B2.y) {
      return p$1.distance(A);
    }
    var len2 = (B2.x - A.x) * (B2.x - A.x) + (B2.y - A.y) * (B2.y - A.y);
    var r = ((p$1.x - A.x) * (B2.x - A.x) + (p$1.y - A.y) * (B2.y - A.y)) / len2;
    if (r <= 0) {
      return p$1.distance(A);
    }
    if (r >= 1) {
      return p$1.distance(B2);
    }
    var s = ((A.y - p$1.y) * (B2.x - A.x) - (A.x - p$1.x) * (B2.y - A.y)) / len2;
    return Math.abs(s) * Math.sqrt(len2);
  }
};
CGAlgorithms.isOnLine = function isOnLine(p, pt) {
  var lineIntersector = new RobustLineIntersector();
  for (var i = 1; i < pt.length; i++) {
    var p0 = pt[i - 1];
    var p1 = pt[i];
    lineIntersector.computeIntersection(p, p0, p1);
    if (lineIntersector.hasIntersection()) {
      return true;
    }
  }
  return false;
};
staticAccessors$3.CLOCKWISE.get = function() {
  return -1;
};
staticAccessors$3.RIGHT.get = function() {
  return CGAlgorithms.CLOCKWISE;
};
staticAccessors$3.COUNTERCLOCKWISE.get = function() {
  return 1;
};
staticAccessors$3.LEFT.get = function() {
  return CGAlgorithms.COUNTERCLOCKWISE;
};
staticAccessors$3.COLLINEAR.get = function() {
  return 0;
};
staticAccessors$3.STRAIGHT.get = function() {
  return CGAlgorithms.COLLINEAR;
};
Object.defineProperties(CGAlgorithms, staticAccessors$3);
var GeometryComponentFilter = function GeometryComponentFilter2() {
};
GeometryComponentFilter.prototype.filter = function filter(geom) {
};
GeometryComponentFilter.prototype.interfaces_ = function interfaces_17() {
  return [];
};
GeometryComponentFilter.prototype.getClass = function getClass17() {
  return GeometryComponentFilter;
};
var Geometry = function Geometry2() {
  var factory = arguments[0];
  this._envelope = null;
  this._factory = null;
  this._SRID = null;
  this._userData = null;
  this._factory = factory;
  this._SRID = factory.getSRID();
};
var staticAccessors$11 = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
Geometry.prototype.isGeometryCollection = function isGeometryCollection() {
  return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;
};
Geometry.prototype.getFactory = function getFactory() {
  return this._factory;
};
Geometry.prototype.getGeometryN = function getGeometryN(n) {
  return this;
};
Geometry.prototype.getArea = function getArea2() {
  return 0;
};
Geometry.prototype.isRectangle = function isRectangle() {
  return false;
};
Geometry.prototype.equals = function equals6() {
  if (arguments[0] instanceof Geometry) {
    var g$1 = arguments[0];
    if (g$1 === null) {
      return false;
    }
    return this.equalsTopo(g$1);
  } else if (arguments[0] instanceof Object) {
    var o = arguments[0];
    if (!(o instanceof Geometry)) {
      return false;
    }
    var g = o;
    return this.equalsExact(g);
  }
};
Geometry.prototype.equalsExact = function equalsExact(other) {
  return this === other || this.equalsExact(other, 0);
};
Geometry.prototype.geometryChanged = function geometryChanged() {
  this.apply(Geometry.geometryChangedFilter);
};
Geometry.prototype.geometryChangedAction = function geometryChangedAction() {
  this._envelope = null;
};
Geometry.prototype.equalsNorm = function equalsNorm(g) {
  if (g === null) {
    return false;
  }
  return this.norm().equalsExact(g.norm());
};
Geometry.prototype.getLength = function getLength() {
  return 0;
};
Geometry.prototype.getNumGeometries = function getNumGeometries() {
  return 1;
};
Geometry.prototype.compareTo = function compareTo5() {
  if (arguments.length === 1) {
    var o = arguments[0];
    var other = o;
    if (this.getSortIndex() !== other.getSortIndex()) {
      return this.getSortIndex() - other.getSortIndex();
    }
    if (this.isEmpty() && other.isEmpty()) {
      return 0;
    }
    if (this.isEmpty()) {
      return -1;
    }
    if (other.isEmpty()) {
      return 1;
    }
    return this.compareToSameClass(o);
  } else if (arguments.length === 2) {
    var other$1 = arguments[0];
    var comp = arguments[1];
    if (this.getSortIndex() !== other$1.getSortIndex()) {
      return this.getSortIndex() - other$1.getSortIndex();
    }
    if (this.isEmpty() && other$1.isEmpty()) {
      return 0;
    }
    if (this.isEmpty()) {
      return -1;
    }
    if (other$1.isEmpty()) {
      return 1;
    }
    return this.compareToSameClass(other$1, comp);
  }
};
Geometry.prototype.getUserData = function getUserData() {
  return this._userData;
};
Geometry.prototype.getSRID = function getSRID() {
  return this._SRID;
};
Geometry.prototype.getEnvelope = function getEnvelope() {
  return this.getFactory().toGeometry(this.getEnvelopeInternal());
};
Geometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection(g) {
  if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
    throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
  }
};
Geometry.prototype.equal = function equal(a, b, tolerance) {
  if (tolerance === 0) {
    return a.equals(b);
  }
  return a.distance(b) <= tolerance;
};
Geometry.prototype.norm = function norm() {
  var copy8 = this.copy();
  copy8.normalize();
  return copy8;
};
Geometry.prototype.getPrecisionModel = function getPrecisionModel() {
  return this._factory.getPrecisionModel();
};
Geometry.prototype.getEnvelopeInternal = function getEnvelopeInternal() {
  if (this._envelope === null) {
    this._envelope = this.computeEnvelopeInternal();
  }
  return new Envelope(this._envelope);
};
Geometry.prototype.setSRID = function setSRID(SRID) {
  this._SRID = SRID;
};
Geometry.prototype.setUserData = function setUserData(userData) {
  this._userData = userData;
};
Geometry.prototype.compare = function compare3(a, b) {
  var i = a.iterator();
  var j = b.iterator();
  while (i.hasNext() && j.hasNext()) {
    var aElement = i.next();
    var bElement = j.next();
    var comparison = aElement.compareTo(bElement);
    if (comparison !== 0) {
      return comparison;
    }
  }
  if (i.hasNext()) {
    return 1;
  }
  if (j.hasNext()) {
    return -1;
  }
  return 0;
};
Geometry.prototype.hashCode = function hashCode4() {
  return this.getEnvelopeInternal().hashCode();
};
Geometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived() {
  if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
    return true;
  }
  return false;
};
Geometry.prototype.interfaces_ = function interfaces_18() {
  return [Clonable, Comparable, Serializable];
};
Geometry.prototype.getClass = function getClass18() {
  return Geometry;
};
Geometry.hasNonEmptyElements = function hasNonEmptyElements(geometries) {
  for (var i = 0; i < geometries.length; i++) {
    if (!geometries[i].isEmpty()) {
      return true;
    }
  }
  return false;
};
Geometry.hasNullElements = function hasNullElements(array) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === null) {
      return true;
    }
  }
  return false;
};
staticAccessors$11.serialVersionUID.get = function() {
  return 8763622679187377e3;
};
staticAccessors$11.SORTINDEX_POINT.get = function() {
  return 0;
};
staticAccessors$11.SORTINDEX_MULTIPOINT.get = function() {
  return 1;
};
staticAccessors$11.SORTINDEX_LINESTRING.get = function() {
  return 2;
};
staticAccessors$11.SORTINDEX_LINEARRING.get = function() {
  return 3;
};
staticAccessors$11.SORTINDEX_MULTILINESTRING.get = function() {
  return 4;
};
staticAccessors$11.SORTINDEX_POLYGON.get = function() {
  return 5;
};
staticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function() {
  return 6;
};
staticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
  return 7;
};
staticAccessors$11.geometryChangedFilter.get = function() {
  return geometryChangedFilter;
};
Object.defineProperties(Geometry, staticAccessors$11);
var geometryChangedFilter = function geometryChangedFilter2() {
};
geometryChangedFilter.interfaces_ = function interfaces_19() {
  return [GeometryComponentFilter];
};
geometryChangedFilter.filter = function filter2(geom) {
  geom.geometryChangedAction();
};
var CoordinateFilter = function CoordinateFilter2() {
};
CoordinateFilter.prototype.filter = function filter3(coord) {
};
CoordinateFilter.prototype.interfaces_ = function interfaces_20() {
  return [];
};
CoordinateFilter.prototype.getClass = function getClass19() {
  return CoordinateFilter;
};
var BoundaryNodeRule = function BoundaryNodeRule2() {
};
var staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
};
BoundaryNodeRule.prototype.interfaces_ = function interfaces_21() {
  return [];
};
BoundaryNodeRule.prototype.getClass = function getClass20() {
  return BoundaryNodeRule;
};
staticAccessors$12.Mod2BoundaryNodeRule.get = function() {
  return Mod2BoundaryNodeRule;
};
staticAccessors$12.EndPointBoundaryNodeRule.get = function() {
  return EndPointBoundaryNodeRule;
};
staticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function() {
  return MultiValentEndPointBoundaryNodeRule;
};
staticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function() {
  return MonoValentEndPointBoundaryNodeRule;
};
staticAccessors$12.MOD2_BOUNDARY_RULE.get = function() {
  return new Mod2BoundaryNodeRule();
};
staticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function() {
  return new EndPointBoundaryNodeRule();
};
staticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new MultiValentEndPointBoundaryNodeRule();
};
staticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new MonoValentEndPointBoundaryNodeRule();
};
staticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function() {
  return BoundaryNodeRule.MOD2_BOUNDARY_RULE;
};
Object.defineProperties(BoundaryNodeRule, staticAccessors$12);
var Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule2() {
};
Mod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary2(boundaryCount) {
  return boundaryCount % 2 === 1;
};
Mod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_22() {
  return [BoundaryNodeRule];
};
Mod2BoundaryNodeRule.prototype.getClass = function getClass21() {
  return Mod2BoundaryNodeRule;
};
var EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule2() {
};
EndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary3(boundaryCount) {
  return boundaryCount > 0;
};
EndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_23() {
  return [BoundaryNodeRule];
};
EndPointBoundaryNodeRule.prototype.getClass = function getClass22() {
  return EndPointBoundaryNodeRule;
};
var MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule2() {
};
MultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary4(boundaryCount) {
  return boundaryCount > 1;
};
MultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_24() {
  return [BoundaryNodeRule];
};
MultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass23() {
  return MultiValentEndPointBoundaryNodeRule;
};
var MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule2() {
};
MonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary5(boundaryCount) {
  return boundaryCount === 1;
};
MonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_25() {
  return [BoundaryNodeRule];
};
MonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass24() {
  return MonoValentEndPointBoundaryNodeRule;
};
var Collection = function Collection2() {
};
Collection.prototype.add = function add2() {
};
Collection.prototype.addAll = function addAll() {
};
Collection.prototype.isEmpty = function isEmpty() {
};
Collection.prototype.iterator = function iterator() {
};
Collection.prototype.size = function size2() {
};
Collection.prototype.toArray = function toArray() {
};
Collection.prototype.remove = function remove() {
};
function IndexOutOfBoundsException(message) {
  this.message = message || "";
}
IndexOutOfBoundsException.prototype = new Error();
IndexOutOfBoundsException.prototype.name = "IndexOutOfBoundsException";
var Iterator = function Iterator2() {
};
Iterator.prototype.hasNext = function hasNext() {
};
Iterator.prototype.next = function next() {
};
Iterator.prototype.remove = function remove2() {
};
var List = function(Collection$$1) {
  function List2() {
    Collection$$1.apply(this, arguments);
  }
  if (Collection$$1)
    List2.__proto__ = Collection$$1;
  List2.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
  List2.prototype.constructor = List2;
  List2.prototype.get = function get5() {
  };
  List2.prototype.set = function set2() {
  };
  List2.prototype.isEmpty = function isEmpty6() {
  };
  return List2;
}(Collection);
function NoSuchElementException(message) {
  this.message = message || "";
}
NoSuchElementException.prototype = new Error();
NoSuchElementException.prototype.name = "NoSuchElementException";
var ArrayList = function(List$$1) {
  function ArrayList2() {
    List$$1.call(this);
    this.array_ = [];
    if (arguments[0] instanceof Collection) {
      this.addAll(arguments[0]);
    }
  }
  if (List$$1)
    ArrayList2.__proto__ = List$$1;
  ArrayList2.prototype = Object.create(List$$1 && List$$1.prototype);
  ArrayList2.prototype.constructor = ArrayList2;
  ArrayList2.prototype.ensureCapacity = function ensureCapacity() {
  };
  ArrayList2.prototype.interfaces_ = function interfaces_170() {
    return [List$$1, Collection];
  };
  ArrayList2.prototype.add = function add16(e2) {
    if (arguments.length === 1) {
      this.array_.push(e2);
    } else {
      this.array_.splice(arguments[0], arguments[1]);
    }
    return true;
  };
  ArrayList2.prototype.clear = function clear3() {
    this.array_ = [];
  };
  ArrayList2.prototype.addAll = function addAll3(c) {
    var this$1$1 = this;
    for (var i = c.iterator(); i.hasNext(); ) {
      this$1$1.add(i.next());
    }
    return true;
  };
  ArrayList2.prototype.set = function set2(index2, element) {
    var oldElement = this.array_[index2];
    this.array_[index2] = element;
    return oldElement;
  };
  ArrayList2.prototype.iterator = function iterator8() {
    return new Iterator_(this);
  };
  ArrayList2.prototype.get = function get5(index2) {
    if (index2 < 0 || index2 >= this.size()) {
      throw new IndexOutOfBoundsException();
    }
    return this.array_[index2];
  };
  ArrayList2.prototype.isEmpty = function isEmpty6() {
    return this.array_.length === 0;
  };
  ArrayList2.prototype.size = function size11() {
    return this.array_.length;
  };
  ArrayList2.prototype.toArray = function toArray2() {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = this.array_.length; i < len2; i++) {
      array.push(this$1$1.array_[i]);
    }
    return array;
  };
  ArrayList2.prototype.remove = function remove6(o) {
    var this$1$1 = this;
    var found = false;
    for (var i = 0, len2 = this.array_.length; i < len2; i++) {
      if (this$1$1.array_[i] === o) {
        this$1$1.array_.splice(i, 1);
        found = true;
        break;
      }
    }
    return found;
  };
  return ArrayList2;
}(List);
var Iterator_ = function(Iterator$$1) {
  function Iterator_2(arrayList) {
    Iterator$$1.call(this);
    this.arrayList_ = arrayList;
    this.position_ = 0;
  }
  if (Iterator$$1)
    Iterator_2.__proto__ = Iterator$$1;
  Iterator_2.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
  Iterator_2.prototype.constructor = Iterator_2;
  Iterator_2.prototype.next = function next3() {
    if (this.position_ === this.arrayList_.size()) {
      throw new NoSuchElementException();
    }
    return this.arrayList_.get(this.position_++);
  };
  Iterator_2.prototype.hasNext = function hasNext3() {
    if (this.position_ < this.arrayList_.size()) {
      return true;
    } else {
      return false;
    }
  };
  Iterator_2.prototype.set = function set2(element) {
    return this.arrayList_.set(this.position_ - 1, element);
  };
  Iterator_2.prototype.remove = function remove6() {
    this.arrayList_.remove(this.arrayList_.get(this.position_));
  };
  return Iterator_2;
}(Iterator);
var CoordinateList = function(ArrayList$$1) {
  function CoordinateList2() {
    ArrayList$$1.call(this);
    if (arguments.length === 0)
      ;
    else if (arguments.length === 1) {
      var coord = arguments[0];
      this.ensureCapacity(coord.length);
      this.add(coord, true);
    } else if (arguments.length === 2) {
      var coord$1 = arguments[0];
      var allowRepeated = arguments[1];
      this.ensureCapacity(coord$1.length);
      this.add(coord$1, allowRepeated);
    }
  }
  if (ArrayList$$1)
    CoordinateList2.__proto__ = ArrayList$$1;
  CoordinateList2.prototype = Object.create(ArrayList$$1 && ArrayList$$1.prototype);
  CoordinateList2.prototype.constructor = CoordinateList2;
  var staticAccessors2 = { coordArrayType: { configurable: true } };
  staticAccessors2.coordArrayType.get = function() {
    return new Array(0).fill(null);
  };
  CoordinateList2.prototype.getCoordinate = function getCoordinate18(i) {
    return this.get(i);
  };
  CoordinateList2.prototype.addAll = function addAll3() {
    var this$1$1 = this;
    if (arguments.length === 2) {
      var coll = arguments[0];
      var allowRepeated = arguments[1];
      var isChanged = false;
      for (var i = coll.iterator(); i.hasNext(); ) {
        this$1$1.add(i.next(), allowRepeated);
        isChanged = true;
      }
      return isChanged;
    } else {
      return ArrayList$$1.prototype.addAll.apply(this, arguments);
    }
  };
  CoordinateList2.prototype.clone = function clone6() {
    var this$1$1 = this;
    var clone7 = ArrayList$$1.prototype.clone.call(this);
    for (var i = 0; i < this.size(); i++) {
      clone7.add(i, this$1$1.get(i).copy());
    }
    return clone7;
  };
  CoordinateList2.prototype.toCoordinateArray = function toCoordinateArray4() {
    return this.toArray(CoordinateList2.coordArrayType);
  };
  CoordinateList2.prototype.add = function add16() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var coord = arguments[0];
      ArrayList$$1.prototype.add.call(this, coord);
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && typeof arguments[1] === "boolean") {
        var coord$1 = arguments[0];
        var allowRepeated = arguments[1];
        this.add(coord$1, allowRepeated, true);
        return true;
      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === "boolean") {
        var coord$2 = arguments[0];
        var allowRepeated$1 = arguments[1];
        if (!allowRepeated$1) {
          if (this.size() >= 1) {
            var last = this.get(this.size() - 1);
            if (last.equals2D(coord$2)) {
              return null;
            }
          }
        }
        ArrayList$$1.prototype.add.call(this, coord$2);
      } else if (arguments[0] instanceof Object && typeof arguments[1] === "boolean") {
        var obj = arguments[0];
        var allowRepeated$2 = arguments[1];
        this.add(obj, allowRepeated$2);
        return true;
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Array && typeof arguments[1] === "boolean")) {
        var coord$3 = arguments[0];
        var allowRepeated$3 = arguments[1];
        var direction = arguments[2];
        if (direction) {
          for (var i$1 = 0; i$1 < coord$3.length; i$1++) {
            this$1$1.add(coord$3[i$1], allowRepeated$3);
          }
        } else {
          for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {
            this$1$1.add(coord$3[i$2], allowRepeated$3);
          }
        }
        return true;
      } else if (typeof arguments[2] === "boolean" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
        var i$3 = arguments[0];
        var coord$4 = arguments[1];
        var allowRepeated$4 = arguments[2];
        if (!allowRepeated$4) {
          var size11 = this.size();
          if (size11 > 0) {
            if (i$3 > 0) {
              var prev = this.get(i$3 - 1);
              if (prev.equals2D(coord$4)) {
                return null;
              }
            }
            if (i$3 < size11) {
              var next3 = this.get(i$3);
              if (next3.equals2D(coord$4)) {
                return null;
              }
            }
          }
        }
        ArrayList$$1.prototype.add.call(this, i$3, coord$4);
      }
    } else if (arguments.length === 4) {
      var coord$5 = arguments[0];
      var allowRepeated$5 = arguments[1];
      var start2 = arguments[2];
      var end2 = arguments[3];
      var inc = 1;
      if (start2 > end2) {
        inc = -1;
      }
      for (var i = start2; i !== end2; i += inc) {
        this$1$1.add(coord$5[i], allowRepeated$5);
      }
      return true;
    }
  };
  CoordinateList2.prototype.closeRing = function closeRing3() {
    if (this.size() > 0) {
      this.add(new Coordinate(this.get(0)), false);
    }
  };
  CoordinateList2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  CoordinateList2.prototype.getClass = function getClass169() {
    return CoordinateList2;
  };
  Object.defineProperties(CoordinateList2, staticAccessors2);
  return CoordinateList2;
}(ArrayList);
var CoordinateArrays = function CoordinateArrays2() {
};
var staticAccessors$13 = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
staticAccessors$13.ForwardComparator.get = function() {
  return ForwardComparator;
};
staticAccessors$13.BidirectionalComparator.get = function() {
  return BidirectionalComparator;
};
staticAccessors$13.coordArrayType.get = function() {
  return new Array(0).fill(null);
};
CoordinateArrays.prototype.interfaces_ = function interfaces_26() {
  return [];
};
CoordinateArrays.prototype.getClass = function getClass25() {
  return CoordinateArrays;
};
CoordinateArrays.isRing = function isRing(pts) {
  if (pts.length < 4) {
    return false;
  }
  if (!pts[0].equals2D(pts[pts.length - 1])) {
    return false;
  }
  return true;
};
CoordinateArrays.ptNotInList = function ptNotInList(testPts, pts) {
  for (var i = 0; i < testPts.length; i++) {
    var testPt = testPts[i];
    if (CoordinateArrays.indexOf(testPt, pts) < 0) {
      return testPt;
    }
  }
  return null;
};
CoordinateArrays.scroll = function scroll(coordinates, firstCoordinate) {
  var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
  if (i < 0) {
    return null;
  }
  var newCoordinates = new Array(coordinates.length).fill(null);
  System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
  System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
  System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
};
CoordinateArrays.equals = function equals7() {
  if (arguments.length === 2) {
    var coord1 = arguments[0];
    var coord2 = arguments[1];
    if (coord1 === coord2) {
      return true;
    }
    if (coord1 === null || coord2 === null) {
      return false;
    }
    if (coord1.length !== coord2.length) {
      return false;
    }
    for (var i = 0; i < coord1.length; i++) {
      if (!coord1[i].equals(coord2[i])) {
        return false;
      }
    }
    return true;
  } else if (arguments.length === 3) {
    var coord1$1 = arguments[0];
    var coord2$1 = arguments[1];
    var coordinateComparator = arguments[2];
    if (coord1$1 === coord2$1) {
      return true;
    }
    if (coord1$1 === null || coord2$1 === null) {
      return false;
    }
    if (coord1$1.length !== coord2$1.length) {
      return false;
    }
    for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {
      if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) {
        return false;
      }
    }
    return true;
  }
};
CoordinateArrays.intersection = function intersection7(coordinates, env2) {
  var coordList = new CoordinateList();
  for (var i = 0; i < coordinates.length; i++) {
    if (env2.intersects(coordinates[i])) {
      coordList.add(coordinates[i], true);
    }
  }
  return coordList.toCoordinateArray();
};
CoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints(coord) {
  for (var i = 1; i < coord.length; i++) {
    if (coord[i - 1].equals(coord[i])) {
      return true;
    }
  }
  return false;
};
CoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints(coord) {
  if (!CoordinateArrays.hasRepeatedPoints(coord)) {
    return coord;
  }
  var coordList = new CoordinateList(coord, false);
  return coordList.toCoordinateArray();
};
CoordinateArrays.reverse = function reverse(coord) {
  var last = coord.length - 1;
  var mid = Math.trunc(last / 2);
  for (var i = 0; i <= mid; i++) {
    var tmp = coord[i];
    coord[i] = coord[last - i];
    coord[last - i] = tmp;
  }
};
CoordinateArrays.removeNull = function removeNull(coord) {
  var nonNull = 0;
  for (var i = 0; i < coord.length; i++) {
    if (coord[i] !== null) {
      nonNull++;
    }
  }
  var newCoord = new Array(nonNull).fill(null);
  if (nonNull === 0) {
    return newCoord;
  }
  var j = 0;
  for (var i$1 = 0; i$1 < coord.length; i$1++) {
    if (coord[i$1] !== null) {
      newCoord[j++] = coord[i$1];
    }
  }
  return newCoord;
};
CoordinateArrays.copyDeep = function copyDeep() {
  if (arguments.length === 1) {
    var coordinates = arguments[0];
    var copy8 = new Array(coordinates.length).fill(null);
    for (var i = 0; i < coordinates.length; i++) {
      copy8[i] = new Coordinate(coordinates[i]);
    }
    return copy8;
  } else if (arguments.length === 5) {
    var src2 = arguments[0];
    var srcStart = arguments[1];
    var dest = arguments[2];
    var destStart = arguments[3];
    var length3 = arguments[4];
    for (var i$1 = 0; i$1 < length3; i$1++) {
      dest[destStart + i$1] = new Coordinate(src2[srcStart + i$1]);
    }
  }
};
CoordinateArrays.isEqualReversed = function isEqualReversed(pts1, pts2) {
  for (var i = 0; i < pts1.length; i++) {
    var p1 = pts1[i];
    var p2 = pts2[pts1.length - i - 1];
    if (p1.compareTo(p2) !== 0) {
      return false;
    }
  }
  return true;
};
CoordinateArrays.envelope = function envelope2(coordinates) {
  var env2 = new Envelope();
  for (var i = 0; i < coordinates.length; i++) {
    env2.expandToInclude(coordinates[i]);
  }
  return env2;
};
CoordinateArrays.toCoordinateArray = function toCoordinateArray2(coordList) {
  return coordList.toArray(CoordinateArrays.coordArrayType);
};
CoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing(n, c) {
  return c.length >= n ? c : [];
};
CoordinateArrays.indexOf = function indexOf(coordinate2, coordinates) {
  for (var i = 0; i < coordinates.length; i++) {
    if (coordinate2.equals(coordinates[i])) {
      return i;
    }
  }
  return -1;
};
CoordinateArrays.increasingDirection = function increasingDirection(pts) {
  for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
    var j = pts.length - 1 - i;
    var comp = pts[i].compareTo(pts[j]);
    if (comp !== 0) {
      return comp;
    }
  }
  return 1;
};
CoordinateArrays.compare = function compare4(pts1, pts2) {
  var i = 0;
  while (i < pts1.length && i < pts2.length) {
    var compare11 = pts1[i].compareTo(pts2[i]);
    if (compare11 !== 0) {
      return compare11;
    }
    i++;
  }
  if (i < pts2.length) {
    return -1;
  }
  if (i < pts1.length) {
    return 1;
  }
  return 0;
};
CoordinateArrays.minCoordinate = function minCoordinate(coordinates) {
  var minCoord = null;
  for (var i = 0; i < coordinates.length; i++) {
    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
      minCoord = coordinates[i];
    }
  }
  return minCoord;
};
CoordinateArrays.extract = function extract(pts, start2, end2) {
  start2 = MathUtil.clamp(start2, 0, pts.length);
  end2 = MathUtil.clamp(end2, -1, pts.length);
  var npts = end2 - start2 + 1;
  if (end2 < 0) {
    npts = 0;
  }
  if (start2 >= pts.length) {
    npts = 0;
  }
  if (end2 < start2) {
    npts = 0;
  }
  var extractPts = new Array(npts).fill(null);
  if (npts === 0) {
    return extractPts;
  }
  var iPts = 0;
  for (var i = start2; i <= end2; i++) {
    extractPts[iPts++] = pts[i];
  }
  return extractPts;
};
Object.defineProperties(CoordinateArrays, staticAccessors$13);
var ForwardComparator = function ForwardComparator2() {
};
ForwardComparator.prototype.compare = function compare5(o1, o2) {
  var pts1 = o1;
  var pts2 = o2;
  return CoordinateArrays.compare(pts1, pts2);
};
ForwardComparator.prototype.interfaces_ = function interfaces_27() {
  return [Comparator];
};
ForwardComparator.prototype.getClass = function getClass26() {
  return ForwardComparator;
};
var BidirectionalComparator = function BidirectionalComparator2() {
};
BidirectionalComparator.prototype.compare = function compare6(o1, o2) {
  var pts1 = o1;
  var pts2 = o2;
  if (pts1.length < pts2.length) {
    return -1;
  }
  if (pts1.length > pts2.length) {
    return 1;
  }
  if (pts1.length === 0) {
    return 0;
  }
  var forwardComp = CoordinateArrays.compare(pts1, pts2);
  var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
  if (isEqualRev) {
    return 0;
  }
  return forwardComp;
};
BidirectionalComparator.prototype.OLDcompare = function OLDcompare(o1, o2) {
  var pts1 = o1;
  var pts2 = o2;
  if (pts1.length < pts2.length) {
    return -1;
  }
  if (pts1.length > pts2.length) {
    return 1;
  }
  if (pts1.length === 0) {
    return 0;
  }
  var dir1 = CoordinateArrays.increasingDirection(pts1);
  var dir22 = CoordinateArrays.increasingDirection(pts2);
  var i1 = dir1 > 0 ? 0 : pts1.length - 1;
  var i2 = dir22 > 0 ? 0 : pts1.length - 1;
  for (var i = 0; i < pts1.length; i++) {
    var comparePt = pts1[i1].compareTo(pts2[i2]);
    if (comparePt !== 0) {
      return comparePt;
    }
    i1 += dir1;
    i2 += dir22;
  }
  return 0;
};
BidirectionalComparator.prototype.interfaces_ = function interfaces_28() {
  return [Comparator];
};
BidirectionalComparator.prototype.getClass = function getClass27() {
  return BidirectionalComparator;
};
var Map$1 = function Map2() {
};
Map$1.prototype.get = function get() {
};
Map$1.prototype.put = function put() {
};
Map$1.prototype.size = function size3() {
};
Map$1.prototype.values = function values() {
};
Map$1.prototype.entrySet = function entrySet() {
};
var SortedMap = function(Map3) {
  function SortedMap2() {
    Map3.apply(this, arguments);
  }
  if (Map3)
    SortedMap2.__proto__ = Map3;
  SortedMap2.prototype = Object.create(Map3 && Map3.prototype);
  SortedMap2.prototype.constructor = SortedMap2;
  return SortedMap2;
}(Map$1);
function OperationNotSupported(message) {
  this.message = message || "";
}
OperationNotSupported.prototype = new Error();
OperationNotSupported.prototype.name = "OperationNotSupported";
function Set$1() {
}
Set$1.prototype = new Collection();
Set$1.prototype.contains = function() {
};
var HashSet = function(Set$$1) {
  function HashSet2() {
    Set$$1.call(this);
    this.array_ = [];
    if (arguments[0] instanceof Collection) {
      this.addAll(arguments[0]);
    }
  }
  if (Set$$1)
    HashSet2.__proto__ = Set$$1;
  HashSet2.prototype = Object.create(Set$$1 && Set$$1.prototype);
  HashSet2.prototype.constructor = HashSet2;
  HashSet2.prototype.contains = function contains3(o) {
    var this$1$1 = this;
    for (var i = 0, len2 = this.array_.length; i < len2; i++) {
      var e2 = this$1$1.array_[i];
      if (e2 === o) {
        return true;
      }
    }
    return false;
  };
  HashSet2.prototype.add = function add16(o) {
    if (this.contains(o)) {
      return false;
    }
    this.array_.push(o);
    return true;
  };
  HashSet2.prototype.addAll = function addAll3(c) {
    var this$1$1 = this;
    for (var i = c.iterator(); i.hasNext(); ) {
      this$1$1.add(i.next());
    }
    return true;
  };
  HashSet2.prototype.remove = function remove6(o) {
    throw new Error();
  };
  HashSet2.prototype.size = function size11() {
    return this.array_.length;
  };
  HashSet2.prototype.isEmpty = function isEmpty6() {
    return this.array_.length === 0;
  };
  HashSet2.prototype.toArray = function toArray2() {
    var this$1$1 = this;
    var array = [];
    for (var i = 0, len2 = this.array_.length; i < len2; i++) {
      array.push(this$1$1.array_[i]);
    }
    return array;
  };
  HashSet2.prototype.iterator = function iterator8() {
    return new Iterator_$1(this);
  };
  return HashSet2;
}(Set$1);
var Iterator_$1 = function(Iterator$$1) {
  function Iterator_2(hashSet) {
    Iterator$$1.call(this);
    this.hashSet_ = hashSet;
    this.position_ = 0;
  }
  if (Iterator$$1)
    Iterator_2.__proto__ = Iterator$$1;
  Iterator_2.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
  Iterator_2.prototype.constructor = Iterator_2;
  Iterator_2.prototype.next = function next3() {
    if (this.position_ === this.hashSet_.size()) {
      throw new NoSuchElementException();
    }
    return this.hashSet_.array_[this.position_++];
  };
  Iterator_2.prototype.hasNext = function hasNext3() {
    if (this.position_ < this.hashSet_.size()) {
      return true;
    } else {
      return false;
    }
  };
  Iterator_2.prototype.remove = function remove6() {
    throw new OperationNotSupported();
  };
  return Iterator_2;
}(Iterator);
var BLACK = 0;
var RED = 1;
function colorOf(p) {
  return p === null ? BLACK : p.color;
}
function parentOf(p) {
  return p === null ? null : p.parent;
}
function setColor(p, c) {
  if (p !== null) {
    p.color = c;
  }
}
function leftOf(p) {
  return p === null ? null : p.left;
}
function rightOf(p) {
  return p === null ? null : p.right;
}
function TreeMap() {
  this.root_ = null;
  this.size_ = 0;
}
TreeMap.prototype = new SortedMap();
TreeMap.prototype.get = function(key) {
  var p = this.root_;
  while (p !== null) {
    var cmp3 = key["compareTo"](p.key);
    if (cmp3 < 0) {
      p = p.left;
    } else if (cmp3 > 0) {
      p = p.right;
    } else {
      return p.value;
    }
  }
  return null;
};
TreeMap.prototype.put = function(key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key,
      value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue: function getValue() {
        return this.value;
      },
      getKey: function getKey2() {
        return this.key;
      }
    };
    this.size_ = 1;
    return null;
  }
  var t = this.root_;
  var parent;
  var cmp3;
  do {
    parent = t;
    cmp3 = key["compareTo"](t.key);
    if (cmp3 < 0) {
      t = t.left;
    } else if (cmp3 > 0) {
      t = t.right;
    } else {
      var oldValue = t.value;
      t.value = value;
      return oldValue;
    }
  } while (t !== null);
  var e2 = {
    key,
    left: null,
    right: null,
    value,
    parent,
    color: BLACK,
    getValue: function getValue() {
      return this.value;
    },
    getKey: function getKey2() {
      return this.key;
    }
  };
  if (cmp3 < 0) {
    parent.left = e2;
  } else {
    parent.right = e2;
  }
  this.fixAfterInsertion(e2);
  this.size_++;
  return null;
};
TreeMap.prototype.fixAfterInsertion = function(x2) {
  var this$1$1 = this;
  x2.color = RED;
  while (x2 != null && x2 !== this.root_ && x2.parent.color === RED) {
    if (parentOf(x2) === leftOf(parentOf(parentOf(x2)))) {
      var y2 = rightOf(parentOf(parentOf(x2)));
      if (colorOf(y2) === RED) {
        setColor(parentOf(x2), BLACK);
        setColor(y2, BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        x2 = parentOf(parentOf(x2));
      } else {
        if (x2 === rightOf(parentOf(x2))) {
          x2 = parentOf(x2);
          this$1$1.rotateLeft(x2);
        }
        setColor(parentOf(x2), BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        this$1$1.rotateRight(parentOf(parentOf(x2)));
      }
    } else {
      var y$1 = leftOf(parentOf(parentOf(x2)));
      if (colorOf(y$1) === RED) {
        setColor(parentOf(x2), BLACK);
        setColor(y$1, BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        x2 = parentOf(parentOf(x2));
      } else {
        if (x2 === leftOf(parentOf(x2))) {
          x2 = parentOf(x2);
          this$1$1.rotateRight(x2);
        }
        setColor(parentOf(x2), BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        this$1$1.rotateLeft(parentOf(parentOf(x2)));
      }
    }
  }
  this.root_.color = BLACK;
};
TreeMap.prototype.values = function() {
  var arrayList = new ArrayList();
  var p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList;
};
TreeMap.prototype.entrySet = function() {
  var hashSet = new HashSet();
  var p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet;
};
TreeMap.prototype.rotateLeft = function(p) {
  if (p != null) {
    var r = p.right;
    p.right = r.left;
    if (r.left != null) {
      r.left.parent = p;
    }
    r.parent = p.parent;
    if (p.parent === null) {
      this.root_ = r;
    } else if (p.parent.left === p) {
      p.parent.left = r;
    } else {
      p.parent.right = r;
    }
    r.left = p;
    p.parent = r;
  }
};
TreeMap.prototype.rotateRight = function(p) {
  if (p != null) {
    var l = p.left;
    p.left = l.right;
    if (l.right != null) {
      l.right.parent = p;
    }
    l.parent = p.parent;
    if (p.parent === null) {
      this.root_ = l;
    } else if (p.parent.right === p) {
      p.parent.right = l;
    } else {
      p.parent.left = l;
    }
    l.right = p;
    p.parent = l;
  }
};
TreeMap.prototype.getFirstEntry = function() {
  var p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p;
};
TreeMap.successor = function(t) {
  if (t === null) {
    return null;
  } else if (t.right !== null) {
    var p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p;
  } else {
    var p$1 = t.parent;
    var ch = t;
    while (p$1 !== null && ch === p$1.right) {
      ch = p$1;
      p$1 = p$1.parent;
    }
    return p$1;
  }
};
TreeMap.prototype.size = function() {
  return this.size_;
};
var Lineal = function Lineal2() {
};
Lineal.prototype.interfaces_ = function interfaces_29() {
  return [];
};
Lineal.prototype.getClass = function getClass28() {
  return Lineal;
};
function SortedSet() {
}
SortedSet.prototype = new Set$1();
function TreeSet() {
  this.array_ = [];
  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
TreeSet.prototype = new SortedSet();
TreeSet.prototype.contains = function(o) {
  var this$1$1 = this;
  for (var i = 0, len2 = this.array_.length; i < len2; i++) {
    var e2 = this$1$1.array_[i];
    if (e2["compareTo"](o) === 0) {
      return true;
    }
  }
  return false;
};
TreeSet.prototype.add = function(o) {
  var this$1$1 = this;
  if (this.contains(o)) {
    return false;
  }
  for (var i = 0, len2 = this.array_.length; i < len2; i++) {
    var e2 = this$1$1.array_[i];
    if (e2["compareTo"](o) === 1) {
      this$1$1.array_.splice(i, 0, o);
      return true;
    }
  }
  this.array_.push(o);
  return true;
};
TreeSet.prototype.addAll = function(c) {
  var this$1$1 = this;
  for (var i = c.iterator(); i.hasNext(); ) {
    this$1$1.add(i.next());
  }
  return true;
};
TreeSet.prototype.remove = function(e2) {
  throw new OperationNotSupported();
};
TreeSet.prototype.size = function() {
  return this.array_.length;
};
TreeSet.prototype.isEmpty = function() {
  return this.array_.length === 0;
};
TreeSet.prototype.toArray = function() {
  var this$1$1 = this;
  var array = [];
  for (var i = 0, len2 = this.array_.length; i < len2; i++) {
    array.push(this$1$1.array_[i]);
  }
  return array;
};
TreeSet.prototype.iterator = function() {
  return new Iterator_$2(this);
};
var Iterator_$2 = function(treeSet) {
  this.treeSet_ = treeSet;
  this.position_ = 0;
};
Iterator_$2.prototype.next = function() {
  if (this.position_ === this.treeSet_.size()) {
    throw new NoSuchElementException();
  }
  return this.treeSet_.array_[this.position_++];
};
Iterator_$2.prototype.hasNext = function() {
  if (this.position_ < this.treeSet_.size()) {
    return true;
  } else {
    return false;
  }
};
Iterator_$2.prototype.remove = function() {
  throw new OperationNotSupported();
};
var Arrays = function Arrays2() {
};
Arrays.sort = function sort() {
  var a = arguments[0];
  var i;
  var t;
  var comparator;
  var compare11;
  if (arguments.length === 1) {
    compare11 = function(a2, b) {
      return a2.compareTo(b);
    };
    a.sort(compare11);
  } else if (arguments.length === 2) {
    comparator = arguments[1];
    compare11 = function(a2, b) {
      return comparator["compare"](a2, b);
    };
    a.sort(compare11);
  } else if (arguments.length === 3) {
    t = a.slice(arguments[1], arguments[2]);
    t.sort();
    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
  } else if (arguments.length === 4) {
    t = a.slice(arguments[1], arguments[2]);
    comparator = arguments[3];
    compare11 = function(a2, b) {
      return comparator["compare"](a2, b);
    };
    t.sort(compare11);
    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
  }
};
Arrays.asList = function asList(array) {
  var arrayList = new ArrayList();
  for (var i = 0, len2 = array.length; i < len2; i++) {
    arrayList.add(array[i]);
  }
  return arrayList;
};
var Dimension = function Dimension2() {
};
var staticAccessors$14 = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
staticAccessors$14.P.get = function() {
  return 0;
};
staticAccessors$14.L.get = function() {
  return 1;
};
staticAccessors$14.A.get = function() {
  return 2;
};
staticAccessors$14.FALSE.get = function() {
  return -1;
};
staticAccessors$14.TRUE.get = function() {
  return -2;
};
staticAccessors$14.DONTCARE.get = function() {
  return -3;
};
staticAccessors$14.SYM_FALSE.get = function() {
  return "F";
};
staticAccessors$14.SYM_TRUE.get = function() {
  return "T";
};
staticAccessors$14.SYM_DONTCARE.get = function() {
  return "*";
};
staticAccessors$14.SYM_P.get = function() {
  return "0";
};
staticAccessors$14.SYM_L.get = function() {
  return "1";
};
staticAccessors$14.SYM_A.get = function() {
  return "2";
};
Dimension.prototype.interfaces_ = function interfaces_30() {
  return [];
};
Dimension.prototype.getClass = function getClass29() {
  return Dimension;
};
Dimension.toDimensionSymbol = function toDimensionSymbol(dimensionValue) {
  switch (dimensionValue) {
    case Dimension.FALSE:
      return Dimension.SYM_FALSE;
    case Dimension.TRUE:
      return Dimension.SYM_TRUE;
    case Dimension.DONTCARE:
      return Dimension.SYM_DONTCARE;
    case Dimension.P:
      return Dimension.SYM_P;
    case Dimension.L:
      return Dimension.SYM_L;
    case Dimension.A:
      return Dimension.SYM_A;
  }
  throw new IllegalArgumentException("Unknown dimension value: " + dimensionValue);
};
Dimension.toDimensionValue = function toDimensionValue(dimensionSymbol) {
  switch (Character.toUpperCase(dimensionSymbol)) {
    case Dimension.SYM_FALSE:
      return Dimension.FALSE;
    case Dimension.SYM_TRUE:
      return Dimension.TRUE;
    case Dimension.SYM_DONTCARE:
      return Dimension.DONTCARE;
    case Dimension.SYM_P:
      return Dimension.P;
    case Dimension.SYM_L:
      return Dimension.L;
    case Dimension.SYM_A:
      return Dimension.A;
  }
  throw new IllegalArgumentException("Unknown dimension symbol: " + dimensionSymbol);
};
Object.defineProperties(Dimension, staticAccessors$14);
var GeometryFilter = function GeometryFilter2() {
};
GeometryFilter.prototype.filter = function filter4(geom) {
};
GeometryFilter.prototype.interfaces_ = function interfaces_31() {
  return [];
};
GeometryFilter.prototype.getClass = function getClass30() {
  return GeometryFilter;
};
var CoordinateSequenceFilter = function CoordinateSequenceFilter2() {
};
CoordinateSequenceFilter.prototype.filter = function filter5(seq, i) {
};
CoordinateSequenceFilter.prototype.isDone = function isDone() {
};
CoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
};
CoordinateSequenceFilter.prototype.interfaces_ = function interfaces_32() {
  return [];
};
CoordinateSequenceFilter.prototype.getClass = function getClass31() {
  return CoordinateSequenceFilter;
};
var GeometryCollection = function(Geometry$$1) {
  function GeometryCollection2(geometries, factory) {
    Geometry$$1.call(this, factory);
    this._geometries = geometries || [];
    if (Geometry$$1.hasNullElements(this._geometries)) {
      throw new IllegalArgumentException("geometries must not contain null elements");
    }
  }
  if (Geometry$$1)
    GeometryCollection2.__proto__ = Geometry$$1;
  GeometryCollection2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  GeometryCollection2.prototype.constructor = GeometryCollection2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  GeometryCollection2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    var this$1$1 = this;
    var envelope3 = new Envelope();
    for (var i = 0; i < this._geometries.length; i++) {
      envelope3.expandToInclude(this$1$1._geometries[i].getEnvelopeInternal());
    }
    return envelope3;
  };
  GeometryCollection2.prototype.getGeometryN = function getGeometryN2(n) {
    return this._geometries[n];
  };
  GeometryCollection2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION;
  };
  GeometryCollection2.prototype.getCoordinates = function getCoordinates11() {
    var this$1$1 = this;
    var coordinates = new Array(this.getNumPoints()).fill(null);
    var k = -1;
    for (var i = 0; i < this._geometries.length; i++) {
      var childCoordinates = this$1$1._geometries[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates;
  };
  GeometryCollection2.prototype.getArea = function getArea3() {
    var this$1$1 = this;
    var area5 = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      area5 += this$1$1._geometries[i].getArea();
    }
    return area5;
  };
  GeometryCollection2.prototype.equalsExact = function equalsExact2() {
    var this$1$1 = this;
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      var otherCollection = other;
      if (this._geometries.length !== otherCollection._geometries.length) {
        return false;
      }
      for (var i = 0; i < this._geometries.length; i++) {
        if (!this$1$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
          return false;
        }
      }
      return true;
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  GeometryCollection2.prototype.normalize = function normalize5() {
    var this$1$1 = this;
    for (var i = 0; i < this._geometries.length; i++) {
      this$1$1._geometries[i].normalize();
    }
    Arrays.sort(this._geometries);
  };
  GeometryCollection2.prototype.getCoordinate = function getCoordinate18() {
    if (this.isEmpty()) {
      return null;
    }
    return this._geometries[0].getCoordinate();
  };
  GeometryCollection2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    var this$1$1 = this;
    var dimension = Dimension.FALSE;
    for (var i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this$1$1._geometries[i].getBoundaryDimension());
    }
    return dimension;
  };
  GeometryCollection2.prototype.getDimension = function getDimension3() {
    var this$1$1 = this;
    var dimension = Dimension.FALSE;
    for (var i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this$1$1._geometries[i].getDimension());
    }
    return dimension;
  };
  GeometryCollection2.prototype.getLength = function getLength3() {
    var this$1$1 = this;
    var sum2 = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      sum2 += this$1$1._geometries[i].getLength();
    }
    return sum2;
  };
  GeometryCollection2.prototype.getNumPoints = function getNumPoints() {
    var this$1$1 = this;
    var numPoints = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      numPoints += this$1$1._geometries[i].getNumPoints();
    }
    return numPoints;
  };
  GeometryCollection2.prototype.getNumGeometries = function getNumGeometries2() {
    return this._geometries.length;
  };
  GeometryCollection2.prototype.reverse = function reverse5() {
    var this$1$1 = this;
    var n = this._geometries.length;
    var revGeoms = new Array(n).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this$1$1._geometries[i].reverse();
    }
    return this.getFactory().createGeometryCollection(revGeoms);
  };
  GeometryCollection2.prototype.compareToSameClass = function compareToSameClass() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var o = arguments[0];
      var theseElements = new TreeSet(Arrays.asList(this._geometries));
      var otherElements = new TreeSet(Arrays.asList(o._geometries));
      return this.compare(theseElements, otherElements);
    } else if (arguments.length === 2) {
      var o$1 = arguments[0];
      var comp = arguments[1];
      var gc = o$1;
      var n1 = this.getNumGeometries();
      var n2 = gc.getNumGeometries();
      var i = 0;
      while (i < n1 && i < n2) {
        var thisGeom = this$1$1.getGeometryN(i);
        var otherGeom = gc.getGeometryN(i);
        var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
        if (holeComp !== 0) {
          return holeComp;
        }
        i++;
      }
      if (i < n1) {
        return 1;
      }
      if (i < n2) {
        return -1;
      }
      return 0;
    }
  };
  GeometryCollection2.prototype.apply = function apply() {
    var this$1$1 = this;
    if (hasInterface(arguments[0], CoordinateFilter)) {
      var filter18 = arguments[0];
      for (var i = 0; i < this._geometries.length; i++) {
        this$1$1._geometries[i].apply(filter18);
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      var filter$1 = arguments[0];
      if (this._geometries.length === 0) {
        return null;
      }
      for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {
        this$1$1._geometries[i$1].apply(filter$1);
        if (filter$1.isDone()) {
          break;
        }
      }
      if (filter$1.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      var filter$2 = arguments[0];
      filter$2.filter(this);
      for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {
        this$1$1._geometries[i$2].apply(filter$2);
      }
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      var filter$3 = arguments[0];
      filter$3.filter(this);
      for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {
        this$1$1._geometries[i$3].apply(filter$3);
      }
    }
  };
  GeometryCollection2.prototype.getBoundary = function getBoundary3() {
    this.checkNotGeometryCollection(this);
    Assert.shouldNeverReachHere();
    return null;
  };
  GeometryCollection2.prototype.clone = function clone6() {
    var this$1$1 = this;
    var gc = Geometry$$1.prototype.clone.call(this);
    gc._geometries = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      gc._geometries[i] = this$1$1._geometries[i].clone();
    }
    return gc;
  };
  GeometryCollection2.prototype.getGeometryType = function getGeometryType() {
    return "GeometryCollection";
  };
  GeometryCollection2.prototype.copy = function copy8() {
    var this$1$1 = this;
    var geometries = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < geometries.length; i++) {
      geometries[i] = this$1$1._geometries[i].copy();
    }
    return new GeometryCollection2(geometries, this._factory);
  };
  GeometryCollection2.prototype.isEmpty = function isEmpty6() {
    var this$1$1 = this;
    for (var i = 0; i < this._geometries.length; i++) {
      if (!this$1$1._geometries[i].isEmpty()) {
        return false;
      }
    }
    return true;
  };
  GeometryCollection2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  GeometryCollection2.prototype.getClass = function getClass169() {
    return GeometryCollection2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -5694727726395021e3;
  };
  Object.defineProperties(GeometryCollection2, staticAccessors2);
  return GeometryCollection2;
}(Geometry);
var MultiLineString = function(GeometryCollection$$1) {
  function MultiLineString2() {
    GeometryCollection$$1.apply(this, arguments);
  }
  if (GeometryCollection$$1)
    MultiLineString2.__proto__ = GeometryCollection$$1;
  MultiLineString2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
  MultiLineString2.prototype.constructor = MultiLineString2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  MultiLineString2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_MULTILINESTRING;
  };
  MultiLineString2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
    } else {
      return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  MultiLineString2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    if (this.isClosed()) {
      return Dimension.FALSE;
    }
    return 0;
  };
  MultiLineString2.prototype.isClosed = function isClosed5() {
    var this$1$1 = this;
    if (this.isEmpty()) {
      return false;
    }
    for (var i = 0; i < this._geometries.length; i++) {
      if (!this$1$1._geometries[i].isClosed()) {
        return false;
      }
    }
    return true;
  };
  MultiLineString2.prototype.getDimension = function getDimension3() {
    return 1;
  };
  MultiLineString2.prototype.reverse = function reverse5() {
    var this$1$1 = this;
    var nLines = this._geometries.length;
    var revLines = new Array(nLines).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revLines[nLines - 1 - i] = this$1$1._geometries[i].reverse();
    }
    return this.getFactory().createMultiLineString(revLines);
  };
  MultiLineString2.prototype.getBoundary = function getBoundary3() {
    return new BoundaryOp(this).getBoundary();
  };
  MultiLineString2.prototype.getGeometryType = function getGeometryType() {
    return "MultiLineString";
  };
  MultiLineString2.prototype.copy = function copy8() {
    var this$1$1 = this;
    var lineStrings2 = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < lineStrings2.length; i++) {
      lineStrings2[i] = this$1$1._geometries[i].copy();
    }
    return new MultiLineString2(lineStrings2, this._factory);
  };
  MultiLineString2.prototype.interfaces_ = function interfaces_170() {
    return [Lineal];
  };
  MultiLineString2.prototype.getClass = function getClass169() {
    return MultiLineString2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 8166665132445434e3;
  };
  Object.defineProperties(MultiLineString2, staticAccessors2);
  return MultiLineString2;
}(GeometryCollection);
var BoundaryOp = function BoundaryOp2() {
  this._geom = null;
  this._geomFact = null;
  this._bnRule = null;
  this._endpointMap = null;
  if (arguments.length === 1) {
    var geom = arguments[0];
    var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
    this._geom = geom;
    this._geomFact = geom.getFactory();
    this._bnRule = bnRule;
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var bnRule$1 = arguments[1];
    this._geom = geom$1;
    this._geomFact = geom$1.getFactory();
    this._bnRule = bnRule$1;
  }
};
BoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString(mLine) {
  if (this._geom.isEmpty()) {
    return this.getEmptyMultiPoint();
  }
  var bdyPts = this.computeBoundaryCoordinates(mLine);
  if (bdyPts.length === 1) {
    return this._geomFact.createPoint(bdyPts[0]);
  }
  return this._geomFact.createMultiPointFromCoords(bdyPts);
};
BoundaryOp.prototype.getBoundary = function getBoundary() {
  if (this._geom instanceof LineString) {
    return this.boundaryLineString(this._geom);
  }
  if (this._geom instanceof MultiLineString) {
    return this.boundaryMultiLineString(this._geom);
  }
  return this._geom.getBoundary();
};
BoundaryOp.prototype.boundaryLineString = function boundaryLineString(line) {
  if (this._geom.isEmpty()) {
    return this.getEmptyMultiPoint();
  }
  if (line.isClosed()) {
    var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
    if (closedEndpointOnBoundary) {
      return line.getStartPoint();
    } else {
      return this._geomFact.createMultiPoint();
    }
  }
  return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);
};
BoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint() {
  return this._geomFact.createMultiPoint();
};
BoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates(mLine) {
  var this$1$1 = this;
  var bdyPts = new ArrayList();
  this._endpointMap = new TreeMap();
  for (var i = 0; i < mLine.getNumGeometries(); i++) {
    var line = mLine.getGeometryN(i);
    if (line.getNumPoints() === 0) {
      continue;
    }
    this$1$1.addEndpoint(line.getCoordinateN(0));
    this$1$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
  }
  for (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {
    var entry = it.next();
    var counter = entry.getValue();
    var valence = counter.count;
    if (this$1$1._bnRule.isInBoundary(valence)) {
      bdyPts.add(entry.getKey());
    }
  }
  return CoordinateArrays.toCoordinateArray(bdyPts);
};
BoundaryOp.prototype.addEndpoint = function addEndpoint(pt) {
  var counter = this._endpointMap.get(pt);
  if (counter === null) {
    counter = new Counter();
    this._endpointMap.put(pt, counter);
  }
  counter.count++;
};
BoundaryOp.prototype.interfaces_ = function interfaces_33() {
  return [];
};
BoundaryOp.prototype.getClass = function getClass32() {
  return BoundaryOp;
};
BoundaryOp.getBoundary = function getBoundary2() {
  if (arguments.length === 1) {
    var g = arguments[0];
    var bop = new BoundaryOp(g);
    return bop.getBoundary();
  } else if (arguments.length === 2) {
    var g$1 = arguments[0];
    var bnRule = arguments[1];
    var bop$1 = new BoundaryOp(g$1, bnRule);
    return bop$1.getBoundary();
  }
};
var Counter = function Counter2() {
  this.count = null;
};
Counter.prototype.interfaces_ = function interfaces_34() {
  return [];
};
Counter.prototype.getClass = function getClass33() {
  return Counter;
};
function PrintStream() {
}
function StringReader() {
}
var DecimalFormat = function DecimalFormat2() {
};
function ByteArrayOutputStream() {
}
function IOException() {
}
function LineNumberReader() {
}
var StringUtil = function StringUtil2() {
};
var staticAccessors$15 = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
StringUtil.prototype.interfaces_ = function interfaces_35() {
  return [];
};
StringUtil.prototype.getClass = function getClass34() {
  return StringUtil;
};
StringUtil.chars = function chars(c, n) {
  var ch = new Array(n).fill(null);
  for (var i = 0; i < n; i++) {
    ch[i] = c;
  }
  return String(ch);
};
StringUtil.getStackTrace = function getStackTrace() {
  if (arguments.length === 1) {
    var t = arguments[0];
    var os = new ByteArrayOutputStream();
    var ps = new PrintStream();
    t.printStackTrace(ps);
    return os.toString();
  } else if (arguments.length === 2) {
    var t$1 = arguments[0];
    var depth2 = arguments[1];
    var stackTrace = "";
    new StringReader(StringUtil.getStackTrace(t$1));
    var lineNumberReader = new LineNumberReader();
    for (var i = 0; i < depth2; i++) {
      try {
        stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
      } catch (e2) {
        if (e2 instanceof IOException) {
          Assert.shouldNeverReachHere();
        } else {
          throw e2;
        }
      } finally {
      }
    }
    return stackTrace;
  }
};
StringUtil.split = function split(s, separator) {
  var separatorlen = separator.length;
  var tokenList = new ArrayList();
  var tmpString = "" + s;
  var pos = tmpString.indexOf(separator);
  while (pos >= 0) {
    var token = tmpString.substring(0, pos);
    tokenList.add(token);
    tmpString = tmpString.substring(pos + separatorlen);
    pos = tmpString.indexOf(separator);
  }
  if (tmpString.length > 0) {
    tokenList.add(tmpString);
  }
  var res = new Array(tokenList.size()).fill(null);
  for (var i = 0; i < res.length; i++) {
    res[i] = tokenList.get(i);
  }
  return res;
};
StringUtil.toString = function toString6() {
  if (arguments.length === 1) {
    var d = arguments[0];
    return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);
  }
};
StringUtil.spaces = function spaces(n) {
  return StringUtil.chars(" ", n);
};
staticAccessors$15.NEWLINE.get = function() {
  return System.getProperty("line.separator");
};
staticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function() {
  return new DecimalFormat();
};
Object.defineProperties(StringUtil, staticAccessors$15);
var CoordinateSequences = function CoordinateSequences2() {
};
CoordinateSequences.prototype.interfaces_ = function interfaces_36() {
  return [];
};
CoordinateSequences.prototype.getClass = function getClass35() {
  return CoordinateSequences;
};
CoordinateSequences.copyCoord = function copyCoord(src2, srcPos, dest, destPos) {
  var minDim = Math.min(src2.getDimension(), dest.getDimension());
  for (var dim = 0; dim < minDim; dim++) {
    dest.setOrdinate(destPos, dim, src2.getOrdinate(srcPos, dim));
  }
};
CoordinateSequences.isRing = function isRing2(seq) {
  var n = seq.size();
  if (n === 0) {
    return true;
  }
  if (n <= 3) {
    return false;
  }
  return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
};
CoordinateSequences.isEqual = function isEqual(cs1, cs2) {
  var cs1Size = cs1.size();
  var cs2Size = cs2.size();
  if (cs1Size !== cs2Size) {
    return false;
  }
  var dim = Math.min(cs1.getDimension(), cs2.getDimension());
  for (var i = 0; i < cs1Size; i++) {
    for (var d = 0; d < dim; d++) {
      var v12 = cs1.getOrdinate(i, d);
      var v22 = cs2.getOrdinate(i, d);
      if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) {
        continue;
      }
      if (Double.isNaN(v12) && Double.isNaN(v22)) {
        continue;
      }
      return false;
    }
  }
  return true;
};
CoordinateSequences.extend = function extend(fact, seq, size11) {
  var newseq = fact.create(size11, seq.getDimension());
  var n = seq.size();
  CoordinateSequences.copy(seq, 0, newseq, 0, n);
  if (n > 0) {
    for (var i = n; i < size11; i++) {
      CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
    }
  }
  return newseq;
};
CoordinateSequences.reverse = function reverse2(seq) {
  var last = seq.size() - 1;
  var mid = Math.trunc(last / 2);
  for (var i = 0; i <= mid; i++) {
    CoordinateSequences.swap(seq, i, last - i);
  }
};
CoordinateSequences.swap = function swap(seq, i, j) {
  if (i === j) {
    return null;
  }
  for (var dim = 0; dim < seq.getDimension(); dim++) {
    var tmp = seq.getOrdinate(i, dim);
    seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
    seq.setOrdinate(j, dim, tmp);
  }
};
CoordinateSequences.copy = function copy4(src2, srcPos, dest, destPos, length3) {
  for (var i = 0; i < length3; i++) {
    CoordinateSequences.copyCoord(src2, srcPos + i, dest, destPos + i);
  }
};
CoordinateSequences.toString = function toString7() {
  if (arguments.length === 1) {
    var cs = arguments[0];
    var size11 = cs.size();
    if (size11 === 0) {
      return "()";
    }
    var dim = cs.getDimension();
    var buf = new StringBuffer();
    buf.append("(");
    for (var i = 0; i < size11; i++) {
      if (i > 0) {
        buf.append(" ");
      }
      for (var d = 0; d < dim; d++) {
        if (d > 0) {
          buf.append(",");
        }
        buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
      }
    }
    buf.append(")");
    return buf.toString();
  }
};
CoordinateSequences.ensureValidRing = function ensureValidRing(fact, seq) {
  var n = seq.size();
  if (n === 0) {
    return seq;
  }
  if (n <= 3) {
    return CoordinateSequences.createClosedRing(fact, seq, 4);
  }
  var isClosed5 = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
  if (isClosed5) {
    return seq;
  }
  return CoordinateSequences.createClosedRing(fact, seq, n + 1);
};
CoordinateSequences.createClosedRing = function createClosedRing(fact, seq, size11) {
  var newseq = fact.create(size11, seq.getDimension());
  var n = seq.size();
  CoordinateSequences.copy(seq, 0, newseq, 0, n);
  for (var i = n; i < size11; i++) {
    CoordinateSequences.copy(seq, 0, newseq, i, 1);
  }
  return newseq;
};
var LineString = function(Geometry$$1) {
  function LineString2(points2, factory) {
    Geometry$$1.call(this, factory);
    this._points = null;
    this.init(points2);
  }
  if (Geometry$$1)
    LineString2.__proto__ = Geometry$$1;
  LineString2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  LineString2.prototype.constructor = LineString2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  LineString2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    if (this.isEmpty()) {
      return new Envelope();
    }
    return this._points.expandEnvelope(new Envelope());
  };
  LineString2.prototype.isRing = function isRing3() {
    return this.isClosed() && this.isSimple();
  };
  LineString2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_LINESTRING;
  };
  LineString2.prototype.getCoordinates = function getCoordinates11() {
    return this._points.toCoordinateArray();
  };
  LineString2.prototype.equalsExact = function equalsExact2() {
    var this$1$1 = this;
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      var otherLineString = other;
      if (this._points.size() !== otherLineString._points.size()) {
        return false;
      }
      for (var i = 0; i < this._points.size(); i++) {
        if (!this$1$1.equal(this$1$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
          return false;
        }
      }
      return true;
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  LineString2.prototype.normalize = function normalize5() {
    var this$1$1 = this;
    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
      var j = this$1$1._points.size() - 1 - i;
      if (!this$1$1._points.getCoordinate(i).equals(this$1$1._points.getCoordinate(j))) {
        if (this$1$1._points.getCoordinate(i).compareTo(this$1$1._points.getCoordinate(j)) > 0) {
          CoordinateSequences.reverse(this$1$1._points);
        }
        return null;
      }
    }
  };
  LineString2.prototype.getCoordinate = function getCoordinate18() {
    if (this.isEmpty()) {
      return null;
    }
    return this._points.getCoordinate(0);
  };
  LineString2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    if (this.isClosed()) {
      return Dimension.FALSE;
    }
    return 0;
  };
  LineString2.prototype.isClosed = function isClosed5() {
    if (this.isEmpty()) {
      return false;
    }
    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
  };
  LineString2.prototype.getEndPoint = function getEndPoint() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getPointN(this.getNumPoints() - 1);
  };
  LineString2.prototype.getDimension = function getDimension3() {
    return 1;
  };
  LineString2.prototype.getLength = function getLength3() {
    return CGAlgorithms.computeLength(this._points);
  };
  LineString2.prototype.getNumPoints = function getNumPoints() {
    return this._points.size();
  };
  LineString2.prototype.reverse = function reverse5() {
    var seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    var revLine = this.getFactory().createLineString(seq);
    return revLine;
  };
  LineString2.prototype.compareToSameClass = function compareToSameClass() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var o = arguments[0];
      var line = o;
      var i = 0;
      var j = 0;
      while (i < this._points.size() && j < line._points.size()) {
        var comparison = this$1$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
        if (comparison !== 0) {
          return comparison;
        }
        i++;
        j++;
      }
      if (i < this._points.size()) {
        return 1;
      }
      if (j < line._points.size()) {
        return -1;
      }
      return 0;
    } else if (arguments.length === 2) {
      var o$1 = arguments[0];
      var comp = arguments[1];
      var line$1 = o$1;
      return comp.compare(this._points, line$1._points);
    }
  };
  LineString2.prototype.apply = function apply() {
    var this$1$1 = this;
    if (hasInterface(arguments[0], CoordinateFilter)) {
      var filter18 = arguments[0];
      for (var i = 0; i < this._points.size(); i++) {
        filter18.filter(this$1$1._points.getCoordinate(i));
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      var filter$1 = arguments[0];
      if (this._points.size() === 0) {
        return null;
      }
      for (var i$1 = 0; i$1 < this._points.size(); i$1++) {
        filter$1.filter(this$1$1._points, i$1);
        if (filter$1.isDone()) {
          break;
        }
      }
      if (filter$1.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      var filter$2 = arguments[0];
      filter$2.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      var filter$3 = arguments[0];
      filter$3.filter(this);
    }
  };
  LineString2.prototype.getBoundary = function getBoundary3() {
    return new BoundaryOp(this).getBoundary();
  };
  LineString2.prototype.isEquivalentClass = function isEquivalentClass(other) {
    return other instanceof LineString2;
  };
  LineString2.prototype.clone = function clone6() {
    var ls = Geometry$$1.prototype.clone.call(this);
    ls._points = this._points.clone();
    return ls;
  };
  LineString2.prototype.getCoordinateN = function getCoordinateN(n) {
    return this._points.getCoordinate(n);
  };
  LineString2.prototype.getGeometryType = function getGeometryType() {
    return "LineString";
  };
  LineString2.prototype.copy = function copy8() {
    return new LineString2(this._points.copy(), this._factory);
  };
  LineString2.prototype.getCoordinateSequence = function getCoordinateSequence() {
    return this._points;
  };
  LineString2.prototype.isEmpty = function isEmpty6() {
    return this._points.size() === 0;
  };
  LineString2.prototype.init = function init9(points2) {
    if (points2 === null) {
      points2 = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    if (points2.size() === 1) {
      throw new IllegalArgumentException("Invalid number of points in LineString (found " + points2.size() + " - must be 0 or >= 2)");
    }
    this._points = points2;
  };
  LineString2.prototype.isCoordinate = function isCoordinate(pt) {
    var this$1$1 = this;
    for (var i = 0; i < this._points.size(); i++) {
      if (this$1$1._points.getCoordinate(i).equals(pt)) {
        return true;
      }
    }
    return false;
  };
  LineString2.prototype.getStartPoint = function getStartPoint() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getPointN(0);
  };
  LineString2.prototype.getPointN = function getPointN(n) {
    return this.getFactory().createPoint(this._points.getCoordinate(n));
  };
  LineString2.prototype.interfaces_ = function interfaces_170() {
    return [Lineal];
  };
  LineString2.prototype.getClass = function getClass169() {
    return LineString2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 3110669828065365500;
  };
  Object.defineProperties(LineString2, staticAccessors2);
  return LineString2;
}(Geometry);
var Puntal = function Puntal2() {
};
Puntal.prototype.interfaces_ = function interfaces_37() {
  return [];
};
Puntal.prototype.getClass = function getClass36() {
  return Puntal;
};
var Point$2 = function(Geometry$$1) {
  function Point2(coordinates, factory) {
    Geometry$$1.call(this, factory);
    this._coordinates = coordinates || null;
    this.init(this._coordinates);
  }
  if (Geometry$$1)
    Point2.__proto__ = Geometry$$1;
  Point2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  Point2.prototype.constructor = Point2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  Point2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    if (this.isEmpty()) {
      return new Envelope();
    }
    var env2 = new Envelope();
    env2.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
    return env2;
  };
  Point2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_POINT;
  };
  Point2.prototype.getCoordinates = function getCoordinates11() {
    return this.isEmpty() ? [] : [this.getCoordinate()];
  };
  Point2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      if (this.isEmpty() && other.isEmpty()) {
        return true;
      }
      if (this.isEmpty() !== other.isEmpty()) {
        return false;
      }
      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  Point2.prototype.normalize = function normalize5() {
  };
  Point2.prototype.getCoordinate = function getCoordinate18() {
    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
  };
  Point2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return Dimension.FALSE;
  };
  Point2.prototype.getDimension = function getDimension3() {
    return 0;
  };
  Point2.prototype.getNumPoints = function getNumPoints() {
    return this.isEmpty() ? 0 : 1;
  };
  Point2.prototype.reverse = function reverse5() {
    return this.copy();
  };
  Point2.prototype.getX = function getX4() {
    if (this.getCoordinate() === null) {
      throw new Error("getX called on empty Point");
    }
    return this.getCoordinate().x;
  };
  Point2.prototype.compareToSameClass = function compareToSameClass() {
    if (arguments.length === 1) {
      var other = arguments[0];
      var point$1 = other;
      return this.getCoordinate().compareTo(point$1.getCoordinate());
    } else if (arguments.length === 2) {
      var other$1 = arguments[0];
      var comp = arguments[1];
      var point4 = other$1;
      return comp.compare(this._coordinates, point4._coordinates);
    }
  };
  Point2.prototype.apply = function apply() {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      var filter18 = arguments[0];
      if (this.isEmpty()) {
        return null;
      }
      filter18.filter(this.getCoordinate());
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      var filter$1 = arguments[0];
      if (this.isEmpty()) {
        return null;
      }
      filter$1.filter(this._coordinates, 0);
      if (filter$1.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      var filter$2 = arguments[0];
      filter$2.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      var filter$3 = arguments[0];
      filter$3.filter(this);
    }
  };
  Point2.prototype.getBoundary = function getBoundary3() {
    return this.getFactory().createGeometryCollection(null);
  };
  Point2.prototype.clone = function clone6() {
    var p = Geometry$$1.prototype.clone.call(this);
    p._coordinates = this._coordinates.clone();
    return p;
  };
  Point2.prototype.getGeometryType = function getGeometryType() {
    return "Point";
  };
  Point2.prototype.copy = function copy8() {
    return new Point2(this._coordinates.copy(), this._factory);
  };
  Point2.prototype.getCoordinateSequence = function getCoordinateSequence() {
    return this._coordinates;
  };
  Point2.prototype.getY = function getY4() {
    if (this.getCoordinate() === null) {
      throw new Error("getY called on empty Point");
    }
    return this.getCoordinate().y;
  };
  Point2.prototype.isEmpty = function isEmpty6() {
    return this._coordinates.size() === 0;
  };
  Point2.prototype.init = function init9(coordinates) {
    if (coordinates === null) {
      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    Assert.isTrue(coordinates.size() <= 1);
    this._coordinates = coordinates;
  };
  Point2.prototype.isSimple = function isSimple() {
    return true;
  };
  Point2.prototype.interfaces_ = function interfaces_170() {
    return [Puntal];
  };
  Point2.prototype.getClass = function getClass169() {
    return Point2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 4902022702746615e3;
  };
  Object.defineProperties(Point2, staticAccessors2);
  return Point2;
}(Geometry);
var Polygonal = function Polygonal2() {
};
Polygonal.prototype.interfaces_ = function interfaces_38() {
  return [];
};
Polygonal.prototype.getClass = function getClass37() {
  return Polygonal;
};
var Polygon$2 = function(Geometry$$1) {
  function Polygon2(shell, holes, factory) {
    Geometry$$1.call(this, factory);
    this._shell = null;
    this._holes = null;
    if (shell === null) {
      shell = this.getFactory().createLinearRing();
    }
    if (holes === null) {
      holes = [];
    }
    if (Geometry$$1.hasNullElements(holes)) {
      throw new IllegalArgumentException("holes must not contain null elements");
    }
    if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {
      throw new IllegalArgumentException("shell is empty but holes are not");
    }
    this._shell = shell;
    this._holes = holes;
  }
  if (Geometry$$1)
    Polygon2.__proto__ = Geometry$$1;
  Polygon2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  Polygon2.prototype.constructor = Polygon2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  Polygon2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    return this._shell.getEnvelopeInternal();
  };
  Polygon2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_POLYGON;
  };
  Polygon2.prototype.getCoordinates = function getCoordinates11() {
    var this$1$1 = this;
    if (this.isEmpty()) {
      return [];
    }
    var coordinates = new Array(this.getNumPoints()).fill(null);
    var k = -1;
    var shellCoordinates = this._shell.getCoordinates();
    for (var x2 = 0; x2 < shellCoordinates.length; x2++) {
      k++;
      coordinates[k] = shellCoordinates[x2];
    }
    for (var i = 0; i < this._holes.length; i++) {
      var childCoordinates = this$1$1._holes[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates;
  };
  Polygon2.prototype.getArea = function getArea3() {
    var this$1$1 = this;
    var area5 = 0;
    area5 += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
    for (var i = 0; i < this._holes.length; i++) {
      area5 -= Math.abs(CGAlgorithms.signedArea(this$1$1._holes[i].getCoordinateSequence()));
    }
    return area5;
  };
  Polygon2.prototype.isRectangle = function isRectangle2() {
    if (this.getNumInteriorRing() !== 0) {
      return false;
    }
    if (this._shell === null) {
      return false;
    }
    if (this._shell.getNumPoints() !== 5) {
      return false;
    }
    var seq = this._shell.getCoordinateSequence();
    var env2 = this.getEnvelopeInternal();
    for (var i = 0; i < 5; i++) {
      var x2 = seq.getX(i);
      if (!(x2 === env2.getMinX() || x2 === env2.getMaxX())) {
        return false;
      }
      var y2 = seq.getY(i);
      if (!(y2 === env2.getMinY() || y2 === env2.getMaxY())) {
        return false;
      }
    }
    var prevX = seq.getX(0);
    var prevY = seq.getY(0);
    for (var i$1 = 1; i$1 <= 4; i$1++) {
      var x$1 = seq.getX(i$1);
      var y$1 = seq.getY(i$1);
      var xChanged = x$1 !== prevX;
      var yChanged = y$1 !== prevY;
      if (xChanged === yChanged) {
        return false;
      }
      prevX = x$1;
      prevY = y$1;
    }
    return true;
  };
  Polygon2.prototype.equalsExact = function equalsExact2() {
    var this$1$1 = this;
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      var otherPolygon = other;
      var thisShell = this._shell;
      var otherPolygonShell = otherPolygon._shell;
      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
        return false;
      }
      if (this._holes.length !== otherPolygon._holes.length) {
        return false;
      }
      for (var i = 0; i < this._holes.length; i++) {
        if (!this$1$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
          return false;
        }
      }
      return true;
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  Polygon2.prototype.normalize = function normalize5() {
    var this$1$1 = this;
    if (arguments.length === 0) {
      this.normalize(this._shell, true);
      for (var i = 0; i < this._holes.length; i++) {
        this$1$1.normalize(this$1$1._holes[i], false);
      }
      Arrays.sort(this._holes);
    } else if (arguments.length === 2) {
      var ring = arguments[0];
      var clockwise = arguments[1];
      if (ring.isEmpty()) {
        return null;
      }
      var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
      var minCoordinate2 = CoordinateArrays.minCoordinate(ring.getCoordinates());
      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate2);
      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
        CoordinateArrays.reverse(ring.getCoordinates());
      }
    }
  };
  Polygon2.prototype.getCoordinate = function getCoordinate18() {
    return this._shell.getCoordinate();
  };
  Polygon2.prototype.getNumInteriorRing = function getNumInteriorRing() {
    return this._holes.length;
  };
  Polygon2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return 1;
  };
  Polygon2.prototype.getDimension = function getDimension3() {
    return 2;
  };
  Polygon2.prototype.getLength = function getLength3() {
    var this$1$1 = this;
    var len2 = 0;
    len2 += this._shell.getLength();
    for (var i = 0; i < this._holes.length; i++) {
      len2 += this$1$1._holes[i].getLength();
    }
    return len2;
  };
  Polygon2.prototype.getNumPoints = function getNumPoints() {
    var this$1$1 = this;
    var numPoints = this._shell.getNumPoints();
    for (var i = 0; i < this._holes.length; i++) {
      numPoints += this$1$1._holes[i].getNumPoints();
    }
    return numPoints;
  };
  Polygon2.prototype.reverse = function reverse5() {
    var this$1$1 = this;
    var poly = this.copy();
    poly._shell = this._shell.copy().reverse();
    poly._holes = new Array(this._holes.length).fill(null);
    for (var i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this$1$1._holes[i].copy().reverse();
    }
    return poly;
  };
  Polygon2.prototype.convexHull = function convexHull2() {
    return this.getExteriorRing().convexHull();
  };
  Polygon2.prototype.compareToSameClass = function compareToSameClass() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var o = arguments[0];
      var thisShell = this._shell;
      var otherShell = o._shell;
      return thisShell.compareToSameClass(otherShell);
    } else if (arguments.length === 2) {
      var o$1 = arguments[0];
      var comp = arguments[1];
      var poly = o$1;
      var thisShell$1 = this._shell;
      var otherShell$1 = poly._shell;
      var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);
      if (shellComp !== 0) {
        return shellComp;
      }
      var nHole1 = this.getNumInteriorRing();
      var nHole2 = poly.getNumInteriorRing();
      var i = 0;
      while (i < nHole1 && i < nHole2) {
        var thisHole = this$1$1.getInteriorRingN(i);
        var otherHole = poly.getInteriorRingN(i);
        var holeComp = thisHole.compareToSameClass(otherHole, comp);
        if (holeComp !== 0) {
          return holeComp;
        }
        i++;
      }
      if (i < nHole1) {
        return 1;
      }
      if (i < nHole2) {
        return -1;
      }
      return 0;
    }
  };
  Polygon2.prototype.apply = function apply(filter18) {
    var this$1$1 = this;
    if (hasInterface(filter18, CoordinateFilter)) {
      this._shell.apply(filter18);
      for (var i$1 = 0; i$1 < this._holes.length; i$1++) {
        this$1$1._holes[i$1].apply(filter18);
      }
    } else if (hasInterface(filter18, CoordinateSequenceFilter)) {
      this._shell.apply(filter18);
      if (!filter18.isDone()) {
        for (var i$2 = 0; i$2 < this._holes.length; i$2++) {
          this$1$1._holes[i$2].apply(filter18);
          if (filter18.isDone()) {
            break;
          }
        }
      }
      if (filter18.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(filter18, GeometryFilter)) {
      filter18.filter(this);
    } else if (hasInterface(filter18, GeometryComponentFilter)) {
      filter18.filter(this);
      this._shell.apply(filter18);
      for (var i = 0; i < this._holes.length; i++) {
        this$1$1._holes[i].apply(filter18);
      }
    }
  };
  Polygon2.prototype.getBoundary = function getBoundary3() {
    var this$1$1 = this;
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString();
    }
    var rings = new Array(this._holes.length + 1).fill(null);
    rings[0] = this._shell;
    for (var i = 0; i < this._holes.length; i++) {
      rings[i + 1] = this$1$1._holes[i];
    }
    if (rings.length <= 1) {
      return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
    }
    return this.getFactory().createMultiLineString(rings);
  };
  Polygon2.prototype.clone = function clone6() {
    var this$1$1 = this;
    var poly = Geometry$$1.prototype.clone.call(this);
    poly._shell = this._shell.clone();
    poly._holes = new Array(this._holes.length).fill(null);
    for (var i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this$1$1._holes[i].clone();
    }
    return poly;
  };
  Polygon2.prototype.getGeometryType = function getGeometryType() {
    return "Polygon";
  };
  Polygon2.prototype.copy = function copy8() {
    var this$1$1 = this;
    var shell = this._shell.copy();
    var holes = new Array(this._holes.length).fill(null);
    for (var i = 0; i < holes.length; i++) {
      holes[i] = this$1$1._holes[i].copy();
    }
    return new Polygon2(shell, holes, this._factory);
  };
  Polygon2.prototype.getExteriorRing = function getExteriorRing() {
    return this._shell;
  };
  Polygon2.prototype.isEmpty = function isEmpty6() {
    return this._shell.isEmpty();
  };
  Polygon2.prototype.getInteriorRingN = function getInteriorRingN(n) {
    return this._holes[n];
  };
  Polygon2.prototype.interfaces_ = function interfaces_170() {
    return [Polygonal];
  };
  Polygon2.prototype.getClass = function getClass169() {
    return Polygon2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -3494792200821764600;
  };
  Object.defineProperties(Polygon2, staticAccessors2);
  return Polygon2;
}(Geometry);
var MultiPoint = function(GeometryCollection$$1) {
  function MultiPoint2() {
    GeometryCollection$$1.apply(this, arguments);
  }
  if (GeometryCollection$$1)
    MultiPoint2.__proto__ = GeometryCollection$$1;
  MultiPoint2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
  MultiPoint2.prototype.constructor = MultiPoint2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  MultiPoint2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_MULTIPOINT;
  };
  MultiPoint2.prototype.isValid = function isValid7() {
    return true;
  };
  MultiPoint2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
    } else {
      return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  MultiPoint2.prototype.getCoordinate = function getCoordinate18() {
    if (arguments.length === 1) {
      var n = arguments[0];
      return this._geometries[n].getCoordinate();
    } else {
      return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments);
    }
  };
  MultiPoint2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return Dimension.FALSE;
  };
  MultiPoint2.prototype.getDimension = function getDimension3() {
    return 0;
  };
  MultiPoint2.prototype.getBoundary = function getBoundary3() {
    return this.getFactory().createGeometryCollection(null);
  };
  MultiPoint2.prototype.getGeometryType = function getGeometryType() {
    return "MultiPoint";
  };
  MultiPoint2.prototype.copy = function copy8() {
    var this$1$1 = this;
    var points2 = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < points2.length; i++) {
      points2[i] = this$1$1._geometries[i].copy();
    }
    return new MultiPoint2(points2, this._factory);
  };
  MultiPoint2.prototype.interfaces_ = function interfaces_170() {
    return [Puntal];
  };
  MultiPoint2.prototype.getClass = function getClass169() {
    return MultiPoint2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -8048474874175356e3;
  };
  Object.defineProperties(MultiPoint2, staticAccessors2);
  return MultiPoint2;
}(GeometryCollection);
var LinearRing = function(LineString$$1) {
  function LinearRing2(points2, factory) {
    if (points2 instanceof Coordinate && factory instanceof GeometryFactory) {
      points2 = factory.getCoordinateSequenceFactory().create(points2);
    }
    LineString$$1.call(this, points2, factory);
    this.validateConstruction();
  }
  if (LineString$$1)
    LinearRing2.__proto__ = LineString$$1;
  LinearRing2.prototype = Object.create(LineString$$1 && LineString$$1.prototype);
  LinearRing2.prototype.constructor = LinearRing2;
  var staticAccessors2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
  LinearRing2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_LINEARRING;
  };
  LinearRing2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return Dimension.FALSE;
  };
  LinearRing2.prototype.isClosed = function isClosed5() {
    if (this.isEmpty()) {
      return true;
    }
    return LineString$$1.prototype.isClosed.call(this);
  };
  LinearRing2.prototype.reverse = function reverse5() {
    var seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    var rev = this.getFactory().createLinearRing(seq);
    return rev;
  };
  LinearRing2.prototype.validateConstruction = function validateConstruction() {
    if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {
      throw new IllegalArgumentException("Points of LinearRing do not form a closed linestring");
    }
    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing2.MINIMUM_VALID_SIZE) {
      throw new IllegalArgumentException("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
    }
  };
  LinearRing2.prototype.getGeometryType = function getGeometryType() {
    return "LinearRing";
  };
  LinearRing2.prototype.copy = function copy8() {
    return new LinearRing2(this._points.copy(), this._factory);
  };
  LinearRing2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  LinearRing2.prototype.getClass = function getClass169() {
    return LinearRing2;
  };
  staticAccessors2.MINIMUM_VALID_SIZE.get = function() {
    return 4;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -4261142084085851600;
  };
  Object.defineProperties(LinearRing2, staticAccessors2);
  return LinearRing2;
}(LineString);
var MultiPolygon = function(GeometryCollection$$1) {
  function MultiPolygon2() {
    GeometryCollection$$1.apply(this, arguments);
  }
  if (GeometryCollection$$1)
    MultiPolygon2.__proto__ = GeometryCollection$$1;
  MultiPolygon2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
  MultiPolygon2.prototype.constructor = MultiPolygon2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  MultiPolygon2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_MULTIPOLYGON;
  };
  MultiPolygon2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
    } else {
      return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  MultiPolygon2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return 1;
  };
  MultiPolygon2.prototype.getDimension = function getDimension3() {
    return 2;
  };
  MultiPolygon2.prototype.reverse = function reverse5() {
    var this$1$1 = this;
    var n = this._geometries.length;
    var revGeoms = new Array(n).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this$1$1._geometries[i].reverse();
    }
    return this.getFactory().createMultiPolygon(revGeoms);
  };
  MultiPolygon2.prototype.getBoundary = function getBoundary3() {
    var this$1$1 = this;
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString();
    }
    var allRings = new ArrayList();
    for (var i = 0; i < this._geometries.length; i++) {
      var polygon4 = this$1$1._geometries[i];
      var rings = polygon4.getBoundary();
      for (var j = 0; j < rings.getNumGeometries(); j++) {
        allRings.add(rings.getGeometryN(j));
      }
    }
    var allRingsArray = new Array(allRings.size()).fill(null);
    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
  };
  MultiPolygon2.prototype.getGeometryType = function getGeometryType() {
    return "MultiPolygon";
  };
  MultiPolygon2.prototype.copy = function copy8() {
    var this$1$1 = this;
    var polygons2 = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < polygons2.length; i++) {
      polygons2[i] = this$1$1._geometries[i].copy();
    }
    return new MultiPolygon2(polygons2, this._factory);
  };
  MultiPolygon2.prototype.interfaces_ = function interfaces_170() {
    return [Polygonal];
  };
  MultiPolygon2.prototype.getClass = function getClass169() {
    return MultiPolygon2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -551033529766975900;
  };
  Object.defineProperties(MultiPolygon2, staticAccessors2);
  return MultiPolygon2;
}(GeometryCollection);
var GeometryEditor = function GeometryEditor2(factory) {
  this._factory = factory || null;
  this._isUserDataCopied = false;
};
var staticAccessors$16 = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
GeometryEditor.prototype.setCopyUserData = function setCopyUserData(isUserDataCopied) {
  this._isUserDataCopied = isUserDataCopied;
};
GeometryEditor.prototype.edit = function edit(geometry2, operation2) {
  if (geometry2 === null) {
    return null;
  }
  var result = this.editInternal(geometry2, operation2);
  if (this._isUserDataCopied) {
    result.setUserData(geometry2.getUserData());
  }
  return result;
};
GeometryEditor.prototype.editInternal = function editInternal(geometry2, operation2) {
  if (this._factory === null) {
    this._factory = geometry2.getFactory();
  }
  if (geometry2 instanceof GeometryCollection) {
    return this.editGeometryCollection(geometry2, operation2);
  }
  if (geometry2 instanceof Polygon$2) {
    return this.editPolygon(geometry2, operation2);
  }
  if (geometry2 instanceof Point$2) {
    return operation2.edit(geometry2, this._factory);
  }
  if (geometry2 instanceof LineString) {
    return operation2.edit(geometry2, this._factory);
  }
  Assert.shouldNeverReachHere("Unsupported Geometry class: " + geometry2.getClass().getName());
  return null;
};
GeometryEditor.prototype.editGeometryCollection = function editGeometryCollection(collection, operation2) {
  var this$1$1 = this;
  var collectionForType = operation2.edit(collection, this._factory);
  var geometries = new ArrayList();
  for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
    var geometry2 = this$1$1.edit(collectionForType.getGeometryN(i), operation2);
    if (geometry2 === null || geometry2.isEmpty()) {
      continue;
    }
    geometries.add(geometry2);
  }
  if (collectionForType.getClass() === MultiPoint) {
    return this._factory.createMultiPoint(geometries.toArray([]));
  }
  if (collectionForType.getClass() === MultiLineString) {
    return this._factory.createMultiLineString(geometries.toArray([]));
  }
  if (collectionForType.getClass() === MultiPolygon) {
    return this._factory.createMultiPolygon(geometries.toArray([]));
  }
  return this._factory.createGeometryCollection(geometries.toArray([]));
};
GeometryEditor.prototype.editPolygon = function editPolygon(polygon4, operation2) {
  var this$1$1 = this;
  var newPolygon = operation2.edit(polygon4, this._factory);
  if (newPolygon === null) {
    newPolygon = this._factory.createPolygon(null);
  }
  if (newPolygon.isEmpty()) {
    return newPolygon;
  }
  var shell = this.edit(newPolygon.getExteriorRing(), operation2);
  if (shell === null || shell.isEmpty()) {
    return this._factory.createPolygon();
  }
  var holes = new ArrayList();
  for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
    var hole = this$1$1.edit(newPolygon.getInteriorRingN(i), operation2);
    if (hole === null || hole.isEmpty()) {
      continue;
    }
    holes.add(hole);
  }
  return this._factory.createPolygon(shell, holes.toArray([]));
};
GeometryEditor.prototype.interfaces_ = function interfaces_39() {
  return [];
};
GeometryEditor.prototype.getClass = function getClass38() {
  return GeometryEditor;
};
GeometryEditor.GeometryEditorOperation = function GeometryEditorOperation() {
};
staticAccessors$16.NoOpGeometryOperation.get = function() {
  return NoOpGeometryOperation;
};
staticAccessors$16.CoordinateOperation.get = function() {
  return CoordinateOperation;
};
staticAccessors$16.CoordinateSequenceOperation.get = function() {
  return CoordinateSequenceOperation;
};
Object.defineProperties(GeometryEditor, staticAccessors$16);
var NoOpGeometryOperation = function NoOpGeometryOperation2() {
};
NoOpGeometryOperation.prototype.edit = function edit2(geometry2, factory) {
  return geometry2;
};
NoOpGeometryOperation.prototype.interfaces_ = function interfaces_40() {
  return [GeometryEditor.GeometryEditorOperation];
};
NoOpGeometryOperation.prototype.getClass = function getClass39() {
  return NoOpGeometryOperation;
};
var CoordinateOperation = function CoordinateOperation2() {
};
CoordinateOperation.prototype.edit = function edit3(geometry2, factory) {
  var coords = this.editCoordinates(geometry2.getCoordinates(), geometry2);
  if (coords === null) {
    return geometry2;
  }
  if (geometry2 instanceof LinearRing) {
    return factory.createLinearRing(coords);
  }
  if (geometry2 instanceof LineString) {
    return factory.createLineString(coords);
  }
  if (geometry2 instanceof Point$2) {
    if (coords.length > 0) {
      return factory.createPoint(coords[0]);
    } else {
      return factory.createPoint();
    }
  }
  return geometry2;
};
CoordinateOperation.prototype.interfaces_ = function interfaces_41() {
  return [GeometryEditor.GeometryEditorOperation];
};
CoordinateOperation.prototype.getClass = function getClass40() {
  return CoordinateOperation;
};
var CoordinateSequenceOperation = function CoordinateSequenceOperation2() {
};
CoordinateSequenceOperation.prototype.edit = function edit4(geometry2, factory) {
  if (geometry2 instanceof LinearRing) {
    return factory.createLinearRing(this.edit(geometry2.getCoordinateSequence(), geometry2));
  }
  if (geometry2 instanceof LineString) {
    return factory.createLineString(this.edit(geometry2.getCoordinateSequence(), geometry2));
  }
  if (geometry2 instanceof Point$2) {
    return factory.createPoint(this.edit(geometry2.getCoordinateSequence(), geometry2));
  }
  return geometry2;
};
CoordinateSequenceOperation.prototype.interfaces_ = function interfaces_42() {
  return [GeometryEditor.GeometryEditorOperation];
};
CoordinateSequenceOperation.prototype.getClass = function getClass41() {
  return CoordinateSequenceOperation;
};
var CoordinateArraySequence = function CoordinateArraySequence2() {
  var this$1$1 = this;
  this._dimension = 3;
  this._coordinates = null;
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      this._coordinates = arguments[0];
      this._dimension = 3;
    } else if (Number.isInteger(arguments[0])) {
      var size11 = arguments[0];
      this._coordinates = new Array(size11).fill(null);
      for (var i = 0; i < size11; i++) {
        this$1$1._coordinates[i] = new Coordinate();
      }
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordSeq = arguments[0];
      if (coordSeq === null) {
        this._coordinates = new Array(0).fill(null);
        return null;
      }
      this._dimension = coordSeq.getDimension();
      this._coordinates = new Array(coordSeq.size()).fill(null);
      for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {
        this$1$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);
      }
    }
  } else if (arguments.length === 2) {
    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      var coordinates = arguments[0];
      var dimension = arguments[1];
      this._coordinates = coordinates;
      this._dimension = dimension;
      if (coordinates === null) {
        this._coordinates = new Array(0).fill(null);
      }
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var size$1 = arguments[0];
      var dimension$1 = arguments[1];
      this._coordinates = new Array(size$1).fill(null);
      this._dimension = dimension$1;
      for (var i$2 = 0; i$2 < size$1; i$2++) {
        this$1$1._coordinates[i$2] = new Coordinate();
      }
    }
  }
};
var staticAccessors$18 = { serialVersionUID: { configurable: true } };
CoordinateArraySequence.prototype.setOrdinate = function setOrdinate3(index2, ordinateIndex, value) {
  switch (ordinateIndex) {
    case CoordinateSequence.X:
      this._coordinates[index2].x = value;
      break;
    case CoordinateSequence.Y:
      this._coordinates[index2].y = value;
      break;
    case CoordinateSequence.Z:
      this._coordinates[index2].z = value;
      break;
    default:
      throw new IllegalArgumentException("invalid ordinateIndex");
  }
};
CoordinateArraySequence.prototype.size = function size4() {
  return this._coordinates.length;
};
CoordinateArraySequence.prototype.getOrdinate = function getOrdinate3(index2, ordinateIndex) {
  switch (ordinateIndex) {
    case CoordinateSequence.X:
      return this._coordinates[index2].x;
    case CoordinateSequence.Y:
      return this._coordinates[index2].y;
    case CoordinateSequence.Z:
      return this._coordinates[index2].z;
  }
  return Double.NaN;
};
CoordinateArraySequence.prototype.getCoordinate = function getCoordinate3() {
  if (arguments.length === 1) {
    var i = arguments[0];
    return this._coordinates[i];
  } else if (arguments.length === 2) {
    var index2 = arguments[0];
    var coord = arguments[1];
    coord.x = this._coordinates[index2].x;
    coord.y = this._coordinates[index2].y;
    coord.z = this._coordinates[index2].z;
  }
};
CoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy2(i) {
  return new Coordinate(this._coordinates[i]);
};
CoordinateArraySequence.prototype.getDimension = function getDimension2() {
  return this._dimension;
};
CoordinateArraySequence.prototype.getX = function getX3(index2) {
  return this._coordinates[index2].x;
};
CoordinateArraySequence.prototype.clone = function clone4() {
  var this$1$1 = this;
  var cloneCoordinates = new Array(this.size()).fill(null);
  for (var i = 0; i < this._coordinates.length; i++) {
    cloneCoordinates[i] = this$1$1._coordinates[i].clone();
  }
  return new CoordinateArraySequence(cloneCoordinates, this._dimension);
};
CoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope2(env2) {
  var this$1$1 = this;
  for (var i = 0; i < this._coordinates.length; i++) {
    env2.expandToInclude(this$1$1._coordinates[i]);
  }
  return env2;
};
CoordinateArraySequence.prototype.copy = function copy5() {
  var this$1$1 = this;
  var cloneCoordinates = new Array(this.size()).fill(null);
  for (var i = 0; i < this._coordinates.length; i++) {
    cloneCoordinates[i] = this$1$1._coordinates[i].copy();
  }
  return new CoordinateArraySequence(cloneCoordinates, this._dimension);
};
CoordinateArraySequence.prototype.toString = function toString8() {
  var this$1$1 = this;
  if (this._coordinates.length > 0) {
    var strBuf = new StringBuffer(17 * this._coordinates.length);
    strBuf.append("(");
    strBuf.append(this._coordinates[0]);
    for (var i = 1; i < this._coordinates.length; i++) {
      strBuf.append(", ");
      strBuf.append(this$1$1._coordinates[i]);
    }
    strBuf.append(")");
    return strBuf.toString();
  } else {
    return "()";
  }
};
CoordinateArraySequence.prototype.getY = function getY3(index2) {
  return this._coordinates[index2].y;
};
CoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray3() {
  return this._coordinates;
};
CoordinateArraySequence.prototype.interfaces_ = function interfaces_43() {
  return [CoordinateSequence, Serializable];
};
CoordinateArraySequence.prototype.getClass = function getClass42() {
  return CoordinateArraySequence;
};
staticAccessors$18.serialVersionUID.get = function() {
  return -915438501601840600;
};
Object.defineProperties(CoordinateArraySequence, staticAccessors$18);
var CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory2() {
};
var staticAccessors$17 = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
CoordinateArraySequenceFactory.prototype.readResolve = function readResolve() {
  return CoordinateArraySequenceFactory.instance();
};
CoordinateArraySequenceFactory.prototype.create = function create2() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var coordinates = arguments[0];
      return new CoordinateArraySequence(coordinates);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordSeq = arguments[0];
      return new CoordinateArraySequence(coordSeq);
    }
  } else if (arguments.length === 2) {
    var size11 = arguments[0];
    var dimension = arguments[1];
    if (dimension > 3) {
      dimension = 3;
    }
    if (dimension < 2) {
      return new CoordinateArraySequence(size11);
    }
    return new CoordinateArraySequence(size11, dimension);
  }
};
CoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_44() {
  return [CoordinateSequenceFactory, Serializable];
};
CoordinateArraySequenceFactory.prototype.getClass = function getClass43() {
  return CoordinateArraySequenceFactory;
};
CoordinateArraySequenceFactory.instance = function instance() {
  return CoordinateArraySequenceFactory.instanceObject;
};
staticAccessors$17.serialVersionUID.get = function() {
  return -4099577099607551500;
};
staticAccessors$17.instanceObject.get = function() {
  return new CoordinateArraySequenceFactory();
};
Object.defineProperties(CoordinateArraySequenceFactory, staticAccessors$17);
var HashMap$1 = function(MapInterface) {
  function HashMap2() {
    MapInterface.call(this);
    this.map_ = /* @__PURE__ */ new Map();
  }
  if (MapInterface)
    HashMap2.__proto__ = MapInterface;
  HashMap2.prototype = Object.create(MapInterface && MapInterface.prototype);
  HashMap2.prototype.constructor = HashMap2;
  HashMap2.prototype.get = function get5(key) {
    return this.map_.get(key) || null;
  };
  HashMap2.prototype.put = function put2(key, value) {
    this.map_.set(key, value);
    return value;
  };
  HashMap2.prototype.values = function values3() {
    var arrayList = new ArrayList();
    var it = this.map_.values();
    var o = it.next();
    while (!o.done) {
      arrayList.add(o.value);
      o = it.next();
    }
    return arrayList;
  };
  HashMap2.prototype.entrySet = function entrySet2() {
    var hashSet = new HashSet();
    this.map_.entries().forEach(function(entry) {
      return hashSet.add(entry);
    });
    return hashSet;
  };
  HashMap2.prototype.size = function size11() {
    return this.map_.size();
  };
  return HashMap2;
}(Map$1);
var PrecisionModel = function PrecisionModel2() {
  this._modelType = null;
  this._scale = null;
  if (arguments.length === 0) {
    this._modelType = PrecisionModel2.FLOATING;
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Type) {
      var modelType = arguments[0];
      this._modelType = modelType;
      if (modelType === PrecisionModel2.FIXED) {
        this.setScale(1);
      }
    } else if (typeof arguments[0] === "number") {
      var scale4 = arguments[0];
      this._modelType = PrecisionModel2.FIXED;
      this.setScale(scale4);
    } else if (arguments[0] instanceof PrecisionModel2) {
      var pm = arguments[0];
      this._modelType = pm._modelType;
      this._scale = pm._scale;
    }
  }
};
var staticAccessors$19 = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
PrecisionModel.prototype.equals = function equals8(other) {
  if (!(other instanceof PrecisionModel)) {
    return false;
  }
  var otherPrecisionModel = other;
  return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
};
PrecisionModel.prototype.compareTo = function compareTo6(o) {
  var other = o;
  var sigDigits = this.getMaximumSignificantDigits();
  var otherSigDigits = other.getMaximumSignificantDigits();
  return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));
};
PrecisionModel.prototype.getScale = function getScale() {
  return this._scale;
};
PrecisionModel.prototype.isFloating = function isFloating() {
  return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
};
PrecisionModel.prototype.getType = function getType2() {
  return this._modelType;
};
PrecisionModel.prototype.toString = function toString9() {
  var description2 = "UNKNOWN";
  if (this._modelType === PrecisionModel.FLOATING) {
    description2 = "Floating";
  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
    description2 = "Floating-Single";
  } else if (this._modelType === PrecisionModel.FIXED) {
    description2 = "Fixed (Scale=" + this.getScale() + ")";
  }
  return description2;
};
PrecisionModel.prototype.makePrecise = function makePrecise() {
  if (typeof arguments[0] === "number") {
    var val = arguments[0];
    if (Double.isNaN(val)) {
      return val;
    }
    if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
      var floatSingleVal = val;
      return floatSingleVal;
    }
    if (this._modelType === PrecisionModel.FIXED) {
      return Math.round(val * this._scale) / this._scale;
    }
    return val;
  } else if (arguments[0] instanceof Coordinate) {
    var coord = arguments[0];
    if (this._modelType === PrecisionModel.FLOATING) {
      return null;
    }
    coord.x = this.makePrecise(coord.x);
    coord.y = this.makePrecise(coord.y);
  }
};
PrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits() {
  var maxSigDigits = 16;
  if (this._modelType === PrecisionModel.FLOATING) {
    maxSigDigits = 16;
  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
    maxSigDigits = 6;
  } else if (this._modelType === PrecisionModel.FIXED) {
    maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
  }
  return maxSigDigits;
};
PrecisionModel.prototype.setScale = function setScale(scale4) {
  this._scale = Math.abs(scale4);
};
PrecisionModel.prototype.interfaces_ = function interfaces_45() {
  return [Serializable, Comparable];
};
PrecisionModel.prototype.getClass = function getClass44() {
  return PrecisionModel;
};
PrecisionModel.mostPrecise = function mostPrecise(pm1, pm2) {
  if (pm1.compareTo(pm2) >= 0) {
    return pm1;
  }
  return pm2;
};
staticAccessors$19.serialVersionUID.get = function() {
  return 7777263578777804e3;
};
staticAccessors$19.maximumPreciseValue.get = function() {
  return 9007199254740992;
};
Object.defineProperties(PrecisionModel, staticAccessors$19);
var Type = function Type2(name2) {
  this._name = name2 || null;
  Type2.nameToTypeMap.put(name2, this);
};
var staticAccessors$1$1 = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
Type.prototype.readResolve = function readResolve2() {
  return Type.nameToTypeMap.get(this._name);
};
Type.prototype.toString = function toString10() {
  return this._name;
};
Type.prototype.interfaces_ = function interfaces_46() {
  return [Serializable];
};
Type.prototype.getClass = function getClass45() {
  return Type;
};
staticAccessors$1$1.serialVersionUID.get = function() {
  return -552860263173159e4;
};
staticAccessors$1$1.nameToTypeMap.get = function() {
  return new HashMap$1();
};
Object.defineProperties(Type, staticAccessors$1$1);
PrecisionModel.Type = Type;
PrecisionModel.FIXED = new Type("FIXED");
PrecisionModel.FLOATING = new Type("FLOATING");
PrecisionModel.FLOATING_SINGLE = new Type("FLOATING SINGLE");
var GeometryFactory = function GeometryFactory2() {
  this._precisionModel = new PrecisionModel();
  this._SRID = 0;
  this._coordinateSequenceFactory = GeometryFactory2.getDefaultCoordinateSequenceFactory();
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
      this._coordinateSequenceFactory = arguments[0];
    } else if (arguments[0] instanceof PrecisionModel) {
      this._precisionModel = arguments[0];
    }
  } else if (arguments.length === 2) {
    this._precisionModel = arguments[0];
    this._SRID = arguments[1];
  } else if (arguments.length === 3) {
    this._precisionModel = arguments[0];
    this._SRID = arguments[1];
    this._coordinateSequenceFactory = arguments[2];
  }
};
var staticAccessors$2 = { serialVersionUID: { configurable: true } };
GeometryFactory.prototype.toGeometry = function toGeometry(envelope3) {
  if (envelope3.isNull()) {
    return this.createPoint(null);
  }
  if (envelope3.getMinX() === envelope3.getMaxX() && envelope3.getMinY() === envelope3.getMaxY()) {
    return this.createPoint(new Coordinate(envelope3.getMinX(), envelope3.getMinY()));
  }
  if (envelope3.getMinX() === envelope3.getMaxX() || envelope3.getMinY() === envelope3.getMaxY()) {
    return this.createLineString([new Coordinate(envelope3.getMinX(), envelope3.getMinY()), new Coordinate(envelope3.getMaxX(), envelope3.getMaxY())]);
  }
  return this.createPolygon(this.createLinearRing([new Coordinate(envelope3.getMinX(), envelope3.getMinY()), new Coordinate(envelope3.getMinX(), envelope3.getMaxY()), new Coordinate(envelope3.getMaxX(), envelope3.getMaxY()), new Coordinate(envelope3.getMaxX(), envelope3.getMinY()), new Coordinate(envelope3.getMinX(), envelope3.getMinY())]), null);
};
GeometryFactory.prototype.createLineString = function createLineString(coordinates) {
  if (!coordinates) {
    return new LineString(this.getCoordinateSequenceFactory().create([]), this);
  } else if (coordinates instanceof Array) {
    return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this);
  } else if (hasInterface(coordinates, CoordinateSequence)) {
    return new LineString(coordinates, this);
  }
};
GeometryFactory.prototype.createMultiLineString = function createMultiLineString() {
  if (arguments.length === 0) {
    return new MultiLineString(null, this);
  } else if (arguments.length === 1) {
    var lineStrings2 = arguments[0];
    return new MultiLineString(lineStrings2, this);
  }
};
GeometryFactory.prototype.buildGeometry = function buildGeometry(geomList) {
  var geomClass = null;
  var isHeterogeneous = false;
  var hasGeometryCollection = false;
  for (var i = geomList.iterator(); i.hasNext(); ) {
    var geom = i.next();
    var partClass = geom.getClass();
    if (geomClass === null) {
      geomClass = partClass;
    }
    if (partClass !== geomClass) {
      isHeterogeneous = true;
    }
    if (geom.isGeometryCollectionOrDerived()) {
      hasGeometryCollection = true;
    }
  }
  if (geomClass === null) {
    return this.createGeometryCollection();
  }
  if (isHeterogeneous || hasGeometryCollection) {
    return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
  }
  var geom0 = geomList.iterator().next();
  var isCollection = geomList.size() > 1;
  if (isCollection) {
    if (geom0 instanceof Polygon$2) {
      return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
    } else if (geom0 instanceof LineString) {
      return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
    } else if (geom0 instanceof Point$2) {
      return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
    }
    Assert.shouldNeverReachHere("Unhandled class: " + geom0.getClass().getName());
  }
  return geom0;
};
GeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords(coordinates) {
  return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
};
GeometryFactory.prototype.createPoint = function createPoint() {
  if (arguments.length === 0) {
    return this.createPoint(this.getCoordinateSequenceFactory().create([]));
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var coordinate2 = arguments[0];
      return this.createPoint(coordinate2 !== null ? this.getCoordinateSequenceFactory().create([coordinate2]) : null);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates = arguments[0];
      return new Point$2(coordinates, this);
    }
  }
};
GeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory() {
  return this._coordinateSequenceFactory;
};
GeometryFactory.prototype.createPolygon = function createPolygon() {
  if (arguments.length === 0) {
    return new Polygon$2(null, null, this);
  } else if (arguments.length === 1) {
    if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates = arguments[0];
      return this.createPolygon(this.createLinearRing(coordinates));
    } else if (arguments[0] instanceof Array) {
      var coordinates$1 = arguments[0];
      return this.createPolygon(this.createLinearRing(coordinates$1));
    } else if (arguments[0] instanceof LinearRing) {
      var shell = arguments[0];
      return this.createPolygon(shell, null);
    }
  } else if (arguments.length === 2) {
    var shell$1 = arguments[0];
    var holes = arguments[1];
    return new Polygon$2(shell$1, holes, this);
  }
};
GeometryFactory.prototype.getSRID = function getSRID2() {
  return this._SRID;
};
GeometryFactory.prototype.createGeometryCollection = function createGeometryCollection() {
  if (arguments.length === 0) {
    return new GeometryCollection(null, this);
  } else if (arguments.length === 1) {
    var geometries = arguments[0];
    return new GeometryCollection(geometries, this);
  }
};
GeometryFactory.prototype.createGeometry = function createGeometry(g) {
  var editor = new GeometryEditor(this);
  return editor.edit(g, {
    edit: function() {
      if (arguments.length === 2) {
        var coordSeq = arguments[0];
        return this._coordinateSequenceFactory.create(coordSeq);
      }
    }
  });
};
GeometryFactory.prototype.getPrecisionModel = function getPrecisionModel2() {
  return this._precisionModel;
};
GeometryFactory.prototype.createLinearRing = function createLinearRing() {
  if (arguments.length === 0) {
    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var coordinates = arguments[0];
      return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates$1 = arguments[0];
      return new LinearRing(coordinates$1, this);
    }
  }
};
GeometryFactory.prototype.createMultiPolygon = function createMultiPolygon() {
  if (arguments.length === 0) {
    return new MultiPolygon(null, this);
  } else if (arguments.length === 1) {
    var polygons2 = arguments[0];
    return new MultiPolygon(polygons2, this);
  }
};
GeometryFactory.prototype.createMultiPoint = function createMultiPoint() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    return new MultiPoint(null, this);
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var point4 = arguments[0];
      return new MultiPoint(point4, this);
    } else if (arguments[0] instanceof Array) {
      var coordinates = arguments[0];
      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates$1 = arguments[0];
      if (coordinates$1 === null) {
        return this.createMultiPoint(new Array(0).fill(null));
      }
      var points2 = new Array(coordinates$1.size()).fill(null);
      for (var i = 0; i < coordinates$1.size(); i++) {
        var ptSeq = this$1$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());
        CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);
        points2[i] = this$1$1.createPoint(ptSeq);
      }
      return this.createMultiPoint(points2);
    }
  }
};
GeometryFactory.prototype.interfaces_ = function interfaces_47() {
  return [Serializable];
};
GeometryFactory.prototype.getClass = function getClass46() {
  return GeometryFactory;
};
GeometryFactory.toMultiPolygonArray = function toMultiPolygonArray(multiPolygons) {
  var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
  return multiPolygons.toArray(multiPolygonArray);
};
GeometryFactory.toGeometryArray = function toGeometryArray(geometries) {
  if (geometries === null) {
    return null;
  }
  var geometryArray = new Array(geometries.size()).fill(null);
  return geometries.toArray(geometryArray);
};
GeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory() {
  return CoordinateArraySequenceFactory.instance();
};
GeometryFactory.toMultiLineStringArray = function toMultiLineStringArray(multiLineStrings) {
  var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
  return multiLineStrings.toArray(multiLineStringArray);
};
GeometryFactory.toLineStringArray = function toLineStringArray(lineStrings2) {
  var lineStringArray = new Array(lineStrings2.size()).fill(null);
  return lineStrings2.toArray(lineStringArray);
};
GeometryFactory.toMultiPointArray = function toMultiPointArray(multiPoints) {
  var multiPointArray = new Array(multiPoints.size()).fill(null);
  return multiPoints.toArray(multiPointArray);
};
GeometryFactory.toLinearRingArray = function toLinearRingArray(linearRings) {
  var linearRingArray = new Array(linearRings.size()).fill(null);
  return linearRings.toArray(linearRingArray);
};
GeometryFactory.toPointArray = function toPointArray(points2) {
  var pointArray = new Array(points2.size()).fill(null);
  return points2.toArray(pointArray);
};
GeometryFactory.toPolygonArray = function toPolygonArray(polygons2) {
  var polygonArray = new Array(polygons2.size()).fill(null);
  return polygons2.toArray(polygonArray);
};
GeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord(coord, exemplar) {
  exemplar.getPrecisionModel().makePrecise(coord);
  return exemplar.getFactory().createPoint(coord);
};
staticAccessors$2.serialVersionUID.get = function() {
  return -6820524753094096e3;
};
Object.defineProperties(GeometryFactory, staticAccessors$2);
var geometryTypes = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
var GeoJSONParser = function GeoJSONParser2(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
};
GeoJSONParser.prototype.read = function read2(json) {
  var obj;
  if (typeof json === "string") {
    obj = JSON.parse(json);
  } else {
    obj = json;
  }
  var type = obj.type;
  if (!parse$2[type]) {
    throw new Error("Unknown GeoJSON type: " + obj.type);
  }
  if (geometryTypes.indexOf(type) !== -1) {
    return parse$2[type].apply(this, [obj.coordinates]);
  } else if (type === "GeometryCollection") {
    return parse$2[type].apply(this, [obj.geometries]);
  }
  return parse$2[type].apply(this, [obj]);
};
GeoJSONParser.prototype.write = function write3(geometry2) {
  var type = geometry2.getGeometryType();
  if (!extract2[type]) {
    throw new Error("Geometry is not supported");
  }
  return extract2[type].apply(this, [geometry2]);
};
var parse$2 = {
  Feature: function(obj) {
    var feature2 = {};
    for (var key in obj) {
      feature2[key] = obj[key];
    }
    if (obj.geometry) {
      var type = obj.geometry.type;
      if (!parse$2[type]) {
        throw new Error("Unknown GeoJSON type: " + obj.type);
      }
      feature2.geometry = this.read(obj.geometry);
    }
    if (obj.bbox) {
      feature2.bbox = parse$2.bbox.apply(this, [obj.bbox]);
    }
    return feature2;
  },
  FeatureCollection: function(obj) {
    var this$1$1 = this;
    var featureCollection2 = {};
    if (obj.features) {
      featureCollection2.features = [];
      for (var i = 0; i < obj.features.length; ++i) {
        featureCollection2.features.push(this$1$1.read(obj.features[i]));
      }
    }
    if (obj.bbox) {
      featureCollection2.bbox = this.parse.bbox.apply(this, [obj.bbox]);
    }
    return featureCollection2;
  },
  coordinates: function(array) {
    var coordinates = [];
    for (var i = 0; i < array.length; ++i) {
      var sub2 = array[i];
      coordinates.push(new Coordinate(sub2[0], sub2[1]));
    }
    return coordinates;
  },
  bbox: function(array) {
    return this.geometryFactory.createLinearRing([
      new Coordinate(array[0], array[1]),
      new Coordinate(array[2], array[1]),
      new Coordinate(array[2], array[3]),
      new Coordinate(array[0], array[3]),
      new Coordinate(array[0], array[1])
    ]);
  },
  Point: function(array) {
    var coordinate2 = new Coordinate(array[0], array[1]);
    return this.geometryFactory.createPoint(coordinate2);
  },
  MultiPoint: function(array) {
    var this$1$1 = this;
    var points2 = [];
    for (var i = 0; i < array.length; ++i) {
      points2.push(parse$2.Point.apply(this$1$1, [array[i]]));
    }
    return this.geometryFactory.createMultiPoint(points2);
  },
  LineString: function(array) {
    var coordinates = parse$2.coordinates.apply(this, [array]);
    return this.geometryFactory.createLineString(coordinates);
  },
  MultiLineString: function(array) {
    var this$1$1 = this;
    var lineStrings2 = [];
    for (var i = 0; i < array.length; ++i) {
      lineStrings2.push(parse$2.LineString.apply(this$1$1, [array[i]]));
    }
    return this.geometryFactory.createMultiLineString(lineStrings2);
  },
  Polygon: function(array) {
    var this$1$1 = this;
    var shellCoordinates = parse$2.coordinates.apply(this, [array[0]]);
    var shell = this.geometryFactory.createLinearRing(shellCoordinates);
    var holes = [];
    for (var i = 1; i < array.length; ++i) {
      var hole = array[i];
      var coordinates = parse$2.coordinates.apply(this$1$1, [hole]);
      var linearRing = this$1$1.geometryFactory.createLinearRing(coordinates);
      holes.push(linearRing);
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },
  MultiPolygon: function(array) {
    var this$1$1 = this;
    var polygons2 = [];
    for (var i = 0; i < array.length; ++i) {
      var polygon4 = array[i];
      polygons2.push(parse$2.Polygon.apply(this$1$1, [polygon4]));
    }
    return this.geometryFactory.createMultiPolygon(polygons2);
  },
  GeometryCollection: function(array) {
    var this$1$1 = this;
    var geometries = [];
    for (var i = 0; i < array.length; ++i) {
      var geometry2 = array[i];
      geometries.push(this$1$1.read(geometry2));
    }
    return this.geometryFactory.createGeometryCollection(geometries);
  }
};
var extract2 = {
  coordinate: function(coordinate2) {
    return [coordinate2.x, coordinate2.y];
  },
  Point: function(point4) {
    var array = extract2.coordinate.apply(this, [point4.getCoordinate()]);
    return {
      type: "Point",
      coordinates: array
    };
  },
  MultiPoint: function(multipoint3) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0; i < multipoint3._geometries.length; ++i) {
      var point4 = multipoint3._geometries[i];
      var geoJson = extract2.Point.apply(this$1$1, [point4]);
      array.push(geoJson.coordinates);
    }
    return {
      type: "MultiPoint",
      coordinates: array
    };
  },
  LineString: function(linestring3) {
    var this$1$1 = this;
    var array = [];
    var coordinates = linestring3.getCoordinates();
    for (var i = 0; i < coordinates.length; ++i) {
      var coordinate2 = coordinates[i];
      array.push(extract2.coordinate.apply(this$1$1, [coordinate2]));
    }
    return {
      type: "LineString",
      coordinates: array
    };
  },
  MultiLineString: function(multilinestring3) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0; i < multilinestring3._geometries.length; ++i) {
      var linestring3 = multilinestring3._geometries[i];
      var geoJson = extract2.LineString.apply(this$1$1, [linestring3]);
      array.push(geoJson.coordinates);
    }
    return {
      type: "MultiLineString",
      coordinates: array
    };
  },
  Polygon: function(polygon4) {
    var this$1$1 = this;
    var array = [];
    var shellGeoJson = extract2.LineString.apply(this, [polygon4._shell]);
    array.push(shellGeoJson.coordinates);
    for (var i = 0; i < polygon4._holes.length; ++i) {
      var hole = polygon4._holes[i];
      var holeGeoJson = extract2.LineString.apply(this$1$1, [hole]);
      array.push(holeGeoJson.coordinates);
    }
    return {
      type: "Polygon",
      coordinates: array
    };
  },
  MultiPolygon: function(multipolygon3) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0; i < multipolygon3._geometries.length; ++i) {
      var polygon4 = multipolygon3._geometries[i];
      var geoJson = extract2.Polygon.apply(this$1$1, [polygon4]);
      array.push(geoJson.coordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates: array
    };
  },
  GeometryCollection: function(collection) {
    var this$1$1 = this;
    var array = [];
    for (var i = 0; i < collection._geometries.length; ++i) {
      var geometry2 = collection._geometries[i];
      var type = geometry2.getGeometryType();
      array.push(extract2[type].apply(this$1$1, [geometry2]));
    }
    return {
      type: "GeometryCollection",
      geometries: array
    };
  }
};
var GeoJSONReader = function GeoJSONReader2(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
  this.precisionModel = this.geometryFactory.getPrecisionModel();
  this.parser = new GeoJSONParser(this.geometryFactory);
};
GeoJSONReader.prototype.read = function read3(geoJson) {
  var geometry2 = this.parser.read(geoJson);
  if (this.precisionModel.getType() === PrecisionModel.FIXED) {
    this.reducePrecision(geometry2);
  }
  return geometry2;
};
GeoJSONReader.prototype.reducePrecision = function reducePrecision(geometry2) {
  var this$1$1 = this;
  var i, len2;
  if (geometry2.coordinate) {
    this.precisionModel.makePrecise(geometry2.coordinate);
  } else if (geometry2.points) {
    for (i = 0, len2 = geometry2.points.length; i < len2; i++) {
      this$1$1.precisionModel.makePrecise(geometry2.points[i]);
    }
  } else if (geometry2.geometries) {
    for (i = 0, len2 = geometry2.geometries.length; i < len2; i++) {
      this$1$1.reducePrecision(geometry2.geometries[i]);
    }
  }
};
var GeoJSONWriter = function GeoJSONWriter2() {
  this.parser = new GeoJSONParser(this.geometryFactory);
};
GeoJSONWriter.prototype.write = function write4(geometry2) {
  return this.parser.write(geometry2);
};
var Position = function Position2() {
};
var staticAccessors$20 = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
Position.prototype.interfaces_ = function interfaces_48() {
  return [];
};
Position.prototype.getClass = function getClass47() {
  return Position;
};
Position.opposite = function opposite(position2) {
  if (position2 === Position.LEFT) {
    return Position.RIGHT;
  }
  if (position2 === Position.RIGHT) {
    return Position.LEFT;
  }
  return position2;
};
staticAccessors$20.ON.get = function() {
  return 0;
};
staticAccessors$20.LEFT.get = function() {
  return 1;
};
staticAccessors$20.RIGHT.get = function() {
  return 2;
};
Object.defineProperties(Position, staticAccessors$20);
function EmptyStackException(message) {
  this.message = message || "";
}
EmptyStackException.prototype = new Error();
EmptyStackException.prototype.name = "EmptyStackException";
function Stack() {
  this.array_ = [];
}
Stack.prototype = new List();
Stack.prototype.add = function(e2) {
  this.array_.push(e2);
  return true;
};
Stack.prototype.get = function(index2) {
  if (index2 < 0 || index2 >= this.size()) {
    throw new Error();
  }
  return this.array_[index2];
};
Stack.prototype.push = function(e2) {
  this.array_.push(e2);
  return e2;
};
Stack.prototype.pop = function(e2) {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }
  return this.array_.pop();
};
Stack.prototype.peek = function() {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }
  return this.array_[this.array_.length - 1];
};
Stack.prototype.empty = function() {
  if (this.array_.length === 0) {
    return true;
  } else {
    return false;
  }
};
Stack.prototype.isEmpty = function() {
  return this.empty();
};
Stack.prototype.search = function(o) {
  return this.array_.indexOf(o);
};
Stack.prototype.size = function() {
  return this.array_.length;
};
Stack.prototype.toArray = function() {
  var this$1$1 = this;
  var array = [];
  for (var i = 0, len2 = this.array_.length; i < len2; i++) {
    array.push(this$1$1.array_[i]);
  }
  return array;
};
var RightmostEdgeFinder = function RightmostEdgeFinder2() {
  this._minIndex = -1;
  this._minCoord = null;
  this._minDe = null;
  this._orientedDe = null;
};
RightmostEdgeFinder.prototype.getCoordinate = function getCoordinate4() {
  return this._minCoord;
};
RightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide(de, index2) {
  var side = this.getRightmostSideOfSegment(de, index2);
  if (side < 0) {
    side = this.getRightmostSideOfSegment(de, index2 - 1);
  }
  if (side < 0) {
    this._minCoord = null;
    this.checkForRightmostCoordinate(de);
  }
  return side;
};
RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex() {
  var pts = this._minDe.getEdge().getCoordinates();
  Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, "rightmost point expected to be interior vertex of edge");
  var pPrev = pts[this._minIndex - 1];
  var pNext = pts[this._minIndex + 1];
  var orientation2 = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
  var usePrev = false;
  if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation2 === CGAlgorithms.COUNTERCLOCKWISE) {
    usePrev = true;
  } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation2 === CGAlgorithms.CLOCKWISE) {
    usePrev = true;
  }
  if (usePrev) {
    this._minIndex = this._minIndex - 1;
  }
};
RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment(de, i) {
  var e2 = de.getEdge();
  var coord = e2.getCoordinates();
  if (i < 0 || i + 1 >= coord.length) {
    return -1;
  }
  if (coord[i].y === coord[i + 1].y) {
    return -1;
  }
  var pos = Position.LEFT;
  if (coord[i].y < coord[i + 1].y) {
    pos = Position.RIGHT;
  }
  return pos;
};
RightmostEdgeFinder.prototype.getEdge = function getEdge() {
  return this._orientedDe;
};
RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate(de) {
  var this$1$1 = this;
  var coord = de.getEdge().getCoordinates();
  for (var i = 0; i < coord.length - 1; i++) {
    if (this$1$1._minCoord === null || coord[i].x > this$1$1._minCoord.x) {
      this$1$1._minDe = de;
      this$1$1._minIndex = i;
      this$1$1._minCoord = coord[i];
    }
  }
};
RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode() {
  var node = this._minDe.getNode();
  var star = node.getEdges();
  this._minDe = star.getRightmostEdge();
  if (!this._minDe.isForward()) {
    this._minDe = this._minDe.getSym();
    this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
  }
};
RightmostEdgeFinder.prototype.findEdge = function findEdge(dirEdgeList) {
  var this$1$1 = this;
  for (var i = dirEdgeList.iterator(); i.hasNext(); ) {
    var de = i.next();
    if (!de.isForward()) {
      continue;
    }
    this$1$1.checkForRightmostCoordinate(de);
  }
  Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing");
  if (this._minIndex === 0) {
    this.findRightmostEdgeAtNode();
  } else {
    this.findRightmostEdgeAtVertex();
  }
  this._orientedDe = this._minDe;
  var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
  if (rightmostSide === Position.LEFT) {
    this._orientedDe = this._minDe.getSym();
  }
};
RightmostEdgeFinder.prototype.interfaces_ = function interfaces_49() {
  return [];
};
RightmostEdgeFinder.prototype.getClass = function getClass48() {
  return RightmostEdgeFinder;
};
var TopologyException = function(RuntimeException$$1) {
  function TopologyException2(msg, pt) {
    RuntimeException$$1.call(this, TopologyException2.msgWithCoord(msg, pt));
    this.pt = pt ? new Coordinate(pt) : null;
    this.name = "TopologyException";
  }
  if (RuntimeException$$1)
    TopologyException2.__proto__ = RuntimeException$$1;
  TopologyException2.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
  TopologyException2.prototype.constructor = TopologyException2;
  TopologyException2.prototype.getCoordinate = function getCoordinate18() {
    return this.pt;
  };
  TopologyException2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  TopologyException2.prototype.getClass = function getClass169() {
    return TopologyException2;
  };
  TopologyException2.msgWithCoord = function msgWithCoord(msg, pt) {
    if (!pt) {
      return msg + " [ " + pt + " ]";
    }
    return msg;
  };
  return TopologyException2;
}(RuntimeException);
var LinkedList$1 = function LinkedList() {
  this.array_ = [];
};
LinkedList$1.prototype.addLast = function addLast(e2) {
  this.array_.push(e2);
};
LinkedList$1.prototype.removeFirst = function removeFirst() {
  return this.array_.shift();
};
LinkedList$1.prototype.isEmpty = function isEmpty2() {
  return this.array_.length === 0;
};
var BufferSubgraph = function BufferSubgraph2() {
  this._finder = null;
  this._dirEdgeList = new ArrayList();
  this._nodes = new ArrayList();
  this._rightMostCoord = null;
  this._env = null;
  this._finder = new RightmostEdgeFinder();
};
BufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges() {
  for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
    var de = it.next();
    de.setVisited(false);
  }
};
BufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate() {
  return this._rightMostCoord;
};
BufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth(n) {
  var this$1$1 = this;
  var startEdge = null;
  for (var i = n.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    if (de.isVisited() || de.getSym().isVisited()) {
      startEdge = de;
      break;
    }
  }
  if (startEdge === null) {
    throw new TopologyException("unable to find edge to compute depths at " + n.getCoordinate());
  }
  n.getEdges().computeDepths(startEdge);
  for (var i$1 = n.getEdges().iterator(); i$1.hasNext(); ) {
    var de$1 = i$1.next();
    de$1.setVisited(true);
    this$1$1.copySymDepths(de$1);
  }
};
BufferSubgraph.prototype.computeDepth = function computeDepth(outsideDepth) {
  this.clearVisitedEdges();
  var de = this._finder.getEdge();
  de.setEdgeDepths(Position.RIGHT, outsideDepth);
  this.copySymDepths(de);
  this.computeDepths(de);
};
BufferSubgraph.prototype.create = function create3(node) {
  this.addReachable(node);
  this._finder.findEdge(this._dirEdgeList);
  this._rightMostCoord = this._finder.getCoordinate();
};
BufferSubgraph.prototype.findResultEdges = function findResultEdges() {
  for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
    var de = it.next();
    if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
      de.setInResult(true);
    }
  }
};
BufferSubgraph.prototype.computeDepths = function computeDepths(startEdge) {
  var this$1$1 = this;
  var nodesVisited = new HashSet();
  var nodeQueue = new LinkedList$1();
  var startNode = startEdge.getNode();
  nodeQueue.addLast(startNode);
  nodesVisited.add(startNode);
  startEdge.setVisited(true);
  while (!nodeQueue.isEmpty()) {
    var n = nodeQueue.removeFirst();
    nodesVisited.add(n);
    this$1$1.computeNodeDepth(n);
    for (var i = n.getEdges().iterator(); i.hasNext(); ) {
      var de = i.next();
      var sym = de.getSym();
      if (sym.isVisited()) {
        continue;
      }
      var adjNode = sym.getNode();
      if (!nodesVisited.contains(adjNode)) {
        nodeQueue.addLast(adjNode);
        nodesVisited.add(adjNode);
      }
    }
  }
};
BufferSubgraph.prototype.compareTo = function compareTo7(o) {
  var graph = o;
  if (this._rightMostCoord.x < graph._rightMostCoord.x) {
    return -1;
  }
  if (this._rightMostCoord.x > graph._rightMostCoord.x) {
    return 1;
  }
  return 0;
};
BufferSubgraph.prototype.getEnvelope = function getEnvelope2() {
  if (this._env === null) {
    var edgeEnv = new Envelope();
    for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
      var dirEdge = it.next();
      var pts = dirEdge.getEdge().getCoordinates();
      for (var i = 0; i < pts.length - 1; i++) {
        edgeEnv.expandToInclude(pts[i]);
      }
    }
    this._env = edgeEnv;
  }
  return this._env;
};
BufferSubgraph.prototype.addReachable = function addReachable(startNode) {
  var this$1$1 = this;
  var nodeStack = new Stack();
  nodeStack.add(startNode);
  while (!nodeStack.empty()) {
    var node = nodeStack.pop();
    this$1$1.add(node, nodeStack);
  }
};
BufferSubgraph.prototype.copySymDepths = function copySymDepths(de) {
  var sym = de.getSym();
  sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
  sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
};
BufferSubgraph.prototype.add = function add3(node, nodeStack) {
  var this$1$1 = this;
  node.setVisited(true);
  this._nodes.add(node);
  for (var i = node.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    this$1$1._dirEdgeList.add(de);
    var sym = de.getSym();
    var symNode = sym.getNode();
    if (!symNode.isVisited()) {
      nodeStack.push(symNode);
    }
  }
};
BufferSubgraph.prototype.getNodes = function getNodes() {
  return this._nodes;
};
BufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges() {
  return this._dirEdgeList;
};
BufferSubgraph.prototype.interfaces_ = function interfaces_50() {
  return [Comparable];
};
BufferSubgraph.prototype.getClass = function getClass49() {
  return BufferSubgraph;
};
var TopologyLocation = function TopologyLocation2() {
  var this$1$1 = this;
  this.location = null;
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var location = arguments[0];
      this.init(location.length);
    } else if (Number.isInteger(arguments[0])) {
      var on = arguments[0];
      this.init(1);
      this.location[Position.ON] = on;
    } else if (arguments[0] instanceof TopologyLocation2) {
      var gl = arguments[0];
      this.init(gl.location.length);
      if (gl !== null) {
        for (var i = 0; i < this.location.length; i++) {
          this$1$1.location[i] = gl.location[i];
        }
      }
    }
  } else if (arguments.length === 3) {
    var on$1 = arguments[0];
    var left = arguments[1];
    var right = arguments[2];
    this.init(3);
    this.location[Position.ON] = on$1;
    this.location[Position.LEFT] = left;
    this.location[Position.RIGHT] = right;
  }
};
TopologyLocation.prototype.setAllLocations = function setAllLocations(locValue) {
  var this$1$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    this$1$1.location[i] = locValue;
  }
};
TopologyLocation.prototype.isNull = function isNull2() {
  var this$1$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1$1.location[i] !== Location.NONE) {
      return false;
    }
  }
  return true;
};
TopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull(locValue) {
  var this$1$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1$1.location[i] === Location.NONE) {
      this$1$1.location[i] = locValue;
    }
  }
};
TopologyLocation.prototype.isLine = function isLine() {
  return this.location.length === 1;
};
TopologyLocation.prototype.merge = function merge(gl) {
  var this$1$1 = this;
  if (gl.location.length > this.location.length) {
    var newLoc = new Array(3).fill(null);
    newLoc[Position.ON] = this.location[Position.ON];
    newLoc[Position.LEFT] = Location.NONE;
    newLoc[Position.RIGHT] = Location.NONE;
    this.location = newLoc;
  }
  for (var i = 0; i < this.location.length; i++) {
    if (this$1$1.location[i] === Location.NONE && i < gl.location.length) {
      this$1$1.location[i] = gl.location[i];
    }
  }
};
TopologyLocation.prototype.getLocations = function getLocations() {
  return this.location;
};
TopologyLocation.prototype.flip = function flip2() {
  if (this.location.length <= 1) {
    return null;
  }
  var temp2 = this.location[Position.LEFT];
  this.location[Position.LEFT] = this.location[Position.RIGHT];
  this.location[Position.RIGHT] = temp2;
};
TopologyLocation.prototype.toString = function toString11() {
  var buf = new StringBuffer();
  if (this.location.length > 1) {
    buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
  }
  buf.append(Location.toLocationSymbol(this.location[Position.ON]));
  if (this.location.length > 1) {
    buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
  }
  return buf.toString();
};
TopologyLocation.prototype.setLocations = function setLocations(on, left, right) {
  this.location[Position.ON] = on;
  this.location[Position.LEFT] = left;
  this.location[Position.RIGHT] = right;
};
TopologyLocation.prototype.get = function get2(posIndex) {
  if (posIndex < this.location.length) {
    return this.location[posIndex];
  }
  return Location.NONE;
};
TopologyLocation.prototype.isArea = function isArea() {
  return this.location.length > 1;
};
TopologyLocation.prototype.isAnyNull = function isAnyNull() {
  var this$1$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1$1.location[i] === Location.NONE) {
      return true;
    }
  }
  return false;
};
TopologyLocation.prototype.setLocation = function setLocation() {
  if (arguments.length === 1) {
    var locValue = arguments[0];
    this.setLocation(Position.ON, locValue);
  } else if (arguments.length === 2) {
    var locIndex = arguments[0];
    var locValue$1 = arguments[1];
    this.location[locIndex] = locValue$1;
  }
};
TopologyLocation.prototype.init = function init3(size11) {
  this.location = new Array(size11).fill(null);
  this.setAllLocations(Location.NONE);
};
TopologyLocation.prototype.isEqualOnSide = function isEqualOnSide(le2, locIndex) {
  return this.location[locIndex] === le2.location[locIndex];
};
TopologyLocation.prototype.allPositionsEqual = function allPositionsEqual(loc) {
  var this$1$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1$1.location[i] !== loc) {
      return false;
    }
  }
  return true;
};
TopologyLocation.prototype.interfaces_ = function interfaces_51() {
  return [];
};
TopologyLocation.prototype.getClass = function getClass50() {
  return TopologyLocation;
};
var Label = function Label2() {
  this.elt = new Array(2).fill(null);
  if (arguments.length === 1) {
    if (Number.isInteger(arguments[0])) {
      var onLoc = arguments[0];
      this.elt[0] = new TopologyLocation(onLoc);
      this.elt[1] = new TopologyLocation(onLoc);
    } else if (arguments[0] instanceof Label2) {
      var lbl = arguments[0];
      this.elt[0] = new TopologyLocation(lbl.elt[0]);
      this.elt[1] = new TopologyLocation(lbl.elt[1]);
    }
  } else if (arguments.length === 2) {
    var geomIndex = arguments[0];
    var onLoc$1 = arguments[1];
    this.elt[0] = new TopologyLocation(Location.NONE);
    this.elt[1] = new TopologyLocation(Location.NONE);
    this.elt[geomIndex].setLocation(onLoc$1);
  } else if (arguments.length === 3) {
    var onLoc$2 = arguments[0];
    var leftLoc = arguments[1];
    var rightLoc = arguments[2];
    this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
    this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
  } else if (arguments.length === 4) {
    var geomIndex$1 = arguments[0];
    var onLoc$3 = arguments[1];
    var leftLoc$1 = arguments[2];
    var rightLoc$1 = arguments[3];
    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
    this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);
  }
};
Label.prototype.getGeometryCount = function getGeometryCount() {
  var count3 = 0;
  if (!this.elt[0].isNull()) {
    count3++;
  }
  if (!this.elt[1].isNull()) {
    count3++;
  }
  return count3;
};
Label.prototype.setAllLocations = function setAllLocations2(geomIndex, location) {
  this.elt[geomIndex].setAllLocations(location);
};
Label.prototype.isNull = function isNull3(geomIndex) {
  return this.elt[geomIndex].isNull();
};
Label.prototype.setAllLocationsIfNull = function setAllLocationsIfNull2() {
  if (arguments.length === 1) {
    var location = arguments[0];
    this.setAllLocationsIfNull(0, location);
    this.setAllLocationsIfNull(1, location);
  } else if (arguments.length === 2) {
    var geomIndex = arguments[0];
    var location$1 = arguments[1];
    this.elt[geomIndex].setAllLocationsIfNull(location$1);
  }
};
Label.prototype.isLine = function isLine2(geomIndex) {
  return this.elt[geomIndex].isLine();
};
Label.prototype.merge = function merge2(lbl) {
  var this$1$1 = this;
  for (var i = 0; i < 2; i++) {
    if (this$1$1.elt[i] === null && lbl.elt[i] !== null) {
      this$1$1.elt[i] = new TopologyLocation(lbl.elt[i]);
    } else {
      this$1$1.elt[i].merge(lbl.elt[i]);
    }
  }
};
Label.prototype.flip = function flip3() {
  this.elt[0].flip();
  this.elt[1].flip();
};
Label.prototype.getLocation = function getLocation2() {
  if (arguments.length === 1) {
    var geomIndex = arguments[0];
    return this.elt[geomIndex].get(Position.ON);
  } else if (arguments.length === 2) {
    var geomIndex$1 = arguments[0];
    var posIndex = arguments[1];
    return this.elt[geomIndex$1].get(posIndex);
  }
};
Label.prototype.toString = function toString12() {
  var buf = new StringBuffer();
  if (this.elt[0] !== null) {
    buf.append("A:");
    buf.append(this.elt[0].toString());
  }
  if (this.elt[1] !== null) {
    buf.append(" B:");
    buf.append(this.elt[1].toString());
  }
  return buf.toString();
};
Label.prototype.isArea = function isArea2() {
  if (arguments.length === 0) {
    return this.elt[0].isArea() || this.elt[1].isArea();
  } else if (arguments.length === 1) {
    var geomIndex = arguments[0];
    return this.elt[geomIndex].isArea();
  }
};
Label.prototype.isAnyNull = function isAnyNull2(geomIndex) {
  return this.elt[geomIndex].isAnyNull();
};
Label.prototype.setLocation = function setLocation2() {
  if (arguments.length === 2) {
    var geomIndex = arguments[0];
    var location = arguments[1];
    this.elt[geomIndex].setLocation(Position.ON, location);
  } else if (arguments.length === 3) {
    var geomIndex$1 = arguments[0];
    var posIndex = arguments[1];
    var location$1 = arguments[2];
    this.elt[geomIndex$1].setLocation(posIndex, location$1);
  }
};
Label.prototype.isEqualOnSide = function isEqualOnSide2(lbl, side) {
  return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
};
Label.prototype.allPositionsEqual = function allPositionsEqual2(geomIndex, loc) {
  return this.elt[geomIndex].allPositionsEqual(loc);
};
Label.prototype.toLine = function toLine(geomIndex) {
  if (this.elt[geomIndex].isArea()) {
    this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
  }
};
Label.prototype.interfaces_ = function interfaces_52() {
  return [];
};
Label.prototype.getClass = function getClass51() {
  return Label;
};
Label.toLineLabel = function toLineLabel(label) {
  var lineLabel = new Label(Location.NONE);
  for (var i = 0; i < 2; i++) {
    lineLabel.setLocation(i, label.getLocation(i));
  }
  return lineLabel;
};
var EdgeRing = function EdgeRing2() {
  this._startDe = null;
  this._maxNodeDegree = -1;
  this._edges = new ArrayList();
  this._pts = new ArrayList();
  this._label = new Label(Location.NONE);
  this._ring = null;
  this._isHole = null;
  this._shell = null;
  this._holes = new ArrayList();
  this._geometryFactory = null;
  var start2 = arguments[0];
  var geometryFactory = arguments[1];
  this._geometryFactory = geometryFactory;
  this.computePoints(start2);
  this.computeRing();
};
EdgeRing.prototype.computeRing = function computeRing() {
  var this$1$1 = this;
  if (this._ring !== null) {
    return null;
  }
  var coord = new Array(this._pts.size()).fill(null);
  for (var i = 0; i < this._pts.size(); i++) {
    coord[i] = this$1$1._pts.get(i);
  }
  this._ring = this._geometryFactory.createLinearRing(coord);
  this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
};
EdgeRing.prototype.isIsolated = function isIsolated() {
  return this._label.getGeometryCount() === 1;
};
EdgeRing.prototype.computePoints = function computePoints(start2) {
  var this$1$1 = this;
  this._startDe = start2;
  var de = start2;
  var isFirstEdge = true;
  do {
    if (de === null) {
      throw new TopologyException("Found null DirectedEdge");
    }
    if (de.getEdgeRing() === this$1$1) {
      throw new TopologyException("Directed Edge visited twice during ring-building at " + de.getCoordinate());
    }
    this$1$1._edges.add(de);
    var label = de.getLabel();
    Assert.isTrue(label.isArea());
    this$1$1.mergeLabel(label);
    this$1$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
    isFirstEdge = false;
    this$1$1.setEdgeRing(de, this$1$1);
    de = this$1$1.getNext(de);
  } while (de !== this._startDe);
};
EdgeRing.prototype.getLinearRing = function getLinearRing() {
  return this._ring;
};
EdgeRing.prototype.getCoordinate = function getCoordinate5(i) {
  return this._pts.get(i);
};
EdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree() {
  var this$1$1 = this;
  this._maxNodeDegree = 0;
  var de = this._startDe;
  do {
    var node = de.getNode();
    var degree2 = node.getEdges().getOutgoingDegree(this$1$1);
    if (degree2 > this$1$1._maxNodeDegree) {
      this$1$1._maxNodeDegree = degree2;
    }
    de = this$1$1.getNext(de);
  } while (de !== this._startDe);
  this._maxNodeDegree *= 2;
};
EdgeRing.prototype.addPoints = function addPoints(edge, isForward, isFirstEdge) {
  var this$1$1 = this;
  var edgePts = edge.getCoordinates();
  if (isForward) {
    var startIndex = 1;
    if (isFirstEdge) {
      startIndex = 0;
    }
    for (var i = startIndex; i < edgePts.length; i++) {
      this$1$1._pts.add(edgePts[i]);
    }
  } else {
    var startIndex$1 = edgePts.length - 2;
    if (isFirstEdge) {
      startIndex$1 = edgePts.length - 1;
    }
    for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {
      this$1$1._pts.add(edgePts[i$1]);
    }
  }
};
EdgeRing.prototype.isHole = function isHole() {
  return this._isHole;
};
EdgeRing.prototype.setInResult = function setInResult() {
  var de = this._startDe;
  do {
    de.getEdge().setInResult(true);
    de = de.getNext();
  } while (de !== this._startDe);
};
EdgeRing.prototype.containsPoint = function containsPoint(p) {
  var shell = this.getLinearRing();
  var env2 = shell.getEnvelopeInternal();
  if (!env2.contains(p)) {
    return false;
  }
  if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) {
    return false;
  }
  for (var i = this._holes.iterator(); i.hasNext(); ) {
    var hole = i.next();
    if (hole.containsPoint(p)) {
      return false;
    }
  }
  return true;
};
EdgeRing.prototype.addHole = function addHole(ring) {
  this._holes.add(ring);
};
EdgeRing.prototype.isShell = function isShell() {
  return this._shell === null;
};
EdgeRing.prototype.getLabel = function getLabel() {
  return this._label;
};
EdgeRing.prototype.getEdges = function getEdges() {
  return this._edges;
};
EdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree() {
  if (this._maxNodeDegree < 0) {
    this.computeMaxNodeDegree();
  }
  return this._maxNodeDegree;
};
EdgeRing.prototype.getShell = function getShell() {
  return this._shell;
};
EdgeRing.prototype.mergeLabel = function mergeLabel() {
  if (arguments.length === 1) {
    var deLabel = arguments[0];
    this.mergeLabel(deLabel, 0);
    this.mergeLabel(deLabel, 1);
  } else if (arguments.length === 2) {
    var deLabel$1 = arguments[0];
    var geomIndex = arguments[1];
    var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);
    if (loc === Location.NONE) {
      return null;
    }
    if (this._label.getLocation(geomIndex) === Location.NONE) {
      this._label.setLocation(geomIndex, loc);
      return null;
    }
  }
};
EdgeRing.prototype.setShell = function setShell(shell) {
  this._shell = shell;
  if (shell !== null) {
    shell.addHole(this);
  }
};
EdgeRing.prototype.toPolygon = function toPolygon(geometryFactory) {
  var this$1$1 = this;
  var holeLR = new Array(this._holes.size()).fill(null);
  for (var i = 0; i < this._holes.size(); i++) {
    holeLR[i] = this$1$1._holes.get(i).getLinearRing();
  }
  var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
  return poly;
};
EdgeRing.prototype.interfaces_ = function interfaces_53() {
  return [];
};
EdgeRing.prototype.getClass = function getClass52() {
  return EdgeRing;
};
var MinimalEdgeRing = function(EdgeRing$$1) {
  function MinimalEdgeRing2() {
    var start2 = arguments[0];
    var geometryFactory = arguments[1];
    EdgeRing$$1.call(this, start2, geometryFactory);
  }
  if (EdgeRing$$1)
    MinimalEdgeRing2.__proto__ = EdgeRing$$1;
  MinimalEdgeRing2.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
  MinimalEdgeRing2.prototype.constructor = MinimalEdgeRing2;
  MinimalEdgeRing2.prototype.setEdgeRing = function setEdgeRing(de, er) {
    de.setMinEdgeRing(er);
  };
  MinimalEdgeRing2.prototype.getNext = function getNext(de) {
    return de.getNextMin();
  };
  MinimalEdgeRing2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  MinimalEdgeRing2.prototype.getClass = function getClass169() {
    return MinimalEdgeRing2;
  };
  return MinimalEdgeRing2;
}(EdgeRing);
var MaximalEdgeRing = function(EdgeRing$$1) {
  function MaximalEdgeRing2() {
    var start2 = arguments[0];
    var geometryFactory = arguments[1];
    EdgeRing$$1.call(this, start2, geometryFactory);
  }
  if (EdgeRing$$1)
    MaximalEdgeRing2.__proto__ = EdgeRing$$1;
  MaximalEdgeRing2.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
  MaximalEdgeRing2.prototype.constructor = MaximalEdgeRing2;
  MaximalEdgeRing2.prototype.buildMinimalRings = function buildMinimalRings() {
    var this$1$1 = this;
    var minEdgeRings = new ArrayList();
    var de = this._startDe;
    do {
      if (de.getMinEdgeRing() === null) {
        var minEr = new MinimalEdgeRing(de, this$1$1._geometryFactory);
        minEdgeRings.add(minEr);
      }
      de = de.getNext();
    } while (de !== this._startDe);
    return minEdgeRings;
  };
  MaximalEdgeRing2.prototype.setEdgeRing = function setEdgeRing(de, er) {
    de.setEdgeRing(er);
  };
  MaximalEdgeRing2.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings() {
    var this$1$1 = this;
    var de = this._startDe;
    do {
      var node = de.getNode();
      node.getEdges().linkMinimalDirectedEdges(this$1$1);
      de = de.getNext();
    } while (de !== this._startDe);
  };
  MaximalEdgeRing2.prototype.getNext = function getNext(de) {
    return de.getNext();
  };
  MaximalEdgeRing2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  MaximalEdgeRing2.prototype.getClass = function getClass169() {
    return MaximalEdgeRing2;
  };
  return MaximalEdgeRing2;
}(EdgeRing);
var GraphComponent = function GraphComponent2() {
  this._label = null;
  this._isInResult = false;
  this._isCovered = false;
  this._isCoveredSet = false;
  this._isVisited = false;
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    var label = arguments[0];
    this._label = label;
  }
};
GraphComponent.prototype.setVisited = function setVisited(isVisited2) {
  this._isVisited = isVisited2;
};
GraphComponent.prototype.setInResult = function setInResult2(isInResult2) {
  this._isInResult = isInResult2;
};
GraphComponent.prototype.isCovered = function isCovered() {
  return this._isCovered;
};
GraphComponent.prototype.isCoveredSet = function isCoveredSet() {
  return this._isCoveredSet;
};
GraphComponent.prototype.setLabel = function setLabel(label) {
  this._label = label;
};
GraphComponent.prototype.getLabel = function getLabel2() {
  return this._label;
};
GraphComponent.prototype.setCovered = function setCovered(isCovered2) {
  this._isCovered = isCovered2;
  this._isCoveredSet = true;
};
GraphComponent.prototype.updateIM = function updateIM(im) {
  Assert.isTrue(this._label.getGeometryCount() >= 2, "found partial label");
  this.computeIM(im);
};
GraphComponent.prototype.isInResult = function isInResult() {
  return this._isInResult;
};
GraphComponent.prototype.isVisited = function isVisited() {
  return this._isVisited;
};
GraphComponent.prototype.interfaces_ = function interfaces_54() {
  return [];
};
GraphComponent.prototype.getClass = function getClass53() {
  return GraphComponent;
};
var Node = function(GraphComponent$$1) {
  function Node4() {
    GraphComponent$$1.call(this);
    this._coord = null;
    this._edges = null;
    var coord = arguments[0];
    var edges2 = arguments[1];
    this._coord = coord;
    this._edges = edges2;
    this._label = new Label(0, Location.NONE);
  }
  if (GraphComponent$$1)
    Node4.__proto__ = GraphComponent$$1;
  Node4.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
  Node4.prototype.constructor = Node4;
  Node4.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult() {
    for (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {
      var de = it.next();
      if (de.getEdge().isInResult()) {
        return true;
      }
    }
    return false;
  };
  Node4.prototype.isIsolated = function isIsolated2() {
    return this._label.getGeometryCount() === 1;
  };
  Node4.prototype.getCoordinate = function getCoordinate18() {
    return this._coord;
  };
  Node4.prototype.print = function print9(out2) {
    out2.println("node " + this._coord + " lbl: " + this._label);
  };
  Node4.prototype.computeIM = function computeIM(im) {
  };
  Node4.prototype.computeMergedLocation = function computeMergedLocation(label2, eltIndex) {
    var loc = Location.NONE;
    loc = this._label.getLocation(eltIndex);
    if (!label2.isNull(eltIndex)) {
      var nLoc = label2.getLocation(eltIndex);
      if (loc !== Location.BOUNDARY) {
        loc = nLoc;
      }
    }
    return loc;
  };
  Node4.prototype.setLabel = function setLabel2() {
    if (arguments.length === 2) {
      var argIndex = arguments[0];
      var onLocation = arguments[1];
      if (this._label === null) {
        this._label = new Label(argIndex, onLocation);
      } else {
        this._label.setLocation(argIndex, onLocation);
      }
    } else {
      return GraphComponent$$1.prototype.setLabel.apply(this, arguments);
    }
  };
  Node4.prototype.getEdges = function getEdges4() {
    return this._edges;
  };
  Node4.prototype.mergeLabel = function mergeLabel2() {
    var this$1$1 = this;
    if (arguments[0] instanceof Node4) {
      var n = arguments[0];
      this.mergeLabel(n._label);
    } else if (arguments[0] instanceof Label) {
      var label2 = arguments[0];
      for (var i = 0; i < 2; i++) {
        var loc = this$1$1.computeMergedLocation(label2, i);
        var thisLoc = this$1$1._label.getLocation(i);
        if (thisLoc === Location.NONE) {
          this$1$1._label.setLocation(i, loc);
        }
      }
    }
  };
  Node4.prototype.add = function add16(e2) {
    this._edges.insert(e2);
    e2.setNode(this);
  };
  Node4.prototype.setLabelBoundary = function setLabelBoundary(argIndex) {
    if (this._label === null) {
      return null;
    }
    var loc = Location.NONE;
    if (this._label !== null) {
      loc = this._label.getLocation(argIndex);
    }
    var newLoc = null;
    switch (loc) {
      case Location.BOUNDARY:
        newLoc = Location.INTERIOR;
        break;
      case Location.INTERIOR:
        newLoc = Location.BOUNDARY;
        break;
      default:
        newLoc = Location.BOUNDARY;
        break;
    }
    this._label.setLocation(argIndex, newLoc);
  };
  Node4.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  Node4.prototype.getClass = function getClass169() {
    return Node4;
  };
  return Node4;
}(GraphComponent);
var NodeMap = function NodeMap2() {
  this.nodeMap = new TreeMap();
  this.nodeFact = null;
  var nodeFact = arguments[0];
  this.nodeFact = nodeFact;
};
NodeMap.prototype.find = function find(coord) {
  return this.nodeMap.get(coord);
};
NodeMap.prototype.addNode = function addNode() {
  if (arguments[0] instanceof Coordinate) {
    var coord = arguments[0];
    var node = this.nodeMap.get(coord);
    if (node === null) {
      node = this.nodeFact.createNode(coord);
      this.nodeMap.put(coord, node);
    }
    return node;
  } else if (arguments[0] instanceof Node) {
    var n = arguments[0];
    var node$1 = this.nodeMap.get(n.getCoordinate());
    if (node$1 === null) {
      this.nodeMap.put(n.getCoordinate(), n);
      return n;
    }
    node$1.mergeLabel(n);
    return node$1;
  }
};
NodeMap.prototype.print = function print(out2) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var n = it.next();
    n.print(out2);
  }
};
NodeMap.prototype.iterator = function iterator2() {
  return this.nodeMap.values().iterator();
};
NodeMap.prototype.values = function values2() {
  return this.nodeMap.values();
};
NodeMap.prototype.getBoundaryNodes = function getBoundaryNodes(geomIndex) {
  var bdyNodes = new ArrayList();
  for (var i = this.iterator(); i.hasNext(); ) {
    var node = i.next();
    if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) {
      bdyNodes.add(node);
    }
  }
  return bdyNodes;
};
NodeMap.prototype.add = function add4(e2) {
  var p = e2.getCoordinate();
  var n = this.addNode(p);
  n.add(e2);
};
NodeMap.prototype.interfaces_ = function interfaces_55() {
  return [];
};
NodeMap.prototype.getClass = function getClass54() {
  return NodeMap;
};
var Quadrant = function Quadrant2() {
};
var staticAccessors$21 = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
Quadrant.prototype.interfaces_ = function interfaces_56() {
  return [];
};
Quadrant.prototype.getClass = function getClass55() {
  return Quadrant;
};
Quadrant.isNorthern = function isNorthern(quad) {
  return quad === Quadrant.NE || quad === Quadrant.NW;
};
Quadrant.isOpposite = function isOpposite(quad1, quad2) {
  if (quad1 === quad2) {
    return false;
  }
  var diff2 = (quad1 - quad2 + 4) % 4;
  if (diff2 === 2) {
    return true;
  }
  return false;
};
Quadrant.commonHalfPlane = function commonHalfPlane(quad1, quad2) {
  if (quad1 === quad2) {
    return quad1;
  }
  var diff2 = (quad1 - quad2 + 4) % 4;
  if (diff2 === 2) {
    return -1;
  }
  var min5 = quad1 < quad2 ? quad1 : quad2;
  var max4 = quad1 > quad2 ? quad1 : quad2;
  if (min5 === 0 && max4 === 3) {
    return 3;
  }
  return min5;
};
Quadrant.isInHalfPlane = function isInHalfPlane(quad, halfPlane) {
  if (halfPlane === Quadrant.SE) {
    return quad === Quadrant.SE || quad === Quadrant.SW;
  }
  return quad === halfPlane || quad === halfPlane + 1;
};
Quadrant.quadrant = function quadrant() {
  if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
    var dx = arguments[0];
    var dy = arguments[1];
    if (dx === 0 && dy === 0) {
      throw new IllegalArgumentException("Cannot compute the quadrant for point ( " + dx + ", " + dy + " )");
    }
    if (dx >= 0) {
      if (dy >= 0) {
        return Quadrant.NE;
      } else {
        return Quadrant.SE;
      }
    } else {
      if (dy >= 0) {
        return Quadrant.NW;
      } else {
        return Quadrant.SW;
      }
    }
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (p1.x === p0.x && p1.y === p0.y) {
      throw new IllegalArgumentException("Cannot compute the quadrant for two identical points " + p0);
    }
    if (p1.x >= p0.x) {
      if (p1.y >= p0.y) {
        return Quadrant.NE;
      } else {
        return Quadrant.SE;
      }
    } else {
      if (p1.y >= p0.y) {
        return Quadrant.NW;
      } else {
        return Quadrant.SW;
      }
    }
  }
};
staticAccessors$21.NE.get = function() {
  return 0;
};
staticAccessors$21.NW.get = function() {
  return 1;
};
staticAccessors$21.SW.get = function() {
  return 2;
};
staticAccessors$21.SE.get = function() {
  return 3;
};
Object.defineProperties(Quadrant, staticAccessors$21);
var EdgeEnd = function EdgeEnd2() {
  this._edge = null;
  this._label = null;
  this._node = null;
  this._p0 = null;
  this._p1 = null;
  this._dx = null;
  this._dy = null;
  this._quadrant = null;
  if (arguments.length === 1) {
    var edge = arguments[0];
    this._edge = edge;
  } else if (arguments.length === 3) {
    var edge$1 = arguments[0];
    var p0 = arguments[1];
    var p1 = arguments[2];
    var label = null;
    this._edge = edge$1;
    this.init(p0, p1);
    this._label = label;
  } else if (arguments.length === 4) {
    var edge$2 = arguments[0];
    var p0$1 = arguments[1];
    var p1$1 = arguments[2];
    var label$1 = arguments[3];
    this._edge = edge$2;
    this.init(p0$1, p1$1);
    this._label = label$1;
  }
};
EdgeEnd.prototype.compareDirection = function compareDirection(e2) {
  if (this._dx === e2._dx && this._dy === e2._dy) {
    return 0;
  }
  if (this._quadrant > e2._quadrant) {
    return 1;
  }
  if (this._quadrant < e2._quadrant) {
    return -1;
  }
  return CGAlgorithms.computeOrientation(e2._p0, e2._p1, this._p1);
};
EdgeEnd.prototype.getDy = function getDy() {
  return this._dy;
};
EdgeEnd.prototype.getCoordinate = function getCoordinate6() {
  return this._p0;
};
EdgeEnd.prototype.setNode = function setNode(node) {
  this._node = node;
};
EdgeEnd.prototype.print = function print2(out2) {
  var angle4 = Math.atan2(this._dy, this._dx);
  var className = this.getClass().getName();
  var lastDotPos = className.lastIndexOf(".");
  var name2 = className.substring(lastDotPos + 1);
  out2.print("  " + name2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle4 + "   " + this._label);
};
EdgeEnd.prototype.compareTo = function compareTo8(obj) {
  var e2 = obj;
  return this.compareDirection(e2);
};
EdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate() {
  return this._p1;
};
EdgeEnd.prototype.getDx = function getDx() {
  return this._dx;
};
EdgeEnd.prototype.getLabel = function getLabel3() {
  return this._label;
};
EdgeEnd.prototype.getEdge = function getEdge2() {
  return this._edge;
};
EdgeEnd.prototype.getQuadrant = function getQuadrant() {
  return this._quadrant;
};
EdgeEnd.prototype.getNode = function getNode() {
  return this._node;
};
EdgeEnd.prototype.toString = function toString13() {
  var angle4 = Math.atan2(this._dy, this._dx);
  var className = this.getClass().getName();
  var lastDotPos = className.lastIndexOf(".");
  var name2 = className.substring(lastDotPos + 1);
  return "  " + name2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle4 + "   " + this._label;
};
EdgeEnd.prototype.computeLabel = function computeLabel(boundaryNodeRule) {
};
EdgeEnd.prototype.init = function init4(p0, p1) {
  this._p0 = p0;
  this._p1 = p1;
  this._dx = p1.x - p0.x;
  this._dy = p1.y - p0.y;
  this._quadrant = Quadrant.quadrant(this._dx, this._dy);
  Assert.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
};
EdgeEnd.prototype.interfaces_ = function interfaces_57() {
  return [Comparable];
};
EdgeEnd.prototype.getClass = function getClass56() {
  return EdgeEnd;
};
var DirectedEdge = function(EdgeEnd$$1) {
  function DirectedEdge2() {
    var edge = arguments[0];
    var isForward = arguments[1];
    EdgeEnd$$1.call(this, edge);
    this._isForward = null;
    this._isInResult = false;
    this._isVisited = false;
    this._sym = null;
    this._next = null;
    this._nextMin = null;
    this._edgeRing = null;
    this._minEdgeRing = null;
    this._depth = [0, -999, -999];
    this._isForward = isForward;
    if (isForward) {
      this.init(edge.getCoordinate(0), edge.getCoordinate(1));
    } else {
      var n = edge.getNumPoints() - 1;
      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
    }
    this.computeDirectedLabel();
  }
  if (EdgeEnd$$1)
    DirectedEdge2.__proto__ = EdgeEnd$$1;
  DirectedEdge2.prototype = Object.create(EdgeEnd$$1 && EdgeEnd$$1.prototype);
  DirectedEdge2.prototype.constructor = DirectedEdge2;
  DirectedEdge2.prototype.getNextMin = function getNextMin() {
    return this._nextMin;
  };
  DirectedEdge2.prototype.getDepth = function getDepth3(position2) {
    return this._depth[position2];
  };
  DirectedEdge2.prototype.setVisited = function setVisited2(isVisited2) {
    this._isVisited = isVisited2;
  };
  DirectedEdge2.prototype.computeDirectedLabel = function computeDirectedLabel() {
    this._label = new Label(this._edge.getLabel());
    if (!this._isForward) {
      this._label.flip();
    }
  };
  DirectedEdge2.prototype.getNext = function getNext() {
    return this._next;
  };
  DirectedEdge2.prototype.setDepth = function setDepth2(position2, depthVal) {
    if (this._depth[position2] !== -999) {
      if (this._depth[position2] !== depthVal) {
        throw new TopologyException("assigned depths do not match", this.getCoordinate());
      }
    }
    this._depth[position2] = depthVal;
  };
  DirectedEdge2.prototype.isInteriorAreaEdge = function isInteriorAreaEdge() {
    var this$1$1 = this;
    var isInteriorAreaEdge2 = true;
    for (var i = 0; i < 2; i++) {
      if (!(this$1$1._label.isArea(i) && this$1$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
        isInteriorAreaEdge2 = false;
      }
    }
    return isInteriorAreaEdge2;
  };
  DirectedEdge2.prototype.setNextMin = function setNextMin(nextMin) {
    this._nextMin = nextMin;
  };
  DirectedEdge2.prototype.print = function print9(out2) {
    EdgeEnd$$1.prototype.print.call(this, out2);
    out2.print(" " + this._depth[Position.LEFT] + "/" + this._depth[Position.RIGHT]);
    out2.print(" (" + this.getDepthDelta() + ")");
    if (this._isInResult) {
      out2.print(" inResult");
    }
  };
  DirectedEdge2.prototype.setMinEdgeRing = function setMinEdgeRing(minEdgeRing) {
    this._minEdgeRing = minEdgeRing;
  };
  DirectedEdge2.prototype.isLineEdge = function isLineEdge() {
    var isLine3 = this._label.isLine(0) || this._label.isLine(1);
    var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
    var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
    return isLine3 && isExteriorIfArea0 && isExteriorIfArea1;
  };
  DirectedEdge2.prototype.setEdgeRing = function setEdgeRing(edgeRing) {
    this._edgeRing = edgeRing;
  };
  DirectedEdge2.prototype.getMinEdgeRing = function getMinEdgeRing() {
    return this._minEdgeRing;
  };
  DirectedEdge2.prototype.getDepthDelta = function getDepthDelta() {
    var depthDelta2 = this._edge.getDepthDelta();
    if (!this._isForward) {
      depthDelta2 = -depthDelta2;
    }
    return depthDelta2;
  };
  DirectedEdge2.prototype.setInResult = function setInResult3(isInResult2) {
    this._isInResult = isInResult2;
  };
  DirectedEdge2.prototype.getSym = function getSym() {
    return this._sym;
  };
  DirectedEdge2.prototype.isForward = function isForward() {
    return this._isForward;
  };
  DirectedEdge2.prototype.getEdge = function getEdge4() {
    return this._edge;
  };
  DirectedEdge2.prototype.printEdge = function printEdge(out2) {
    this.print(out2);
    out2.print(" ");
    if (this._isForward) {
      this._edge.print(out2);
    } else {
      this._edge.printReverse(out2);
    }
  };
  DirectedEdge2.prototype.setSym = function setSym(de) {
    this._sym = de;
  };
  DirectedEdge2.prototype.setVisitedEdge = function setVisitedEdge(isVisited2) {
    this.setVisited(isVisited2);
    this._sym.setVisited(isVisited2);
  };
  DirectedEdge2.prototype.setEdgeDepths = function setEdgeDepths(position2, depth2) {
    var depthDelta2 = this.getEdge().getDepthDelta();
    if (!this._isForward) {
      depthDelta2 = -depthDelta2;
    }
    var directionFactor = 1;
    if (position2 === Position.LEFT) {
      directionFactor = -1;
    }
    var oppositePos = Position.opposite(position2);
    var delta2 = depthDelta2 * directionFactor;
    var oppositeDepth = depth2 + delta2;
    this.setDepth(position2, depth2);
    this.setDepth(oppositePos, oppositeDepth);
  };
  DirectedEdge2.prototype.getEdgeRing = function getEdgeRing() {
    return this._edgeRing;
  };
  DirectedEdge2.prototype.isInResult = function isInResult2() {
    return this._isInResult;
  };
  DirectedEdge2.prototype.setNext = function setNext(next3) {
    this._next = next3;
  };
  DirectedEdge2.prototype.isVisited = function isVisited2() {
    return this._isVisited;
  };
  DirectedEdge2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  DirectedEdge2.prototype.getClass = function getClass169() {
    return DirectedEdge2;
  };
  DirectedEdge2.depthFactor = function depthFactor(currLocation, nextLocation) {
    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) {
      return 1;
    } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) {
      return -1;
    }
    return 0;
  };
  return DirectedEdge2;
}(EdgeEnd);
var NodeFactory = function NodeFactory2() {
};
NodeFactory.prototype.createNode = function createNode2(coord) {
  return new Node(coord, null);
};
NodeFactory.prototype.interfaces_ = function interfaces_58() {
  return [];
};
NodeFactory.prototype.getClass = function getClass57() {
  return NodeFactory;
};
var PlanarGraph = function PlanarGraph2() {
  this._edges = new ArrayList();
  this._nodes = null;
  this._edgeEndList = new ArrayList();
  if (arguments.length === 0) {
    this._nodes = new NodeMap(new NodeFactory());
  } else if (arguments.length === 1) {
    var nodeFact = arguments[0];
    this._nodes = new NodeMap(nodeFact);
  }
};
PlanarGraph.prototype.printEdges = function printEdges(out2) {
  var this$1$1 = this;
  out2.println("Edges:");
  for (var i = 0; i < this._edges.size(); i++) {
    out2.println("edge " + i + ":");
    var e2 = this$1$1._edges.get(i);
    e2.print(out2);
    e2.eiList.print(out2);
  }
};
PlanarGraph.prototype.find = function find2(coord) {
  return this._nodes.find(coord);
};
PlanarGraph.prototype.addNode = function addNode2() {
  if (arguments[0] instanceof Node) {
    var node = arguments[0];
    return this._nodes.addNode(node);
  } else if (arguments[0] instanceof Coordinate) {
    var coord = arguments[0];
    return this._nodes.addNode(coord);
  }
};
PlanarGraph.prototype.getNodeIterator = function getNodeIterator() {
  return this._nodes.iterator();
};
PlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {
  for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().linkResultDirectedEdges();
  }
};
PlanarGraph.prototype.debugPrintln = function debugPrintln(o) {
  System.out.println(o);
};
PlanarGraph.prototype.isBoundaryNode = function isBoundaryNode(geomIndex, coord) {
  var node = this._nodes.find(coord);
  if (node === null) {
    return false;
  }
  var label = node.getLabel();
  if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) {
    return true;
  }
  return false;
};
PlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {
  for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().linkAllDirectedEdges();
  }
};
PlanarGraph.prototype.matchInSameDirection = function matchInSameDirection(p0, p1, ep0, ep1) {
  if (!p0.equals(ep0)) {
    return false;
  }
  if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) {
    return true;
  }
  return false;
};
PlanarGraph.prototype.getEdgeEnds = function getEdgeEnds() {
  return this._edgeEndList;
};
PlanarGraph.prototype.debugPrint = function debugPrint(o) {
  System.out.print(o);
};
PlanarGraph.prototype.getEdgeIterator = function getEdgeIterator() {
  return this._edges.iterator();
};
PlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection(p0, p1) {
  var this$1$1 = this;
  for (var i = 0; i < this._edges.size(); i++) {
    var e2 = this$1$1._edges.get(i);
    var eCoord = e2.getCoordinates();
    if (this$1$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) {
      return e2;
    }
    if (this$1$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) {
      return e2;
    }
  }
  return null;
};
PlanarGraph.prototype.insertEdge = function insertEdge(e2) {
  this._edges.add(e2);
};
PlanarGraph.prototype.findEdgeEnd = function findEdgeEnd(e2) {
  for (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {
    var ee = i.next();
    if (ee.getEdge() === e2) {
      return ee;
    }
  }
  return null;
};
PlanarGraph.prototype.addEdges = function addEdges(edgesToAdd) {
  var this$1$1 = this;
  for (var it = edgesToAdd.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    this$1$1._edges.add(e2);
    var de1 = new DirectedEdge(e2, true);
    var de2 = new DirectedEdge(e2, false);
    de1.setSym(de2);
    de2.setSym(de1);
    this$1$1.add(de1);
    this$1$1.add(de2);
  }
};
PlanarGraph.prototype.add = function add5(e2) {
  this._nodes.add(e2);
  this._edgeEndList.add(e2);
};
PlanarGraph.prototype.getNodes = function getNodes2() {
  return this._nodes.values();
};
PlanarGraph.prototype.findEdge = function findEdge2(p0, p1) {
  var this$1$1 = this;
  for (var i = 0; i < this._edges.size(); i++) {
    var e2 = this$1$1._edges.get(i);
    var eCoord = e2.getCoordinates();
    if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) {
      return e2;
    }
  }
  return null;
};
PlanarGraph.prototype.interfaces_ = function interfaces_59() {
  return [];
};
PlanarGraph.prototype.getClass = function getClass58() {
  return PlanarGraph;
};
PlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges2(nodes) {
  for (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().linkResultDirectedEdges();
  }
};
var PolygonBuilder = function PolygonBuilder2() {
  this._geometryFactory = null;
  this._shellList = new ArrayList();
  var geometryFactory = arguments[0];
  this._geometryFactory = geometryFactory;
};
PolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
  for (var it = edgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.isHole()) {
      freeHoleList.add(er);
    } else {
      shellList.add(er);
    }
  }
};
PolygonBuilder.prototype.computePolygons = function computePolygons(shellList) {
  var this$1$1 = this;
  var resultPolyList = new ArrayList();
  for (var it = shellList.iterator(); it.hasNext(); ) {
    var er = it.next();
    var poly = er.toPolygon(this$1$1._geometryFactory);
    resultPolyList.add(poly);
  }
  return resultPolyList;
};
PolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles(shellList, freeHoleList) {
  var this$1$1 = this;
  for (var it = freeHoleList.iterator(); it.hasNext(); ) {
    var hole = it.next();
    if (hole.getShell() === null) {
      var shell = this$1$1.findEdgeRingContaining(hole, shellList);
      if (shell === null) {
        throw new TopologyException("unable to assign hole to a shell", hole.getCoordinate(0));
      }
      hole.setShell(shell);
    }
  }
};
PolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
  var this$1$1 = this;
  var edgeRings = new ArrayList();
  for (var it = maxEdgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.getMaxNodeDegree() > 2) {
      er.linkDirectedEdgesForMinimalEdgeRings();
      var minEdgeRings = er.buildMinimalRings();
      var shell = this$1$1.findShell(minEdgeRings);
      if (shell !== null) {
        this$1$1.placePolygonHoles(shell, minEdgeRings);
        shellList.add(shell);
      } else {
        freeHoleList.addAll(minEdgeRings);
      }
    } else {
      edgeRings.add(er);
    }
  }
  return edgeRings;
};
PolygonBuilder.prototype.containsPoint = function containsPoint2(p) {
  for (var it = this._shellList.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.containsPoint(p)) {
      return true;
    }
  }
  return false;
};
PolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings(dirEdges) {
  var this$1$1 = this;
  var maxEdgeRings = new ArrayList();
  for (var it = dirEdges.iterator(); it.hasNext(); ) {
    var de = it.next();
    if (de.isInResult() && de.getLabel().isArea()) {
      if (de.getEdgeRing() === null) {
        var er = new MaximalEdgeRing(de, this$1$1._geometryFactory);
        maxEdgeRings.add(er);
        er.setInResult();
      }
    }
  }
  return maxEdgeRings;
};
PolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles(shell, minEdgeRings) {
  for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.isHole()) {
      er.setShell(shell);
    }
  }
};
PolygonBuilder.prototype.getPolygons = function getPolygons() {
  var resultPolyList = this.computePolygons(this._shellList);
  return resultPolyList;
};
PolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining(testEr, shellList) {
  var testRing = testEr.getLinearRing();
  var testEnv = testRing.getEnvelopeInternal();
  var testPt = testRing.getCoordinateN(0);
  var minShell = null;
  var minEnv = null;
  for (var it = shellList.iterator(); it.hasNext(); ) {
    var tryShell = it.next();
    var tryRing = tryShell.getLinearRing();
    var tryEnv = tryRing.getEnvelopeInternal();
    if (minShell !== null) {
      minEnv = minShell.getLinearRing().getEnvelopeInternal();
    }
    var isContained = false;
    if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) {
      isContained = true;
    }
    if (isContained) {
      if (minShell === null || minEnv.contains(tryEnv)) {
        minShell = tryShell;
      }
    }
  }
  return minShell;
};
PolygonBuilder.prototype.findShell = function findShell(minEdgeRings) {
  var shellCount = 0;
  var shell = null;
  for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (!er.isHole()) {
      shell = er;
      shellCount++;
    }
  }
  Assert.isTrue(shellCount <= 1, "found two shells in MinimalEdgeRing list");
  return shell;
};
PolygonBuilder.prototype.add = function add6() {
  if (arguments.length === 1) {
    var graph = arguments[0];
    this.add(graph.getEdgeEnds(), graph.getNodes());
  } else if (arguments.length === 2) {
    var dirEdges = arguments[0];
    var nodes = arguments[1];
    PlanarGraph.linkResultDirectedEdges(nodes);
    var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
    var freeHoleList = new ArrayList();
    var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
    this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
    this.placeFreeHoles(this._shellList, freeHoleList);
  }
};
PolygonBuilder.prototype.interfaces_ = function interfaces_60() {
  return [];
};
PolygonBuilder.prototype.getClass = function getClass59() {
  return PolygonBuilder;
};
var Boundable = function Boundable2() {
};
Boundable.prototype.getBounds = function getBounds() {
};
Boundable.prototype.interfaces_ = function interfaces_61() {
  return [];
};
Boundable.prototype.getClass = function getClass60() {
  return Boundable;
};
var ItemBoundable = function ItemBoundable2() {
  this._bounds = null;
  this._item = null;
  var bounds2 = arguments[0];
  var item = arguments[1];
  this._bounds = bounds2;
  this._item = item;
};
ItemBoundable.prototype.getItem = function getItem() {
  return this._item;
};
ItemBoundable.prototype.getBounds = function getBounds2() {
  return this._bounds;
};
ItemBoundable.prototype.interfaces_ = function interfaces_62() {
  return [Boundable, Serializable];
};
ItemBoundable.prototype.getClass = function getClass61() {
  return ItemBoundable;
};
var PriorityQueue = function PriorityQueue2() {
  this._size = null;
  this._items = null;
  this._size = 0;
  this._items = new ArrayList();
  this._items.add(null);
};
PriorityQueue.prototype.poll = function poll() {
  if (this.isEmpty()) {
    return null;
  }
  var minItem = this._items.get(1);
  this._items.set(1, this._items.get(this._size));
  this._size -= 1;
  this.reorder(1);
  return minItem;
};
PriorityQueue.prototype.size = function size5() {
  return this._size;
};
PriorityQueue.prototype.reorder = function reorder(hole) {
  var this$1$1 = this;
  var child = null;
  var tmp = this._items.get(hole);
  for (; hole * 2 <= this._size; hole = child) {
    child = hole * 2;
    if (child !== this$1$1._size && this$1$1._items.get(child + 1).compareTo(this$1$1._items.get(child)) < 0) {
      child++;
    }
    if (this$1$1._items.get(child).compareTo(tmp) < 0) {
      this$1$1._items.set(hole, this$1$1._items.get(child));
    } else {
      break;
    }
  }
  this._items.set(hole, tmp);
};
PriorityQueue.prototype.clear = function clear() {
  this._size = 0;
  this._items.clear();
};
PriorityQueue.prototype.isEmpty = function isEmpty3() {
  return this._size === 0;
};
PriorityQueue.prototype.add = function add7(x2) {
  var this$1$1 = this;
  this._items.add(null);
  this._size += 1;
  var hole = this._size;
  this._items.set(0, x2);
  for (; x2.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
    this$1$1._items.set(hole, this$1$1._items.get(Math.trunc(hole / 2)));
  }
  this._items.set(hole, x2);
};
PriorityQueue.prototype.interfaces_ = function interfaces_63() {
  return [];
};
PriorityQueue.prototype.getClass = function getClass62() {
  return PriorityQueue;
};
var ItemVisitor = function ItemVisitor2() {
};
ItemVisitor.prototype.visitItem = function visitItem(item) {
};
ItemVisitor.prototype.interfaces_ = function interfaces_64() {
  return [];
};
ItemVisitor.prototype.getClass = function getClass63() {
  return ItemVisitor;
};
var SpatialIndex = function SpatialIndex2() {
};
SpatialIndex.prototype.insert = function insert2(itemEnv, item) {
};
SpatialIndex.prototype.remove = function remove3(itemEnv, item) {
};
SpatialIndex.prototype.query = function query() {
};
SpatialIndex.prototype.interfaces_ = function interfaces_65() {
  return [];
};
SpatialIndex.prototype.getClass = function getClass64() {
  return SpatialIndex;
};
var AbstractNode = function AbstractNode2() {
  this._childBoundables = new ArrayList();
  this._bounds = null;
  this._level = null;
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    var level = arguments[0];
    this._level = level;
  }
};
var staticAccessors$22 = { serialVersionUID: { configurable: true } };
AbstractNode.prototype.getLevel = function getLevel() {
  return this._level;
};
AbstractNode.prototype.size = function size6() {
  return this._childBoundables.size();
};
AbstractNode.prototype.getChildBoundables = function getChildBoundables() {
  return this._childBoundables;
};
AbstractNode.prototype.addChildBoundable = function addChildBoundable(childBoundable) {
  Assert.isTrue(this._bounds === null);
  this._childBoundables.add(childBoundable);
};
AbstractNode.prototype.isEmpty = function isEmpty4() {
  return this._childBoundables.isEmpty();
};
AbstractNode.prototype.getBounds = function getBounds3() {
  if (this._bounds === null) {
    this._bounds = this.computeBounds();
  }
  return this._bounds;
};
AbstractNode.prototype.interfaces_ = function interfaces_66() {
  return [Boundable, Serializable];
};
AbstractNode.prototype.getClass = function getClass65() {
  return AbstractNode;
};
staticAccessors$22.serialVersionUID.get = function() {
  return 6493722185909574e3;
};
Object.defineProperties(AbstractNode, staticAccessors$22);
var Collections = function Collections2() {
};
Collections.reverseOrder = function reverseOrder() {
  return {
    compare: function compare11(a, b) {
      return b.compareTo(a);
    }
  };
};
Collections.min = function min3(l) {
  Collections.sort(l);
  return l.get(0);
};
Collections.sort = function sort2(l, c) {
  var a = l.toArray();
  if (c) {
    Arrays.sort(a, c);
  } else {
    Arrays.sort(a);
  }
  var i = l.iterator();
  for (var pos = 0, alen = a.length; pos < alen; pos++) {
    i.next();
    i.set(a[pos]);
  }
};
Collections.singletonList = function singletonList(o) {
  var arrayList = new ArrayList();
  arrayList.add(o);
  return arrayList;
};
var BoundablePair = function BoundablePair2() {
  this._boundable1 = null;
  this._boundable2 = null;
  this._distance = null;
  this._itemDistance = null;
  var boundable1 = arguments[0];
  var boundable2 = arguments[1];
  var itemDistance = arguments[2];
  this._boundable1 = boundable1;
  this._boundable2 = boundable2;
  this._itemDistance = itemDistance;
  this._distance = this.distance();
};
BoundablePair.prototype.expandToQueue = function expandToQueue(priQ, minDistance) {
  var isComp1 = BoundablePair.isComposite(this._boundable1);
  var isComp2 = BoundablePair.isComposite(this._boundable2);
  if (isComp1 && isComp2) {
    if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
      this.expand(this._boundable1, this._boundable2, priQ, minDistance);
      return null;
    } else {
      this.expand(this._boundable2, this._boundable1, priQ, minDistance);
      return null;
    }
  } else if (isComp1) {
    this.expand(this._boundable1, this._boundable2, priQ, minDistance);
    return null;
  } else if (isComp2) {
    this.expand(this._boundable2, this._boundable1, priQ, minDistance);
    return null;
  }
  throw new IllegalArgumentException("neither boundable is composite");
};
BoundablePair.prototype.isLeaves = function isLeaves() {
  return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
};
BoundablePair.prototype.compareTo = function compareTo9(o) {
  var nd = o;
  if (this._distance < nd._distance) {
    return -1;
  }
  if (this._distance > nd._distance) {
    return 1;
  }
  return 0;
};
BoundablePair.prototype.expand = function expand(bndComposite, bndOther, priQ, minDistance) {
  var this$1$1 = this;
  var children = bndComposite.getChildBoundables();
  for (var i = children.iterator(); i.hasNext(); ) {
    var child = i.next();
    var bp = new BoundablePair(child, bndOther, this$1$1._itemDistance);
    if (bp.getDistance() < minDistance) {
      priQ.add(bp);
    }
  }
};
BoundablePair.prototype.getBoundable = function getBoundable(i) {
  if (i === 0) {
    return this._boundable1;
  }
  return this._boundable2;
};
BoundablePair.prototype.getDistance = function getDistance() {
  return this._distance;
};
BoundablePair.prototype.distance = function distance3() {
  if (this.isLeaves()) {
    return this._itemDistance.distance(this._boundable1, this._boundable2);
  }
  return this._boundable1.getBounds().distance(this._boundable2.getBounds());
};
BoundablePair.prototype.interfaces_ = function interfaces_67() {
  return [Comparable];
};
BoundablePair.prototype.getClass = function getClass66() {
  return BoundablePair;
};
BoundablePair.area = function area2(b) {
  return b.getBounds().getArea();
};
BoundablePair.isComposite = function isComposite(item) {
  return item instanceof AbstractNode;
};
var AbstractSTRtree = function AbstractSTRtree2() {
  this._root = null;
  this._built = false;
  this._itemBoundables = new ArrayList();
  this._nodeCapacity = null;
  if (arguments.length === 0) {
    var nodeCapacity = AbstractSTRtree2.DEFAULT_NODE_CAPACITY;
    this._nodeCapacity = nodeCapacity;
  } else if (arguments.length === 1) {
    var nodeCapacity$1 = arguments[0];
    Assert.isTrue(nodeCapacity$1 > 1, "Node capacity must be greater than 1");
    this._nodeCapacity = nodeCapacity$1;
  }
};
var staticAccessors$23 = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
AbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity() {
  return this._nodeCapacity;
};
AbstractSTRtree.prototype.lastNode = function lastNode(nodes) {
  return nodes.get(nodes.size() - 1);
};
AbstractSTRtree.prototype.size = function size7() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    if (this.isEmpty()) {
      return 0;
    }
    this.build();
    return this.size(this._root);
  } else if (arguments.length === 1) {
    var node = arguments[0];
    var size11 = 0;
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (childBoundable instanceof AbstractNode) {
        size11 += this$1$1.size(childBoundable);
      } else if (childBoundable instanceof ItemBoundable) {
        size11 += 1;
      }
    }
    return size11;
  }
};
AbstractSTRtree.prototype.removeItem = function removeItem(node, item) {
  var childToRemove = null;
  for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
    var childBoundable = i.next();
    if (childBoundable instanceof ItemBoundable) {
      if (childBoundable.getItem() === item) {
        childToRemove = childBoundable;
      }
    }
  }
  if (childToRemove !== null) {
    node.getChildBoundables().remove(childToRemove);
    return true;
  }
  return false;
};
AbstractSTRtree.prototype.itemsTree = function itemsTree() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    this.build();
    var valuesTree = this.itemsTree(this._root);
    if (valuesTree === null) {
      return new ArrayList();
    }
    return valuesTree;
  } else if (arguments.length === 1) {
    var node = arguments[0];
    var valuesTreeForNode = new ArrayList();
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (childBoundable instanceof AbstractNode) {
        var valuesTreeForChild = this$1$1.itemsTree(childBoundable);
        if (valuesTreeForChild !== null) {
          valuesTreeForNode.add(valuesTreeForChild);
        }
      } else if (childBoundable instanceof ItemBoundable) {
        valuesTreeForNode.add(childBoundable.getItem());
      } else {
        Assert.shouldNeverReachHere();
      }
    }
    if (valuesTreeForNode.size() <= 0) {
      return null;
    }
    return valuesTreeForNode;
  }
};
AbstractSTRtree.prototype.insert = function insert3(bounds2, item) {
  Assert.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built.");
  this._itemBoundables.add(new ItemBoundable(bounds2, item));
};
AbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel() {
  var this$1$1 = this;
  if (arguments.length === 1) {
    var level = arguments[0];
    var boundables = new ArrayList();
    this.boundablesAtLevel(level, this._root, boundables);
    return boundables;
  } else if (arguments.length === 3) {
    var level$1 = arguments[0];
    var top = arguments[1];
    var boundables$1 = arguments[2];
    Assert.isTrue(level$1 > -2);
    if (top.getLevel() === level$1) {
      boundables$1.add(top);
      return null;
    }
    for (var i = top.getChildBoundables().iterator(); i.hasNext(); ) {
      var boundable = i.next();
      if (boundable instanceof AbstractNode) {
        this$1$1.boundablesAtLevel(level$1, boundable, boundables$1);
      } else {
        Assert.isTrue(boundable instanceof ItemBoundable);
        if (level$1 === -1) {
          boundables$1.add(boundable);
        }
      }
    }
    return null;
  }
};
AbstractSTRtree.prototype.query = function query2() {
  var this$1$1 = this;
  if (arguments.length === 1) {
    var searchBounds = arguments[0];
    this.build();
    var matches = new ArrayList();
    if (this.isEmpty()) {
      return matches;
    }
    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
      this.query(searchBounds, this._root, matches);
    }
    return matches;
  } else if (arguments.length === 2) {
    var searchBounds$1 = arguments[0];
    var visitor = arguments[1];
    this.build();
    if (this.isEmpty()) {
      return null;
    }
    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {
      this.query(searchBounds$1, this._root, visitor);
    }
  } else if (arguments.length === 3) {
    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
      var searchBounds$2 = arguments[0];
      var node = arguments[1];
      var visitor$1 = arguments[2];
      var childBoundables = node.getChildBoundables();
      for (var i = 0; i < childBoundables.size(); i++) {
        var childBoundable = childBoundables.get(i);
        if (!this$1$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {
          continue;
        }
        if (childBoundable instanceof AbstractNode) {
          this$1$1.query(searchBounds$2, childBoundable, visitor$1);
        } else if (childBoundable instanceof ItemBoundable) {
          visitor$1.visitItem(childBoundable.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
      var searchBounds$3 = arguments[0];
      var node$1 = arguments[1];
      var matches$1 = arguments[2];
      var childBoundables$1 = node$1.getChildBoundables();
      for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {
        var childBoundable$1 = childBoundables$1.get(i$1);
        if (!this$1$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {
          continue;
        }
        if (childBoundable$1 instanceof AbstractNode) {
          this$1$1.query(searchBounds$3, childBoundable$1, matches$1);
        } else if (childBoundable$1 instanceof ItemBoundable) {
          matches$1.add(childBoundable$1.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
    }
  }
};
AbstractSTRtree.prototype.build = function build() {
  if (this._built) {
    return null;
  }
  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
  this._itemBoundables = null;
  this._built = true;
};
AbstractSTRtree.prototype.getRoot = function getRoot() {
  this.build();
  return this._root;
};
AbstractSTRtree.prototype.remove = function remove4() {
  var this$1$1 = this;
  if (arguments.length === 2) {
    var searchBounds = arguments[0];
    var item = arguments[1];
    this.build();
    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
      return this.remove(searchBounds, this._root, item);
    }
    return false;
  } else if (arguments.length === 3) {
    var searchBounds$1 = arguments[0];
    var node = arguments[1];
    var item$1 = arguments[2];
    var found = this.removeItem(node, item$1);
    if (found) {
      return true;
    }
    var childToPrune = null;
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (!this$1$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {
        continue;
      }
      if (childBoundable instanceof AbstractNode) {
        found = this$1$1.remove(searchBounds$1, childBoundable, item$1);
        if (found) {
          childToPrune = childBoundable;
          break;
        }
      }
    }
    if (childToPrune !== null) {
      if (childToPrune.getChildBoundables().isEmpty()) {
        node.getChildBoundables().remove(childToPrune);
      }
    }
    return found;
  }
};
AbstractSTRtree.prototype.createHigherLevels = function createHigherLevels(boundablesOfALevel, level) {
  Assert.isTrue(!boundablesOfALevel.isEmpty());
  var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
  if (parentBoundables.size() === 1) {
    return parentBoundables.get(0);
  }
  return this.createHigherLevels(parentBoundables, level + 1);
};
AbstractSTRtree.prototype.depth = function depth() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    if (this.isEmpty()) {
      return 0;
    }
    this.build();
    return this.depth(this._root);
  } else if (arguments.length === 1) {
    var node = arguments[0];
    var maxChildDepth = 0;
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (childBoundable instanceof AbstractNode) {
        var childDepth = this$1$1.depth(childBoundable);
        if (childDepth > maxChildDepth) {
          maxChildDepth = childDepth;
        }
      }
    }
    return maxChildDepth + 1;
  }
};
AbstractSTRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {
  var this$1$1 = this;
  Assert.isTrue(!childBoundables.isEmpty());
  var parentBoundables = new ArrayList();
  parentBoundables.add(this.createNode(newLevel));
  var sortedChildBoundables = new ArrayList(childBoundables);
  Collections.sort(sortedChildBoundables, this.getComparator());
  for (var i = sortedChildBoundables.iterator(); i.hasNext(); ) {
    var childBoundable = i.next();
    if (this$1$1.lastNode(parentBoundables).getChildBoundables().size() === this$1$1.getNodeCapacity()) {
      parentBoundables.add(this$1$1.createNode(newLevel));
    }
    this$1$1.lastNode(parentBoundables).addChildBoundable(childBoundable);
  }
  return parentBoundables;
};
AbstractSTRtree.prototype.isEmpty = function isEmpty5() {
  if (!this._built) {
    return this._itemBoundables.isEmpty();
  }
  return this._root.isEmpty();
};
AbstractSTRtree.prototype.interfaces_ = function interfaces_68() {
  return [Serializable];
};
AbstractSTRtree.prototype.getClass = function getClass67() {
  return AbstractSTRtree;
};
AbstractSTRtree.compareDoubles = function compareDoubles(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};
staticAccessors$23.IntersectsOp.get = function() {
  return IntersectsOp;
};
staticAccessors$23.serialVersionUID.get = function() {
  return -3886435814360241e3;
};
staticAccessors$23.DEFAULT_NODE_CAPACITY.get = function() {
  return 10;
};
Object.defineProperties(AbstractSTRtree, staticAccessors$23);
var IntersectsOp = function IntersectsOp2() {
};
var ItemDistance = function ItemDistance2() {
};
ItemDistance.prototype.distance = function distance4(item1, item2) {
};
ItemDistance.prototype.interfaces_ = function interfaces_69() {
  return [];
};
ItemDistance.prototype.getClass = function getClass68() {
  return ItemDistance;
};
var STRtree = function(AbstractSTRtree$$1) {
  function STRtree2(nodeCapacity) {
    nodeCapacity = nodeCapacity || STRtree2.DEFAULT_NODE_CAPACITY;
    AbstractSTRtree$$1.call(this, nodeCapacity);
  }
  if (AbstractSTRtree$$1)
    STRtree2.__proto__ = AbstractSTRtree$$1;
  STRtree2.prototype = Object.create(AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype);
  STRtree2.prototype.constructor = STRtree2;
  var staticAccessors2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
  STRtree2.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
    var this$1$1 = this;
    Assert.isTrue(verticalSlices.length > 0);
    var parentBoundables = new ArrayList();
    for (var i = 0; i < verticalSlices.length; i++) {
      parentBoundables.addAll(this$1$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
    }
    return parentBoundables;
  };
  STRtree2.prototype.createNode = function createNode3(level) {
    return new STRtreeNode(level);
  };
  STRtree2.prototype.size = function size11() {
    if (arguments.length === 0) {
      return AbstractSTRtree$$1.prototype.size.call(this);
    } else {
      return AbstractSTRtree$$1.prototype.size.apply(this, arguments);
    }
  };
  STRtree2.prototype.insert = function insert5() {
    if (arguments.length === 2) {
      var itemEnv = arguments[0];
      var item = arguments[1];
      if (itemEnv.isNull()) {
        return null;
      }
      AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);
    } else {
      return AbstractSTRtree$$1.prototype.insert.apply(this, arguments);
    }
  };
  STRtree2.prototype.getIntersectsOp = function getIntersectsOp() {
    return STRtree2.intersectsOp;
  };
  STRtree2.prototype.verticalSlices = function verticalSlices(childBoundables, sliceCount) {
    var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
    var slices = new Array(sliceCount).fill(null);
    var i = childBoundables.iterator();
    for (var j = 0; j < sliceCount; j++) {
      slices[j] = new ArrayList();
      var boundablesAddedToSlice = 0;
      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
        var childBoundable = i.next();
        slices[j].add(childBoundable);
        boundablesAddedToSlice++;
      }
    }
    return slices;
  };
  STRtree2.prototype.query = function query5() {
    if (arguments.length === 1) {
      var searchEnv = arguments[0];
      return AbstractSTRtree$$1.prototype.query.call(this, searchEnv);
    } else if (arguments.length === 2) {
      var searchEnv$1 = arguments[0];
      var visitor = arguments[1];
      AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        var searchBounds = arguments[0];
        var node = arguments[1];
        var visitor$1 = arguments[2];
        AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);
      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        var searchBounds$1 = arguments[0];
        var node$1 = arguments[1];
        var matches = arguments[2];
        AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);
      }
    }
  };
  STRtree2.prototype.getComparator = function getComparator() {
    return STRtree2.yComparator;
  };
  STRtree2.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
    return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel);
  };
  STRtree2.prototype.remove = function remove6() {
    if (arguments.length === 2) {
      var itemEnv = arguments[0];
      var item = arguments[1];
      return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item);
    } else {
      return AbstractSTRtree$$1.prototype.remove.apply(this, arguments);
    }
  };
  STRtree2.prototype.depth = function depth2() {
    if (arguments.length === 0) {
      return AbstractSTRtree$$1.prototype.depth.call(this);
    } else {
      return AbstractSTRtree$$1.prototype.depth.apply(this, arguments);
    }
  };
  STRtree2.prototype.createParentBoundables = function createParentBoundables2(childBoundables, newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
    var sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, STRtree2.xComparator);
    var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
  };
  STRtree2.prototype.nearestNeighbour = function nearestNeighbour() {
    if (arguments.length === 1) {
      if (hasInterface(arguments[0], ItemDistance)) {
        var itemDist = arguments[0];
        var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
        return this.nearestNeighbour(bp);
      } else if (arguments[0] instanceof BoundablePair) {
        var initBndPair = arguments[0];
        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof STRtree2 && hasInterface(arguments[1], ItemDistance)) {
        var tree = arguments[0];
        var itemDist$1 = arguments[1];
        var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);
        return this.nearestNeighbour(bp$1);
      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === "number") {
        var initBndPair$1 = arguments[0];
        var maxDistance = arguments[1];
        var distanceLowerBound = maxDistance;
        var minPair = null;
        var priQ = new PriorityQueue();
        priQ.add(initBndPair$1);
        while (!priQ.isEmpty() && distanceLowerBound > 0) {
          var bndPair = priQ.poll();
          var currentDistance = bndPair.getDistance();
          if (currentDistance >= distanceLowerBound) {
            break;
          }
          if (bndPair.isLeaves()) {
            distanceLowerBound = currentDistance;
            minPair = bndPair;
          } else {
            bndPair.expandToQueue(priQ, distanceLowerBound);
          }
        }
        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
      }
    } else if (arguments.length === 3) {
      var env2 = arguments[0];
      var item = arguments[1];
      var itemDist$2 = arguments[2];
      var bnd = new ItemBoundable(env2, item);
      var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);
      return this.nearestNeighbour(bp$2)[0];
    }
  };
  STRtree2.prototype.interfaces_ = function interfaces_170() {
    return [SpatialIndex, Serializable];
  };
  STRtree2.prototype.getClass = function getClass169() {
    return STRtree2;
  };
  STRtree2.centreX = function centreX(e2) {
    return STRtree2.avg(e2.getMinX(), e2.getMaxX());
  };
  STRtree2.avg = function avg(a, b) {
    return (a + b) / 2;
  };
  STRtree2.centreY = function centreY(e2) {
    return STRtree2.avg(e2.getMinY(), e2.getMaxY());
  };
  staticAccessors2.STRtreeNode.get = function() {
    return STRtreeNode;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 259274702368956900;
  };
  staticAccessors2.xComparator.get = function() {
    return {
      interfaces_: function() {
        return [Comparator];
      },
      compare: function(o1, o2) {
        return AbstractSTRtree$$1.compareDoubles(STRtree2.centreX(o1.getBounds()), STRtree2.centreX(o2.getBounds()));
      }
    };
  };
  staticAccessors2.yComparator.get = function() {
    return {
      interfaces_: function() {
        return [Comparator];
      },
      compare: function(o1, o2) {
        return AbstractSTRtree$$1.compareDoubles(STRtree2.centreY(o1.getBounds()), STRtree2.centreY(o2.getBounds()));
      }
    };
  };
  staticAccessors2.intersectsOp.get = function() {
    return {
      interfaces_: function() {
        return [AbstractSTRtree$$1.IntersectsOp];
      },
      intersects: function(aBounds, bBounds) {
        return aBounds.intersects(bBounds);
      }
    };
  };
  staticAccessors2.DEFAULT_NODE_CAPACITY.get = function() {
    return 10;
  };
  Object.defineProperties(STRtree2, staticAccessors2);
  return STRtree2;
}(AbstractSTRtree);
var STRtreeNode = function(AbstractNode$$1) {
  function STRtreeNode2() {
    var level = arguments[0];
    AbstractNode$$1.call(this, level);
  }
  if (AbstractNode$$1)
    STRtreeNode2.__proto__ = AbstractNode$$1;
  STRtreeNode2.prototype = Object.create(AbstractNode$$1 && AbstractNode$$1.prototype);
  STRtreeNode2.prototype.constructor = STRtreeNode2;
  STRtreeNode2.prototype.computeBounds = function computeBounds() {
    var bounds2 = null;
    for (var i = this.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (bounds2 === null) {
        bounds2 = new Envelope(childBoundable.getBounds());
      } else {
        bounds2.expandToInclude(childBoundable.getBounds());
      }
    }
    return bounds2;
  };
  STRtreeNode2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  STRtreeNode2.prototype.getClass = function getClass169() {
    return STRtreeNode2;
  };
  return STRtreeNode2;
}(AbstractNode);
var SegmentPointComparator = function SegmentPointComparator2() {
};
SegmentPointComparator.prototype.interfaces_ = function interfaces_70() {
  return [];
};
SegmentPointComparator.prototype.getClass = function getClass69() {
  return SegmentPointComparator;
};
SegmentPointComparator.relativeSign = function relativeSign(x02, x12) {
  if (x02 < x12) {
    return -1;
  }
  if (x02 > x12) {
    return 1;
  }
  return 0;
};
SegmentPointComparator.compare = function compare7(octant2, p0, p1) {
  if (p0.equals2D(p1)) {
    return 0;
  }
  var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
  var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
  switch (octant2) {
    case 0:
      return SegmentPointComparator.compareValue(xSign, ySign);
    case 1:
      return SegmentPointComparator.compareValue(ySign, xSign);
    case 2:
      return SegmentPointComparator.compareValue(ySign, -xSign);
    case 3:
      return SegmentPointComparator.compareValue(-xSign, ySign);
    case 4:
      return SegmentPointComparator.compareValue(-xSign, -ySign);
    case 5:
      return SegmentPointComparator.compareValue(-ySign, -xSign);
    case 6:
      return SegmentPointComparator.compareValue(-ySign, xSign);
    case 7:
      return SegmentPointComparator.compareValue(xSign, -ySign);
  }
  Assert.shouldNeverReachHere("invalid octant value");
  return 0;
};
SegmentPointComparator.compareValue = function compareValue(compareSign0, compareSign1) {
  if (compareSign0 < 0) {
    return -1;
  }
  if (compareSign0 > 0) {
    return 1;
  }
  if (compareSign1 < 0) {
    return -1;
  }
  if (compareSign1 > 0) {
    return 1;
  }
  return 0;
};
var SegmentNode = function SegmentNode2() {
  this._segString = null;
  this.coord = null;
  this.segmentIndex = null;
  this._segmentOctant = null;
  this._isInterior = null;
  var segString = arguments[0];
  var coord = arguments[1];
  var segmentIndex = arguments[2];
  var segmentOctant = arguments[3];
  this._segString = segString;
  this.coord = new Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this._segmentOctant = segmentOctant;
  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
};
SegmentNode.prototype.getCoordinate = function getCoordinate7() {
  return this.coord;
};
SegmentNode.prototype.print = function print3(out2) {
  out2.print(this.coord);
  out2.print(" seg # = " + this.segmentIndex);
};
SegmentNode.prototype.compareTo = function compareTo10(obj) {
  var other = obj;
  if (this.segmentIndex < other.segmentIndex) {
    return -1;
  }
  if (this.segmentIndex > other.segmentIndex) {
    return 1;
  }
  if (this.coord.equals2D(other.coord)) {
    return 0;
  }
  return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);
};
SegmentNode.prototype.isEndPoint = function isEndPoint2(maxSegmentIndex) {
  if (this.segmentIndex === 0 && !this._isInterior) {
    return true;
  }
  if (this.segmentIndex === maxSegmentIndex) {
    return true;
  }
  return false;
};
SegmentNode.prototype.isInterior = function isInterior() {
  return this._isInterior;
};
SegmentNode.prototype.interfaces_ = function interfaces_71() {
  return [Comparable];
};
SegmentNode.prototype.getClass = function getClass70() {
  return SegmentNode;
};
var SegmentNodeList = function SegmentNodeList2() {
  this._nodeMap = new TreeMap();
  this._edge = null;
  var edge = arguments[0];
  this._edge = edge;
};
SegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates() {
  var this$1$1 = this;
  var coordList = new CoordinateList();
  this.addEndpoints();
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    this$1$1.addEdgeCoordinates(eiPrev, ei, coordList);
    eiPrev = ei;
  }
  return coordList.toCoordinateArray();
};
SegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes() {
  var this$1$1 = this;
  var collapsedVertexIndexes = new ArrayList();
  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
  for (var it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {
    var vertexIndex = it.next().intValue();
    this$1$1.add(this$1$1._edge.getCoordinate(vertexIndex), vertexIndex);
  }
};
SegmentNodeList.prototype.print = function print4(out2) {
  out2.println("Intersections:");
  for (var it = this.iterator(); it.hasNext(); ) {
    var ei = it.next();
    ei.print(out2);
  }
};
SegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices(collapsedVertexIndexes) {
  var this$1$1 = this;
  for (var i = 0; i < this._edge.size() - 2; i++) {
    var p0 = this$1$1._edge.getCoordinate(i);
    var p2 = this$1$1._edge.getCoordinate(i + 2);
    if (p0.equals2D(p2)) {
      collapsedVertexIndexes.add(new Integer(i + 1));
    }
  }
};
SegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates(ei0, ei1, coordList) {
  var this$1$1 = this;
  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
  coordList.add(new Coordinate(ei0.coord), false);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    coordList.add(this$1$1._edge.getCoordinate(i));
  }
  if (useIntPt1) {
    coordList.add(new Coordinate(ei1.coord));
  }
};
SegmentNodeList.prototype.iterator = function iterator3() {
  return this._nodeMap.values().iterator();
};
SegmentNodeList.prototype.addSplitEdges = function addSplitEdges(edgeList) {
  var this$1$1 = this;
  this.addEndpoints();
  this.addCollapsedNodes();
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var newEdge = this$1$1.createSplitEdge(eiPrev, ei);
    edgeList.add(newEdge);
    eiPrev = ei;
  }
};
SegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
  if (!ei0.coord.equals2D(ei1.coord)) {
    return false;
  }
  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
  if (!ei1.isInterior()) {
    numVerticesBetween--;
  }
  if (numVerticesBetween === 1) {
    collapsedVertexIndex[0] = ei0.segmentIndex + 1;
    return true;
  }
  return false;
};
SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
  var this$1$1 = this;
  var collapsedVertexIndex = new Array(1).fill(null);
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var isCollapsed = this$1$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
    if (isCollapsed) {
      collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
    }
    eiPrev = ei;
  }
};
SegmentNodeList.prototype.getEdge = function getEdge3() {
  return this._edge;
};
SegmentNodeList.prototype.addEndpoints = function addEndpoints() {
  var maxSegIndex = this._edge.size() - 1;
  this.add(this._edge.getCoordinate(0), 0);
  this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
};
SegmentNodeList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {
  var this$1$1 = this;
  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
  if (!useIntPt1) {
    npts--;
  }
  var pts = new Array(npts).fill(null);
  var ipt = 0;
  pts[ipt++] = new Coordinate(ei0.coord);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    pts[ipt++] = this$1$1._edge.getCoordinate(i);
  }
  if (useIntPt1) {
    pts[ipt] = new Coordinate(ei1.coord);
  }
  return new NodedSegmentString(pts, this._edge.getData());
};
SegmentNodeList.prototype.add = function add8(intPt, segmentIndex) {
  var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
  var ei = this._nodeMap.get(eiNew);
  if (ei !== null) {
    Assert.isTrue(ei.coord.equals2D(intPt), "Found equal nodes with different coordinates");
    return ei;
  }
  this._nodeMap.put(eiNew, eiNew);
  return eiNew;
};
SegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness(splitEdges) {
  var edgePts = this._edge.getCoordinates();
  var split0 = splitEdges.get(0);
  var pt02 = split0.getCoordinate(0);
  if (!pt02.equals2D(edgePts[0])) {
    throw new RuntimeException("bad split edge start point at " + pt02);
  }
  var splitn = splitEdges.get(splitEdges.size() - 1);
  var splitnPts = splitn.getCoordinates();
  var ptn = splitnPts[splitnPts.length - 1];
  if (!ptn.equals2D(edgePts[edgePts.length - 1])) {
    throw new RuntimeException("bad split edge end point at " + ptn);
  }
};
SegmentNodeList.prototype.interfaces_ = function interfaces_72() {
  return [];
};
SegmentNodeList.prototype.getClass = function getClass71() {
  return SegmentNodeList;
};
var Octant = function Octant2() {
};
Octant.prototype.interfaces_ = function interfaces_73() {
  return [];
};
Octant.prototype.getClass = function getClass72() {
  return Octant;
};
Octant.octant = function octant() {
  if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
    var dx = arguments[0];
    var dy = arguments[1];
    if (dx === 0 && dy === 0) {
      throw new IllegalArgumentException("Cannot compute the octant for point ( " + dx + ", " + dy + " )");
    }
    var adx = Math.abs(dx);
    var ady = Math.abs(dy);
    if (dx >= 0) {
      if (dy >= 0) {
        if (adx >= ady) {
          return 0;
        } else {
          return 1;
        }
      } else {
        if (adx >= ady) {
          return 7;
        } else {
          return 6;
        }
      }
    } else {
      if (dy >= 0) {
        if (adx >= ady) {
          return 3;
        } else {
          return 2;
        }
      } else {
        if (adx >= ady) {
          return 4;
        } else {
          return 5;
        }
      }
    }
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    var dx$1 = p1.x - p0.x;
    var dy$1 = p1.y - p0.y;
    if (dx$1 === 0 && dy$1 === 0) {
      throw new IllegalArgumentException("Cannot compute the octant for two identical points " + p0);
    }
    return Octant.octant(dx$1, dy$1);
  }
};
var SegmentString = function SegmentString2() {
};
SegmentString.prototype.getCoordinates = function getCoordinates() {
};
SegmentString.prototype.size = function size8() {
};
SegmentString.prototype.getCoordinate = function getCoordinate8(i) {
};
SegmentString.prototype.isClosed = function isClosed() {
};
SegmentString.prototype.setData = function setData(data) {
};
SegmentString.prototype.getData = function getData() {
};
SegmentString.prototype.interfaces_ = function interfaces_74() {
  return [];
};
SegmentString.prototype.getClass = function getClass73() {
  return SegmentString;
};
var NodableSegmentString = function NodableSegmentString2() {
};
NodableSegmentString.prototype.addIntersection = function addIntersection(intPt, segmentIndex) {
};
NodableSegmentString.prototype.interfaces_ = function interfaces_75() {
  return [SegmentString];
};
NodableSegmentString.prototype.getClass = function getClass74() {
  return NodableSegmentString;
};
var NodedSegmentString = function NodedSegmentString2() {
  this._nodeList = new SegmentNodeList(this);
  this._pts = null;
  this._data = null;
  var pts = arguments[0];
  var data = arguments[1];
  this._pts = pts;
  this._data = data;
};
NodedSegmentString.prototype.getCoordinates = function getCoordinates2() {
  return this._pts;
};
NodedSegmentString.prototype.size = function size9() {
  return this._pts.length;
};
NodedSegmentString.prototype.getCoordinate = function getCoordinate9(i) {
  return this._pts[i];
};
NodedSegmentString.prototype.isClosed = function isClosed2() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
NodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index2) {
  if (index2 === this._pts.length - 1) {
    return -1;
  }
  return this.safeOctant(this.getCoordinate(index2), this.getCoordinate(index2 + 1));
};
NodedSegmentString.prototype.setData = function setData2(data) {
  this._data = data;
};
NodedSegmentString.prototype.safeOctant = function safeOctant(p0, p1) {
  if (p0.equals2D(p1)) {
    return 0;
  }
  return Octant.octant(p0, p1);
};
NodedSegmentString.prototype.getData = function getData2() {
  return this._data;
};
NodedSegmentString.prototype.addIntersection = function addIntersection2() {
  if (arguments.length === 2) {
    var intPt$1 = arguments[0];
    var segmentIndex = arguments[1];
    this.addIntersectionNode(intPt$1, segmentIndex);
  } else if (arguments.length === 4) {
    var li = arguments[0];
    var segmentIndex$1 = arguments[1];
    var intIndex = arguments[3];
    var intPt = new Coordinate(li.getIntersection(intIndex));
    this.addIntersection(intPt, segmentIndex$1);
  }
};
NodedSegmentString.prototype.toString = function toString14() {
  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
};
NodedSegmentString.prototype.getNodeList = function getNodeList() {
  return this._nodeList;
};
NodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode(intPt, segmentIndex) {
  var normalizedSegmentIndex = segmentIndex;
  var nextSegIndex = normalizedSegmentIndex + 1;
  if (nextSegIndex < this._pts.length) {
    var nextPt = this._pts[nextSegIndex];
    if (intPt.equals2D(nextPt)) {
      normalizedSegmentIndex = nextSegIndex;
    }
  }
  var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
  return ei;
};
NodedSegmentString.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {
  var this$1$1 = this;
  for (var i = 0; i < li.getIntersectionNum(); i++) {
    this$1$1.addIntersection(li, segmentIndex, geomIndex, i);
  }
};
NodedSegmentString.prototype.interfaces_ = function interfaces_76() {
  return [NodableSegmentString];
};
NodedSegmentString.prototype.getClass = function getClass75() {
  return NodedSegmentString;
};
NodedSegmentString.getNodedSubstrings = function getNodedSubstrings() {
  if (arguments.length === 1) {
    var segStrings = arguments[0];
    var resultEdgelist = new ArrayList();
    NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
    return resultEdgelist;
  } else if (arguments.length === 2) {
    var segStrings$1 = arguments[0];
    var resultEdgelist$1 = arguments[1];
    for (var i = segStrings$1.iterator(); i.hasNext(); ) {
      var ss = i.next();
      ss.getNodeList().addSplitEdges(resultEdgelist$1);
    }
  }
};
var LineSegment = function LineSegment2() {
  this.p0 = null;
  this.p1 = null;
  if (arguments.length === 0) {
    this.p0 = new Coordinate();
    this.p1 = new Coordinate();
  } else if (arguments.length === 1) {
    var ls = arguments[0];
    this.p0 = new Coordinate(ls.p0);
    this.p1 = new Coordinate(ls.p1);
  } else if (arguments.length === 2) {
    this.p0 = arguments[0];
    this.p1 = arguments[1];
  } else if (arguments.length === 4) {
    var x02 = arguments[0];
    var y02 = arguments[1];
    var x12 = arguments[2];
    var y12 = arguments[3];
    this.p0 = new Coordinate(x02, y02);
    this.p1 = new Coordinate(x12, y12);
  }
};
var staticAccessors$24 = { serialVersionUID: { configurable: true } };
LineSegment.prototype.minX = function minX() {
  return Math.min(this.p0.x, this.p1.x);
};
LineSegment.prototype.orientationIndex = function orientationIndex5() {
  if (arguments[0] instanceof LineSegment) {
    var seg = arguments[0];
    var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
    var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
    if (orient0 >= 0 && orient1 >= 0) {
      return Math.max(orient0, orient1);
    }
    if (orient0 <= 0 && orient1 <= 0) {
      return Math.max(orient0, orient1);
    }
    return 0;
  } else if (arguments[0] instanceof Coordinate) {
    var p = arguments[0];
    return CGAlgorithms.orientationIndex(this.p0, this.p1, p);
  }
};
LineSegment.prototype.toGeometry = function toGeometry2(geomFactory) {
  return geomFactory.createLineString([this.p0, this.p1]);
};
LineSegment.prototype.isVertical = function isVertical() {
  return this.p0.x === this.p1.x;
};
LineSegment.prototype.equals = function equals9(o) {
  if (!(o instanceof LineSegment)) {
    return false;
  }
  var other = o;
  return this.p0.equals(other.p0) && this.p1.equals(other.p1);
};
LineSegment.prototype.intersection = function intersection8(line) {
  var li = new RobustLineIntersector();
  li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
  if (li.hasIntersection()) {
    return li.getIntersection(0);
  }
  return null;
};
LineSegment.prototype.project = function project() {
  if (arguments[0] instanceof Coordinate) {
    var p = arguments[0];
    if (p.equals(this.p0) || p.equals(this.p1)) {
      return new Coordinate(p);
    }
    var r = this.projectionFactor(p);
    var coord = new Coordinate();
    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
    return coord;
  } else if (arguments[0] instanceof LineSegment) {
    var seg = arguments[0];
    var pf0 = this.projectionFactor(seg.p0);
    var pf1 = this.projectionFactor(seg.p1);
    if (pf0 >= 1 && pf1 >= 1) {
      return null;
    }
    if (pf0 <= 0 && pf1 <= 0) {
      return null;
    }
    var newp0 = this.project(seg.p0);
    if (pf0 < 0) {
      newp0 = this.p0;
    }
    if (pf0 > 1) {
      newp0 = this.p1;
    }
    var newp1 = this.project(seg.p1);
    if (pf1 < 0) {
      newp1 = this.p0;
    }
    if (pf1 > 1) {
      newp1 = this.p1;
    }
    return new LineSegment(newp0, newp1);
  }
};
LineSegment.prototype.normalize = function normalize() {
  if (this.p1.compareTo(this.p0) < 0) {
    this.reverse();
  }
};
LineSegment.prototype.angle = function angle2() {
  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
};
LineSegment.prototype.getCoordinate = function getCoordinate10(i) {
  if (i === 0) {
    return this.p0;
  }
  return this.p1;
};
LineSegment.prototype.distancePerpendicular = function distancePerpendicular(p) {
  return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);
};
LineSegment.prototype.minY = function minY() {
  return Math.min(this.p0.y, this.p1.y);
};
LineSegment.prototype.midPoint = function midPoint() {
  return LineSegment.midPoint(this.p0, this.p1);
};
LineSegment.prototype.projectionFactor = function projectionFactor(p) {
  if (p.equals(this.p0)) {
    return 0;
  }
  if (p.equals(this.p1)) {
    return 1;
  }
  var dx = this.p1.x - this.p0.x;
  var dy = this.p1.y - this.p0.y;
  var len2 = dx * dx + dy * dy;
  if (len2 <= 0) {
    return Double.NaN;
  }
  var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len2;
  return r;
};
LineSegment.prototype.closestPoints = function closestPoints(line) {
  var intPt = this.intersection(line);
  if (intPt !== null) {
    return [intPt, intPt];
  }
  var closestPt = new Array(2).fill(null);
  var minDistance = Double.MAX_VALUE;
  var dist3 = null;
  var close00 = this.closestPoint(line.p0);
  minDistance = close00.distance(line.p0);
  closestPt[0] = close00;
  closestPt[1] = line.p0;
  var close01 = this.closestPoint(line.p1);
  dist3 = close01.distance(line.p1);
  if (dist3 < minDistance) {
    minDistance = dist3;
    closestPt[0] = close01;
    closestPt[1] = line.p1;
  }
  var close10 = line.closestPoint(this.p0);
  dist3 = close10.distance(this.p0);
  if (dist3 < minDistance) {
    minDistance = dist3;
    closestPt[0] = this.p0;
    closestPt[1] = close10;
  }
  var close11 = line.closestPoint(this.p1);
  dist3 = close11.distance(this.p1);
  if (dist3 < minDistance) {
    minDistance = dist3;
    closestPt[0] = this.p1;
    closestPt[1] = close11;
  }
  return closestPt;
};
LineSegment.prototype.closestPoint = function closestPoint(p) {
  var factor = this.projectionFactor(p);
  if (factor > 0 && factor < 1) {
    return this.project(p);
  }
  var dist0 = this.p0.distance(p);
  var dist1 = this.p1.distance(p);
  if (dist0 < dist1) {
    return this.p0;
  }
  return this.p1;
};
LineSegment.prototype.maxX = function maxX() {
  return Math.max(this.p0.x, this.p1.x);
};
LineSegment.prototype.getLength = function getLength2() {
  return this.p0.distance(this.p1);
};
LineSegment.prototype.compareTo = function compareTo11(o) {
  var other = o;
  var comp0 = this.p0.compareTo(other.p0);
  if (comp0 !== 0) {
    return comp0;
  }
  return this.p1.compareTo(other.p1);
};
LineSegment.prototype.reverse = function reverse3() {
  var temp2 = this.p0;
  this.p0 = this.p1;
  this.p1 = temp2;
};
LineSegment.prototype.equalsTopo = function equalsTopo(other) {
  return this.p0.equals(other.p0) && (this.p1.equals(other.p1) || this.p0.equals(other.p1)) && this.p1.equals(other.p0);
};
LineSegment.prototype.lineIntersection = function lineIntersection(line) {
  try {
    var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
    return intPt;
  } catch (ex) {
    if (ex instanceof NotRepresentableException)
      ;
    else {
      throw ex;
    }
  } finally {
  }
  return null;
};
LineSegment.prototype.maxY = function maxY() {
  return Math.max(this.p0.y, this.p1.y);
};
LineSegment.prototype.pointAlongOffset = function pointAlongOffset(segmentLengthFraction, offsetDistance) {
  var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
  var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
  var dx = this.p1.x - this.p0.x;
  var dy = this.p1.y - this.p0.y;
  var len2 = Math.sqrt(dx * dx + dy * dy);
  var ux = 0;
  var uy = 0;
  if (offsetDistance !== 0) {
    if (len2 <= 0) {
      throw new Error("Cannot compute offset from zero-length line segment");
    }
    ux = offsetDistance * dx / len2;
    uy = offsetDistance * dy / len2;
  }
  var offsetx = segx - uy;
  var offsety = segy + ux;
  var coord = new Coordinate(offsetx, offsety);
  return coord;
};
LineSegment.prototype.setCoordinates = function setCoordinates() {
  if (arguments.length === 1) {
    var ls = arguments[0];
    this.setCoordinates(ls.p0, ls.p1);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    this.p0.x = p0.x;
    this.p0.y = p0.y;
    this.p1.x = p1.x;
    this.p1.y = p1.y;
  }
};
LineSegment.prototype.segmentFraction = function segmentFraction(inputPt) {
  var segFrac = this.projectionFactor(inputPt);
  if (segFrac < 0) {
    segFrac = 0;
  } else if (segFrac > 1 || Double.isNaN(segFrac)) {
    segFrac = 1;
  }
  return segFrac;
};
LineSegment.prototype.toString = function toString15() {
  return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
};
LineSegment.prototype.isHorizontal = function isHorizontal() {
  return this.p0.y === this.p1.y;
};
LineSegment.prototype.distance = function distance5() {
  if (arguments[0] instanceof LineSegment) {
    var ls = arguments[0];
    return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);
  } else if (arguments[0] instanceof Coordinate) {
    var p = arguments[0];
    return CGAlgorithms.distancePointLine(p, this.p0, this.p1);
  }
};
LineSegment.prototype.pointAlong = function pointAlong(segmentLengthFraction) {
  var coord = new Coordinate();
  coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
  coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
  return coord;
};
LineSegment.prototype.hashCode = function hashCode5() {
  var bits0 = Double.doubleToLongBits(this.p0.x);
  bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
  var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
  var bits1 = Double.doubleToLongBits(this.p1.x);
  bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
  var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
  return hash0 ^ hash1;
};
LineSegment.prototype.interfaces_ = function interfaces_77() {
  return [Comparable, Serializable];
};
LineSegment.prototype.getClass = function getClass76() {
  return LineSegment;
};
LineSegment.midPoint = function midPoint2(p0, p1) {
  return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
};
staticAccessors$24.serialVersionUID.get = function() {
  return 3252005833466256400;
};
Object.defineProperties(LineSegment, staticAccessors$24);
var MonotoneChainOverlapAction = function MonotoneChainOverlapAction2() {
  this.tempEnv1 = new Envelope();
  this.tempEnv2 = new Envelope();
  this._overlapSeg1 = new LineSegment();
  this._overlapSeg2 = new LineSegment();
};
MonotoneChainOverlapAction.prototype.overlap = function overlap() {
  if (arguments.length === 2)
    ;
  else if (arguments.length === 4) {
    var mc1 = arguments[0];
    var start1 = arguments[1];
    var mc2 = arguments[2];
    var start2 = arguments[3];
    mc1.getLineSegment(start1, this._overlapSeg1);
    mc2.getLineSegment(start2, this._overlapSeg2);
    this.overlap(this._overlapSeg1, this._overlapSeg2);
  }
};
MonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_78() {
  return [];
};
MonotoneChainOverlapAction.prototype.getClass = function getClass77() {
  return MonotoneChainOverlapAction;
};
var MonotoneChain = function MonotoneChain2() {
  this._pts = null;
  this._start = null;
  this._end = null;
  this._env = null;
  this._context = null;
  this._id = null;
  var pts = arguments[0];
  var start2 = arguments[1];
  var end2 = arguments[2];
  var context = arguments[3];
  this._pts = pts;
  this._start = start2;
  this._end = end2;
  this._context = context;
};
MonotoneChain.prototype.getLineSegment = function getLineSegment(index2, ls) {
  ls.p0 = this._pts[index2];
  ls.p1 = this._pts[index2 + 1];
};
MonotoneChain.prototype.computeSelect = function computeSelect(searchEnv, start0, end0, mcs) {
  var p0 = this._pts[start0];
  var p1 = this._pts[end0];
  mcs.tempEnv1.init(p0, p1);
  if (end0 - start0 === 1) {
    mcs.select(this, start0);
    return null;
  }
  if (!searchEnv.intersects(mcs.tempEnv1)) {
    return null;
  }
  var mid = Math.trunc((start0 + end0) / 2);
  if (start0 < mid) {
    this.computeSelect(searchEnv, start0, mid, mcs);
  }
  if (mid < end0) {
    this.computeSelect(searchEnv, mid, end0, mcs);
  }
};
MonotoneChain.prototype.getCoordinates = function getCoordinates3() {
  var this$1$1 = this;
  var coord = new Array(this._end - this._start + 1).fill(null);
  var index2 = 0;
  for (var i = this._start; i <= this._end; i++) {
    coord[index2++] = this$1$1._pts[i];
  }
  return coord;
};
MonotoneChain.prototype.computeOverlaps = function computeOverlaps(mc, mco) {
  this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
};
MonotoneChain.prototype.setId = function setId(id) {
  this._id = id;
};
MonotoneChain.prototype.select = function select(searchEnv, mcs) {
  this.computeSelect(searchEnv, this._start, this._end, mcs);
};
MonotoneChain.prototype.getEnvelope = function getEnvelope3() {
  if (this._env === null) {
    var p0 = this._pts[this._start];
    var p1 = this._pts[this._end];
    this._env = new Envelope(p0, p1);
  }
  return this._env;
};
MonotoneChain.prototype.getEndIndex = function getEndIndex() {
  return this._end;
};
MonotoneChain.prototype.getStartIndex = function getStartIndex() {
  return this._start;
};
MonotoneChain.prototype.getContext = function getContext() {
  return this._context;
};
MonotoneChain.prototype.getId = function getId() {
  return this._id;
};
MonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {
  var p002 = this._pts[start0];
  var p012 = this._pts[end0];
  var p102 = mc._pts[start1];
  var p112 = mc._pts[end1];
  if (end0 - start0 === 1 && end1 - start1 === 1) {
    mco.overlap(this, start0, mc, start1);
    return null;
  }
  mco.tempEnv1.init(p002, p012);
  mco.tempEnv2.init(p102, p112);
  if (!mco.tempEnv1.intersects(mco.tempEnv2)) {
    return null;
  }
  var mid0 = Math.trunc((start0 + end0) / 2);
  var mid1 = Math.trunc((start1 + end1) / 2);
  if (start0 < mid0) {
    if (start1 < mid1) {
      this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);
    }
    if (mid1 < end1) {
      this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);
    }
  }
  if (mid0 < end0) {
    if (start1 < mid1) {
      this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);
    }
    if (mid1 < end1) {
      this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);
    }
  }
};
MonotoneChain.prototype.interfaces_ = function interfaces_79() {
  return [];
};
MonotoneChain.prototype.getClass = function getClass78() {
  return MonotoneChain;
};
var MonotoneChainBuilder = function MonotoneChainBuilder2() {
};
MonotoneChainBuilder.prototype.interfaces_ = function interfaces_80() {
  return [];
};
MonotoneChainBuilder.prototype.getClass = function getClass79() {
  return MonotoneChainBuilder;
};
MonotoneChainBuilder.getChainStartIndices = function getChainStartIndices(pts) {
  var start2 = 0;
  var startIndexList = new ArrayList();
  startIndexList.add(new Integer(start2));
  do {
    var last = MonotoneChainBuilder.findChainEnd(pts, start2);
    startIndexList.add(new Integer(last));
    start2 = last;
  } while (start2 < pts.length - 1);
  var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
  return startIndex;
};
MonotoneChainBuilder.findChainEnd = function findChainEnd(pts, start2) {
  var safeStart = start2;
  while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
    safeStart++;
  }
  if (safeStart >= pts.length - 1) {
    return pts.length - 1;
  }
  var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
  var last = start2 + 1;
  while (last < pts.length) {
    if (!pts[last - 1].equals2D(pts[last])) {
      var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
      if (quad !== chainQuad) {
        break;
      }
    }
    last++;
  }
  return last - 1;
};
MonotoneChainBuilder.getChains = function getChains() {
  if (arguments.length === 1) {
    var pts = arguments[0];
    return MonotoneChainBuilder.getChains(pts, null);
  } else if (arguments.length === 2) {
    var pts$1 = arguments[0];
    var context = arguments[1];
    var mcList = new ArrayList();
    var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);
    for (var i = 0; i < startIndex.length - 1; i++) {
      var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);
      mcList.add(mc);
    }
    return mcList;
  }
};
MonotoneChainBuilder.toIntArray = function toIntArray(list) {
  var array = new Array(list.size()).fill(null);
  for (var i = 0; i < array.length; i++) {
    array[i] = list.get(i).intValue();
  }
  return array;
};
var Noder = function Noder2() {
};
Noder.prototype.computeNodes = function computeNodes(segStrings) {
};
Noder.prototype.getNodedSubstrings = function getNodedSubstrings2() {
};
Noder.prototype.interfaces_ = function interfaces_81() {
  return [];
};
Noder.prototype.getClass = function getClass80() {
  return Noder;
};
var SinglePassNoder = function SinglePassNoder2() {
  this._segInt = null;
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    var segInt = arguments[0];
    this.setSegmentIntersector(segInt);
  }
};
SinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector(segInt) {
  this._segInt = segInt;
};
SinglePassNoder.prototype.interfaces_ = function interfaces_82() {
  return [Noder];
};
SinglePassNoder.prototype.getClass = function getClass81() {
  return SinglePassNoder;
};
var MCIndexNoder = function(SinglePassNoder$$1) {
  function MCIndexNoder2(si) {
    if (si) {
      SinglePassNoder$$1.call(this, si);
    } else {
      SinglePassNoder$$1.call(this);
    }
    this._monoChains = new ArrayList();
    this._index = new STRtree();
    this._idCounter = 0;
    this._nodedSegStrings = null;
    this._nOverlaps = 0;
  }
  if (SinglePassNoder$$1)
    MCIndexNoder2.__proto__ = SinglePassNoder$$1;
  MCIndexNoder2.prototype = Object.create(SinglePassNoder$$1 && SinglePassNoder$$1.prototype);
  MCIndexNoder2.prototype.constructor = MCIndexNoder2;
  var staticAccessors2 = { SegmentOverlapAction: { configurable: true } };
  MCIndexNoder2.prototype.getMonotoneChains = function getMonotoneChains() {
    return this._monoChains;
  };
  MCIndexNoder2.prototype.getNodedSubstrings = function getNodedSubstrings5() {
    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
  };
  MCIndexNoder2.prototype.getIndex = function getIndex() {
    return this._index;
  };
  MCIndexNoder2.prototype.add = function add16(segStr) {
    var this$1$1 = this;
    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
    for (var i = segChains.iterator(); i.hasNext(); ) {
      var mc = i.next();
      mc.setId(this$1$1._idCounter++);
      this$1$1._index.insert(mc.getEnvelope(), mc);
      this$1$1._monoChains.add(mc);
    }
  };
  MCIndexNoder2.prototype.computeNodes = function computeNodes4(inputSegStrings) {
    var this$1$1 = this;
    this._nodedSegStrings = inputSegStrings;
    for (var i = inputSegStrings.iterator(); i.hasNext(); ) {
      this$1$1.add(i.next());
    }
    this.intersectChains();
  };
  MCIndexNoder2.prototype.intersectChains = function intersectChains() {
    var this$1$1 = this;
    var overlapAction = new SegmentOverlapAction(this._segInt);
    for (var i = this._monoChains.iterator(); i.hasNext(); ) {
      var queryChain = i.next();
      var overlapChains = this$1$1._index.query(queryChain.getEnvelope());
      for (var j = overlapChains.iterator(); j.hasNext(); ) {
        var testChain = j.next();
        if (testChain.getId() > queryChain.getId()) {
          queryChain.computeOverlaps(testChain, overlapAction);
          this$1$1._nOverlaps++;
        }
        if (this$1$1._segInt.isDone()) {
          return null;
        }
      }
    }
  };
  MCIndexNoder2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  MCIndexNoder2.prototype.getClass = function getClass169() {
    return MCIndexNoder2;
  };
  staticAccessors2.SegmentOverlapAction.get = function() {
    return SegmentOverlapAction;
  };
  Object.defineProperties(MCIndexNoder2, staticAccessors2);
  return MCIndexNoder2;
}(SinglePassNoder);
var SegmentOverlapAction = function(MonotoneChainOverlapAction$$1) {
  function SegmentOverlapAction2() {
    MonotoneChainOverlapAction$$1.call(this);
    this._si = null;
    var si = arguments[0];
    this._si = si;
  }
  if (MonotoneChainOverlapAction$$1)
    SegmentOverlapAction2.__proto__ = MonotoneChainOverlapAction$$1;
  SegmentOverlapAction2.prototype = Object.create(MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype);
  SegmentOverlapAction2.prototype.constructor = SegmentOverlapAction2;
  SegmentOverlapAction2.prototype.overlap = function overlap2() {
    if (arguments.length === 4) {
      var mc1 = arguments[0];
      var start1 = arguments[1];
      var mc2 = arguments[2];
      var start2 = arguments[3];
      var ss1 = mc1.getContext();
      var ss2 = mc2.getContext();
      this._si.processIntersections(ss1, start1, ss2, start2);
    } else {
      return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments);
    }
  };
  SegmentOverlapAction2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  SegmentOverlapAction2.prototype.getClass = function getClass169() {
    return SegmentOverlapAction2;
  };
  return SegmentOverlapAction2;
}(MonotoneChainOverlapAction);
var BufferParameters = function BufferParameters2() {
  this._quadrantSegments = BufferParameters2.DEFAULT_QUADRANT_SEGMENTS;
  this._endCapStyle = BufferParameters2.CAP_ROUND;
  this._joinStyle = BufferParameters2.JOIN_ROUND;
  this._mitreLimit = BufferParameters2.DEFAULT_MITRE_LIMIT;
  this._isSingleSided = false;
  this._simplifyFactor = BufferParameters2.DEFAULT_SIMPLIFY_FACTOR;
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    var quadrantSegments = arguments[0];
    this.setQuadrantSegments(quadrantSegments);
  } else if (arguments.length === 2) {
    var quadrantSegments$1 = arguments[0];
    var endCapStyle = arguments[1];
    this.setQuadrantSegments(quadrantSegments$1);
    this.setEndCapStyle(endCapStyle);
  } else if (arguments.length === 4) {
    var quadrantSegments$2 = arguments[0];
    var endCapStyle$1 = arguments[1];
    var joinStyle = arguments[2];
    var mitreLimit = arguments[3];
    this.setQuadrantSegments(quadrantSegments$2);
    this.setEndCapStyle(endCapStyle$1);
    this.setJoinStyle(joinStyle);
    this.setMitreLimit(mitreLimit);
  }
};
var staticAccessors$25 = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
BufferParameters.prototype.getEndCapStyle = function getEndCapStyle() {
  return this._endCapStyle;
};
BufferParameters.prototype.isSingleSided = function isSingleSided() {
  return this._isSingleSided;
};
BufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments(quadSegs) {
  this._quadrantSegments = quadSegs;
  if (this._quadrantSegments === 0) {
    this._joinStyle = BufferParameters.JOIN_BEVEL;
  }
  if (this._quadrantSegments < 0) {
    this._joinStyle = BufferParameters.JOIN_MITRE;
    this._mitreLimit = Math.abs(this._quadrantSegments);
  }
  if (quadSegs <= 0) {
    this._quadrantSegments = 1;
  }
  if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
  }
};
BufferParameters.prototype.getJoinStyle = function getJoinStyle() {
  return this._joinStyle;
};
BufferParameters.prototype.setJoinStyle = function setJoinStyle(joinStyle) {
  this._joinStyle = joinStyle;
};
BufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor(simplifyFactor) {
  this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
};
BufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor() {
  return this._simplifyFactor;
};
BufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments() {
  return this._quadrantSegments;
};
BufferParameters.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {
  this._endCapStyle = endCapStyle;
};
BufferParameters.prototype.getMitreLimit = function getMitreLimit() {
  return this._mitreLimit;
};
BufferParameters.prototype.setMitreLimit = function setMitreLimit(mitreLimit) {
  this._mitreLimit = mitreLimit;
};
BufferParameters.prototype.setSingleSided = function setSingleSided(isSingleSided2) {
  this._isSingleSided = isSingleSided2;
};
BufferParameters.prototype.interfaces_ = function interfaces_83() {
  return [];
};
BufferParameters.prototype.getClass = function getClass82() {
  return BufferParameters;
};
BufferParameters.bufferDistanceError = function bufferDistanceError(quadSegs) {
  var alpha = Math.PI / 2 / quadSegs;
  return 1 - Math.cos(alpha / 2);
};
staticAccessors$25.CAP_ROUND.get = function() {
  return 1;
};
staticAccessors$25.CAP_FLAT.get = function() {
  return 2;
};
staticAccessors$25.CAP_SQUARE.get = function() {
  return 3;
};
staticAccessors$25.JOIN_ROUND.get = function() {
  return 1;
};
staticAccessors$25.JOIN_MITRE.get = function() {
  return 2;
};
staticAccessors$25.JOIN_BEVEL.get = function() {
  return 3;
};
staticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function() {
  return 8;
};
staticAccessors$25.DEFAULT_MITRE_LIMIT.get = function() {
  return 5;
};
staticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function() {
  return 0.01;
};
Object.defineProperties(BufferParameters, staticAccessors$25);
var BufferInputLineSimplifier = function BufferInputLineSimplifier2(inputLine) {
  this._distanceTol = null;
  this._isDeleted = null;
  this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
  this._inputLine = inputLine || null;
};
var staticAccessors$26 = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
BufferInputLineSimplifier.prototype.isDeletable = function isDeletable(i0, i1, i2, distanceTol) {
  var p0 = this._inputLine[i0];
  var p1 = this._inputLine[i1];
  var p2 = this._inputLine[i2];
  if (!this.isConcave(p0, p1, p2)) {
    return false;
  }
  if (!this.isShallow(p0, p1, p2, distanceTol)) {
    return false;
  }
  return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
};
BufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities() {
  var this$1$1 = this;
  var index2 = 1;
  var midIndex = this.findNextNonDeletedIndex(index2);
  var lastIndex = this.findNextNonDeletedIndex(midIndex);
  var isChanged = false;
  while (lastIndex < this._inputLine.length) {
    var isMiddleVertexDeleted = false;
    if (this$1$1.isDeletable(index2, midIndex, lastIndex, this$1$1._distanceTol)) {
      this$1$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
      isMiddleVertexDeleted = true;
      isChanged = true;
    }
    if (isMiddleVertexDeleted) {
      index2 = lastIndex;
    } else {
      index2 = midIndex;
    }
    midIndex = this$1$1.findNextNonDeletedIndex(index2);
    lastIndex = this$1$1.findNextNonDeletedIndex(midIndex);
  }
  return isChanged;
};
BufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity(p0, p1, p2, distanceTol) {
  var orientation2 = CGAlgorithms.computeOrientation(p0, p1, p2);
  var isAngleToSimplify = orientation2 === this._angleOrientation;
  if (!isAngleToSimplify) {
    return false;
  }
  var dist3 = CGAlgorithms.distancePointLine(p1, p0, p2);
  return dist3 < distanceTol;
};
BufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled(p0, p2, i0, i2, distanceTol) {
  var this$1$1 = this;
  var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
  if (inc <= 0) {
    inc = 1;
  }
  for (var i = i0; i < i2; i += inc) {
    if (!this$1$1.isShallow(p0, p2, this$1$1._inputLine[i], distanceTol)) {
      return false;
    }
  }
  return true;
};
BufferInputLineSimplifier.prototype.isConcave = function isConcave(p0, p1, p2) {
  var orientation2 = CGAlgorithms.computeOrientation(p0, p1, p2);
  var isConcave2 = orientation2 === this._angleOrientation;
  return isConcave2;
};
BufferInputLineSimplifier.prototype.simplify = function simplify2(distanceTol) {
  var this$1$1 = this;
  this._distanceTol = Math.abs(distanceTol);
  if (distanceTol < 0) {
    this._angleOrientation = CGAlgorithms.CLOCKWISE;
  }
  this._isDeleted = new Array(this._inputLine.length).fill(null);
  var isChanged = false;
  do {
    isChanged = this$1$1.deleteShallowConcavities();
  } while (isChanged);
  return this.collapseLine();
};
BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex(index2) {
  var next3 = index2 + 1;
  while (next3 < this._inputLine.length && this._isDeleted[next3] === BufferInputLineSimplifier.DELETE) {
    next3++;
  }
  return next3;
};
BufferInputLineSimplifier.prototype.isShallow = function isShallow(p0, p1, p2, distanceTol) {
  var dist3 = CGAlgorithms.distancePointLine(p1, p0, p2);
  return dist3 < distanceTol;
};
BufferInputLineSimplifier.prototype.collapseLine = function collapseLine() {
  var this$1$1 = this;
  var coordList = new CoordinateList();
  for (var i = 0; i < this._inputLine.length; i++) {
    if (this$1$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) {
      coordList.add(this$1$1._inputLine[i]);
    }
  }
  return coordList.toCoordinateArray();
};
BufferInputLineSimplifier.prototype.interfaces_ = function interfaces_84() {
  return [];
};
BufferInputLineSimplifier.prototype.getClass = function getClass83() {
  return BufferInputLineSimplifier;
};
BufferInputLineSimplifier.simplify = function simplify3(inputLine, distanceTol) {
  var simp = new BufferInputLineSimplifier(inputLine);
  return simp.simplify(distanceTol);
};
staticAccessors$26.INIT.get = function() {
  return 0;
};
staticAccessors$26.DELETE.get = function() {
  return 1;
};
staticAccessors$26.KEEP.get = function() {
  return 1;
};
staticAccessors$26.NUM_PTS_TO_CHECK.get = function() {
  return 10;
};
Object.defineProperties(BufferInputLineSimplifier, staticAccessors$26);
var OffsetSegmentString = function OffsetSegmentString2() {
  this._ptList = null;
  this._precisionModel = null;
  this._minimimVertexDistance = 0;
  this._ptList = new ArrayList();
};
var staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };
OffsetSegmentString.prototype.getCoordinates = function getCoordinates4() {
  var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
  return coord;
};
OffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel2(precisionModel) {
  this._precisionModel = precisionModel;
};
OffsetSegmentString.prototype.addPt = function addPt(pt) {
  var bufPt = new Coordinate(pt);
  this._precisionModel.makePrecise(bufPt);
  if (this.isRedundant(bufPt)) {
    return null;
  }
  this._ptList.add(bufPt);
};
OffsetSegmentString.prototype.revere = function revere() {
};
OffsetSegmentString.prototype.addPts = function addPts(pt, isForward) {
  var this$1$1 = this;
  if (isForward) {
    for (var i = 0; i < pt.length; i++) {
      this$1$1.addPt(pt[i]);
    }
  } else {
    for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {
      this$1$1.addPt(pt[i$1]);
    }
  }
};
OffsetSegmentString.prototype.isRedundant = function isRedundant(pt) {
  if (this._ptList.size() < 1) {
    return false;
  }
  var lastPt = this._ptList.get(this._ptList.size() - 1);
  var ptDist = pt.distance(lastPt);
  if (ptDist < this._minimimVertexDistance) {
    return true;
  }
  return false;
};
OffsetSegmentString.prototype.toString = function toString16() {
  var fact = new GeometryFactory();
  var line = fact.createLineString(this.getCoordinates());
  return line.toString();
};
OffsetSegmentString.prototype.closeRing = function closeRing() {
  if (this._ptList.size() < 1) {
    return null;
  }
  var startPt = new Coordinate(this._ptList.get(0));
  var lastPt = this._ptList.get(this._ptList.size() - 1);
  if (startPt.equals(lastPt)) {
    return null;
  }
  this._ptList.add(startPt);
};
OffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance(minimimVertexDistance) {
  this._minimimVertexDistance = minimimVertexDistance;
};
OffsetSegmentString.prototype.interfaces_ = function interfaces_85() {
  return [];
};
OffsetSegmentString.prototype.getClass = function getClass84() {
  return OffsetSegmentString;
};
staticAccessors$28.COORDINATE_ARRAY_TYPE.get = function() {
  return new Array(0).fill(null);
};
Object.defineProperties(OffsetSegmentString, staticAccessors$28);
var Angle = function Angle2() {
};
var staticAccessors$29 = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
Angle.prototype.interfaces_ = function interfaces_86() {
  return [];
};
Angle.prototype.getClass = function getClass85() {
  return Angle;
};
Angle.toDegrees = function toDegrees(radians2) {
  return radians2 * 180 / Math.PI;
};
Angle.normalize = function normalize2(angle4) {
  while (angle4 > Math.PI) {
    angle4 -= Angle.PI_TIMES_2;
  }
  while (angle4 <= -Math.PI) {
    angle4 += Angle.PI_TIMES_2;
  }
  return angle4;
};
Angle.angle = function angle3() {
  if (arguments.length === 1) {
    var p = arguments[0];
    return Math.atan2(p.y, p.x);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    var dx = p1.x - p0.x;
    var dy = p1.y - p0.y;
    return Math.atan2(dy, dx);
  }
};
Angle.isAcute = function isAcute(p0, p1, p2) {
  var dx0 = p0.x - p1.x;
  var dy0 = p0.y - p1.y;
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dotprod = dx0 * dx1 + dy0 * dy1;
  return dotprod > 0;
};
Angle.isObtuse = function isObtuse(p0, p1, p2) {
  var dx0 = p0.x - p1.x;
  var dy0 = p0.y - p1.y;
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dotprod = dx0 * dx1 + dy0 * dy1;
  return dotprod < 0;
};
Angle.interiorAngle = function interiorAngle(p0, p1, p2) {
  var anglePrev = Angle.angle(p1, p0);
  var angleNext = Angle.angle(p1, p2);
  return Math.abs(angleNext - anglePrev);
};
Angle.normalizePositive = function normalizePositive(angle4) {
  if (angle4 < 0) {
    while (angle4 < 0) {
      angle4 += Angle.PI_TIMES_2;
    }
    if (angle4 >= Angle.PI_TIMES_2) {
      angle4 = 0;
    }
  } else {
    while (angle4 >= Angle.PI_TIMES_2) {
      angle4 -= Angle.PI_TIMES_2;
    }
    if (angle4 < 0) {
      angle4 = 0;
    }
  }
  return angle4;
};
Angle.angleBetween = function angleBetween(tip1, tail, tip2) {
  var a1 = Angle.angle(tail, tip1);
  var a2 = Angle.angle(tail, tip2);
  return Angle.diff(a1, a2);
};
Angle.diff = function diff(ang1, ang2) {
  var delAngle = null;
  if (ang1 < ang2) {
    delAngle = ang2 - ang1;
  } else {
    delAngle = ang1 - ang2;
  }
  if (delAngle > Math.PI) {
    delAngle = 2 * Math.PI - delAngle;
  }
  return delAngle;
};
Angle.toRadians = function toRadians(angleDegrees) {
  return angleDegrees * Math.PI / 180;
};
Angle.getTurn = function getTurn(ang1, ang2) {
  var crossproduct = Math.sin(ang2 - ang1);
  if (crossproduct > 0) {
    return Angle.COUNTERCLOCKWISE;
  }
  if (crossproduct < 0) {
    return Angle.CLOCKWISE;
  }
  return Angle.NONE;
};
Angle.angleBetweenOriented = function angleBetweenOriented(tip1, tail, tip2) {
  var a1 = Angle.angle(tail, tip1);
  var a2 = Angle.angle(tail, tip2);
  var angDel = a2 - a1;
  if (angDel <= -Math.PI) {
    return angDel + Angle.PI_TIMES_2;
  }
  if (angDel > Math.PI) {
    return angDel - Angle.PI_TIMES_2;
  }
  return angDel;
};
staticAccessors$29.PI_TIMES_2.get = function() {
  return 2 * Math.PI;
};
staticAccessors$29.PI_OVER_2.get = function() {
  return Math.PI / 2;
};
staticAccessors$29.PI_OVER_4.get = function() {
  return Math.PI / 4;
};
staticAccessors$29.COUNTERCLOCKWISE.get = function() {
  return CGAlgorithms.COUNTERCLOCKWISE;
};
staticAccessors$29.CLOCKWISE.get = function() {
  return CGAlgorithms.CLOCKWISE;
};
staticAccessors$29.NONE.get = function() {
  return CGAlgorithms.COLLINEAR;
};
Object.defineProperties(Angle, staticAccessors$29);
var OffsetSegmentGenerator = function OffsetSegmentGenerator2() {
  this._maxCurveSegmentError = 0;
  this._filletAngleQuantum = null;
  this._closingSegLengthFactor = 1;
  this._segList = null;
  this._distance = 0;
  this._precisionModel = null;
  this._bufParams = null;
  this._li = null;
  this._s0 = null;
  this._s1 = null;
  this._s2 = null;
  this._seg0 = new LineSegment();
  this._seg1 = new LineSegment();
  this._offset0 = new LineSegment();
  this._offset1 = new LineSegment();
  this._side = 0;
  this._hasNarrowConcaveAngle = false;
  var precisionModel = arguments[0];
  var bufParams = arguments[1];
  var distance11 = arguments[2];
  this._precisionModel = precisionModel;
  this._bufParams = bufParams;
  this._li = new RobustLineIntersector();
  this._filletAngleQuantum = Math.PI / 2 / bufParams.getQuadrantSegments();
  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) {
    this._closingSegLengthFactor = OffsetSegmentGenerator2.MAX_CLOSING_SEG_LEN_FACTOR;
  }
  this.init(distance11);
};
var staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
OffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment(p, addStartPoint) {
  this._s0 = this._s1;
  this._s1 = this._s2;
  this._s2 = p;
  this._seg0.setCoordinates(this._s0, this._s1);
  this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
  this._seg1.setCoordinates(this._s1, this._s2);
  this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
  if (this._s1.equals(this._s2)) {
    return null;
  }
  var orientation2 = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
  var outsideTurn = orientation2 === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation2 === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;
  if (orientation2 === 0) {
    this.addCollinear(addStartPoint);
  } else if (outsideTurn) {
    this.addOutsideTurn(orientation2, addStartPoint);
  } else {
    this.addInsideTurn(orientation2, addStartPoint);
  }
};
OffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap(p0, p1) {
  var seg = new LineSegment(p0, p1);
  var offsetL = new LineSegment();
  this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
  var offsetR = new LineSegment();
  this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  var angle4 = Math.atan2(dy, dx);
  switch (this._bufParams.getEndCapStyle()) {
    case BufferParameters.CAP_ROUND:
      this._segList.addPt(offsetL.p1);
      this.addFilletArc(p1, angle4 + Math.PI / 2, angle4 - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
      this._segList.addPt(offsetR.p1);
      break;
    case BufferParameters.CAP_FLAT:
      this._segList.addPt(offsetL.p1);
      this._segList.addPt(offsetR.p1);
      break;
    case BufferParameters.CAP_SQUARE:
      var squareCapSideOffset = new Coordinate();
      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle4);
      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle4);
      var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
      var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
      this._segList.addPt(squareCapLOffset);
      this._segList.addPt(squareCapROffset);
      break;
  }
};
OffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates5() {
  var pts = this._segList.getCoordinates();
  return pts;
};
OffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin(p, offset0, offset1, distance11) {
  var isMitreWithinLimit = true;
  var intPt = null;
  try {
    intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
    var mitreRatio = distance11 <= 0 ? 1 : intPt.distance(p) / Math.abs(distance11);
    if (mitreRatio > this._bufParams.getMitreLimit()) {
      isMitreWithinLimit = false;
    }
  } catch (ex) {
    if (ex instanceof NotRepresentableException) {
      intPt = new Coordinate(0, 0);
      isMitreWithinLimit = false;
    } else {
      throw ex;
    }
  } finally {
  }
  if (isMitreWithinLimit) {
    this._segList.addPt(intPt);
  } else {
    this.addLimitedMitreJoin(offset0, offset1, distance11, this._bufParams.getMitreLimit());
  }
};
OffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner(p, p0, p1, direction, radius) {
  var dx0 = p0.x - p.x;
  var dy0 = p0.y - p.y;
  var startAngle = Math.atan2(dy0, dx0);
  var dx1 = p1.x - p.x;
  var dy1 = p1.y - p.y;
  var endAngle = Math.atan2(dy1, dx1);
  if (direction === CGAlgorithms.CLOCKWISE) {
    if (startAngle <= endAngle) {
      startAngle += 2 * Math.PI;
    }
  } else {
    if (startAngle >= endAngle) {
      startAngle -= 2 * Math.PI;
    }
  }
  this._segList.addPt(p0);
  this.addFilletArc(p, startAngle, endAngle, direction, radius);
  this._segList.addPt(p1);
};
OffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn(orientation2, addStartPoint) {
  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
    this._segList.addPt(this._offset0.p1);
    return null;
  }
  if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
    this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
  } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
    this.addBevelJoin(this._offset0, this._offset1);
  } else {
    if (addStartPoint) {
      this._segList.addPt(this._offset0.p1);
    }
    this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation2, this._distance);
    this._segList.addPt(this._offset1.p0);
  }
};
OffsetSegmentGenerator.prototype.createSquare = function createSquare(p) {
  this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
  this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
  this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
  this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
  this._segList.closeRing();
};
OffsetSegmentGenerator.prototype.addSegments = function addSegments(pt, isForward) {
  this._segList.addPts(pt, isForward);
};
OffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment() {
  this._segList.addPt(this._offset1.p0);
};
OffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment() {
  this._segList.addPt(this._offset1.p1);
};
OffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments(s1, s2, side) {
  this._s1 = s1;
  this._s2 = s2;
  this._side = side;
  this._seg1.setCoordinates(s1, s2);
  this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
};
OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin(offset0, offset1, distance11, mitreLimit) {
  var basePt = this._seg0.p1;
  var ang0 = Angle.angle(basePt, this._seg0.p0);
  var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
  var angDiffHalf = angDiff / 2;
  var midAng = Angle.normalize(ang0 + angDiffHalf);
  var mitreMidAng = Angle.normalize(midAng + Math.PI);
  var mitreDist = mitreLimit * distance11;
  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
  var bevelHalfLen = distance11 - bevelDelta;
  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
  var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
  var mitreMidLine = new LineSegment(basePt, bevelMidPt);
  var bevelEndLeft = mitreMidLine.pointAlongOffset(1, bevelHalfLen);
  var bevelEndRight = mitreMidLine.pointAlongOffset(1, -bevelHalfLen);
  if (this._side === Position.LEFT) {
    this._segList.addPt(bevelEndLeft);
    this._segList.addPt(bevelEndRight);
  } else {
    this._segList.addPt(bevelEndRight);
    this._segList.addPt(bevelEndLeft);
  }
};
OffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment(seg, side, distance11, offset) {
  var sideSign = side === Position.LEFT ? 1 : -1;
  var dx = seg.p1.x - seg.p0.x;
  var dy = seg.p1.y - seg.p0.y;
  var len2 = Math.sqrt(dx * dx + dy * dy);
  var ux = sideSign * distance11 * dx / len2;
  var uy = sideSign * distance11 * dy / len2;
  offset.p0.x = seg.p0.x - uy;
  offset.p0.y = seg.p0.y + ux;
  offset.p1.x = seg.p1.x - uy;
  offset.p1.y = seg.p1.y + ux;
};
OffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc(p, startAngle, endAngle, direction, radius) {
  var this$1$1 = this;
  var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
  var totalAngle = Math.abs(startAngle - endAngle);
  var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
  if (nSegs < 1) {
    return null;
  }
  var initAngle = 0;
  var currAngleInc = totalAngle / nSegs;
  var currAngle = initAngle;
  var pt = new Coordinate();
  while (currAngle < totalAngle) {
    var angle4 = startAngle + directionFactor * currAngle;
    pt.x = p.x + radius * Math.cos(angle4);
    pt.y = p.y + radius * Math.sin(angle4);
    this$1$1._segList.addPt(pt);
    currAngle += currAngleInc;
  }
};
OffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn(orientation2, addStartPoint) {
  this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
  if (this._li.hasIntersection()) {
    this._segList.addPt(this._li.getIntersection(0));
  } else {
    this._hasNarrowConcaveAngle = true;
    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
      this._segList.addPt(this._offset0.p1);
    } else {
      this._segList.addPt(this._offset0.p1);
      if (this._closingSegLengthFactor > 0) {
        var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
        this._segList.addPt(mid0);
        var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
        this._segList.addPt(mid1);
      } else {
        this._segList.addPt(this._s1);
      }
      this._segList.addPt(this._offset1.p0);
    }
  }
};
OffsetSegmentGenerator.prototype.createCircle = function createCircle(p) {
  var pt = new Coordinate(p.x + this._distance, p.y);
  this._segList.addPt(pt);
  this.addFilletArc(p, 0, 2 * Math.PI, -1, this._distance);
  this._segList.closeRing();
};
OffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin(offset0, offset1) {
  this._segList.addPt(offset0.p1);
  this._segList.addPt(offset1.p0);
};
OffsetSegmentGenerator.prototype.init = function init5(distance11) {
  this._distance = distance11;
  this._maxCurveSegmentError = distance11 * (1 - Math.cos(this._filletAngleQuantum / 2));
  this._segList = new OffsetSegmentString();
  this._segList.setPrecisionModel(this._precisionModel);
  this._segList.setMinimumVertexDistance(distance11 * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
};
OffsetSegmentGenerator.prototype.addCollinear = function addCollinear(addStartPoint) {
  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
  var numInt = this._li.getIntersectionNum();
  if (numInt >= 2) {
    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
      if (addStartPoint) {
        this._segList.addPt(this._offset0.p1);
      }
      this._segList.addPt(this._offset1.p0);
    } else {
      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
    }
  }
};
OffsetSegmentGenerator.prototype.closeRing = function closeRing2() {
  this._segList.closeRing();
};
OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle() {
  return this._hasNarrowConcaveAngle;
};
OffsetSegmentGenerator.prototype.interfaces_ = function interfaces_87() {
  return [];
};
OffsetSegmentGenerator.prototype.getClass = function getClass86() {
  return OffsetSegmentGenerator;
};
staticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
  return 1e-3;
};
staticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-3;
};
staticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-6;
};
staticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
  return 80;
};
Object.defineProperties(OffsetSegmentGenerator, staticAccessors$27);
var OffsetCurveBuilder = function OffsetCurveBuilder2() {
  this._distance = 0;
  this._precisionModel = null;
  this._bufParams = null;
  var precisionModel = arguments[0];
  var bufParams = arguments[1];
  this._precisionModel = precisionModel;
  this._bufParams = bufParams;
};
OffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve(inputPts, distance11) {
  this._distance = distance11;
  if (distance11 === 0) {
    return null;
  }
  var isRightSide = distance11 < 0;
  var posDistance = Math.abs(distance11);
  var segGen = this.getSegGen(posDistance);
  if (inputPts.length <= 1) {
    this.computePointCurve(inputPts[0], segGen);
  } else {
    this.computeOffsetCurve(inputPts, isRightSide, segGen);
  }
  var curvePts = segGen.getCoordinates();
  if (isRightSide) {
    CoordinateArrays.reverse(curvePts);
  }
  return curvePts;
};
OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  if (isRightSide) {
    segGen.addSegments(inputPts, true);
    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
    var n2 = simp2.length - 1;
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
  } else {
    segGen.addSegments(inputPts, false);
    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
    var n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i$1 = 2; i$1 <= n1; i$1++) {
      segGen.addNextSegment(simp1[i$1], true);
    }
  }
  segGen.addLastSegment();
  segGen.closeRing();
};
OffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve(inputPts, side, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  if (side === Position.RIGHT) {
    distTol = -distTol;
  }
  var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
  var n = simp.length - 1;
  segGen.initSideSegments(simp[n - 1], simp[0], side);
  for (var i = 1; i <= n; i++) {
    var addStartPoint = i !== 1;
    segGen.addNextSegment(simp[i], addStartPoint);
  }
  segGen.closeRing();
};
OffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve(inputPts, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
  var n1 = simp1.length - 1;
  segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
  for (var i = 2; i <= n1; i++) {
    segGen.addNextSegment(simp1[i], true);
  }
  segGen.addLastSegment();
  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
  var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
  var n2 = simp2.length - 1;
  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
  for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {
    segGen.addNextSegment(simp2[i$1], true);
  }
  segGen.addLastSegment();
  segGen.addLineEndCap(simp2[1], simp2[0]);
  segGen.closeRing();
};
OffsetCurveBuilder.prototype.computePointCurve = function computePointCurve(pt, segGen) {
  switch (this._bufParams.getEndCapStyle()) {
    case BufferParameters.CAP_ROUND:
      segGen.createCircle(pt);
      break;
    case BufferParameters.CAP_SQUARE:
      segGen.createSquare(pt);
      break;
  }
};
OffsetCurveBuilder.prototype.getLineCurve = function getLineCurve(inputPts, distance11) {
  this._distance = distance11;
  if (distance11 < 0 && !this._bufParams.isSingleSided()) {
    return null;
  }
  if (distance11 === 0) {
    return null;
  }
  var posDistance = Math.abs(distance11);
  var segGen = this.getSegGen(posDistance);
  if (inputPts.length <= 1) {
    this.computePointCurve(inputPts[0], segGen);
  } else {
    if (this._bufParams.isSingleSided()) {
      var isRightSide = distance11 < 0;
      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
    } else {
      this.computeLineBufferCurve(inputPts, segGen);
    }
  }
  var lineCoord = segGen.getCoordinates();
  return lineCoord;
};
OffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters() {
  return this._bufParams;
};
OffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance(bufDistance) {
  return bufDistance * this._bufParams.getSimplifyFactor();
};
OffsetCurveBuilder.prototype.getRingCurve = function getRingCurve(inputPts, side, distance11) {
  this._distance = distance11;
  if (inputPts.length <= 2) {
    return this.getLineCurve(inputPts, distance11);
  }
  if (distance11 === 0) {
    return OffsetCurveBuilder.copyCoordinates(inputPts);
  }
  var segGen = this.getSegGen(distance11);
  this.computeRingBufferCurve(inputPts, side, segGen);
  return segGen.getCoordinates();
};
OffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve(inputPts, isRightSide, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  if (isRightSide) {
    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
    var n2 = simp2.length - 1;
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
  } else {
    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
    var n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i$1 = 2; i$1 <= n1; i$1++) {
      segGen.addNextSegment(simp1[i$1], true);
    }
  }
  segGen.addLastSegment();
};
OffsetCurveBuilder.prototype.getSegGen = function getSegGen(distance11) {
  return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance11);
};
OffsetCurveBuilder.prototype.interfaces_ = function interfaces_88() {
  return [];
};
OffsetCurveBuilder.prototype.getClass = function getClass87() {
  return OffsetCurveBuilder;
};
OffsetCurveBuilder.copyCoordinates = function copyCoordinates(pts) {
  var copy8 = new Array(pts.length).fill(null);
  for (var i = 0; i < copy8.length; i++) {
    copy8[i] = new Coordinate(pts[i]);
  }
  return copy8;
};
var SubgraphDepthLocater = function SubgraphDepthLocater2() {
  this._subgraphs = null;
  this._seg = new LineSegment();
  this._cga = new CGAlgorithms();
  var subgraphs = arguments[0];
  this._subgraphs = subgraphs;
};
var staticAccessors$30 = { DepthSegment: { configurable: true } };
SubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments() {
  var this$1$1 = this;
  if (arguments.length === 1) {
    var stabbingRayLeftPt = arguments[0];
    var stabbedSegments = new ArrayList();
    for (var i = this._subgraphs.iterator(); i.hasNext(); ) {
      var bsg = i.next();
      var env2 = bsg.getEnvelope();
      if (stabbingRayLeftPt.y < env2.getMinY() || stabbingRayLeftPt.y > env2.getMaxY()) {
        continue;
      }
      this$1$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
    }
    return stabbedSegments;
  } else if (arguments.length === 3) {
    if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
      var stabbingRayLeftPt$1 = arguments[0];
      var dirEdge = arguments[1];
      var stabbedSegments$1 = arguments[2];
      var pts = dirEdge.getEdge().getCoordinates();
      for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {
        this$1$1._seg.p0 = pts[i$1];
        this$1$1._seg.p1 = pts[i$1 + 1];
        if (this$1$1._seg.p0.y > this$1$1._seg.p1.y) {
          this$1$1._seg.reverse();
        }
        var maxx = Math.max(this$1$1._seg.p0.x, this$1$1._seg.p1.x);
        if (maxx < stabbingRayLeftPt$1.x) {
          continue;
        }
        if (this$1$1._seg.isHorizontal()) {
          continue;
        }
        if (stabbingRayLeftPt$1.y < this$1$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1$1._seg.p1.y) {
          continue;
        }
        if (CGAlgorithms.computeOrientation(this$1$1._seg.p0, this$1$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) {
          continue;
        }
        var depth2 = dirEdge.getDepth(Position.LEFT);
        if (!this$1$1._seg.p0.equals(pts[i$1])) {
          depth2 = dirEdge.getDepth(Position.RIGHT);
        }
        var ds = new DepthSegment(this$1$1._seg, depth2);
        stabbedSegments$1.add(ds);
      }
    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
      var stabbingRayLeftPt$2 = arguments[0];
      var dirEdges = arguments[1];
      var stabbedSegments$2 = arguments[2];
      for (var i$2 = dirEdges.iterator(); i$2.hasNext(); ) {
        var de = i$2.next();
        if (!de.isForward()) {
          continue;
        }
        this$1$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);
      }
    }
  }
};
SubgraphDepthLocater.prototype.getDepth = function getDepth(p) {
  var stabbedSegments = this.findStabbedSegments(p);
  if (stabbedSegments.size() === 0) {
    return 0;
  }
  var ds = Collections.min(stabbedSegments);
  return ds._leftDepth;
};
SubgraphDepthLocater.prototype.interfaces_ = function interfaces_89() {
  return [];
};
SubgraphDepthLocater.prototype.getClass = function getClass88() {
  return SubgraphDepthLocater;
};
staticAccessors$30.DepthSegment.get = function() {
  return DepthSegment;
};
Object.defineProperties(SubgraphDepthLocater, staticAccessors$30);
var DepthSegment = function DepthSegment2() {
  this._upwardSeg = null;
  this._leftDepth = null;
  var seg = arguments[0];
  var depth2 = arguments[1];
  this._upwardSeg = new LineSegment(seg);
  this._leftDepth = depth2;
};
DepthSegment.prototype.compareTo = function compareTo12(obj) {
  var other = obj;
  if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) {
    return 1;
  }
  if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) {
    return -1;
  }
  var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
  if (orientIndex !== 0) {
    return orientIndex;
  }
  orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
  if (orientIndex !== 0) {
    return orientIndex;
  }
  return this._upwardSeg.compareTo(other._upwardSeg);
};
DepthSegment.prototype.compareX = function compareX2(seg0, seg1) {
  var compare0 = seg0.p0.compareTo(seg1.p0);
  if (compare0 !== 0) {
    return compare0;
  }
  return seg0.p1.compareTo(seg1.p1);
};
DepthSegment.prototype.toString = function toString17() {
  return this._upwardSeg.toString();
};
DepthSegment.prototype.interfaces_ = function interfaces_90() {
  return [Comparable];
};
DepthSegment.prototype.getClass = function getClass89() {
  return DepthSegment;
};
var Triangle$1 = function Triangle(p0, p1, p2) {
  this.p0 = p0 || null;
  this.p1 = p1 || null;
  this.p2 = p2 || null;
};
Triangle$1.prototype.area = function area3() {
  return Triangle$1.area(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.signedArea = function signedArea3() {
  return Triangle$1.signedArea(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.interpolateZ = function interpolateZ(p) {
  if (p === null) {
    throw new IllegalArgumentException("Supplied point is null.");
  }
  return Triangle$1.interpolateZ(p, this.p0, this.p1, this.p2);
};
Triangle$1.prototype.longestSideLength = function longestSideLength() {
  return Triangle$1.longestSideLength(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.isAcute = function isAcute2() {
  return Triangle$1.isAcute(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.circumcentre = function circumcentre() {
  return Triangle$1.circumcentre(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.area3D = function area3D() {
  return Triangle$1.area3D(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.centroid = function centroid() {
  return Triangle$1.centroid(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.inCentre = function inCentre() {
  return Triangle$1.inCentre(this.p0, this.p1, this.p2);
};
Triangle$1.prototype.interfaces_ = function interfaces_91() {
  return [];
};
Triangle$1.prototype.getClass = function getClass90() {
  return Triangle$1;
};
Triangle$1.area = function area4(a, b, c) {
  return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
};
Triangle$1.signedArea = function signedArea4(a, b, c) {
  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
};
Triangle$1.det = function det(m00, m01, m10, m11) {
  return m00 * m11 - m01 * m10;
};
Triangle$1.interpolateZ = function interpolateZ2(p, v0, v12, v22) {
  var x02 = v0.x;
  var y02 = v0.y;
  var a = v12.x - x02;
  var b = v22.x - x02;
  var c = v12.y - y02;
  var d = v22.y - y02;
  var det2 = a * d - b * c;
  var dx = p.x - x02;
  var dy = p.y - y02;
  var t = (d * dx - b * dy) / det2;
  var u = (-c * dx + a * dy) / det2;
  var z = v0.z + t * (v12.z - v0.z) + u * (v22.z - v0.z);
  return z;
};
Triangle$1.longestSideLength = function longestSideLength2(a, b, c) {
  var lenAB = a.distance(b);
  var lenBC = b.distance(c);
  var lenCA = c.distance(a);
  var maxLen = lenAB;
  if (lenBC > maxLen) {
    maxLen = lenBC;
  }
  if (lenCA > maxLen) {
    maxLen = lenCA;
  }
  return maxLen;
};
Triangle$1.isAcute = function isAcute3(a, b, c) {
  if (!Angle.isAcute(a, b, c)) {
    return false;
  }
  if (!Angle.isAcute(b, c, a)) {
    return false;
  }
  if (!Angle.isAcute(c, a, b)) {
    return false;
  }
  return true;
};
Triangle$1.circumcentre = function circumcentre2(a, b, c) {
  var cx = c.x;
  var cy = c.y;
  var ax = a.x - cx;
  var ay = a.y - cy;
  var bx = b.x - cx;
  var by = b.y - cy;
  var denom = 2 * Triangle$1.det(ax, ay, bx, by);
  var numx = Triangle$1.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
  var numy = Triangle$1.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
  var ccx = cx - numx / denom;
  var ccy = cy + numy / denom;
  return new Coordinate(ccx, ccy);
};
Triangle$1.perpendicularBisector = function perpendicularBisector(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var l1 = new HCoordinate(a.x + dx / 2, a.y + dy / 2, 1);
  var l2 = new HCoordinate(a.x - dy + dx / 2, a.y + dx + dy / 2, 1);
  return new HCoordinate(l1, l2);
};
Triangle$1.angleBisector = function angleBisector(a, b, c) {
  var len0 = b.distance(a);
  var len2 = b.distance(c);
  var frac = len0 / (len0 + len2);
  var dx = c.x - a.x;
  var dy = c.y - a.y;
  var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
  return splitPt;
};
Triangle$1.area3D = function area3D2(a, b, c) {
  var ux = b.x - a.x;
  var uy = b.y - a.y;
  var uz = b.z - a.z;
  var vx = c.x - a.x;
  var vy = c.y - a.y;
  var vz = c.z - a.z;
  var crossx = uy * vz - uz * vy;
  var crossy = uz * vx - ux * vz;
  var crossz = ux * vy - uy * vx;
  var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
  var area3D3 = Math.sqrt(absSq) / 2;
  return area3D3;
};
Triangle$1.centroid = function centroid2(a, b, c) {
  var x2 = (a.x + b.x + c.x) / 3;
  var y2 = (a.y + b.y + c.y) / 3;
  return new Coordinate(x2, y2);
};
Triangle$1.inCentre = function inCentre2(a, b, c) {
  var len0 = b.distance(c);
  var len1 = a.distance(c);
  var len2 = a.distance(b);
  var circum = len0 + len1 + len2;
  var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
  var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
  return new Coordinate(inCentreX, inCentreY);
};
var OffsetCurveSetBuilder = function OffsetCurveSetBuilder2() {
  this._inputGeom = null;
  this._distance = null;
  this._curveBuilder = null;
  this._curveList = new ArrayList();
  var inputGeom = arguments[0];
  var distance11 = arguments[1];
  var curveBuilder = arguments[2];
  this._inputGeom = inputGeom;
  this._distance = distance11;
  this._curveBuilder = curveBuilder;
};
OffsetCurveSetBuilder.prototype.addPoint = function addPoint(p) {
  if (this._distance <= 0) {
    return null;
  }
  var coord = p.getCoordinates();
  var curve = this._curveBuilder.getLineCurve(coord, this._distance);
  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
};
OffsetCurveSetBuilder.prototype.addPolygon = function addPolygon(p) {
  var this$1$1 = this;
  var offsetDistance = this._distance;
  var offsetSide = Position.LEFT;
  if (this._distance < 0) {
    offsetDistance = -this._distance;
    offsetSide = Position.RIGHT;
  }
  var shell = p.getExteriorRing();
  var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
  if (this._distance < 0 && this.isErodedCompletely(shell, this._distance)) {
    return null;
  }
  if (this._distance <= 0 && shellCoord.length < 3) {
    return null;
  }
  this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
  for (var i = 0; i < p.getNumInteriorRing(); i++) {
    var hole = p.getInteriorRingN(i);
    var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
    if (this$1$1._distance > 0 && this$1$1.isErodedCompletely(hole, -this$1$1._distance)) {
      continue;
    }
    this$1$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
  }
};
OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely(triangleCoord, bufferDistance) {
  var tri = new Triangle$1(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
  var inCentre3 = tri.inCentre();
  var distToCentre = CGAlgorithms.distancePointLine(inCentre3, tri.p0, tri.p1);
  return distToCentre < Math.abs(bufferDistance);
};
OffsetCurveSetBuilder.prototype.addLineString = function addLineString(line) {
  if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) {
    return null;
  }
  var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
  var curve = this._curveBuilder.getLineCurve(coord, this._distance);
  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
};
OffsetCurveSetBuilder.prototype.addCurve = function addCurve(coord, leftLoc, rightLoc) {
  if (coord === null || coord.length < 2) {
    return null;
  }
  var e2 = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
  this._curveList.add(e2);
};
OffsetCurveSetBuilder.prototype.getCurves = function getCurves() {
  this.add(this._inputGeom);
  return this._curveList;
};
OffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
  if (offsetDistance === 0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) {
    return null;
  }
  var leftLoc = cwLeftLoc;
  var rightLoc = cwRightLoc;
  if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
    leftLoc = cwRightLoc;
    rightLoc = cwLeftLoc;
    side = Position.opposite(side);
  }
  var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
  this.addCurve(curve, leftLoc, rightLoc);
};
OffsetCurveSetBuilder.prototype.add = function add9(g) {
  if (g.isEmpty()) {
    return null;
  }
  if (g instanceof Polygon$2) {
    this.addPolygon(g);
  } else if (g instanceof LineString) {
    this.addLineString(g);
  } else if (g instanceof Point$2) {
    this.addPoint(g);
  } else if (g instanceof MultiPoint) {
    this.addCollection(g);
  } else if (g instanceof MultiLineString) {
    this.addCollection(g);
  } else if (g instanceof MultiPolygon) {
    this.addCollection(g);
  } else if (g instanceof GeometryCollection) {
    this.addCollection(g);
  }
};
OffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely(ring, bufferDistance) {
  var ringCoord = ring.getCoordinates();
  if (ringCoord.length < 4) {
    return bufferDistance < 0;
  }
  if (ringCoord.length === 4) {
    return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
  }
  var env2 = ring.getEnvelopeInternal();
  var envMinDimension = Math.min(env2.getHeight(), env2.getWidth());
  if (bufferDistance < 0 && 2 * Math.abs(bufferDistance) > envMinDimension) {
    return true;
  }
  return false;
};
OffsetCurveSetBuilder.prototype.addCollection = function addCollection(gc) {
  var this$1$1 = this;
  for (var i = 0; i < gc.getNumGeometries(); i++) {
    var g = gc.getGeometryN(i);
    this$1$1.add(g);
  }
};
OffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_92() {
  return [];
};
OffsetCurveSetBuilder.prototype.getClass = function getClass91() {
  return OffsetCurveSetBuilder;
};
var PointOnGeometryLocator = function PointOnGeometryLocator2() {
};
PointOnGeometryLocator.prototype.locate = function locate(p) {
};
PointOnGeometryLocator.prototype.interfaces_ = function interfaces_93() {
  return [];
};
PointOnGeometryLocator.prototype.getClass = function getClass92() {
  return PointOnGeometryLocator;
};
var GeometryCollectionIterator = function GeometryCollectionIterator2() {
  this._parent = null;
  this._atStart = null;
  this._max = null;
  this._index = null;
  this._subcollectionIterator = null;
  var parent = arguments[0];
  this._parent = parent;
  this._atStart = true;
  this._index = 0;
  this._max = parent.getNumGeometries();
};
GeometryCollectionIterator.prototype.next = function next2() {
  if (this._atStart) {
    this._atStart = false;
    if (GeometryCollectionIterator.isAtomic(this._parent)) {
      this._index++;
    }
    return this._parent;
  }
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext()) {
      return this._subcollectionIterator.next();
    } else {
      this._subcollectionIterator = null;
    }
  }
  if (this._index >= this._max) {
    throw new NoSuchElementException();
  }
  var obj = this._parent.getGeometryN(this._index++);
  if (obj instanceof GeometryCollection) {
    this._subcollectionIterator = new GeometryCollectionIterator(obj);
    return this._subcollectionIterator.next();
  }
  return obj;
};
GeometryCollectionIterator.prototype.remove = function remove5() {
  throw new Error(this.getClass().getName());
};
GeometryCollectionIterator.prototype.hasNext = function hasNext2() {
  if (this._atStart) {
    return true;
  }
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext()) {
      return true;
    }
    this._subcollectionIterator = null;
  }
  if (this._index >= this._max) {
    return false;
  }
  return true;
};
GeometryCollectionIterator.prototype.interfaces_ = function interfaces_94() {
  return [Iterator];
};
GeometryCollectionIterator.prototype.getClass = function getClass93() {
  return GeometryCollectionIterator;
};
GeometryCollectionIterator.isAtomic = function isAtomic(geom) {
  return !(geom instanceof GeometryCollection);
};
var SimplePointInAreaLocator = function SimplePointInAreaLocator2() {
  this._geom = null;
  var geom = arguments[0];
  this._geom = geom;
};
SimplePointInAreaLocator.prototype.locate = function locate2(p) {
  return SimplePointInAreaLocator.locate(p, this._geom);
};
SimplePointInAreaLocator.prototype.interfaces_ = function interfaces_95() {
  return [PointOnGeometryLocator];
};
SimplePointInAreaLocator.prototype.getClass = function getClass94() {
  return SimplePointInAreaLocator;
};
SimplePointInAreaLocator.isPointInRing = function isPointInRing2(p, ring) {
  if (!ring.getEnvelopeInternal().intersects(p)) {
    return false;
  }
  return CGAlgorithms.isPointInRing(p, ring.getCoordinates());
};
SimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon(p, poly) {
  if (poly.isEmpty()) {
    return false;
  }
  var shell = poly.getExteriorRing();
  if (!SimplePointInAreaLocator.isPointInRing(p, shell)) {
    return false;
  }
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    var hole = poly.getInteriorRingN(i);
    if (SimplePointInAreaLocator.isPointInRing(p, hole)) {
      return false;
    }
  }
  return true;
};
SimplePointInAreaLocator.containsPoint = function containsPoint3(p, geom) {
  if (geom instanceof Polygon$2) {
    return SimplePointInAreaLocator.containsPointInPolygon(p, geom);
  } else if (geom instanceof GeometryCollection) {
    var geomi = new GeometryCollectionIterator(geom);
    while (geomi.hasNext()) {
      var g2 = geomi.next();
      if (g2 !== geom) {
        if (SimplePointInAreaLocator.containsPoint(p, g2)) {
          return true;
        }
      }
    }
  }
  return false;
};
SimplePointInAreaLocator.locate = function locate3(p, geom) {
  if (geom.isEmpty()) {
    return Location.EXTERIOR;
  }
  if (SimplePointInAreaLocator.containsPoint(p, geom)) {
    return Location.INTERIOR;
  }
  return Location.EXTERIOR;
};
var EdgeEndStar = function EdgeEndStar2() {
  this._edgeMap = new TreeMap();
  this._edgeList = null;
  this._ptInAreaLocation = [Location.NONE, Location.NONE];
};
EdgeEndStar.prototype.getNextCW = function getNextCW(ee) {
  this.getEdges();
  var i = this._edgeList.indexOf(ee);
  var iNextCW = i - 1;
  if (i === 0) {
    iNextCW = this._edgeList.size() - 1;
  }
  return this._edgeList.get(iNextCW);
};
EdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels(geomIndex) {
  var startLoc = Location.NONE;
  for (var it = this.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    var label = e2.getLabel();
    if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) {
      startLoc = label.getLocation(geomIndex, Position.LEFT);
    }
  }
  if (startLoc === Location.NONE) {
    return null;
  }
  var currLoc = startLoc;
  for (var it$1 = this.iterator(); it$1.hasNext(); ) {
    var e$1 = it$1.next();
    var label$1 = e$1.getLabel();
    if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) {
      label$1.setLocation(geomIndex, Position.ON, currLoc);
    }
    if (label$1.isArea(geomIndex)) {
      var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);
      var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);
      if (rightLoc !== Location.NONE) {
        if (rightLoc !== currLoc) {
          throw new TopologyException("side location conflict", e$1.getCoordinate());
        }
        if (leftLoc === Location.NONE) {
          Assert.shouldNeverReachHere("found single null side (at " + e$1.getCoordinate() + ")");
        }
        currLoc = leftLoc;
      } else {
        Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, "found single null side");
        label$1.setLocation(geomIndex, Position.RIGHT, currLoc);
        label$1.setLocation(geomIndex, Position.LEFT, currLoc);
      }
    }
  }
};
EdgeEndStar.prototype.getCoordinate = function getCoordinate11() {
  var it = this.iterator();
  if (!it.hasNext()) {
    return null;
  }
  var e2 = it.next();
  return e2.getCoordinate();
};
EdgeEndStar.prototype.print = function print5(out2) {
  System.out.println("EdgeEndStar:   " + this.getCoordinate());
  for (var it = this.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    e2.print(out2);
  }
};
EdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent(geomGraph) {
  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
  return this.checkAreaLabelsConsistent(0);
};
EdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent(geomIndex) {
  var edges2 = this.getEdges();
  if (edges2.size() <= 0) {
    return true;
  }
  var lastEdgeIndex = edges2.size() - 1;
  var startLabel = edges2.get(lastEdgeIndex).getLabel();
  var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
  Assert.isTrue(startLoc !== Location.NONE, "Found unlabelled area edge");
  var currLoc = startLoc;
  for (var it = this.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    var label = e2.getLabel();
    Assert.isTrue(label.isArea(geomIndex), "Found non-area edge");
    var leftLoc = label.getLocation(geomIndex, Position.LEFT);
    var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
    if (leftLoc === rightLoc) {
      return false;
    }
    if (rightLoc !== currLoc) {
      return false;
    }
    currLoc = leftLoc;
  }
  return true;
};
EdgeEndStar.prototype.findIndex = function findIndex(eSearch) {
  var this$1$1 = this;
  this.iterator();
  for (var i = 0; i < this._edgeList.size(); i++) {
    var e2 = this$1$1._edgeList.get(i);
    if (e2 === eSearch) {
      return i;
    }
  }
  return -1;
};
EdgeEndStar.prototype.iterator = function iterator4() {
  return this.getEdges().iterator();
};
EdgeEndStar.prototype.getEdges = function getEdges2() {
  if (this._edgeList === null) {
    this._edgeList = new ArrayList(this._edgeMap.values());
  }
  return this._edgeList;
};
EdgeEndStar.prototype.getLocation = function getLocation3(geomIndex, p, geom) {
  if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
    this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
  }
  return this._ptInAreaLocation[geomIndex];
};
EdgeEndStar.prototype.toString = function toString18() {
  var buf = new StringBuffer();
  buf.append("EdgeEndStar:   " + this.getCoordinate());
  buf.append("\n");
  for (var it = this.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    buf.append(e2);
    buf.append("\n");
  }
  return buf.toString();
};
EdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels(boundaryNodeRule) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var ee = it.next();
    ee.computeLabel(boundaryNodeRule);
  }
};
EdgeEndStar.prototype.computeLabelling = function computeLabelling(geomGraph) {
  var this$1$1 = this;
  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
  this.propagateSideLabels(0);
  this.propagateSideLabels(1);
  var hasDimensionalCollapseEdge = [false, false];
  for (var it = this.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    var label = e2.getLabel();
    for (var geomi = 0; geomi < 2; geomi++) {
      if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) {
        hasDimensionalCollapseEdge[geomi] = true;
      }
    }
  }
  for (var it$1 = this.iterator(); it$1.hasNext(); ) {
    var e$1 = it$1.next();
    var label$1 = e$1.getLabel();
    for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {
      if (label$1.isAnyNull(geomi$1)) {
        var loc = Location.NONE;
        if (hasDimensionalCollapseEdge[geomi$1]) {
          loc = Location.EXTERIOR;
        } else {
          var p = e$1.getCoordinate();
          loc = this$1$1.getLocation(geomi$1, p, geomGraph);
        }
        label$1.setAllLocationsIfNull(geomi$1, loc);
      }
    }
  }
};
EdgeEndStar.prototype.getDegree = function getDegree() {
  return this._edgeMap.size();
};
EdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd(e2, obj) {
  this._edgeMap.put(e2, obj);
  this._edgeList = null;
};
EdgeEndStar.prototype.interfaces_ = function interfaces_96() {
  return [];
};
EdgeEndStar.prototype.getClass = function getClass95() {
  return EdgeEndStar;
};
var DirectedEdgeStar = function(EdgeEndStar$$1) {
  function DirectedEdgeStar2() {
    EdgeEndStar$$1.call(this);
    this._resultAreaEdgeList = null;
    this._label = null;
    this._SCANNING_FOR_INCOMING = 1;
    this._LINKING_TO_OUTGOING = 2;
  }
  if (EdgeEndStar$$1)
    DirectedEdgeStar2.__proto__ = EdgeEndStar$$1;
  DirectedEdgeStar2.prototype = Object.create(EdgeEndStar$$1 && EdgeEndStar$$1.prototype);
  DirectedEdgeStar2.prototype.constructor = DirectedEdgeStar2;
  DirectedEdgeStar2.prototype.linkResultDirectedEdges = function linkResultDirectedEdges3() {
    var this$1$1 = this;
    this.getResultAreaEdges();
    var firstOut = null;
    var incoming = null;
    var state = this._SCANNING_FOR_INCOMING;
    for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
      var nextOut = this$1$1._resultAreaEdgeList.get(i);
      var nextIn = nextOut.getSym();
      if (!nextOut.getLabel().isArea()) {
        continue;
      }
      if (firstOut === null && nextOut.isInResult()) {
        firstOut = nextOut;
      }
      switch (state) {
        case this$1$1._SCANNING_FOR_INCOMING:
          if (!nextIn.isInResult()) {
            continue;
          }
          incoming = nextIn;
          state = this$1$1._LINKING_TO_OUTGOING;
          break;
        case this$1$1._LINKING_TO_OUTGOING:
          if (!nextOut.isInResult()) {
            continue;
          }
          incoming.setNext(nextOut);
          state = this$1$1._SCANNING_FOR_INCOMING;
          break;
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      if (firstOut === null) {
        throw new TopologyException("no outgoing dirEdge found", this.getCoordinate());
      }
      Assert.isTrue(firstOut.isInResult(), "unable to link last incoming dirEdge");
      incoming.setNext(firstOut);
    }
  };
  DirectedEdgeStar2.prototype.insert = function insert5(ee) {
    var de = ee;
    this.insertEdgeEnd(de, de);
  };
  DirectedEdgeStar2.prototype.getRightmostEdge = function getRightmostEdge() {
    var edges2 = this.getEdges();
    var size11 = edges2.size();
    if (size11 < 1) {
      return null;
    }
    var de0 = edges2.get(0);
    if (size11 === 1) {
      return de0;
    }
    var deLast = edges2.get(size11 - 1);
    var quad0 = de0.getQuadrant();
    var quad1 = deLast.getQuadrant();
    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {
      return de0;
    } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {
      return deLast;
    } else {
      if (de0.getDy() !== 0) {
        return de0;
      } else if (deLast.getDy() !== 0) {
        return deLast;
      }
    }
    Assert.shouldNeverReachHere("found two horizontal edges incident on node");
    return null;
  };
  DirectedEdgeStar2.prototype.print = function print9(out2) {
    System.out.println("DirectedEdgeStar: " + this.getCoordinate());
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      out2.print("out ");
      de.print(out2);
      out2.println();
      out2.print("in ");
      de.getSym().print(out2);
      out2.println();
    }
  };
  DirectedEdgeStar2.prototype.getResultAreaEdges = function getResultAreaEdges() {
    var this$1$1 = this;
    if (this._resultAreaEdgeList !== null) {
      return this._resultAreaEdgeList;
    }
    this._resultAreaEdgeList = new ArrayList();
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      if (de.isInResult() || de.getSym().isInResult()) {
        this$1$1._resultAreaEdgeList.add(de);
      }
    }
    return this._resultAreaEdgeList;
  };
  DirectedEdgeStar2.prototype.updateLabelling = function updateLabelling(nodeLabel) {
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      var label = de.getLabel();
      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
    }
  };
  DirectedEdgeStar2.prototype.linkAllDirectedEdges = function linkAllDirectedEdges2() {
    var this$1$1 = this;
    this.getEdges();
    var prevOut = null;
    var firstIn = null;
    for (var i = this._edgeList.size() - 1; i >= 0; i--) {
      var nextOut = this$1$1._edgeList.get(i);
      var nextIn = nextOut.getSym();
      if (firstIn === null) {
        firstIn = nextIn;
      }
      if (prevOut !== null) {
        nextIn.setNext(prevOut);
      }
      prevOut = nextOut;
    }
    firstIn.setNext(prevOut);
  };
  DirectedEdgeStar2.prototype.computeDepths = function computeDepths2() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var de = arguments[0];
      var edgeIndex = this.findIndex(de);
      var startDepth = de.getDepth(Position.LEFT);
      var targetLastDepth = de.getDepth(Position.RIGHT);
      var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
      var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
      if (lastDepth !== targetLastDepth) {
        throw new TopologyException("depth mismatch at " + de.getCoordinate());
      }
    } else if (arguments.length === 3) {
      var startIndex = arguments[0];
      var endIndex = arguments[1];
      var startDepth$1 = arguments[2];
      var currDepth = startDepth$1;
      for (var i = startIndex; i < endIndex; i++) {
        var nextDe = this$1$1._edgeList.get(i);
        nextDe.setEdgeDepths(Position.RIGHT, currDepth);
        currDepth = nextDe.getDepth(Position.LEFT);
      }
      return currDepth;
    }
  };
  DirectedEdgeStar2.prototype.mergeSymLabels = function mergeSymLabels() {
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      var label = de.getLabel();
      label.merge(de.getSym().getLabel());
    }
  };
  DirectedEdgeStar2.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges(er) {
    var this$1$1 = this;
    var firstOut = null;
    var incoming = null;
    var state = this._SCANNING_FOR_INCOMING;
    for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
      var nextOut = this$1$1._resultAreaEdgeList.get(i);
      var nextIn = nextOut.getSym();
      if (firstOut === null && nextOut.getEdgeRing() === er) {
        firstOut = nextOut;
      }
      switch (state) {
        case this$1$1._SCANNING_FOR_INCOMING:
          if (nextIn.getEdgeRing() !== er) {
            continue;
          }
          incoming = nextIn;
          state = this$1$1._LINKING_TO_OUTGOING;
          break;
        case this$1$1._LINKING_TO_OUTGOING:
          if (nextOut.getEdgeRing() !== er) {
            continue;
          }
          incoming.setNextMin(nextOut);
          state = this$1$1._SCANNING_FOR_INCOMING;
          break;
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      Assert.isTrue(firstOut !== null, "found null for first outgoing dirEdge");
      Assert.isTrue(firstOut.getEdgeRing() === er, "unable to link last incoming dirEdge");
      incoming.setNextMin(firstOut);
    }
  };
  DirectedEdgeStar2.prototype.getOutgoingDegree = function getOutgoingDegree() {
    if (arguments.length === 0) {
      var degree2 = 0;
      for (var it = this.iterator(); it.hasNext(); ) {
        var de = it.next();
        if (de.isInResult()) {
          degree2++;
        }
      }
      return degree2;
    } else if (arguments.length === 1) {
      var er = arguments[0];
      var degree$1 = 0;
      for (var it$1 = this.iterator(); it$1.hasNext(); ) {
        var de$1 = it$1.next();
        if (de$1.getEdgeRing() === er) {
          degree$1++;
        }
      }
      return degree$1;
    }
  };
  DirectedEdgeStar2.prototype.getLabel = function getLabel4() {
    return this._label;
  };
  DirectedEdgeStar2.prototype.findCoveredLineEdges = function findCoveredLineEdges2() {
    var startLoc = Location.NONE;
    for (var it = this.iterator(); it.hasNext(); ) {
      var nextOut = it.next();
      var nextIn = nextOut.getSym();
      if (!nextOut.isLineEdge()) {
        if (nextOut.isInResult()) {
          startLoc = Location.INTERIOR;
          break;
        }
        if (nextIn.isInResult()) {
          startLoc = Location.EXTERIOR;
          break;
        }
      }
    }
    if (startLoc === Location.NONE) {
      return null;
    }
    var currLoc = startLoc;
    for (var it$1 = this.iterator(); it$1.hasNext(); ) {
      var nextOut$1 = it$1.next();
      var nextIn$1 = nextOut$1.getSym();
      if (nextOut$1.isLineEdge()) {
        nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);
      } else {
        if (nextOut$1.isInResult()) {
          currLoc = Location.EXTERIOR;
        }
        if (nextIn$1.isInResult()) {
          currLoc = Location.INTERIOR;
        }
      }
    }
  };
  DirectedEdgeStar2.prototype.computeLabelling = function computeLabelling2(geom) {
    var this$1$1 = this;
    EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);
    this._label = new Label(Location.NONE);
    for (var it = this.iterator(); it.hasNext(); ) {
      var ee = it.next();
      var e2 = ee.getEdge();
      var eLabel = e2.getLabel();
      for (var i = 0; i < 2; i++) {
        var eLoc = eLabel.getLocation(i);
        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) {
          this$1$1._label.setLocation(i, Location.INTERIOR);
        }
      }
    }
  };
  DirectedEdgeStar2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  DirectedEdgeStar2.prototype.getClass = function getClass169() {
    return DirectedEdgeStar2;
  };
  return DirectedEdgeStar2;
}(EdgeEndStar);
var OverlayNodeFactory = function(NodeFactory$$1) {
  function OverlayNodeFactory2() {
    NodeFactory$$1.apply(this, arguments);
  }
  if (NodeFactory$$1)
    OverlayNodeFactory2.__proto__ = NodeFactory$$1;
  OverlayNodeFactory2.prototype = Object.create(NodeFactory$$1 && NodeFactory$$1.prototype);
  OverlayNodeFactory2.prototype.constructor = OverlayNodeFactory2;
  OverlayNodeFactory2.prototype.createNode = function createNode3(coord) {
    return new Node(coord, new DirectedEdgeStar());
  };
  OverlayNodeFactory2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  OverlayNodeFactory2.prototype.getClass = function getClass169() {
    return OverlayNodeFactory2;
  };
  return OverlayNodeFactory2;
}(NodeFactory);
var OrientedCoordinateArray = function OrientedCoordinateArray2() {
  this._pts = null;
  this._orientation = null;
  var pts = arguments[0];
  this._pts = pts;
  this._orientation = OrientedCoordinateArray2.orientation(pts);
};
OrientedCoordinateArray.prototype.compareTo = function compareTo13(o1) {
  var oca = o1;
  var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
  return comp;
};
OrientedCoordinateArray.prototype.interfaces_ = function interfaces_97() {
  return [Comparable];
};
OrientedCoordinateArray.prototype.getClass = function getClass96() {
  return OrientedCoordinateArray;
};
OrientedCoordinateArray.orientation = function orientation(pts) {
  return CoordinateArrays.increasingDirection(pts) === 1;
};
OrientedCoordinateArray.compareOriented = function compareOriented(pts1, orientation1, pts2, orientation2) {
  var dir1 = orientation1 ? 1 : -1;
  var dir22 = orientation2 ? 1 : -1;
  var limit1 = orientation1 ? pts1.length : -1;
  var limit2 = orientation2 ? pts2.length : -1;
  var i1 = orientation1 ? 0 : pts1.length - 1;
  var i2 = orientation2 ? 0 : pts2.length - 1;
  while (true) {
    var compPt = pts1[i1].compareTo(pts2[i2]);
    if (compPt !== 0) {
      return compPt;
    }
    i1 += dir1;
    i2 += dir22;
    var done1 = i1 === limit1;
    var done2 = i2 === limit2;
    if (done1 && !done2) {
      return -1;
    }
    if (!done1 && done2) {
      return 1;
    }
    if (done1 && done2) {
      return 0;
    }
  }
};
var EdgeList = function EdgeList2() {
  this._edges = new ArrayList();
  this._ocaMap = new TreeMap();
};
EdgeList.prototype.print = function print6(out2) {
  var this$1$1 = this;
  out2.print("MULTILINESTRING ( ");
  for (var j = 0; j < this._edges.size(); j++) {
    var e2 = this$1$1._edges.get(j);
    if (j > 0) {
      out2.print(",");
    }
    out2.print("(");
    var pts = e2.getCoordinates();
    for (var i = 0; i < pts.length; i++) {
      if (i > 0) {
        out2.print(",");
      }
      out2.print(pts[i].x + " " + pts[i].y);
    }
    out2.println(")");
  }
  out2.print(")  ");
};
EdgeList.prototype.addAll = function addAll2(edgeColl) {
  var this$1$1 = this;
  for (var i = edgeColl.iterator(); i.hasNext(); ) {
    this$1$1.add(i.next());
  }
};
EdgeList.prototype.findEdgeIndex = function findEdgeIndex(e2) {
  var this$1$1 = this;
  for (var i = 0; i < this._edges.size(); i++) {
    if (this$1$1._edges.get(i).equals(e2)) {
      return i;
    }
  }
  return -1;
};
EdgeList.prototype.iterator = function iterator5() {
  return this._edges.iterator();
};
EdgeList.prototype.getEdges = function getEdges3() {
  return this._edges;
};
EdgeList.prototype.get = function get3(i) {
  return this._edges.get(i);
};
EdgeList.prototype.findEqualEdge = function findEqualEdge(e2) {
  var oca = new OrientedCoordinateArray(e2.getCoordinates());
  var matchEdge = this._ocaMap.get(oca);
  return matchEdge;
};
EdgeList.prototype.add = function add10(e2) {
  this._edges.add(e2);
  var oca = new OrientedCoordinateArray(e2.getCoordinates());
  this._ocaMap.put(oca, e2);
};
EdgeList.prototype.interfaces_ = function interfaces_98() {
  return [];
};
EdgeList.prototype.getClass = function getClass97() {
  return EdgeList;
};
var SegmentIntersector = function SegmentIntersector2() {
};
SegmentIntersector.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
};
SegmentIntersector.prototype.isDone = function isDone2() {
};
SegmentIntersector.prototype.interfaces_ = function interfaces_99() {
  return [];
};
SegmentIntersector.prototype.getClass = function getClass98() {
  return SegmentIntersector;
};
var IntersectionAdder = function IntersectionAdder2() {
  this._hasIntersection = false;
  this._hasProper = false;
  this._hasProperInterior = false;
  this._hasInterior = false;
  this._properIntersectionPoint = null;
  this._li = null;
  this._isSelfIntersection = null;
  this.numIntersections = 0;
  this.numInteriorIntersections = 0;
  this.numProperIntersections = 0;
  this.numTests = 0;
  var li = arguments[0];
  this._li = li;
};
IntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1) {
    if (this._li.getIntersectionNum() === 1) {
      if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) {
        return true;
      }
      if (e0.isClosed()) {
        var maxSegIndex = e0.size() - 1;
        if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
          return true;
        }
      }
    }
  }
  return false;
};
IntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {
  return this._properIntersectionPoint;
};
IntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {
  return this._hasProperInterior;
};
IntersectionAdder.prototype.getLineIntersector = function getLineIntersector() {
  return this._li;
};
IntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection() {
  return this._hasProper;
};
IntersectionAdder.prototype.processIntersections = function processIntersections2(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  this.numTests++;
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    this.numIntersections++;
    if (this._li.isInteriorIntersection()) {
      this.numInteriorIntersections++;
      this._hasInterior = true;
    }
    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
      this._hasIntersection = true;
      e0.addIntersections(this._li, segIndex0, 0);
      e1.addIntersections(this._li, segIndex1, 1);
      if (this._li.isProper()) {
        this.numProperIntersections++;
        this._hasProper = true;
        this._hasProperInterior = true;
      }
    }
  }
};
IntersectionAdder.prototype.hasIntersection = function hasIntersection2() {
  return this._hasIntersection;
};
IntersectionAdder.prototype.isDone = function isDone3() {
  return false;
};
IntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection() {
  return this._hasInterior;
};
IntersectionAdder.prototype.interfaces_ = function interfaces_100() {
  return [SegmentIntersector];
};
IntersectionAdder.prototype.getClass = function getClass99() {
  return IntersectionAdder;
};
IntersectionAdder.isAdjacentSegments = function isAdjacentSegments(i1, i2) {
  return Math.abs(i1 - i2) === 1;
};
var EdgeIntersection = function EdgeIntersection2() {
  this.coord = null;
  this.segmentIndex = null;
  this.dist = null;
  var coord = arguments[0];
  var segmentIndex = arguments[1];
  var dist3 = arguments[2];
  this.coord = new Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this.dist = dist3;
};
EdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex() {
  return this.segmentIndex;
};
EdgeIntersection.prototype.getCoordinate = function getCoordinate12() {
  return this.coord;
};
EdgeIntersection.prototype.print = function print7(out2) {
  out2.print(this.coord);
  out2.print(" seg # = " + this.segmentIndex);
  out2.println(" dist = " + this.dist);
};
EdgeIntersection.prototype.compareTo = function compareTo14(obj) {
  var other = obj;
  return this.compare(other.segmentIndex, other.dist);
};
EdgeIntersection.prototype.isEndPoint = function isEndPoint3(maxSegmentIndex) {
  if (this.segmentIndex === 0 && this.dist === 0) {
    return true;
  }
  if (this.segmentIndex === maxSegmentIndex) {
    return true;
  }
  return false;
};
EdgeIntersection.prototype.toString = function toString19() {
  return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
};
EdgeIntersection.prototype.getDistance = function getDistance2() {
  return this.dist;
};
EdgeIntersection.prototype.compare = function compare8(segmentIndex, dist3) {
  if (this.segmentIndex < segmentIndex) {
    return -1;
  }
  if (this.segmentIndex > segmentIndex) {
    return 1;
  }
  if (this.dist < dist3) {
    return -1;
  }
  if (this.dist > dist3) {
    return 1;
  }
  return 0;
};
EdgeIntersection.prototype.interfaces_ = function interfaces_101() {
  return [Comparable];
};
EdgeIntersection.prototype.getClass = function getClass100() {
  return EdgeIntersection;
};
var EdgeIntersectionList = function EdgeIntersectionList2() {
  this._nodeMap = new TreeMap();
  this.edge = null;
  var edge = arguments[0];
  this.edge = edge;
};
EdgeIntersectionList.prototype.print = function print8(out2) {
  out2.println("Intersections:");
  for (var it = this.iterator(); it.hasNext(); ) {
    var ei = it.next();
    ei.print(out2);
  }
};
EdgeIntersectionList.prototype.iterator = function iterator6() {
  return this._nodeMap.values().iterator();
};
EdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges2(edgeList) {
  var this$1$1 = this;
  this.addEndpoints();
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var newEdge = this$1$1.createSplitEdge(eiPrev, ei);
    edgeList.add(newEdge);
    eiPrev = ei;
  }
};
EdgeIntersectionList.prototype.addEndpoints = function addEndpoints2() {
  var maxSegIndex = this.edge.pts.length - 1;
  this.add(this.edge.pts[0], 0, 0);
  this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0);
};
EdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge2(ei0, ei1) {
  var this$1$1 = this;
  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
  var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
  var useIntPt1 = ei1.dist > 0 || !ei1.coord.equals2D(lastSegStartPt);
  if (!useIntPt1) {
    npts--;
  }
  var pts = new Array(npts).fill(null);
  var ipt = 0;
  pts[ipt++] = new Coordinate(ei0.coord);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    pts[ipt++] = this$1$1.edge.pts[i];
  }
  if (useIntPt1) {
    pts[ipt] = ei1.coord;
  }
  return new Edge(pts, new Label(this.edge._label));
};
EdgeIntersectionList.prototype.add = function add11(intPt, segmentIndex, dist3) {
  var eiNew = new EdgeIntersection(intPt, segmentIndex, dist3);
  var ei = this._nodeMap.get(eiNew);
  if (ei !== null) {
    return ei;
  }
  this._nodeMap.put(eiNew, eiNew);
  return eiNew;
};
EdgeIntersectionList.prototype.isIntersection = function isIntersection2(pt) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var ei = it.next();
    if (ei.coord.equals(pt)) {
      return true;
    }
  }
  return false;
};
EdgeIntersectionList.prototype.interfaces_ = function interfaces_102() {
  return [];
};
EdgeIntersectionList.prototype.getClass = function getClass101() {
  return EdgeIntersectionList;
};
var MonotoneChainIndexer = function MonotoneChainIndexer2() {
};
MonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices2(pts) {
  var this$1$1 = this;
  var start2 = 0;
  var startIndexList = new ArrayList();
  startIndexList.add(new Integer(start2));
  do {
    var last = this$1$1.findChainEnd(pts, start2);
    startIndexList.add(new Integer(last));
    start2 = last;
  } while (start2 < pts.length - 1);
  var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
  return startIndex;
};
MonotoneChainIndexer.prototype.findChainEnd = function findChainEnd2(pts, start2) {
  var chainQuad = Quadrant.quadrant(pts[start2], pts[start2 + 1]);
  var last = start2 + 1;
  while (last < pts.length) {
    var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
    if (quad !== chainQuad) {
      break;
    }
    last++;
  }
  return last - 1;
};
MonotoneChainIndexer.prototype.interfaces_ = function interfaces_103() {
  return [];
};
MonotoneChainIndexer.prototype.getClass = function getClass102() {
  return MonotoneChainIndexer;
};
MonotoneChainIndexer.toIntArray = function toIntArray2(list) {
  var array = new Array(list.size()).fill(null);
  for (var i = 0; i < array.length; i++) {
    array[i] = list.get(i).intValue();
  }
  return array;
};
var MonotoneChainEdge = function MonotoneChainEdge2() {
  this.e = null;
  this.pts = null;
  this.startIndex = null;
  this.env1 = new Envelope();
  this.env2 = new Envelope();
  var e2 = arguments[0];
  this.e = e2;
  this.pts = e2.getCoordinates();
  var mcb = new MonotoneChainIndexer();
  this.startIndex = mcb.getChainStartIndices(this.pts);
};
MonotoneChainEdge.prototype.getCoordinates = function getCoordinates6() {
  return this.pts;
};
MonotoneChainEdge.prototype.getMaxX = function getMaxX2(chainIndex) {
  var x12 = this.pts[this.startIndex[chainIndex]].x;
  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
  return x12 > x2 ? x12 : x2;
};
MonotoneChainEdge.prototype.getMinX = function getMinX2(chainIndex) {
  var x12 = this.pts[this.startIndex[chainIndex]].x;
  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
  return x12 < x2 ? x12 : x2;
};
MonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain() {
  if (arguments.length === 4) {
    var chainIndex0 = arguments[0];
    var mce = arguments[1];
    var chainIndex1 = arguments[2];
    var si = arguments[3];
    this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
  } else if (arguments.length === 6) {
    var start0 = arguments[0];
    var end0 = arguments[1];
    var mce$1 = arguments[2];
    var start1 = arguments[3];
    var end1 = arguments[4];
    var ei = arguments[5];
    var p002 = this.pts[start0];
    var p012 = this.pts[end0];
    var p102 = mce$1.pts[start1];
    var p112 = mce$1.pts[end1];
    if (end0 - start0 === 1 && end1 - start1 === 1) {
      ei.addIntersections(this.e, start0, mce$1.e, start1);
      return null;
    }
    this.env1.init(p002, p012);
    this.env2.init(p102, p112);
    if (!this.env1.intersects(this.env2)) {
      return null;
    }
    var mid0 = Math.trunc((start0 + end0) / 2);
    var mid1 = Math.trunc((start1 + end1) / 2);
    if (start0 < mid0) {
      if (start1 < mid1) {
        this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei);
      }
      if (mid1 < end1) {
        this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei);
      }
    }
    if (mid0 < end0) {
      if (start1 < mid1) {
        this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei);
      }
      if (mid1 < end1) {
        this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei);
      }
    }
  }
};
MonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes() {
  return this.startIndex;
};
MonotoneChainEdge.prototype.computeIntersects = function computeIntersects(mce, si) {
  var this$1$1 = this;
  for (var i = 0; i < this.startIndex.length - 1; i++) {
    for (var j = 0; j < mce.startIndex.length - 1; j++) {
      this$1$1.computeIntersectsForChain(i, mce, j, si);
    }
  }
};
MonotoneChainEdge.prototype.interfaces_ = function interfaces_104() {
  return [];
};
MonotoneChainEdge.prototype.getClass = function getClass103() {
  return MonotoneChainEdge;
};
var Depth = function Depth2() {
  var this$1$1 = this;
  this._depth = Array(2).fill().map(function() {
    return Array(3);
  });
  for (var i = 0; i < 2; i++) {
    for (var j = 0; j < 3; j++) {
      this$1$1._depth[i][j] = Depth2.NULL_VALUE;
    }
  }
};
var staticAccessors$31 = { NULL_VALUE: { configurable: true } };
Depth.prototype.getDepth = function getDepth2(geomIndex, posIndex) {
  return this._depth[geomIndex][posIndex];
};
Depth.prototype.setDepth = function setDepth(geomIndex, posIndex, depthValue) {
  this._depth[geomIndex][posIndex] = depthValue;
};
Depth.prototype.isNull = function isNull4() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    for (var i = 0; i < 2; i++) {
      for (var j = 0; j < 3; j++) {
        if (this$1$1._depth[i][j] !== Depth.NULL_VALUE) {
          return false;
        }
      }
    }
    return true;
  } else if (arguments.length === 1) {
    var geomIndex = arguments[0];
    return this._depth[geomIndex][1] === Depth.NULL_VALUE;
  } else if (arguments.length === 2) {
    var geomIndex$1 = arguments[0];
    var posIndex = arguments[1];
    return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE;
  }
};
Depth.prototype.normalize = function normalize3() {
  var this$1$1 = this;
  for (var i = 0; i < 2; i++) {
    if (!this$1$1.isNull(i)) {
      var minDepth = this$1$1._depth[i][1];
      if (this$1$1._depth[i][2] < minDepth) {
        minDepth = this$1$1._depth[i][2];
      }
      if (minDepth < 0) {
        minDepth = 0;
      }
      for (var j = 1; j < 3; j++) {
        var newValue = 0;
        if (this$1$1._depth[i][j] > minDepth) {
          newValue = 1;
        }
        this$1$1._depth[i][j] = newValue;
      }
    }
  }
};
Depth.prototype.getDelta = function getDelta(geomIndex) {
  return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];
};
Depth.prototype.getLocation = function getLocation4(geomIndex, posIndex) {
  if (this._depth[geomIndex][posIndex] <= 0) {
    return Location.EXTERIOR;
  }
  return Location.INTERIOR;
};
Depth.prototype.toString = function toString20() {
  return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
};
Depth.prototype.add = function add12() {
  var this$1$1 = this;
  if (arguments.length === 1) {
    var lbl = arguments[0];
    for (var i = 0; i < 2; i++) {
      for (var j = 1; j < 3; j++) {
        var loc = lbl.getLocation(i, j);
        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
          if (this$1$1.isNull(i, j)) {
            this$1$1._depth[i][j] = Depth.depthAtLocation(loc);
          } else {
            this$1$1._depth[i][j] += Depth.depthAtLocation(loc);
          }
        }
      }
    }
  } else if (arguments.length === 3) {
    var geomIndex = arguments[0];
    var posIndex = arguments[1];
    var location = arguments[2];
    if (location === Location.INTERIOR) {
      this._depth[geomIndex][posIndex]++;
    }
  }
};
Depth.prototype.interfaces_ = function interfaces_105() {
  return [];
};
Depth.prototype.getClass = function getClass104() {
  return Depth;
};
Depth.depthAtLocation = function depthAtLocation(location) {
  if (location === Location.EXTERIOR) {
    return 0;
  }
  if (location === Location.INTERIOR) {
    return 1;
  }
  return Depth.NULL_VALUE;
};
staticAccessors$31.NULL_VALUE.get = function() {
  return -1;
};
Object.defineProperties(Depth, staticAccessors$31);
var Edge = function(GraphComponent$$1) {
  function Edge2() {
    GraphComponent$$1.call(this);
    this.pts = null;
    this._env = null;
    this.eiList = new EdgeIntersectionList(this);
    this._name = null;
    this._mce = null;
    this._isIsolated = true;
    this._depth = new Depth();
    this._depthDelta = 0;
    if (arguments.length === 1) {
      var pts = arguments[0];
      Edge2.call(this, pts, null);
    } else if (arguments.length === 2) {
      var pts$1 = arguments[0];
      var label = arguments[1];
      this.pts = pts$1;
      this._label = label;
    }
  }
  if (GraphComponent$$1)
    Edge2.__proto__ = GraphComponent$$1;
  Edge2.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
  Edge2.prototype.constructor = Edge2;
  Edge2.prototype.getDepth = function getDepth3() {
    return this._depth;
  };
  Edge2.prototype.getCollapsedEdge = function getCollapsedEdge() {
    var newPts = new Array(2).fill(null);
    newPts[0] = this.pts[0];
    newPts[1] = this.pts[1];
    var newe = new Edge2(newPts, Label.toLineLabel(this._label));
    return newe;
  };
  Edge2.prototype.isIsolated = function isIsolated2() {
    return this._isIsolated;
  };
  Edge2.prototype.getCoordinates = function getCoordinates11() {
    return this.pts;
  };
  Edge2.prototype.setIsolated = function setIsolated(isIsolated2) {
    this._isIsolated = isIsolated2;
  };
  Edge2.prototype.setName = function setName(name2) {
    this._name = name2;
  };
  Edge2.prototype.equals = function equals10(o) {
    var this$1$1 = this;
    if (!(o instanceof Edge2)) {
      return false;
    }
    var e2 = o;
    if (this.pts.length !== e2.pts.length) {
      return false;
    }
    var isEqualForward = true;
    var isEqualReverse = true;
    var iRev = this.pts.length;
    for (var i = 0; i < this.pts.length; i++) {
      if (!this$1$1.pts[i].equals2D(e2.pts[i])) {
        isEqualForward = false;
      }
      if (!this$1$1.pts[i].equals2D(e2.pts[--iRev])) {
        isEqualReverse = false;
      }
      if (!isEqualForward && !isEqualReverse) {
        return false;
      }
    }
    return true;
  };
  Edge2.prototype.getCoordinate = function getCoordinate18() {
    if (arguments.length === 0) {
      if (this.pts.length > 0) {
        return this.pts[0];
      }
      return null;
    } else if (arguments.length === 1) {
      var i = arguments[0];
      return this.pts[i];
    }
  };
  Edge2.prototype.print = function print9(out2) {
    var this$1$1 = this;
    out2.print("edge " + this._name + ": ");
    out2.print("LINESTRING (");
    for (var i = 0; i < this.pts.length; i++) {
      if (i > 0) {
        out2.print(",");
      }
      out2.print(this$1$1.pts[i].x + " " + this$1$1.pts[i].y);
    }
    out2.print(")  " + this._label + " " + this._depthDelta);
  };
  Edge2.prototype.computeIM = function computeIM(im) {
    Edge2.updateIM(this._label, im);
  };
  Edge2.prototype.isCollapsed = function isCollapsed() {
    if (!this._label.isArea()) {
      return false;
    }
    if (this.pts.length !== 3) {
      return false;
    }
    if (this.pts[0].equals(this.pts[2])) {
      return true;
    }
    return false;
  };
  Edge2.prototype.isClosed = function isClosed5() {
    return this.pts[0].equals(this.pts[this.pts.length - 1]);
  };
  Edge2.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex() {
    return this.pts.length - 1;
  };
  Edge2.prototype.getDepthDelta = function getDepthDelta() {
    return this._depthDelta;
  };
  Edge2.prototype.getNumPoints = function getNumPoints() {
    return this.pts.length;
  };
  Edge2.prototype.printReverse = function printReverse(out2) {
    var this$1$1 = this;
    out2.print("edge " + this._name + ": ");
    for (var i = this.pts.length - 1; i >= 0; i--) {
      out2.print(this$1$1.pts[i] + " ");
    }
    out2.println("");
  };
  Edge2.prototype.getMonotoneChainEdge = function getMonotoneChainEdge() {
    if (this._mce === null) {
      this._mce = new MonotoneChainEdge(this);
    }
    return this._mce;
  };
  Edge2.prototype.getEnvelope = function getEnvelope4() {
    var this$1$1 = this;
    if (this._env === null) {
      this._env = new Envelope();
      for (var i = 0; i < this.pts.length; i++) {
        this$1$1._env.expandToInclude(this$1$1.pts[i]);
      }
    }
    return this._env;
  };
  Edge2.prototype.addIntersection = function addIntersection3(li, segmentIndex, geomIndex, intIndex) {
    var intPt = new Coordinate(li.getIntersection(intIndex));
    var normalizedSegmentIndex = segmentIndex;
    var dist3 = li.getEdgeDistance(geomIndex, intIndex);
    var nextSegIndex = normalizedSegmentIndex + 1;
    if (nextSegIndex < this.pts.length) {
      var nextPt = this.pts[nextSegIndex];
      if (intPt.equals2D(nextPt)) {
        normalizedSegmentIndex = nextSegIndex;
        dist3 = 0;
      }
    }
    this.eiList.add(intPt, normalizedSegmentIndex, dist3);
  };
  Edge2.prototype.toString = function toString27() {
    var this$1$1 = this;
    var buf = new StringBuffer();
    buf.append("edge " + this._name + ": ");
    buf.append("LINESTRING (");
    for (var i = 0; i < this.pts.length; i++) {
      if (i > 0) {
        buf.append(",");
      }
      buf.append(this$1$1.pts[i].x + " " + this$1$1.pts[i].y);
    }
    buf.append(")  " + this._label + " " + this._depthDelta);
    return buf.toString();
  };
  Edge2.prototype.isPointwiseEqual = function isPointwiseEqual(e2) {
    var this$1$1 = this;
    if (this.pts.length !== e2.pts.length) {
      return false;
    }
    for (var i = 0; i < this.pts.length; i++) {
      if (!this$1$1.pts[i].equals2D(e2.pts[i])) {
        return false;
      }
    }
    return true;
  };
  Edge2.prototype.setDepthDelta = function setDepthDelta(depthDelta2) {
    this._depthDelta = depthDelta2;
  };
  Edge2.prototype.getEdgeIntersectionList = function getEdgeIntersectionList() {
    return this.eiList;
  };
  Edge2.prototype.addIntersections = function addIntersections3(li, segmentIndex, geomIndex) {
    var this$1$1 = this;
    for (var i = 0; i < li.getIntersectionNum(); i++) {
      this$1$1.addIntersection(li, segmentIndex, geomIndex, i);
    }
  };
  Edge2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  Edge2.prototype.getClass = function getClass169() {
    return Edge2;
  };
  Edge2.updateIM = function updateIM2() {
    if (arguments.length === 2) {
      var label = arguments[0];
      var im = arguments[1];
      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
      if (label.isArea()) {
        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
      }
    } else {
      return GraphComponent$$1.prototype.updateIM.apply(this, arguments);
    }
  };
  return Edge2;
}(GraphComponent);
var BufferBuilder = function BufferBuilder2(bufParams) {
  this._workingPrecisionModel = null;
  this._workingNoder = null;
  this._geomFact = null;
  this._graph = null;
  this._edgeList = new EdgeList();
  this._bufParams = bufParams || null;
};
BufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel(pm) {
  this._workingPrecisionModel = pm;
};
BufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge(e2) {
  var existingEdge = this._edgeList.findEqualEdge(e2);
  if (existingEdge !== null) {
    var existingLabel = existingEdge.getLabel();
    var labelToMerge = e2.getLabel();
    if (!existingEdge.isPointwiseEqual(e2)) {
      labelToMerge = new Label(e2.getLabel());
      labelToMerge.flip();
    }
    existingLabel.merge(labelToMerge);
    var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
    var existingDelta = existingEdge.getDepthDelta();
    var newDelta = existingDelta + mergeDelta;
    existingEdge.setDepthDelta(newDelta);
  } else {
    this._edgeList.add(e2);
    e2.setDepthDelta(BufferBuilder.depthDelta(e2.getLabel()));
  }
};
BufferBuilder.prototype.buildSubgraphs = function buildSubgraphs(subgraphList, polyBuilder) {
  var processedGraphs = new ArrayList();
  for (var i = subgraphList.iterator(); i.hasNext(); ) {
    var subgraph = i.next();
    var p = subgraph.getRightmostCoordinate();
    var locater = new SubgraphDepthLocater(processedGraphs);
    var outsideDepth = locater.getDepth(p);
    subgraph.computeDepth(outsideDepth);
    subgraph.findResultEdges();
    processedGraphs.add(subgraph);
    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
  }
};
BufferBuilder.prototype.createSubgraphs = function createSubgraphs(graph) {
  var subgraphList = new ArrayList();
  for (var i = graph.getNodes().iterator(); i.hasNext(); ) {
    var node = i.next();
    if (!node.isVisited()) {
      var subgraph = new BufferSubgraph();
      subgraph.create(node);
      subgraphList.add(subgraph);
    }
  }
  Collections.sort(subgraphList, Collections.reverseOrder());
  return subgraphList;
};
BufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry() {
  var emptyGeom = this._geomFact.createPolygon();
  return emptyGeom;
};
BufferBuilder.prototype.getNoder = function getNoder(precisionModel) {
  if (this._workingNoder !== null) {
    return this._workingNoder;
  }
  var noder = new MCIndexNoder();
  var li = new RobustLineIntersector();
  li.setPrecisionModel(precisionModel);
  noder.setSegmentIntersector(new IntersectionAdder(li));
  return noder;
};
BufferBuilder.prototype.buffer = function buffer(g, distance11) {
  var precisionModel = this._workingPrecisionModel;
  if (precisionModel === null) {
    precisionModel = g.getPrecisionModel();
  }
  this._geomFact = g.getFactory();
  var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
  var curveSetBuilder = new OffsetCurveSetBuilder(g, distance11, curveBuilder);
  var bufferSegStrList = curveSetBuilder.getCurves();
  if (bufferSegStrList.size() <= 0) {
    return this.createEmptyResultGeometry();
  }
  this.computeNodedEdges(bufferSegStrList, precisionModel);
  this._graph = new PlanarGraph(new OverlayNodeFactory());
  this._graph.addEdges(this._edgeList.getEdges());
  var subgraphList = this.createSubgraphs(this._graph);
  var polyBuilder = new PolygonBuilder(this._geomFact);
  this.buildSubgraphs(subgraphList, polyBuilder);
  var resultPolyList = polyBuilder.getPolygons();
  if (resultPolyList.size() <= 0) {
    return this.createEmptyResultGeometry();
  }
  var resultGeom = this._geomFact.buildGeometry(resultPolyList);
  return resultGeom;
};
BufferBuilder.prototype.computeNodedEdges = function computeNodedEdges(bufferSegStrList, precisionModel) {
  var this$1$1 = this;
  var noder = this.getNoder(precisionModel);
  noder.computeNodes(bufferSegStrList);
  var nodedSegStrings = noder.getNodedSubstrings();
  for (var i = nodedSegStrings.iterator(); i.hasNext(); ) {
    var segStr = i.next();
    var pts = segStr.getCoordinates();
    if (pts.length === 2 && pts[0].equals2D(pts[1])) {
      continue;
    }
    var oldLabel = segStr.getData();
    var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));
    this$1$1.insertUniqueEdge(edge);
  }
};
BufferBuilder.prototype.setNoder = function setNoder(noder) {
  this._workingNoder = noder;
};
BufferBuilder.prototype.interfaces_ = function interfaces_106() {
  return [];
};
BufferBuilder.prototype.getClass = function getClass105() {
  return BufferBuilder;
};
BufferBuilder.depthDelta = function depthDelta(label) {
  var lLoc = label.getLocation(0, Position.LEFT);
  var rLoc = label.getLocation(0, Position.RIGHT);
  if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) {
    return 1;
  } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) {
    return -1;
  }
  return 0;
};
BufferBuilder.convertSegStrings = function convertSegStrings(it) {
  var fact = new GeometryFactory();
  var lines = new ArrayList();
  while (it.hasNext()) {
    var ss = it.next();
    var line = fact.createLineString(ss.getCoordinates());
    lines.add(line);
  }
  return fact.buildGeometry(lines);
};
var ScaledNoder = function ScaledNoder2() {
  this._noder = null;
  this._scaleFactor = null;
  this._offsetX = null;
  this._offsetY = null;
  this._isScaled = false;
  if (arguments.length === 2) {
    var noder = arguments[0];
    var scaleFactor = arguments[1];
    this._noder = noder;
    this._scaleFactor = scaleFactor;
    this._offsetX = 0;
    this._offsetY = 0;
    this._isScaled = !this.isIntegerPrecision();
  } else if (arguments.length === 4) {
    var noder$1 = arguments[0];
    var scaleFactor$1 = arguments[1];
    var offsetX = arguments[2];
    var offsetY = arguments[3];
    this._noder = noder$1;
    this._scaleFactor = scaleFactor$1;
    this._offsetX = offsetX;
    this._offsetY = offsetY;
    this._isScaled = !this.isIntegerPrecision();
  }
};
ScaledNoder.prototype.rescale = function rescale() {
  var this$1$1 = this;
  if (hasInterface(arguments[0], Collection)) {
    var segStrings = arguments[0];
    for (var i = segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      this$1$1.rescale(ss.getCoordinates());
    }
  } else if (arguments[0] instanceof Array) {
    var pts = arguments[0];
    for (var i$1 = 0; i$1 < pts.length; i$1++) {
      pts[i$1].x = pts[i$1].x / this$1$1._scaleFactor + this$1$1._offsetX;
      pts[i$1].y = pts[i$1].y / this$1$1._scaleFactor + this$1$1._offsetY;
    }
    if (pts.length === 2 && pts[0].equals2D(pts[1])) {
      System.out.println(pts);
    }
  }
};
ScaledNoder.prototype.scale = function scale() {
  var this$1$1 = this;
  if (hasInterface(arguments[0], Collection)) {
    var segStrings = arguments[0];
    var nodedSegmentStrings = new ArrayList();
    for (var i = segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      nodedSegmentStrings.add(new NodedSegmentString(this$1$1.scale(ss.getCoordinates()), ss.getData()));
    }
    return nodedSegmentStrings;
  } else if (arguments[0] instanceof Array) {
    var pts = arguments[0];
    var roundPts = new Array(pts.length).fill(null);
    for (var i$1 = 0; i$1 < pts.length; i$1++) {
      roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1$1._offsetX) * this$1$1._scaleFactor), Math.round((pts[i$1].y - this$1$1._offsetY) * this$1$1._scaleFactor), pts[i$1].z);
    }
    var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
    return roundPtsNoDup;
  }
};
ScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision() {
  return this._scaleFactor === 1;
};
ScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings3() {
  var splitSS = this._noder.getNodedSubstrings();
  if (this._isScaled) {
    this.rescale(splitSS);
  }
  return splitSS;
};
ScaledNoder.prototype.computeNodes = function computeNodes2(inputSegStrings) {
  var intSegStrings = inputSegStrings;
  if (this._isScaled) {
    intSegStrings = this.scale(inputSegStrings);
  }
  this._noder.computeNodes(intSegStrings);
};
ScaledNoder.prototype.interfaces_ = function interfaces_107() {
  return [Noder];
};
ScaledNoder.prototype.getClass = function getClass106() {
  return ScaledNoder;
};
var NodingValidator = function NodingValidator2() {
  this._li = new RobustLineIntersector();
  this._segStrings = null;
  var segStrings = arguments[0];
  this._segStrings = segStrings;
};
var staticAccessors$33 = { fact: { configurable: true } };
NodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    for (var i = this._segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      var pts = ss.getCoordinates();
      this$1$1.checkEndPtVertexIntersections(pts[0], this$1$1._segStrings);
      this$1$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1$1._segStrings);
    }
  } else if (arguments.length === 2) {
    var testPt = arguments[0];
    var segStrings = arguments[1];
    for (var i$1 = segStrings.iterator(); i$1.hasNext(); ) {
      var ss$1 = i$1.next();
      var pts$1 = ss$1.getCoordinates();
      for (var j = 1; j < pts$1.length - 1; j++) {
        if (pts$1[j].equals(testPt)) {
          throw new RuntimeException("found endpt/interior pt intersection at index " + j + " :pt " + testPt);
        }
      }
    }
  }
};
NodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    for (var i = this._segStrings.iterator(); i.hasNext(); ) {
      var ss0 = i.next();
      for (var j = this._segStrings.iterator(); j.hasNext(); ) {
        var ss1 = j.next();
        this$1$1.checkInteriorIntersections(ss0, ss1);
      }
    }
  } else if (arguments.length === 2) {
    var ss0$1 = arguments[0];
    var ss1$1 = arguments[1];
    var pts0 = ss0$1.getCoordinates();
    var pts1 = ss1$1.getCoordinates();
    for (var i0 = 0; i0 < pts0.length - 1; i0++) {
      for (var i1 = 0; i1 < pts1.length - 1; i1++) {
        this$1$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);
      }
    }
  } else if (arguments.length === 4) {
    var e0 = arguments[0];
    var segIndex0 = arguments[1];
    var e1 = arguments[2];
    var segIndex1 = arguments[3];
    if (e0 === e1 && segIndex0 === segIndex1) {
      return null;
    }
    var p002 = e0.getCoordinates()[segIndex0];
    var p012 = e0.getCoordinates()[segIndex0 + 1];
    var p102 = e1.getCoordinates()[segIndex1];
    var p112 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p002, p012, p102, p112);
    if (this._li.hasIntersection()) {
      if (this._li.isProper() || this.hasInteriorIntersection(this._li, p002, p012) || this.hasInteriorIntersection(this._li, p102, p112)) {
        throw new RuntimeException("found non-noded intersection at " + p002 + "-" + p012 + " and " + p102 + "-" + p112);
      }
    }
  }
};
NodingValidator.prototype.checkValid = function checkValid() {
  this.checkEndPtVertexIntersections();
  this.checkInteriorIntersections();
  this.checkCollapses();
};
NodingValidator.prototype.checkCollapses = function checkCollapses() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    for (var i = this._segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      this$1$1.checkCollapses(ss);
    }
  } else if (arguments.length === 1) {
    var ss$1 = arguments[0];
    var pts = ss$1.getCoordinates();
    for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {
      this$1$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);
    }
  }
};
NodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection2(li, p0, p1) {
  for (var i = 0; i < li.getIntersectionNum(); i++) {
    var intPt = li.getIntersection(i);
    if (!(intPt.equals(p0) || intPt.equals(p1))) {
      return true;
    }
  }
  return false;
};
NodingValidator.prototype.checkCollapse = function checkCollapse(p0, p1, p2) {
  if (p0.equals(p2)) {
    throw new RuntimeException("found non-noded collapse at " + NodingValidator.fact.createLineString([p0, p1, p2]));
  }
};
NodingValidator.prototype.interfaces_ = function interfaces_108() {
  return [];
};
NodingValidator.prototype.getClass = function getClass107() {
  return NodingValidator;
};
staticAccessors$33.fact.get = function() {
  return new GeometryFactory();
};
Object.defineProperties(NodingValidator, staticAccessors$33);
var HotPixel = function HotPixel2() {
  this._li = null;
  this._pt = null;
  this._originalPt = null;
  this._ptScaled = null;
  this._p0Scaled = null;
  this._p1Scaled = null;
  this._scaleFactor = null;
  this._minx = null;
  this._maxx = null;
  this._miny = null;
  this._maxy = null;
  this._corner = new Array(4).fill(null);
  this._safeEnv = null;
  var pt = arguments[0];
  var scaleFactor = arguments[1];
  var li = arguments[2];
  this._originalPt = pt;
  this._pt = pt;
  this._scaleFactor = scaleFactor;
  this._li = li;
  if (scaleFactor <= 0) {
    throw new IllegalArgumentException("Scale factor must be non-zero");
  }
  if (scaleFactor !== 1) {
    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
    this._p0Scaled = new Coordinate();
    this._p1Scaled = new Coordinate();
  }
  this.initCorners(this._pt);
};
var staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
HotPixel.prototype.intersectsScaled = function intersectsScaled(p0, p1) {
  var segMinx = Math.min(p0.x, p1.x);
  var segMaxx = Math.max(p0.x, p1.x);
  var segMiny = Math.min(p0.y, p1.y);
  var segMaxy = Math.max(p0.y, p1.y);
  var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
  if (isOutsidePixelEnv) {
    return false;
  }
  var intersects7 = this.intersectsToleranceSquare(p0, p1);
  Assert.isTrue(!(isOutsidePixelEnv && intersects7), "Found bad envelope test");
  return intersects7;
};
HotPixel.prototype.initCorners = function initCorners(pt) {
  var tolerance = 0.5;
  this._minx = pt.x - tolerance;
  this._maxx = pt.x + tolerance;
  this._miny = pt.y - tolerance;
  this._maxy = pt.y + tolerance;
  this._corner[0] = new Coordinate(this._maxx, this._maxy);
  this._corner[1] = new Coordinate(this._minx, this._maxy);
  this._corner[2] = new Coordinate(this._minx, this._miny);
  this._corner[3] = new Coordinate(this._maxx, this._miny);
};
HotPixel.prototype.intersects = function intersects4(p0, p1) {
  if (this._scaleFactor === 1) {
    return this.intersectsScaled(p0, p1);
  }
  this.copyScaled(p0, this._p0Scaled);
  this.copyScaled(p1, this._p1Scaled);
  return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
};
HotPixel.prototype.scale = function scale2(val) {
  return Math.round(val * this._scaleFactor);
};
HotPixel.prototype.getCoordinate = function getCoordinate13() {
  return this._originalPt;
};
HotPixel.prototype.copyScaled = function copyScaled(p, pScaled) {
  pScaled.x = this.scale(p.x);
  pScaled.y = this.scale(p.y);
};
HotPixel.prototype.getSafeEnvelope = function getSafeEnvelope() {
  if (this._safeEnv === null) {
    var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
    this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
  }
  return this._safeEnv;
};
HotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure(p0, p1) {
  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
  if (this._li.hasIntersection()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
  if (this._li.hasIntersection()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
  if (this._li.hasIntersection()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
  if (this._li.hasIntersection()) {
    return true;
  }
  return false;
};
HotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare(p0, p1) {
  var intersectsLeft = false;
  var intersectsBottom = false;
  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
  if (this._li.isProper()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
  if (this._li.isProper()) {
    return true;
  }
  if (this._li.hasIntersection()) {
    intersectsLeft = true;
  }
  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
  if (this._li.isProper()) {
    return true;
  }
  if (this._li.hasIntersection()) {
    intersectsBottom = true;
  }
  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
  if (this._li.isProper()) {
    return true;
  }
  if (intersectsLeft && intersectsBottom) {
    return true;
  }
  if (p0.equals(this._pt)) {
    return true;
  }
  if (p1.equals(this._pt)) {
    return true;
  }
  return false;
};
HotPixel.prototype.addSnappedNode = function addSnappedNode(segStr, segIndex) {
  var p0 = segStr.getCoordinate(segIndex);
  var p1 = segStr.getCoordinate(segIndex + 1);
  if (this.intersects(p0, p1)) {
    segStr.addIntersection(this.getCoordinate(), segIndex);
    return true;
  }
  return false;
};
HotPixel.prototype.interfaces_ = function interfaces_109() {
  return [];
};
HotPixel.prototype.getClass = function getClass108() {
  return HotPixel;
};
staticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function() {
  return 0.75;
};
Object.defineProperties(HotPixel, staticAccessors$34);
var MonotoneChainSelectAction = function MonotoneChainSelectAction2() {
  this.tempEnv1 = new Envelope();
  this.selectedSegment = new LineSegment();
};
MonotoneChainSelectAction.prototype.select = function select2() {
  if (arguments.length === 1)
    ;
  else if (arguments.length === 2) {
    var mc = arguments[0];
    var startIndex = arguments[1];
    mc.getLineSegment(startIndex, this.selectedSegment);
    this.select(this.selectedSegment);
  }
};
MonotoneChainSelectAction.prototype.interfaces_ = function interfaces_110() {
  return [];
};
MonotoneChainSelectAction.prototype.getClass = function getClass109() {
  return MonotoneChainSelectAction;
};
var MCIndexPointSnapper = function MCIndexPointSnapper2() {
  this._index = null;
  var index2 = arguments[0];
  this._index = index2;
};
var staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };
MCIndexPointSnapper.prototype.snap = function snap() {
  if (arguments.length === 1) {
    var hotPixel = arguments[0];
    return this.snap(hotPixel, null, -1);
  } else if (arguments.length === 3) {
    var hotPixel$1 = arguments[0];
    var parentEdge = arguments[1];
    var hotPixelVertexIndex = arguments[2];
    var pixelEnv = hotPixel$1.getSafeEnvelope();
    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);
    this._index.query(pixelEnv, {
      interfaces_: function() {
        return [ItemVisitor];
      },
      visitItem: function(item) {
        var testChain = item;
        testChain.select(pixelEnv, hotPixelSnapAction);
      }
    });
    return hotPixelSnapAction.isNodeAdded();
  }
};
MCIndexPointSnapper.prototype.interfaces_ = function interfaces_111() {
  return [];
};
MCIndexPointSnapper.prototype.getClass = function getClass110() {
  return MCIndexPointSnapper;
};
staticAccessors$35.HotPixelSnapAction.get = function() {
  return HotPixelSnapAction;
};
Object.defineProperties(MCIndexPointSnapper, staticAccessors$35);
var HotPixelSnapAction = function(MonotoneChainSelectAction$$1) {
  function HotPixelSnapAction2() {
    MonotoneChainSelectAction$$1.call(this);
    this._hotPixel = null;
    this._parentEdge = null;
    this._hotPixelVertexIndex = null;
    this._isNodeAdded = false;
    var hotPixel = arguments[0];
    var parentEdge = arguments[1];
    var hotPixelVertexIndex = arguments[2];
    this._hotPixel = hotPixel;
    this._parentEdge = parentEdge;
    this._hotPixelVertexIndex = hotPixelVertexIndex;
  }
  if (MonotoneChainSelectAction$$1)
    HotPixelSnapAction2.__proto__ = MonotoneChainSelectAction$$1;
  HotPixelSnapAction2.prototype = Object.create(MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype);
  HotPixelSnapAction2.prototype.constructor = HotPixelSnapAction2;
  HotPixelSnapAction2.prototype.isNodeAdded = function isNodeAdded() {
    return this._isNodeAdded;
  };
  HotPixelSnapAction2.prototype.select = function select3() {
    if (arguments.length === 2) {
      var mc = arguments[0];
      var startIndex = arguments[1];
      var ss = mc.getContext();
      if (this._parentEdge !== null) {
        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) {
          return null;
        }
      }
      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
    } else {
      return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments);
    }
  };
  HotPixelSnapAction2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  HotPixelSnapAction2.prototype.getClass = function getClass169() {
    return HotPixelSnapAction2;
  };
  return HotPixelSnapAction2;
}(MonotoneChainSelectAction);
var InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder2() {
  this._li = null;
  this._interiorIntersections = null;
  var li = arguments[0];
  this._li = li;
  this._interiorIntersections = new ArrayList();
};
InteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections3(e0, segIndex0, e1, segIndex1) {
  var this$1$1 = this;
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    if (this._li.isInteriorIntersection()) {
      for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
        this$1$1._interiorIntersections.add(this$1$1._li.getIntersection(intIndex));
      }
      e0.addIntersections(this._li, segIndex0, 0);
      e1.addIntersections(this._li, segIndex1, 1);
    }
  }
};
InteriorIntersectionFinderAdder.prototype.isDone = function isDone4() {
  return false;
};
InteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections() {
  return this._interiorIntersections;
};
InteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_112() {
  return [SegmentIntersector];
};
InteriorIntersectionFinderAdder.prototype.getClass = function getClass111() {
  return InteriorIntersectionFinderAdder;
};
var MCIndexSnapRounder = function MCIndexSnapRounder2() {
  this._pm = null;
  this._li = null;
  this._scaleFactor = null;
  this._noder = null;
  this._pointSnapper = null;
  this._nodedSegStrings = null;
  var pm = arguments[0];
  this._pm = pm;
  this._li = new RobustLineIntersector();
  this._li.setPrecisionModel(pm);
  this._scaleFactor = pm.getScale();
};
MCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness(inputSegmentStrings) {
  var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
  var nv = new NodingValidator(resultSegStrings);
  try {
    nv.checkValid();
  } catch (ex) {
    if (ex instanceof Exception) {
      ex.printStackTrace();
    } else {
      throw ex;
    }
  } finally {
  }
};
MCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings4() {
  return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
};
MCIndexSnapRounder.prototype.snapRound = function snapRound(segStrings, li) {
  var intersections = this.findInteriorIntersections(segStrings, li);
  this.computeIntersectionSnaps(intersections);
  this.computeVertexSnaps(segStrings);
};
MCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections(segStrings, li) {
  var intFinderAdder = new InteriorIntersectionFinderAdder(li);
  this._noder.setSegmentIntersector(intFinderAdder);
  this._noder.computeNodes(segStrings);
  return intFinderAdder.getInteriorIntersections();
};
MCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps() {
  var this$1$1 = this;
  if (hasInterface(arguments[0], Collection)) {
    var edges2 = arguments[0];
    for (var i0 = edges2.iterator(); i0.hasNext(); ) {
      var edge0 = i0.next();
      this$1$1.computeVertexSnaps(edge0);
    }
  } else if (arguments[0] instanceof NodedSegmentString) {
    var e2 = arguments[0];
    var pts0 = e2.getCoordinates();
    for (var i = 0; i < pts0.length; i++) {
      var hotPixel = new HotPixel(pts0[i], this$1$1._scaleFactor, this$1$1._li);
      var isNodeAdded = this$1$1._pointSnapper.snap(hotPixel, e2, i);
      if (isNodeAdded) {
        e2.addIntersection(pts0[i], i);
      }
    }
  }
};
MCIndexSnapRounder.prototype.computeNodes = function computeNodes3(inputSegmentStrings) {
  this._nodedSegStrings = inputSegmentStrings;
  this._noder = new MCIndexNoder();
  this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
  this.snapRound(inputSegmentStrings, this._li);
};
MCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps(snapPts) {
  var this$1$1 = this;
  for (var it = snapPts.iterator(); it.hasNext(); ) {
    var snapPt = it.next();
    var hotPixel = new HotPixel(snapPt, this$1$1._scaleFactor, this$1$1._li);
    this$1$1._pointSnapper.snap(hotPixel);
  }
};
MCIndexSnapRounder.prototype.interfaces_ = function interfaces_113() {
  return [Noder];
};
MCIndexSnapRounder.prototype.getClass = function getClass112() {
  return MCIndexSnapRounder;
};
var BufferOp = function BufferOp2() {
  this._argGeom = null;
  this._distance = null;
  this._bufParams = new BufferParameters();
  this._resultGeometry = null;
  this._saveException = null;
  if (arguments.length === 1) {
    var g = arguments[0];
    this._argGeom = g;
  } else if (arguments.length === 2) {
    var g$1 = arguments[0];
    var bufParams = arguments[1];
    this._argGeom = g$1;
    this._bufParams = bufParams;
  }
};
var staticAccessors$32 = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
BufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision(fixedPM) {
  var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1)), fixedPM.getScale());
  var bufBuilder = new BufferBuilder(this._bufParams);
  bufBuilder.setWorkingPrecisionModel(fixedPM);
  bufBuilder.setNoder(noder);
  this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
};
BufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
      try {
        this$1$1.bufferReducedPrecision(precDigits);
      } catch (ex) {
        if (ex instanceof TopologyException) {
          this$1$1._saveException = ex;
        } else {
          throw ex;
        }
      } finally {
      }
      if (this$1$1._resultGeometry !== null) {
        return null;
      }
    }
    throw this._saveException;
  } else if (arguments.length === 1) {
    var precisionDigits = arguments[0];
    var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
    var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
    this.bufferFixedPrecision(fixedPM);
  }
};
BufferOp.prototype.computeGeometry = function computeGeometry() {
  this.bufferOriginalPrecision();
  if (this._resultGeometry !== null) {
    return null;
  }
  var argPM = this._argGeom.getFactory().getPrecisionModel();
  if (argPM.getType() === PrecisionModel.FIXED) {
    this.bufferFixedPrecision(argPM);
  } else {
    this.bufferReducedPrecision();
  }
};
BufferOp.prototype.setQuadrantSegments = function setQuadrantSegments2(quadrantSegments) {
  this._bufParams.setQuadrantSegments(quadrantSegments);
};
BufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision() {
  try {
    var bufBuilder = new BufferBuilder(this._bufParams);
    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
  } catch (ex) {
    if (ex instanceof RuntimeException) {
      this._saveException = ex;
    } else {
      throw ex;
    }
  } finally {
  }
};
BufferOp.prototype.getResultGeometry = function getResultGeometry(distance11) {
  this._distance = distance11;
  this.computeGeometry();
  return this._resultGeometry;
};
BufferOp.prototype.setEndCapStyle = function setEndCapStyle2(endCapStyle) {
  this._bufParams.setEndCapStyle(endCapStyle);
};
BufferOp.prototype.interfaces_ = function interfaces_114() {
  return [];
};
BufferOp.prototype.getClass = function getClass113() {
  return BufferOp;
};
BufferOp.bufferOp = function bufferOp() {
  if (arguments.length === 2) {
    var g = arguments[0];
    var distance11 = arguments[1];
    var gBuf = new BufferOp(g);
    var geomBuf = gBuf.getResultGeometry(distance11);
    return geomBuf;
  } else if (arguments.length === 3) {
    if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === "number")) {
      var g$1 = arguments[0];
      var distance$12 = arguments[1];
      var quadrantSegments = arguments[2];
      var bufOp = new BufferOp(g$1);
      bufOp.setQuadrantSegments(quadrantSegments);
      var geomBuf$1 = bufOp.getResultGeometry(distance$12);
      return geomBuf$1;
    } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === "number")) {
      var g$2 = arguments[0];
      var distance$22 = arguments[1];
      var params = arguments[2];
      var bufOp$1 = new BufferOp(g$2, params);
      var geomBuf$2 = bufOp$1.getResultGeometry(distance$22);
      return geomBuf$2;
    }
  } else if (arguments.length === 4) {
    var g$3 = arguments[0];
    var distance$3 = arguments[1];
    var quadrantSegments$1 = arguments[2];
    var endCapStyle = arguments[3];
    var bufOp$2 = new BufferOp(g$3);
    bufOp$2.setQuadrantSegments(quadrantSegments$1);
    bufOp$2.setEndCapStyle(endCapStyle);
    var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);
    return geomBuf$3;
  }
};
BufferOp.precisionScaleFactor = function precisionScaleFactor(g, distance11, maxPrecisionDigits) {
  var env2 = g.getEnvelopeInternal();
  var envMax = MathUtil.max(Math.abs(env2.getMaxX()), Math.abs(env2.getMaxY()), Math.abs(env2.getMinX()), Math.abs(env2.getMinY()));
  var expandByDistance = distance11 > 0 ? distance11 : 0;
  var bufEnvMax = envMax + 2 * expandByDistance;
  var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1);
  var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
  var scaleFactor = Math.pow(10, minUnitLog10);
  return scaleFactor;
};
staticAccessors$32.CAP_ROUND.get = function() {
  return BufferParameters.CAP_ROUND;
};
staticAccessors$32.CAP_BUTT.get = function() {
  return BufferParameters.CAP_FLAT;
};
staticAccessors$32.CAP_FLAT.get = function() {
  return BufferParameters.CAP_FLAT;
};
staticAccessors$32.CAP_SQUARE.get = function() {
  return BufferParameters.CAP_SQUARE;
};
staticAccessors$32.MAX_PRECISION_DIGITS.get = function() {
  return 12;
};
Object.defineProperties(BufferOp, staticAccessors$32);
var PointPairDistance = function PointPairDistance2() {
  this._pt = [new Coordinate(), new Coordinate()];
  this._distance = Double.NaN;
  this._isNull = true;
};
PointPairDistance.prototype.getCoordinates = function getCoordinates7() {
  return this._pt;
};
PointPairDistance.prototype.getCoordinate = function getCoordinate14(i) {
  return this._pt[i];
};
PointPairDistance.prototype.setMinimum = function setMinimum() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist3 = p0.distance(p1);
    if (dist3 < this._distance) {
      this.initialize(p0, p1, dist3);
    }
  }
};
PointPairDistance.prototype.initialize = function initialize() {
  if (arguments.length === 0) {
    this._isNull = true;
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    this._pt[0].setCoordinate(p0);
    this._pt[1].setCoordinate(p1);
    this._distance = p0.distance(p1);
    this._isNull = false;
  } else if (arguments.length === 3) {
    var p0$1 = arguments[0];
    var p1$1 = arguments[1];
    var distance11 = arguments[2];
    this._pt[0].setCoordinate(p0$1);
    this._pt[1].setCoordinate(p1$1);
    this._distance = distance11;
    this._isNull = false;
  }
};
PointPairDistance.prototype.getDistance = function getDistance3() {
  return this._distance;
};
PointPairDistance.prototype.setMaximum = function setMaximum() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist3 = p0.distance(p1);
    if (dist3 > this._distance) {
      this.initialize(p0, p1, dist3);
    }
  }
};
PointPairDistance.prototype.interfaces_ = function interfaces_115() {
  return [];
};
PointPairDistance.prototype.getClass = function getClass114() {
  return PointPairDistance;
};
var DistanceToPointFinder = function DistanceToPointFinder2() {
};
DistanceToPointFinder.prototype.interfaces_ = function interfaces_116() {
  return [];
};
DistanceToPointFinder.prototype.getClass = function getClass115() {
  return DistanceToPointFinder;
};
DistanceToPointFinder.computeDistance = function computeDistance() {
  if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {
    var line = arguments[0];
    var pt = arguments[1];
    var ptDist = arguments[2];
    var coords = line.getCoordinates();
    var tempSegment = new LineSegment();
    for (var i = 0; i < coords.length - 1; i++) {
      tempSegment.setCoordinates(coords[i], coords[i + 1]);
      var closestPt = tempSegment.closestPoint(pt);
      ptDist.setMinimum(closestPt, pt);
    }
  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon$2 && arguments[1] instanceof Coordinate)) {
    var poly = arguments[0];
    var pt$1 = arguments[1];
    var ptDist$1 = arguments[2];
    DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
      DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
    }
  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
    var geom = arguments[0];
    var pt$2 = arguments[1];
    var ptDist$2 = arguments[2];
    if (geom instanceof LineString) {
      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof Polygon$2) {
      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof GeometryCollection) {
      var gc = geom;
      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
        var g = gc.getGeometryN(i$2);
        DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);
      }
    } else {
      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
    }
  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
    var segment = arguments[0];
    var pt$3 = arguments[1];
    var ptDist$3 = arguments[2];
    var closestPt$1 = segment.closestPoint(pt$3);
    ptDist$3.setMinimum(closestPt$1, pt$3);
  }
};
var BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder2(inputGeom) {
  this._maxPtDist = new PointPairDistance();
  this._inputGeom = inputGeom || null;
};
var staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
BufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance(curve) {
  var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);
  curve.apply(distFilter);
  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
};
BufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance(curve) {
  var distFilter = new MaxPointDistanceFilter(this._inputGeom);
  curve.apply(distFilter);
  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
};
BufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance(bufferCurve) {
  this.computeMaxVertexDistance(bufferCurve);
  this.computeMaxMidpointDistance(bufferCurve);
  return this._maxPtDist.getDistance();
};
BufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints() {
  return this._maxPtDist;
};
BufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_117() {
  return [];
};
BufferCurveMaximumDistanceFinder.prototype.getClass = function getClass116() {
  return BufferCurveMaximumDistanceFinder;
};
staticAccessors$36.MaxPointDistanceFilter.get = function() {
  return MaxPointDistanceFilter;
};
staticAccessors$36.MaxMidpointDistanceFilter.get = function() {
  return MaxMidpointDistanceFilter;
};
Object.defineProperties(BufferCurveMaximumDistanceFinder, staticAccessors$36);
var MaxPointDistanceFilter = function MaxPointDistanceFilter2(geom) {
  this._maxPtDist = new PointPairDistance();
  this._minPtDist = new PointPairDistance();
  this._geom = geom || null;
};
MaxPointDistanceFilter.prototype.filter = function filter6(pt) {
  this._minPtDist.initialize();
  DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);
  this._maxPtDist.setMaximum(this._minPtDist);
};
MaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
  return this._maxPtDist;
};
MaxPointDistanceFilter.prototype.interfaces_ = function interfaces_118() {
  return [CoordinateFilter];
};
MaxPointDistanceFilter.prototype.getClass = function getClass117() {
  return MaxPointDistanceFilter;
};
var MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter2(geom) {
  this._maxPtDist = new PointPairDistance();
  this._minPtDist = new PointPairDistance();
  this._geom = geom || null;
};
MaxMidpointDistanceFilter.prototype.filter = function filter7(seq, index2) {
  if (index2 === 0) {
    return null;
  }
  var p0 = seq.getCoordinate(index2 - 1);
  var p1 = seq.getCoordinate(index2);
  var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
  this._minPtDist.initialize();
  DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);
  this._maxPtDist.setMaximum(this._minPtDist);
};
MaxMidpointDistanceFilter.prototype.isDone = function isDone5() {
  return false;
};
MaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged2() {
  return false;
};
MaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance2() {
  return this._maxPtDist;
};
MaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_119() {
  return [CoordinateSequenceFilter];
};
MaxMidpointDistanceFilter.prototype.getClass = function getClass118() {
  return MaxMidpointDistanceFilter;
};
var PolygonExtracter = function PolygonExtracter2(comps) {
  this._comps = comps || null;
};
PolygonExtracter.prototype.filter = function filter8(geom) {
  if (geom instanceof Polygon$2) {
    this._comps.add(geom);
  }
};
PolygonExtracter.prototype.interfaces_ = function interfaces_120() {
  return [GeometryFilter];
};
PolygonExtracter.prototype.getClass = function getClass119() {
  return PolygonExtracter;
};
PolygonExtracter.getPolygons = function getPolygons2() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    return PolygonExtracter.getPolygons(geom, new ArrayList());
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var list = arguments[1];
    if (geom$1 instanceof Polygon$2) {
      list.add(geom$1);
    } else if (geom$1 instanceof GeometryCollection) {
      geom$1.apply(new PolygonExtracter(list));
    }
    return list;
  }
};
var LinearComponentExtracter = function LinearComponentExtracter2() {
  this._lines = null;
  this._isForcedToLineString = false;
  if (arguments.length === 1) {
    var lines = arguments[0];
    this._lines = lines;
  } else if (arguments.length === 2) {
    var lines$1 = arguments[0];
    var isForcedToLineString = arguments[1];
    this._lines = lines$1;
    this._isForcedToLineString = isForcedToLineString;
  }
};
LinearComponentExtracter.prototype.filter = function filter9(geom) {
  if (this._isForcedToLineString && geom instanceof LinearRing) {
    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
    this._lines.add(line);
    return null;
  }
  if (geom instanceof LineString) {
    this._lines.add(geom);
  }
};
LinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString(isForcedToLineString) {
  this._isForcedToLineString = isForcedToLineString;
};
LinearComponentExtracter.prototype.interfaces_ = function interfaces_121() {
  return [GeometryComponentFilter];
};
LinearComponentExtracter.prototype.getClass = function getClass120() {
  return LinearComponentExtracter;
};
LinearComponentExtracter.getGeometry = function getGeometry() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var forceToLineString = arguments[1];
    return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString));
  }
};
LinearComponentExtracter.getLines = function getLines() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    return LinearComponentExtracter.getLines(geom, false);
  } else if (arguments.length === 2) {
    if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
      var geoms = arguments[0];
      var lines$1 = arguments[1];
      for (var i = geoms.iterator(); i.hasNext(); ) {
        var g = i.next();
        LinearComponentExtracter.getLines(g, lines$1);
      }
      return lines$1;
    } else if (arguments[0] instanceof Geometry && typeof arguments[1] === "boolean") {
      var geom$1 = arguments[0];
      var forceToLineString = arguments[1];
      var lines = new ArrayList();
      geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));
      return lines;
    } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
      var geom$2 = arguments[0];
      var lines$2 = arguments[1];
      if (geom$2 instanceof LineString) {
        lines$2.add(geom$2);
      } else {
        geom$2.apply(new LinearComponentExtracter(lines$2));
      }
      return lines$2;
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === "boolean" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {
      var geoms$1 = arguments[0];
      var lines$3 = arguments[1];
      var forceToLineString$1 = arguments[2];
      for (var i$1 = geoms$1.iterator(); i$1.hasNext(); ) {
        var g$1 = i$1.next();
        LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);
      }
      return lines$3;
    } else if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {
      var geom$3 = arguments[0];
      var lines$4 = arguments[1];
      var forceToLineString$2 = arguments[2];
      geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));
      return lines$4;
    }
  }
};
var PointLocator = function PointLocator2() {
  this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
  this._isIn = null;
  this._numBoundaries = null;
  if (arguments.length === 0)
    ;
  else if (arguments.length === 1) {
    var boundaryRule = arguments[0];
    if (boundaryRule === null) {
      throw new IllegalArgumentException("Rule must be non-null");
    }
    this._boundaryRule = boundaryRule;
  }
};
PointLocator.prototype.locateInternal = function locateInternal() {
  var this$1$1 = this;
  if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon$2) {
    var p = arguments[0];
    var poly = arguments[1];
    if (poly.isEmpty()) {
      return Location.EXTERIOR;
    }
    var shell = poly.getExteriorRing();
    var shellLoc = this.locateInPolygonRing(p, shell);
    if (shellLoc === Location.EXTERIOR) {
      return Location.EXTERIOR;
    }
    if (shellLoc === Location.BOUNDARY) {
      return Location.BOUNDARY;
    }
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
      var hole = poly.getInteriorRingN(i);
      var holeLoc = this$1$1.locateInPolygonRing(p, hole);
      if (holeLoc === Location.INTERIOR) {
        return Location.EXTERIOR;
      }
      if (holeLoc === Location.BOUNDARY) {
        return Location.BOUNDARY;
      }
    }
    return Location.INTERIOR;
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {
    var p$1 = arguments[0];
    var l = arguments[1];
    if (!l.getEnvelopeInternal().intersects(p$1)) {
      return Location.EXTERIOR;
    }
    var pt = l.getCoordinates();
    if (!l.isClosed()) {
      if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {
        return Location.BOUNDARY;
      }
    }
    if (CGAlgorithms.isOnLine(p$1, pt)) {
      return Location.INTERIOR;
    }
    return Location.EXTERIOR;
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point$2) {
    var p$2 = arguments[0];
    var pt$1 = arguments[1];
    var ptCoord = pt$1.getCoordinate();
    if (ptCoord.equals2D(p$2)) {
      return Location.INTERIOR;
    }
    return Location.EXTERIOR;
  }
};
PointLocator.prototype.locateInPolygonRing = function locateInPolygonRing(p, ring) {
  if (!ring.getEnvelopeInternal().intersects(p)) {
    return Location.EXTERIOR;
  }
  return CGAlgorithms.locatePointInRing(p, ring.getCoordinates());
};
PointLocator.prototype.intersects = function intersects5(p, geom) {
  return this.locate(p, geom) !== Location.EXTERIOR;
};
PointLocator.prototype.updateLocationInfo = function updateLocationInfo(loc) {
  if (loc === Location.INTERIOR) {
    this._isIn = true;
  }
  if (loc === Location.BOUNDARY) {
    this._numBoundaries++;
  }
};
PointLocator.prototype.computeLocation = function computeLocation(p, geom) {
  var this$1$1 = this;
  if (geom instanceof Point$2) {
    this.updateLocationInfo(this.locateInternal(p, geom));
  }
  if (geom instanceof LineString) {
    this.updateLocationInfo(this.locateInternal(p, geom));
  } else if (geom instanceof Polygon$2) {
    this.updateLocationInfo(this.locateInternal(p, geom));
  } else if (geom instanceof MultiLineString) {
    var ml = geom;
    for (var i = 0; i < ml.getNumGeometries(); i++) {
      var l = ml.getGeometryN(i);
      this$1$1.updateLocationInfo(this$1$1.locateInternal(p, l));
    }
  } else if (geom instanceof MultiPolygon) {
    var mpoly = geom;
    for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {
      var poly = mpoly.getGeometryN(i$1);
      this$1$1.updateLocationInfo(this$1$1.locateInternal(p, poly));
    }
  } else if (geom instanceof GeometryCollection) {
    var geomi = new GeometryCollectionIterator(geom);
    while (geomi.hasNext()) {
      var g2 = geomi.next();
      if (g2 !== geom) {
        this$1$1.computeLocation(p, g2);
      }
    }
  }
};
PointLocator.prototype.locate = function locate4(p, geom) {
  if (geom.isEmpty()) {
    return Location.EXTERIOR;
  }
  if (geom instanceof LineString) {
    return this.locateInternal(p, geom);
  } else if (geom instanceof Polygon$2) {
    return this.locateInternal(p, geom);
  }
  this._isIn = false;
  this._numBoundaries = 0;
  this.computeLocation(p, geom);
  if (this._boundaryRule.isInBoundary(this._numBoundaries)) {
    return Location.BOUNDARY;
  }
  if (this._numBoundaries > 0 || this._isIn) {
    return Location.INTERIOR;
  }
  return Location.EXTERIOR;
};
PointLocator.prototype.interfaces_ = function interfaces_122() {
  return [];
};
PointLocator.prototype.getClass = function getClass121() {
  return PointLocator;
};
var GeometryLocation = function GeometryLocation2() {
  this._component = null;
  this._segIndex = null;
  this._pt = null;
  if (arguments.length === 2) {
    var component = arguments[0];
    var pt = arguments[1];
    GeometryLocation2.call(this, component, GeometryLocation2.INSIDE_AREA, pt);
  } else if (arguments.length === 3) {
    var component$1 = arguments[0];
    var segIndex = arguments[1];
    var pt$1 = arguments[2];
    this._component = component$1;
    this._segIndex = segIndex;
    this._pt = pt$1;
  }
};
var staticAccessors$38 = { INSIDE_AREA: { configurable: true } };
GeometryLocation.prototype.isInsideArea = function isInsideArea() {
  return this._segIndex === GeometryLocation.INSIDE_AREA;
};
GeometryLocation.prototype.getCoordinate = function getCoordinate15() {
  return this._pt;
};
GeometryLocation.prototype.getGeometryComponent = function getGeometryComponent() {
  return this._component;
};
GeometryLocation.prototype.getSegmentIndex = function getSegmentIndex2() {
  return this._segIndex;
};
GeometryLocation.prototype.interfaces_ = function interfaces_123() {
  return [];
};
GeometryLocation.prototype.getClass = function getClass122() {
  return GeometryLocation;
};
staticAccessors$38.INSIDE_AREA.get = function() {
  return -1;
};
Object.defineProperties(GeometryLocation, staticAccessors$38);
var PointExtracter = function PointExtracter2(pts) {
  this._pts = pts || null;
};
PointExtracter.prototype.filter = function filter10(geom) {
  if (geom instanceof Point$2) {
    this._pts.add(geom);
  }
};
PointExtracter.prototype.interfaces_ = function interfaces_124() {
  return [GeometryFilter];
};
PointExtracter.prototype.getClass = function getClass123() {
  return PointExtracter;
};
PointExtracter.getPoints = function getPoints() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    if (geom instanceof Point$2) {
      return Collections.singletonList(geom);
    }
    return PointExtracter.getPoints(geom, new ArrayList());
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var list = arguments[1];
    if (geom$1 instanceof Point$2) {
      list.add(geom$1);
    } else if (geom$1 instanceof GeometryCollection) {
      geom$1.apply(new PointExtracter(list));
    }
    return list;
  }
};
var ConnectedElementLocationFilter = function ConnectedElementLocationFilter2() {
  this._locations = null;
  var locations = arguments[0];
  this._locations = locations;
};
ConnectedElementLocationFilter.prototype.filter = function filter11(geom) {
  if (geom instanceof Point$2 || geom instanceof LineString || geom instanceof Polygon$2) {
    this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));
  }
};
ConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_125() {
  return [GeometryFilter];
};
ConnectedElementLocationFilter.prototype.getClass = function getClass124() {
  return ConnectedElementLocationFilter;
};
ConnectedElementLocationFilter.getLocations = function getLocations2(geom) {
  var locations = new ArrayList();
  geom.apply(new ConnectedElementLocationFilter(locations));
  return locations;
};
var DistanceOp = function DistanceOp2() {
  this._geom = null;
  this._terminateDistance = 0;
  this._ptLocator = new PointLocator();
  this._minDistanceLocation = null;
  this._minDistance = Double.MAX_VALUE;
  if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    this._geom = [g0, g1];
    this._terminateDistance = 0;
  } else if (arguments.length === 3) {
    var g0$1 = arguments[0];
    var g1$1 = arguments[1];
    var terminateDistance = arguments[2];
    this._geom = new Array(2).fill(null);
    this._geom[0] = g0$1;
    this._geom[1] = g1$1;
    this._terminateDistance = terminateDistance;
  }
};
DistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    var locPtPoly = new Array(2).fill(null);
    this.computeContainmentDistance(0, locPtPoly);
    if (this._minDistance <= this._terminateDistance) {
      return null;
    }
    this.computeContainmentDistance(1, locPtPoly);
  } else if (arguments.length === 2) {
    var polyGeomIndex = arguments[0];
    var locPtPoly$1 = arguments[1];
    var locationsIndex = 1 - polyGeomIndex;
    var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);
    if (polys.size() > 0) {
      var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
      this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);
      if (this._minDistance <= this._terminateDistance) {
        this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];
        this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];
        return null;
      }
    }
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
      var locs = arguments[0];
      var polys$1 = arguments[1];
      var locPtPoly$2 = arguments[2];
      for (var i = 0; i < locs.size(); i++) {
        var loc = locs.get(i);
        for (var j = 0; j < polys$1.size(); j++) {
          this$1$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);
          if (this$1$1._minDistance <= this$1$1._terminateDistance) {
            return null;
          }
        }
      }
    } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon$2)) {
      var ptLoc = arguments[0];
      var poly = arguments[1];
      var locPtPoly$3 = arguments[2];
      var pt = ptLoc.getCoordinate();
      if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
        this._minDistance = 0;
        locPtPoly$3[0] = ptLoc;
        locPtPoly$3[1] = new GeometryLocation(poly, pt);
        return null;
      }
    }
  }
};
DistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints(lines, points2, locGeom) {
  var this$1$1 = this;
  for (var i = 0; i < lines.size(); i++) {
    var line = lines.get(i);
    for (var j = 0; j < points2.size(); j++) {
      var pt = points2.get(j);
      this$1$1.computeMinDistance(line, pt, locGeom);
      if (this$1$1._minDistance <= this$1$1._terminateDistance) {
        return null;
      }
    }
  }
};
DistanceOp.prototype.computeFacetDistance = function computeFacetDistance() {
  var locGeom = new Array(2).fill(null);
  var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
  var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
  var pts0 = PointExtracter.getPoints(this._geom[0]);
  var pts1 = PointExtracter.getPoints(this._geom[1]);
  this.computeMinDistanceLines(lines0, lines1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this._minDistance <= this._terminateDistance) {
    return null;
  }
  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this._minDistance <= this._terminateDistance) {
    return null;
  }
  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
  this.updateMinDistance(locGeom, true);
  if (this._minDistance <= this._terminateDistance) {
    return null;
  }
  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistancePoints(pts0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
};
DistanceOp.prototype.nearestLocations = function nearestLocations() {
  this.computeMinDistance();
  return this._minDistanceLocation;
};
DistanceOp.prototype.updateMinDistance = function updateMinDistance(locGeom, flip4) {
  if (locGeom[0] === null) {
    return null;
  }
  if (flip4) {
    this._minDistanceLocation[0] = locGeom[1];
    this._minDistanceLocation[1] = locGeom[0];
  } else {
    this._minDistanceLocation[0] = locGeom[0];
    this._minDistanceLocation[1] = locGeom[1];
  }
};
DistanceOp.prototype.nearestPoints = function nearestPoints() {
  this.computeMinDistance();
  var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
  return nearestPts;
};
DistanceOp.prototype.computeMinDistance = function computeMinDistance() {
  var this$1$1 = this;
  if (arguments.length === 0) {
    if (this._minDistanceLocation !== null) {
      return null;
    }
    this._minDistanceLocation = new Array(2).fill(null);
    this.computeContainmentDistance();
    if (this._minDistance <= this._terminateDistance) {
      return null;
    }
    this.computeFacetDistance();
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point$2)) {
      var line = arguments[0];
      var pt = arguments[1];
      var locGeom = arguments[2];
      if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) {
        return null;
      }
      var coord0 = line.getCoordinates();
      var coord = pt.getCoordinate();
      for (var i = 0; i < coord0.length - 1; i++) {
        var dist3 = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
        if (dist3 < this$1$1._minDistance) {
          this$1$1._minDistance = dist3;
          var seg = new LineSegment(coord0[i], coord0[i + 1]);
          var segClosestPoint = seg.closestPoint(coord);
          locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
          locGeom[1] = new GeometryLocation(pt, 0, coord);
        }
        if (this$1$1._minDistance <= this$1$1._terminateDistance) {
          return null;
        }
      }
    } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {
      var line0 = arguments[0];
      var line1 = arguments[1];
      var locGeom$1 = arguments[2];
      if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) {
        return null;
      }
      var coord0$1 = line0.getCoordinates();
      var coord1 = line1.getCoordinates();
      for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {
        for (var j = 0; j < coord1.length - 1; j++) {
          var dist$12 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);
          if (dist$12 < this$1$1._minDistance) {
            this$1$1._minDistance = dist$12;
            var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);
            var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
            var closestPt = seg0.closestPoints(seg1);
            locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);
            locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);
          }
          if (this$1$1._minDistance <= this$1$1._terminateDistance) {
            return null;
          }
        }
      }
    }
  }
};
DistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints(points0, points1, locGeom) {
  var this$1$1 = this;
  for (var i = 0; i < points0.size(); i++) {
    var pt02 = points0.get(i);
    for (var j = 0; j < points1.size(); j++) {
      var pt12 = points1.get(j);
      var dist3 = pt02.getCoordinate().distance(pt12.getCoordinate());
      if (dist3 < this$1$1._minDistance) {
        this$1$1._minDistance = dist3;
        locGeom[0] = new GeometryLocation(pt02, 0, pt02.getCoordinate());
        locGeom[1] = new GeometryLocation(pt12, 0, pt12.getCoordinate());
      }
      if (this$1$1._minDistance <= this$1$1._terminateDistance) {
        return null;
      }
    }
  }
};
DistanceOp.prototype.distance = function distance6() {
  if (this._geom[0] === null || this._geom[1] === null) {
    throw new IllegalArgumentException("null geometries are not supported");
  }
  if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) {
    return 0;
  }
  this.computeMinDistance();
  return this._minDistance;
};
DistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines(lines0, lines1, locGeom) {
  var this$1$1 = this;
  for (var i = 0; i < lines0.size(); i++) {
    var line0 = lines0.get(i);
    for (var j = 0; j < lines1.size(); j++) {
      var line1 = lines1.get(j);
      this$1$1.computeMinDistance(line0, line1, locGeom);
      if (this$1$1._minDistance <= this$1$1._terminateDistance) {
        return null;
      }
    }
  }
};
DistanceOp.prototype.interfaces_ = function interfaces_126() {
  return [];
};
DistanceOp.prototype.getClass = function getClass125() {
  return DistanceOp;
};
DistanceOp.distance = function distance7(g0, g1) {
  var distOp = new DistanceOp(g0, g1);
  return distOp.distance();
};
DistanceOp.isWithinDistance = function isWithinDistance(g0, g1, distance11) {
  var distOp = new DistanceOp(g0, g1, distance11);
  return distOp.distance() <= distance11;
};
DistanceOp.nearestPoints = function nearestPoints2(g0, g1) {
  var distOp = new DistanceOp(g0, g1);
  return distOp.nearestPoints();
};
var PointPairDistance$2 = function PointPairDistance3() {
  this._pt = [new Coordinate(), new Coordinate()];
  this._distance = Double.NaN;
  this._isNull = true;
};
PointPairDistance$2.prototype.getCoordinates = function getCoordinates8() {
  return this._pt;
};
PointPairDistance$2.prototype.getCoordinate = function getCoordinate16(i) {
  return this._pt[i];
};
PointPairDistance$2.prototype.setMinimum = function setMinimum2() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist3 = p0.distance(p1);
    if (dist3 < this._distance) {
      this.initialize(p0, p1, dist3);
    }
  }
};
PointPairDistance$2.prototype.initialize = function initialize2() {
  if (arguments.length === 0) {
    this._isNull = true;
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    this._pt[0].setCoordinate(p0);
    this._pt[1].setCoordinate(p1);
    this._distance = p0.distance(p1);
    this._isNull = false;
  } else if (arguments.length === 3) {
    var p0$1 = arguments[0];
    var p1$1 = arguments[1];
    var distance11 = arguments[2];
    this._pt[0].setCoordinate(p0$1);
    this._pt[1].setCoordinate(p1$1);
    this._distance = distance11;
    this._isNull = false;
  }
};
PointPairDistance$2.prototype.toString = function toString21() {
  return WKTWriter.toLineString(this._pt[0], this._pt[1]);
};
PointPairDistance$2.prototype.getDistance = function getDistance4() {
  return this._distance;
};
PointPairDistance$2.prototype.setMaximum = function setMaximum2() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist3 = p0.distance(p1);
    if (dist3 > this._distance) {
      this.initialize(p0, p1, dist3);
    }
  }
};
PointPairDistance$2.prototype.interfaces_ = function interfaces_127() {
  return [];
};
PointPairDistance$2.prototype.getClass = function getClass126() {
  return PointPairDistance$2;
};
var DistanceToPoint = function DistanceToPoint2() {
};
DistanceToPoint.prototype.interfaces_ = function interfaces_128() {
  return [];
};
DistanceToPoint.prototype.getClass = function getClass127() {
  return DistanceToPoint;
};
DistanceToPoint.computeDistance = function computeDistance2() {
  if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {
    var line = arguments[0];
    var pt = arguments[1];
    var ptDist = arguments[2];
    var tempSegment = new LineSegment();
    var coords = line.getCoordinates();
    for (var i = 0; i < coords.length - 1; i++) {
      tempSegment.setCoordinates(coords[i], coords[i + 1]);
      var closestPt = tempSegment.closestPoint(pt);
      ptDist.setMinimum(closestPt, pt);
    }
  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon$2 && arguments[1] instanceof Coordinate)) {
    var poly = arguments[0];
    var pt$1 = arguments[1];
    var ptDist$1 = arguments[2];
    DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
      DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
    }
  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
    var geom = arguments[0];
    var pt$2 = arguments[1];
    var ptDist$2 = arguments[2];
    if (geom instanceof LineString) {
      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof Polygon$2) {
      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof GeometryCollection) {
      var gc = geom;
      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
        var g = gc.getGeometryN(i$2);
        DistanceToPoint.computeDistance(g, pt$2, ptDist$2);
      }
    } else {
      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
    }
  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
    var segment = arguments[0];
    var pt$3 = arguments[1];
    var ptDist$3 = arguments[2];
    var closestPt$1 = segment.closestPoint(pt$3);
    ptDist$3.setMinimum(closestPt$1, pt$3);
  }
};
var DiscreteHausdorffDistance = function DiscreteHausdorffDistance2() {
  this._g0 = null;
  this._g1 = null;
  this._ptDist = new PointPairDistance$2();
  this._densifyFrac = 0;
  var g0 = arguments[0];
  var g1 = arguments[1];
  this._g0 = g0;
  this._g1 = g1;
};
var staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
DiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates9() {
  return this._ptDist.getCoordinates();
};
DiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction(densifyFrac) {
  if (densifyFrac > 1 || densifyFrac <= 0) {
    throw new IllegalArgumentException("Fraction is not in range (0.0 - 1.0]");
  }
  this._densifyFrac = densifyFrac;
};
DiscreteHausdorffDistance.prototype.compute = function compute(g0, g1) {
  this.computeOrientedDistance(g0, g1, this._ptDist);
  this.computeOrientedDistance(g1, g0, this._ptDist);
};
DiscreteHausdorffDistance.prototype.distance = function distance8() {
  this.compute(this._g0, this._g1);
  return this._ptDist.getDistance();
};
DiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance(discreteGeom, geom, ptDist) {
  var distFilter = new MaxPointDistanceFilter$1(geom);
  discreteGeom.apply(distFilter);
  ptDist.setMaximum(distFilter.getMaxPointDistance());
  if (this._densifyFrac > 0) {
    var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
    discreteGeom.apply(fracFilter);
    ptDist.setMaximum(fracFilter.getMaxPointDistance());
  }
};
DiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance() {
  this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
  return this._ptDist.getDistance();
};
DiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_129() {
  return [];
};
DiscreteHausdorffDistance.prototype.getClass = function getClass128() {
  return DiscreteHausdorffDistance;
};
DiscreteHausdorffDistance.distance = function distance9() {
  if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    var dist3 = new DiscreteHausdorffDistance(g0, g1);
    return dist3.distance();
  } else if (arguments.length === 3) {
    var g0$1 = arguments[0];
    var g1$1 = arguments[1];
    var densifyFrac = arguments[2];
    var dist$12 = new DiscreteHausdorffDistance(g0$1, g1$1);
    dist$12.setDensifyFraction(densifyFrac);
    return dist$12.distance();
  }
};
staticAccessors$39.MaxPointDistanceFilter.get = function() {
  return MaxPointDistanceFilter$1;
};
staticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function() {
  return MaxDensifiedByFractionDistanceFilter;
};
Object.defineProperties(DiscreteHausdorffDistance, staticAccessors$39);
var MaxPointDistanceFilter$1 = function MaxPointDistanceFilter3() {
  this._maxPtDist = new PointPairDistance$2();
  this._minPtDist = new PointPairDistance$2();
  this._euclideanDist = new DistanceToPoint();
  this._geom = null;
  var geom = arguments[0];
  this._geom = geom;
};
MaxPointDistanceFilter$1.prototype.filter = function filter12(pt) {
  this._minPtDist.initialize();
  DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
  this._maxPtDist.setMaximum(this._minPtDist);
};
MaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance3() {
  return this._maxPtDist;
};
MaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_130() {
  return [CoordinateFilter];
};
MaxPointDistanceFilter$1.prototype.getClass = function getClass129() {
  return MaxPointDistanceFilter$1;
};
var MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter2() {
  this._maxPtDist = new PointPairDistance$2();
  this._minPtDist = new PointPairDistance$2();
  this._geom = null;
  this._numSubSegs = 0;
  var geom = arguments[0];
  var fraction = arguments[1];
  this._geom = geom;
  this._numSubSegs = Math.trunc(Math.round(1 / fraction));
};
MaxDensifiedByFractionDistanceFilter.prototype.filter = function filter13(seq, index2) {
  var this$1$1 = this;
  if (index2 === 0) {
    return null;
  }
  var p0 = seq.getCoordinate(index2 - 1);
  var p1 = seq.getCoordinate(index2);
  var delx = (p1.x - p0.x) / this._numSubSegs;
  var dely = (p1.y - p0.y) / this._numSubSegs;
  for (var i = 0; i < this._numSubSegs; i++) {
    var x2 = p0.x + i * delx;
    var y2 = p0.y + i * dely;
    var pt = new Coordinate(x2, y2);
    this$1$1._minPtDist.initialize();
    DistanceToPoint.computeDistance(this$1$1._geom, pt, this$1$1._minPtDist);
    this$1$1._maxPtDist.setMaximum(this$1$1._minPtDist);
  }
};
MaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone6() {
  return false;
};
MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged3() {
  return false;
};
MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance4() {
  return this._maxPtDist;
};
MaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_131() {
  return [CoordinateSequenceFilter];
};
MaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass130() {
  return MaxDensifiedByFractionDistanceFilter;
};
var BufferDistanceValidator = function BufferDistanceValidator2(input, bufDistance, result) {
  this._minValidDistance = null;
  this._maxValidDistance = null;
  this._minDistanceFound = null;
  this._maxDistanceFound = null;
  this._isValid = true;
  this._errMsg = null;
  this._errorLocation = null;
  this._errorIndicator = null;
  this._input = input || null;
  this._bufDistance = bufDistance || null;
  this._result = result || null;
};
var staticAccessors$37 = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
BufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance(input, bufCurve, maxDist) {
  var haus = new DiscreteHausdorffDistance(bufCurve, input);
  haus.setDensifyFraction(0.25);
  this._maxDistanceFound = haus.orientedDistance();
  if (this._maxDistanceFound > maxDist) {
    this._isValid = false;
    var pts = haus.getCoordinates();
    this._errorLocation = pts[1];
    this._errorIndicator = input.getFactory().createLineString(pts);
    this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + WKTWriter.toLineString(pts[0], pts[1]) + ")";
  }
};
BufferDistanceValidator.prototype.isValid = function isValid() {
  var posDistance = Math.abs(this._bufDistance);
  var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;
  this._minValidDistance = posDistance - distDelta;
  this._maxValidDistance = posDistance + distDelta;
  if (this._input.isEmpty() || this._result.isEmpty()) {
    return true;
  }
  if (this._bufDistance > 0) {
    this.checkPositiveValid();
  } else {
    this.checkNegativeValid();
  }
  if (BufferDistanceValidator.VERBOSE) {
    System.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1));
  }
  return this._isValid;
};
BufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid() {
  if (!(this._input instanceof Polygon$2 || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {
    return null;
  }
  var inputCurve = this.getPolygonLines(this._input);
  this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);
  if (!this._isValid) {
    return null;
  }
  this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);
};
BufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator() {
  return this._errorIndicator;
};
BufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance(g1, g2, minDist) {
  var distOp = new DistanceOp(g1, g2, minDist);
  this._minDistanceFound = distOp.distance();
  if (this._minDistanceFound < minDist) {
    this._isValid = false;
    var pts = distOp.nearestPoints();
    this._errorLocation = distOp.nearestPoints()[1];
    this._errorIndicator = g1.getFactory().createLineString(pts);
    this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + WKTWriter.toLineString(pts[0], pts[1]) + " )";
  }
};
BufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid() {
  var bufCurve = this._result.getBoundary();
  this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);
  if (!this._isValid) {
    return null;
  }
  this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);
};
BufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation() {
  return this._errorLocation;
};
BufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines(g) {
  var lines = new ArrayList();
  var lineExtracter = new LinearComponentExtracter(lines);
  var polys = PolygonExtracter.getPolygons(g);
  for (var i = polys.iterator(); i.hasNext(); ) {
    var poly = i.next();
    poly.apply(lineExtracter);
  }
  return g.getFactory().buildGeometry(lines);
};
BufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage() {
  return this._errMsg;
};
BufferDistanceValidator.prototype.interfaces_ = function interfaces_132() {
  return [];
};
BufferDistanceValidator.prototype.getClass = function getClass131() {
  return BufferDistanceValidator;
};
staticAccessors$37.VERBOSE.get = function() {
  return false;
};
staticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(BufferDistanceValidator, staticAccessors$37);
var BufferResultValidator = function BufferResultValidator2(input, distance11, result) {
  this._isValid = true;
  this._errorMsg = null;
  this._errorLocation = null;
  this._errorIndicator = null;
  this._input = input || null;
  this._distance = distance11 || null;
  this._result = result || null;
};
var staticAccessors$40 = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
BufferResultValidator.prototype.isValid = function isValid2() {
  this.checkPolygonal();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkExpectedEmpty();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkEnvelope();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkArea();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkDistance();
  return this._isValid;
};
BufferResultValidator.prototype.checkEnvelope = function checkEnvelope() {
  if (this._distance < 0) {
    return null;
  }
  var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;
  if (padding === 0) {
    padding = 1e-3;
  }
  var expectedEnv = new Envelope(this._input.getEnvelopeInternal());
  expectedEnv.expandBy(this._distance);
  var bufEnv = new Envelope(this._result.getEnvelopeInternal());
  bufEnv.expandBy(padding);
  if (!bufEnv.contains(expectedEnv)) {
    this._isValid = false;
    this._errorMsg = "Buffer envelope is incorrect";
    this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);
  }
  this.report("Envelope");
};
BufferResultValidator.prototype.checkDistance = function checkDistance() {
  var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);
  if (!distValid.isValid()) {
    this._isValid = false;
    this._errorMsg = distValid.getErrorMessage();
    this._errorLocation = distValid.getErrorLocation();
    this._errorIndicator = distValid.getErrorIndicator();
  }
  this.report("Distance");
};
BufferResultValidator.prototype.checkArea = function checkArea() {
  var inputArea = this._input.getArea();
  var resultArea = this._result.getArea();
  if (this._distance > 0 && inputArea > resultArea) {
    this._isValid = false;
    this._errorMsg = "Area of positive buffer is smaller than input";
    this._errorIndicator = this._result;
  }
  if (this._distance < 0 && inputArea < resultArea) {
    this._isValid = false;
    this._errorMsg = "Area of negative buffer is larger than input";
    this._errorIndicator = this._result;
  }
  this.report("Area");
};
BufferResultValidator.prototype.checkPolygonal = function checkPolygonal() {
  if (!(this._result instanceof Polygon$2 || this._result instanceof MultiPolygon)) {
    this._isValid = false;
  }
  this._errorMsg = "Result is not polygonal";
  this._errorIndicator = this._result;
  this.report("Polygonal");
};
BufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator2() {
  return this._errorIndicator;
};
BufferResultValidator.prototype.getErrorLocation = function getErrorLocation2() {
  return this._errorLocation;
};
BufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty() {
  if (this._input.getDimension() >= 2) {
    return null;
  }
  if (this._distance > 0) {
    return null;
  }
  if (!this._result.isEmpty()) {
    this._isValid = false;
    this._errorMsg = "Result is non-empty";
    this._errorIndicator = this._result;
  }
  this.report("ExpectedEmpty");
};
BufferResultValidator.prototype.report = function report(checkName) {
  if (!BufferResultValidator.VERBOSE) {
    return null;
  }
  System.out.println("Check " + checkName + ": " + (this._isValid ? "passed" : "FAILED"));
};
BufferResultValidator.prototype.getErrorMessage = function getErrorMessage2() {
  return this._errorMsg;
};
BufferResultValidator.prototype.interfaces_ = function interfaces_133() {
  return [];
};
BufferResultValidator.prototype.getClass = function getClass132() {
  return BufferResultValidator;
};
BufferResultValidator.isValidMsg = function isValidMsg(g, distance11, result) {
  var validator2 = new BufferResultValidator(g, distance11, result);
  if (!validator2.isValid()) {
    return validator2.getErrorMessage();
  }
  return null;
};
BufferResultValidator.isValid = function isValid3(g, distance11, result) {
  var validator2 = new BufferResultValidator(g, distance11, result);
  if (validator2.isValid()) {
    return true;
  }
  return false;
};
staticAccessors$40.VERBOSE.get = function() {
  return false;
};
staticAccessors$40.MAX_ENV_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(BufferResultValidator, staticAccessors$40);
var BasicSegmentString = function BasicSegmentString2() {
  this._pts = null;
  this._data = null;
  var pts = arguments[0];
  var data = arguments[1];
  this._pts = pts;
  this._data = data;
};
BasicSegmentString.prototype.getCoordinates = function getCoordinates10() {
  return this._pts;
};
BasicSegmentString.prototype.size = function size10() {
  return this._pts.length;
};
BasicSegmentString.prototype.getCoordinate = function getCoordinate17(i) {
  return this._pts[i];
};
BasicSegmentString.prototype.isClosed = function isClosed3() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
BasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant2(index2) {
  if (index2 === this._pts.length - 1) {
    return -1;
  }
  return Octant.octant(this.getCoordinate(index2), this.getCoordinate(index2 + 1));
};
BasicSegmentString.prototype.setData = function setData3(data) {
  this._data = data;
};
BasicSegmentString.prototype.getData = function getData3() {
  return this._data;
};
BasicSegmentString.prototype.toString = function toString22() {
  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
};
BasicSegmentString.prototype.interfaces_ = function interfaces_134() {
  return [SegmentString];
};
BasicSegmentString.prototype.getClass = function getClass133() {
  return BasicSegmentString;
};
var InteriorIntersectionFinder = function InteriorIntersectionFinder2() {
  this._findAllIntersections = false;
  this._isCheckEndSegmentsOnly = false;
  this._li = null;
  this._interiorIntersection = null;
  this._intSegments = null;
  this._intersections = new ArrayList();
  this._intersectionCount = 0;
  this._keepIntersections = true;
  var li = arguments[0];
  this._li = li;
  this._interiorIntersection = null;
};
InteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection() {
  return this._interiorIntersection;
};
InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
  this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
};
InteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments() {
  return this._intSegments;
};
InteriorIntersectionFinder.prototype.count = function count() {
  return this._intersectionCount;
};
InteriorIntersectionFinder.prototype.getIntersections = function getIntersections() {
  return this._intersections;
};
InteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {
  this._findAllIntersections = findAllIntersections;
};
InteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections(keepIntersections) {
  this._keepIntersections = keepIntersections;
};
InteriorIntersectionFinder.prototype.processIntersections = function processIntersections4(e0, segIndex0, e1, segIndex1) {
  if (!this._findAllIntersections && this.hasIntersection()) {
    return null;
  }
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  if (this._isCheckEndSegmentsOnly) {
    var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
    if (!isEndSegPresent) {
      return null;
    }
  }
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    if (this._li.isInteriorIntersection()) {
      this._intSegments = new Array(4).fill(null);
      this._intSegments[0] = p002;
      this._intSegments[1] = p012;
      this._intSegments[2] = p102;
      this._intSegments[3] = p112;
      this._interiorIntersection = this._li.getIntersection(0);
      if (this._keepIntersections) {
        this._intersections.add(this._interiorIntersection);
      }
      this._intersectionCount++;
    }
  }
};
InteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment(segStr, index2) {
  if (index2 === 0) {
    return true;
  }
  if (index2 >= segStr.size() - 2) {
    return true;
  }
  return false;
};
InteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection3() {
  return this._interiorIntersection !== null;
};
InteriorIntersectionFinder.prototype.isDone = function isDone7() {
  if (this._findAllIntersections) {
    return false;
  }
  return this._interiorIntersection !== null;
};
InteriorIntersectionFinder.prototype.interfaces_ = function interfaces_135() {
  return [SegmentIntersector];
};
InteriorIntersectionFinder.prototype.getClass = function getClass134() {
  return InteriorIntersectionFinder;
};
InteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder(li) {
  var finder = new InteriorIntersectionFinder(li);
  finder.setFindAllIntersections(true);
  return finder;
};
InteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder(li) {
  return new InteriorIntersectionFinder(li);
};
InteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter(li) {
  var finder = new InteriorIntersectionFinder(li);
  finder.setFindAllIntersections(true);
  finder.setKeepIntersections(false);
  return finder;
};
var FastNodingValidator = function FastNodingValidator2() {
  this._li = new RobustLineIntersector();
  this._segStrings = null;
  this._findAllIntersections = false;
  this._segInt = null;
  this._isValid = true;
  var segStrings = arguments[0];
  this._segStrings = segStrings;
};
FastNodingValidator.prototype.execute = function execute() {
  if (this._segInt !== null) {
    return null;
  }
  this.checkInteriorIntersections();
};
FastNodingValidator.prototype.getIntersections = function getIntersections2() {
  return this._segInt.getIntersections();
};
FastNodingValidator.prototype.isValid = function isValid4() {
  this.execute();
  return this._isValid;
};
FastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections2(findAllIntersections) {
  this._findAllIntersections = findAllIntersections;
};
FastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections2() {
  this._isValid = true;
  this._segInt = new InteriorIntersectionFinder(this._li);
  this._segInt.setFindAllIntersections(this._findAllIntersections);
  var noder = new MCIndexNoder();
  noder.setSegmentIntersector(this._segInt);
  noder.computeNodes(this._segStrings);
  if (this._segInt.hasIntersection()) {
    this._isValid = false;
    return null;
  }
};
FastNodingValidator.prototype.checkValid = function checkValid2() {
  this.execute();
  if (!this._isValid) {
    throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());
  }
};
FastNodingValidator.prototype.getErrorMessage = function getErrorMessage3() {
  if (this._isValid) {
    return "no intersections found";
  }
  var intSegs = this._segInt.getIntersectionSegments();
  return "found non-noded intersection between " + WKTWriter.toLineString(intSegs[0], intSegs[1]) + " and " + WKTWriter.toLineString(intSegs[2], intSegs[3]);
};
FastNodingValidator.prototype.interfaces_ = function interfaces_136() {
  return [];
};
FastNodingValidator.prototype.getClass = function getClass135() {
  return FastNodingValidator;
};
FastNodingValidator.computeIntersections = function computeIntersections(segStrings) {
  var nv = new FastNodingValidator(segStrings);
  nv.setFindAllIntersections(true);
  nv.isValid();
  return nv.getIntersections();
};
var EdgeNodingValidator = function EdgeNodingValidator2() {
  this._nv = null;
  var edges2 = arguments[0];
  this._nv = new FastNodingValidator(EdgeNodingValidator2.toSegmentStrings(edges2));
};
EdgeNodingValidator.prototype.checkValid = function checkValid3() {
  this._nv.checkValid();
};
EdgeNodingValidator.prototype.interfaces_ = function interfaces_137() {
  return [];
};
EdgeNodingValidator.prototype.getClass = function getClass136() {
  return EdgeNodingValidator;
};
EdgeNodingValidator.toSegmentStrings = function toSegmentStrings(edges2) {
  var segStrings = new ArrayList();
  for (var i = edges2.iterator(); i.hasNext(); ) {
    var e2 = i.next();
    segStrings.add(new BasicSegmentString(e2.getCoordinates(), e2));
  }
  return segStrings;
};
EdgeNodingValidator.checkValid = function checkValid4(edges2) {
  var validator2 = new EdgeNodingValidator(edges2);
  validator2.checkValid();
};
var GeometryCollectionMapper = function GeometryCollectionMapper2(mapOp) {
  this._mapOp = mapOp;
};
GeometryCollectionMapper.prototype.map = function map(gc) {
  var this$1$1 = this;
  var mapped = new ArrayList();
  for (var i = 0; i < gc.getNumGeometries(); i++) {
    var g = this$1$1._mapOp.map(gc.getGeometryN(i));
    if (!g.isEmpty()) {
      mapped.add(g);
    }
  }
  return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));
};
GeometryCollectionMapper.prototype.interfaces_ = function interfaces_138() {
  return [];
};
GeometryCollectionMapper.prototype.getClass = function getClass137() {
  return GeometryCollectionMapper;
};
GeometryCollectionMapper.map = function map2(gc, op) {
  var mapper = new GeometryCollectionMapper(op);
  return mapper.map(gc);
};
var LineBuilder = function LineBuilder2() {
  this._op = null;
  this._geometryFactory = null;
  this._ptLocator = null;
  this._lineEdgesList = new ArrayList();
  this._resultLineList = new ArrayList();
  var op = arguments[0];
  var geometryFactory = arguments[1];
  var ptLocator = arguments[2];
  this._op = op;
  this._geometryFactory = geometryFactory;
  this._ptLocator = ptLocator;
};
LineBuilder.prototype.collectLines = function collectLines(opCode) {
  var this$1$1 = this;
  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
    var de = it.next();
    this$1$1.collectLineEdge(de, opCode, this$1$1._lineEdgesList);
    this$1$1.collectBoundaryTouchEdge(de, opCode, this$1$1._lineEdgesList);
  }
};
LineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine(e2, targetIndex) {
  var loc = this._ptLocator.locate(e2.getCoordinate(), this._op.getArgGeometry(targetIndex));
  e2.getLabel().setLocation(targetIndex, loc);
};
LineBuilder.prototype.build = function build2(opCode) {
  this.findCoveredLineEdges();
  this.collectLines(opCode);
  this.buildLines(opCode);
  return this._resultLineList;
};
LineBuilder.prototype.collectLineEdge = function collectLineEdge(de, opCode, edges2) {
  var label = de.getLabel();
  var e2 = de.getEdge();
  if (de.isLineEdge()) {
    if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e2.isCovered()) {
      edges2.add(e2);
      de.setVisitedEdge(true);
    }
  }
};
LineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges() {
  var this$1$1 = this;
  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().findCoveredLineEdges();
  }
  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
    var de = it.next();
    var e2 = de.getEdge();
    if (de.isLineEdge() && !e2.isCoveredSet()) {
      var isCovered2 = this$1$1._op.isCoveredByA(de.getCoordinate());
      e2.setCovered(isCovered2);
    }
  }
};
LineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines(edgesList) {
  var this$1$1 = this;
  for (var it = edgesList.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    var label = e2.getLabel();
    if (e2.isIsolated()) {
      if (label.isNull(0)) {
        this$1$1.labelIsolatedLine(e2, 0);
      } else {
        this$1$1.labelIsolatedLine(e2, 1);
      }
    }
  }
};
LineBuilder.prototype.buildLines = function buildLines(opCode) {
  var this$1$1 = this;
  for (var it = this._lineEdgesList.iterator(); it.hasNext(); ) {
    var e2 = it.next();
    var line = this$1$1._geometryFactory.createLineString(e2.getCoordinates());
    this$1$1._resultLineList.add(line);
    e2.setInResult(true);
  }
};
LineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge(de, opCode, edges2) {
  var label = de.getLabel();
  if (de.isLineEdge()) {
    return null;
  }
  if (de.isVisited()) {
    return null;
  }
  if (de.isInteriorAreaEdge()) {
    return null;
  }
  if (de.getEdge().isInResult()) {
    return null;
  }
  Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
  if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
    edges2.add(de.getEdge());
    de.setVisitedEdge(true);
  }
};
LineBuilder.prototype.interfaces_ = function interfaces_139() {
  return [];
};
LineBuilder.prototype.getClass = function getClass138() {
  return LineBuilder;
};
var PointBuilder = function PointBuilder2() {
  this._op = null;
  this._geometryFactory = null;
  this._resultPointList = new ArrayList();
  var op = arguments[0];
  var geometryFactory = arguments[1];
  this._op = op;
  this._geometryFactory = geometryFactory;
};
PointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint(n) {
  var coord = n.getCoordinate();
  if (!this._op.isCoveredByLA(coord)) {
    var pt = this._geometryFactory.createPoint(coord);
    this._resultPointList.add(pt);
  }
};
PointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes(opCode) {
  var this$1$1 = this;
  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
    var n = nodeit.next();
    if (n.isInResult()) {
      continue;
    }
    if (n.isIncidentEdgeInResult()) {
      continue;
    }
    if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
      var label = n.getLabel();
      if (OverlayOp.isResultOfOp(label, opCode)) {
        this$1$1.filterCoveredNodeToPoint(n);
      }
    }
  }
};
PointBuilder.prototype.build = function build3(opCode) {
  this.extractNonCoveredResultNodes(opCode);
  return this._resultPointList;
};
PointBuilder.prototype.interfaces_ = function interfaces_140() {
  return [];
};
PointBuilder.prototype.getClass = function getClass139() {
  return PointBuilder;
};
var GeometryTransformer = function GeometryTransformer2() {
  this._inputGeom = null;
  this._factory = null;
  this._pruneEmptyGeometry = true;
  this._preserveGeometryCollectionType = true;
  this._preserveCollections = false;
  this._preserveType = false;
};
GeometryTransformer.prototype.transformPoint = function transformPoint(geom, parent) {
  return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
};
GeometryTransformer.prototype.transformPolygon = function transformPolygon(geom, parent) {
  var this$1$1 = this;
  var isAllValidLinearRings = true;
  var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
  if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) {
    isAllValidLinearRings = false;
  }
  var holes = new ArrayList();
  for (var i = 0; i < geom.getNumInteriorRing(); i++) {
    var hole = this$1$1.transformLinearRing(geom.getInteriorRingN(i), geom);
    if (hole === null || hole.isEmpty()) {
      continue;
    }
    if (!(hole instanceof LinearRing)) {
      isAllValidLinearRings = false;
    }
    holes.add(hole);
  }
  if (isAllValidLinearRings) {
    return this._factory.createPolygon(shell, holes.toArray([]));
  } else {
    var components = new ArrayList();
    if (shell !== null) {
      components.add(shell);
    }
    components.addAll(holes);
    return this._factory.buildGeometry(components);
  }
};
GeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence(coords) {
  return this._factory.getCoordinateSequenceFactory().create(coords);
};
GeometryTransformer.prototype.getInputGeometry = function getInputGeometry() {
  return this._inputGeom;
};
GeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString(geom, parent) {
  var this$1$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1$1.transformLineString(geom.getGeometryN(i), geom);
    if (transformGeom === null) {
      continue;
    }
    if (transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {
  return this.copy(coords);
};
GeometryTransformer.prototype.transformLineString = function transformLineString(geom, parent) {
  return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
};
GeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint(geom, parent) {
  var this$1$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1$1.transformPoint(geom.getGeometryN(i), geom);
    if (transformGeom === null) {
      continue;
    }
    if (transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon(geom, parent) {
  var this$1$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1$1.transformPolygon(geom.getGeometryN(i), geom);
    if (transformGeom === null) {
      continue;
    }
    if (transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.copy = function copy6(seq) {
  return seq.copy();
};
GeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection(geom, parent) {
  var this$1$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1$1.transform(geom.getGeometryN(i));
    if (transformGeom === null) {
      continue;
    }
    if (this$1$1._pruneEmptyGeometry && transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  if (this._preserveGeometryCollectionType) {
    return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.transform = function transform2(inputGeom) {
  this._inputGeom = inputGeom;
  this._factory = inputGeom.getFactory();
  if (inputGeom instanceof Point$2) {
    return this.transformPoint(inputGeom, null);
  }
  if (inputGeom instanceof MultiPoint) {
    return this.transformMultiPoint(inputGeom, null);
  }
  if (inputGeom instanceof LinearRing) {
    return this.transformLinearRing(inputGeom, null);
  }
  if (inputGeom instanceof LineString) {
    return this.transformLineString(inputGeom, null);
  }
  if (inputGeom instanceof MultiLineString) {
    return this.transformMultiLineString(inputGeom, null);
  }
  if (inputGeom instanceof Polygon$2) {
    return this.transformPolygon(inputGeom, null);
  }
  if (inputGeom instanceof MultiPolygon) {
    return this.transformMultiPolygon(inputGeom, null);
  }
  if (inputGeom instanceof GeometryCollection) {
    return this.transformGeometryCollection(inputGeom, null);
  }
  throw new IllegalArgumentException("Unknown Geometry subtype: " + inputGeom.getClass().getName());
};
GeometryTransformer.prototype.transformLinearRing = function transformLinearRing(geom, parent) {
  var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
  if (seq === null) {
    return this._factory.createLinearRing(null);
  }
  var seqSize = seq.size();
  if (seqSize > 0 && seqSize < 4 && !this._preserveType) {
    return this._factory.createLineString(seq);
  }
  return this._factory.createLinearRing(seq);
};
GeometryTransformer.prototype.interfaces_ = function interfaces_141() {
  return [];
};
GeometryTransformer.prototype.getClass = function getClass140() {
  return GeometryTransformer;
};
var LineStringSnapper = function LineStringSnapper2() {
  this._snapTolerance = 0;
  this._srcPts = null;
  this._seg = new LineSegment();
  this._allowSnappingToSourceVertices = false;
  this._isClosed = false;
  if (arguments[0] instanceof LineString && typeof arguments[1] === "number") {
    var srcLine = arguments[0];
    var snapTolerance = arguments[1];
    LineStringSnapper2.call(this, srcLine.getCoordinates(), snapTolerance);
  } else if (arguments[0] instanceof Array && typeof arguments[1] === "number") {
    var srcPts = arguments[0];
    var snapTolerance$1 = arguments[1];
    this._srcPts = srcPts;
    this._isClosed = LineStringSnapper2.isClosed(srcPts);
    this._snapTolerance = snapTolerance$1;
  }
};
LineStringSnapper.prototype.snapVertices = function snapVertices(srcCoords, snapPts) {
  var this$1$1 = this;
  var end2 = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
  for (var i = 0; i < end2; i++) {
    var srcPt = srcCoords.get(i);
    var snapVert = this$1$1.findSnapForVertex(srcPt, snapPts);
    if (snapVert !== null) {
      srcCoords.set(i, new Coordinate(snapVert));
      if (i === 0 && this$1$1._isClosed) {
        srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));
      }
    }
  }
};
LineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex(pt, snapPts) {
  var this$1$1 = this;
  for (var i = 0; i < snapPts.length; i++) {
    if (pt.equals2D(snapPts[i])) {
      return null;
    }
    if (pt.distance(snapPts[i]) < this$1$1._snapTolerance) {
      return snapPts[i];
    }
  }
  return null;
};
LineStringSnapper.prototype.snapTo = function snapTo(snapPts) {
  var coordList = new CoordinateList(this._srcPts);
  this.snapVertices(coordList, snapPts);
  this.snapSegments(coordList, snapPts);
  var newPts = coordList.toCoordinateArray();
  return newPts;
};
LineStringSnapper.prototype.snapSegments = function snapSegments(srcCoords, snapPts) {
  var this$1$1 = this;
  if (snapPts.length === 0) {
    return null;
  }
  var distinctPtCount = snapPts.length;
  if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) {
    distinctPtCount = snapPts.length - 1;
  }
  for (var i = 0; i < distinctPtCount; i++) {
    var snapPt = snapPts[i];
    var index2 = this$1$1.findSegmentIndexToSnap(snapPt, srcCoords);
    if (index2 >= 0) {
      srcCoords.add(index2 + 1, new Coordinate(snapPt), false);
    }
  }
};
LineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap(snapPt, srcCoords) {
  var this$1$1 = this;
  var minDist = Double.MAX_VALUE;
  var snapIndex = -1;
  for (var i = 0; i < srcCoords.size() - 1; i++) {
    this$1$1._seg.p0 = srcCoords.get(i);
    this$1$1._seg.p1 = srcCoords.get(i + 1);
    if (this$1$1._seg.p0.equals2D(snapPt) || this$1$1._seg.p1.equals2D(snapPt)) {
      if (this$1$1._allowSnappingToSourceVertices) {
        continue;
      } else {
        return -1;
      }
    }
    var dist3 = this$1$1._seg.distance(snapPt);
    if (dist3 < this$1$1._snapTolerance && dist3 < minDist) {
      minDist = dist3;
      snapIndex = i;
    }
  }
  return snapIndex;
};
LineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
  this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
};
LineStringSnapper.prototype.interfaces_ = function interfaces_142() {
  return [];
};
LineStringSnapper.prototype.getClass = function getClass141() {
  return LineStringSnapper;
};
LineStringSnapper.isClosed = function isClosed4(pts) {
  if (pts.length <= 1) {
    return false;
  }
  return pts[0].equals2D(pts[pts.length - 1]);
};
var GeometrySnapper = function GeometrySnapper2(srcGeom) {
  this._srcGeom = srcGeom || null;
};
var staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };
GeometrySnapper.prototype.snapTo = function snapTo2(snapGeom, snapTolerance) {
  var snapPts = this.extractTargetCoordinates(snapGeom);
  var snapTrans = new SnapTransformer(snapTolerance, snapPts);
  return snapTrans.transform(this._srcGeom);
};
GeometrySnapper.prototype.snapToSelf = function snapToSelf(snapTolerance, cleanResult) {
  var snapPts = this.extractTargetCoordinates(this._srcGeom);
  var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
  var snappedGeom = snapTrans.transform(this._srcGeom);
  var result = snappedGeom;
  if (cleanResult && hasInterface(result, Polygonal)) {
    result = snappedGeom.buffer(0);
  }
  return result;
};
GeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance(ringPts) {
  var minSegLen = this.computeMinimumSegmentLength(ringPts);
  var snapTol = minSegLen / 10;
  return snapTol;
};
GeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates(g) {
  var ptSet = new TreeSet();
  var pts = g.getCoordinates();
  for (var i = 0; i < pts.length; i++) {
    ptSet.add(pts[i]);
  }
  return ptSet.toArray(new Array(0).fill(null));
};
GeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength(pts) {
  var minSegLen = Double.MAX_VALUE;
  for (var i = 0; i < pts.length - 1; i++) {
    var segLen = pts[i].distance(pts[i + 1]);
    if (segLen < minSegLen) {
      minSegLen = segLen;
    }
  }
  return minSegLen;
};
GeometrySnapper.prototype.interfaces_ = function interfaces_143() {
  return [];
};
GeometrySnapper.prototype.getClass = function getClass142() {
  return GeometrySnapper;
};
GeometrySnapper.snap = function snap2(g0, g1, snapTolerance) {
  var snapGeom = new Array(2).fill(null);
  var snapper0 = new GeometrySnapper(g0);
  snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
  var snapper1 = new GeometrySnapper(g1);
  snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
  return snapGeom;
};
GeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance() {
  if (arguments.length === 1) {
    var g = arguments[0];
    var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
    var pm = g.getPrecisionModel();
    if (pm.getType() === PrecisionModel.FIXED) {
      var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
      if (fixedSnapTol > snapTolerance) {
        snapTolerance = fixedSnapTol;
      }
    }
    return snapTolerance;
  } else if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
  }
};
GeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance(g) {
  var env2 = g.getEnvelopeInternal();
  var minDimension = Math.min(env2.getHeight(), env2.getWidth());
  var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
  return snapTol;
};
GeometrySnapper.snapToSelf = function snapToSelf2(geom, snapTolerance, cleanResult) {
  var snapper0 = new GeometrySnapper(geom);
  return snapper0.snapToSelf(snapTolerance, cleanResult);
};
staticAccessors$41.SNAP_PRECISION_FACTOR.get = function() {
  return 1e-9;
};
Object.defineProperties(GeometrySnapper, staticAccessors$41);
var SnapTransformer = function(GeometryTransformer$$1) {
  function SnapTransformer2(snapTolerance, snapPts, isSelfSnap) {
    GeometryTransformer$$1.call(this);
    this._snapTolerance = snapTolerance || null;
    this._snapPts = snapPts || null;
    this._isSelfSnap = isSelfSnap !== void 0 ? isSelfSnap : false;
  }
  if (GeometryTransformer$$1)
    SnapTransformer2.__proto__ = GeometryTransformer$$1;
  SnapTransformer2.prototype = Object.create(GeometryTransformer$$1 && GeometryTransformer$$1.prototype);
  SnapTransformer2.prototype.constructor = SnapTransformer2;
  SnapTransformer2.prototype.snapLine = function snapLine(srcPts, snapPts) {
    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
    return snapper.snapTo(snapPts);
  };
  SnapTransformer2.prototype.transformCoordinates = function transformCoordinates2(coords, parent) {
    var srcPts = coords.toCoordinateArray();
    var newPts = this.snapLine(srcPts, this._snapPts);
    return this._factory.getCoordinateSequenceFactory().create(newPts);
  };
  SnapTransformer2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  SnapTransformer2.prototype.getClass = function getClass169() {
    return SnapTransformer2;
  };
  return SnapTransformer2;
}(GeometryTransformer);
var CommonBits = function CommonBits2() {
  this._isFirst = true;
  this._commonMantissaBitsCount = 53;
  this._commonBits = 0;
  this._commonSignExp = null;
};
CommonBits.prototype.getCommon = function getCommon() {
  return Double.longBitsToDouble(this._commonBits);
};
CommonBits.prototype.add = function add13(num) {
  var numBits = Double.doubleToLongBits(num);
  if (this._isFirst) {
    this._commonBits = numBits;
    this._commonSignExp = CommonBits.signExpBits(this._commonBits);
    this._isFirst = false;
    return null;
  }
  var numSignExp = CommonBits.signExpBits(numBits);
  if (numSignExp !== this._commonSignExp) {
    this._commonBits = 0;
    return null;
  }
  this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
  this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
};
CommonBits.prototype.toString = function toString23() {
  if (arguments.length === 1) {
    var bits = arguments[0];
    var x2 = Double.longBitsToDouble(bits);
    var numStr = Double.toBinaryString(bits);
    var padStr = "0000000000000000000000000000000000000000000000000000000000000000" + numStr;
    var bitStr = padStr.substring(padStr.length - 64);
    var str = bitStr.substring(0, 1) + "  " + bitStr.substring(1, 12) + "(exp) " + bitStr.substring(12) + " [ " + x2 + " ]";
    return str;
  }
};
CommonBits.prototype.interfaces_ = function interfaces_144() {
  return [];
};
CommonBits.prototype.getClass = function getClass143() {
  return CommonBits;
};
CommonBits.getBit = function getBit(bits, i) {
  var mask2 = 1 << i;
  return (bits & mask2) !== 0 ? 1 : 0;
};
CommonBits.signExpBits = function signExpBits(num) {
  return num >> 52;
};
CommonBits.zeroLowerBits = function zeroLowerBits(bits, nBits) {
  var invMask = (1 << nBits) - 1;
  var mask2 = ~invMask;
  var zeroed = bits & mask2;
  return zeroed;
};
CommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits(num1, num2) {
  var count3 = 0;
  for (var i = 52; i >= 0; i--) {
    if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) {
      return count3;
    }
    count3++;
  }
  return 52;
};
var CommonBitsRemover = function CommonBitsRemover2() {
  this._commonCoord = null;
  this._ccFilter = new CommonCoordinateFilter();
};
var staticAccessors$42 = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
CommonBitsRemover.prototype.addCommonBits = function addCommonBits(geom) {
  var trans = new Translater(this._commonCoord);
  geom.apply(trans);
  geom.geometryChanged();
};
CommonBitsRemover.prototype.removeCommonBits = function removeCommonBits(geom) {
  if (this._commonCoord.x === 0 && this._commonCoord.y === 0) {
    return geom;
  }
  var invCoord = new Coordinate(this._commonCoord);
  invCoord.x = -invCoord.x;
  invCoord.y = -invCoord.y;
  var trans = new Translater(invCoord);
  geom.apply(trans);
  geom.geometryChanged();
  return geom;
};
CommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate() {
  return this._commonCoord;
};
CommonBitsRemover.prototype.add = function add14(geom) {
  geom.apply(this._ccFilter);
  this._commonCoord = this._ccFilter.getCommonCoordinate();
};
CommonBitsRemover.prototype.interfaces_ = function interfaces_145() {
  return [];
};
CommonBitsRemover.prototype.getClass = function getClass144() {
  return CommonBitsRemover;
};
staticAccessors$42.CommonCoordinateFilter.get = function() {
  return CommonCoordinateFilter;
};
staticAccessors$42.Translater.get = function() {
  return Translater;
};
Object.defineProperties(CommonBitsRemover, staticAccessors$42);
var CommonCoordinateFilter = function CommonCoordinateFilter2() {
  this._commonBitsX = new CommonBits();
  this._commonBitsY = new CommonBits();
};
CommonCoordinateFilter.prototype.filter = function filter14(coord) {
  this._commonBitsX.add(coord.x);
  this._commonBitsY.add(coord.y);
};
CommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate2() {
  return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
};
CommonCoordinateFilter.prototype.interfaces_ = function interfaces_146() {
  return [CoordinateFilter];
};
CommonCoordinateFilter.prototype.getClass = function getClass145() {
  return CommonCoordinateFilter;
};
var Translater = function Translater2() {
  this.trans = null;
  var trans = arguments[0];
  this.trans = trans;
};
Translater.prototype.filter = function filter15(seq, i) {
  var xp = seq.getOrdinate(i, 0) + this.trans.x;
  var yp = seq.getOrdinate(i, 1) + this.trans.y;
  seq.setOrdinate(i, 0, xp);
  seq.setOrdinate(i, 1, yp);
};
Translater.prototype.isDone = function isDone8() {
  return false;
};
Translater.prototype.isGeometryChanged = function isGeometryChanged4() {
  return true;
};
Translater.prototype.interfaces_ = function interfaces_147() {
  return [CoordinateSequenceFilter];
};
Translater.prototype.getClass = function getClass146() {
  return Translater;
};
var SnapOverlayOp = function SnapOverlayOp2(g1, g2) {
  this._geom = new Array(2).fill(null);
  this._snapTolerance = null;
  this._cbr = null;
  this._geom[0] = g1;
  this._geom[1] = g2;
  this.computeSnapTolerance();
};
SnapOverlayOp.prototype.selfSnap = function selfSnap(geom) {
  var snapper0 = new GeometrySnapper(geom);
  var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
  return snapGeom;
};
SnapOverlayOp.prototype.removeCommonBits = function removeCommonBits2(geom) {
  this._cbr = new CommonBitsRemover();
  this._cbr.add(geom[0]);
  this._cbr.add(geom[1]);
  var remGeom = new Array(2).fill(null);
  remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
  remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
  return remGeom;
};
SnapOverlayOp.prototype.prepareResult = function prepareResult(geom) {
  this._cbr.addCommonBits(geom);
  return geom;
};
SnapOverlayOp.prototype.getResultGeometry = function getResultGeometry2(opCode) {
  var prepGeom = this.snap(this._geom);
  var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
  return this.prepareResult(result);
};
SnapOverlayOp.prototype.checkValid = function checkValid5(g) {
  if (!g.isValid()) {
    System.out.println("Snapped geometry is invalid");
  }
};
SnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance2() {
  this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
};
SnapOverlayOp.prototype.snap = function snap3(geom) {
  var remGeom = this.removeCommonBits(geom);
  var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
  return snapGeom;
};
SnapOverlayOp.prototype.interfaces_ = function interfaces_148() {
  return [];
};
SnapOverlayOp.prototype.getClass = function getClass147() {
  return SnapOverlayOp;
};
SnapOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {
  var op = new SnapOverlayOp(g0, g1);
  return op.getResultGeometry(opCode);
};
SnapOverlayOp.union = function union2(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
};
SnapOverlayOp.intersection = function intersection9(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
};
SnapOverlayOp.symDifference = function symDifference(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
};
SnapOverlayOp.difference = function difference3(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
};
var SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp2(g1, g2) {
  this._geom = new Array(2).fill(null);
  this._geom[0] = g1;
  this._geom[1] = g2;
};
SnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry3(opCode) {
  var result = null;
  var isSuccess = false;
  var savedException = null;
  try {
    result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
    var isValid7 = true;
    if (isValid7) {
      isSuccess = true;
    }
  } catch (ex) {
    if (ex instanceof RuntimeException) {
      savedException = ex;
    } else {
      throw ex;
    }
  } finally {
  }
  if (!isSuccess) {
    try {
      result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
    } catch (ex) {
      if (ex instanceof RuntimeException) {
        throw savedException;
      } else {
        throw ex;
      }
    } finally {
    }
  }
  return result;
};
SnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_149() {
  return [];
};
SnapIfNeededOverlayOp.prototype.getClass = function getClass148() {
  return SnapIfNeededOverlayOp;
};
SnapIfNeededOverlayOp.overlayOp = function overlayOp2(g0, g1, opCode) {
  var op = new SnapIfNeededOverlayOp(g0, g1);
  return op.getResultGeometry(opCode);
};
SnapIfNeededOverlayOp.union = function union3(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
};
SnapIfNeededOverlayOp.intersection = function intersection10(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
};
SnapIfNeededOverlayOp.symDifference = function symDifference2(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
};
SnapIfNeededOverlayOp.difference = function difference4(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
};
var MonotoneChain$2 = function MonotoneChain3() {
  this.mce = null;
  this.chainIndex = null;
  var mce = arguments[0];
  var chainIndex = arguments[1];
  this.mce = mce;
  this.chainIndex = chainIndex;
};
MonotoneChain$2.prototype.computeIntersections = function computeIntersections2(mc, si) {
  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
};
MonotoneChain$2.prototype.interfaces_ = function interfaces_150() {
  return [];
};
MonotoneChain$2.prototype.getClass = function getClass149() {
  return MonotoneChain$2;
};
var SweepLineEvent = function SweepLineEvent2() {
  this._label = null;
  this._xValue = null;
  this._eventType = null;
  this._insertEvent = null;
  this._deleteEventIndex = null;
  this._obj = null;
  if (arguments.length === 2) {
    var x2 = arguments[0];
    var insertEvent = arguments[1];
    this._eventType = SweepLineEvent2.DELETE;
    this._xValue = x2;
    this._insertEvent = insertEvent;
  } else if (arguments.length === 3) {
    var label = arguments[0];
    var x$1 = arguments[1];
    var obj = arguments[2];
    this._eventType = SweepLineEvent2.INSERT;
    this._label = label;
    this._xValue = x$1;
    this._obj = obj;
  }
};
var staticAccessors$43 = { INSERT: { configurable: true }, DELETE: { configurable: true } };
SweepLineEvent.prototype.isDelete = function isDelete() {
  return this._eventType === SweepLineEvent.DELETE;
};
SweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex(deleteEventIndex) {
  this._deleteEventIndex = deleteEventIndex;
};
SweepLineEvent.prototype.getObject = function getObject() {
  return this._obj;
};
SweepLineEvent.prototype.compareTo = function compareTo15(o) {
  var pe = o;
  if (this._xValue < pe._xValue) {
    return -1;
  }
  if (this._xValue > pe._xValue) {
    return 1;
  }
  if (this._eventType < pe._eventType) {
    return -1;
  }
  if (this._eventType > pe._eventType) {
    return 1;
  }
  return 0;
};
SweepLineEvent.prototype.getInsertEvent = function getInsertEvent() {
  return this._insertEvent;
};
SweepLineEvent.prototype.isInsert = function isInsert() {
  return this._eventType === SweepLineEvent.INSERT;
};
SweepLineEvent.prototype.isSameLabel = function isSameLabel(ev) {
  if (this._label === null) {
    return false;
  }
  return this._label === ev._label;
};
SweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex() {
  return this._deleteEventIndex;
};
SweepLineEvent.prototype.interfaces_ = function interfaces_151() {
  return [Comparable];
};
SweepLineEvent.prototype.getClass = function getClass150() {
  return SweepLineEvent;
};
staticAccessors$43.INSERT.get = function() {
  return 1;
};
staticAccessors$43.DELETE.get = function() {
  return 2;
};
Object.defineProperties(SweepLineEvent, staticAccessors$43);
var EdgeSetIntersector = function EdgeSetIntersector2() {
};
EdgeSetIntersector.prototype.interfaces_ = function interfaces_152() {
  return [];
};
EdgeSetIntersector.prototype.getClass = function getClass151() {
  return EdgeSetIntersector;
};
var SegmentIntersector$2 = function SegmentIntersector3() {
  this._hasIntersection = false;
  this._hasProper = false;
  this._hasProperInterior = false;
  this._properIntersectionPoint = null;
  this._li = null;
  this._includeProper = null;
  this._recordIsolated = null;
  this._isSelfIntersection = null;
  this._numIntersections = 0;
  this.numTests = 0;
  this._bdyNodes = null;
  this._isDone = false;
  this._isDoneWhenProperInt = false;
  var li = arguments[0];
  var includeProper = arguments[1];
  var recordIsolated = arguments[2];
  this._li = li;
  this._includeProper = includeProper;
  this._recordIsolated = recordIsolated;
};
SegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection2(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1) {
    if (this._li.getIntersectionNum() === 1) {
      if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) {
        return true;
      }
      if (e0.isClosed()) {
        var maxSegIndex = e0.getNumPoints() - 1;
        if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
          return true;
        }
      }
    }
  }
  return false;
};
SegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint2() {
  return this._properIntersectionPoint;
};
SegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt(isDoneWhenProperInt) {
  this._isDoneWhenProperInt = isDoneWhenProperInt;
};
SegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection2() {
  return this._hasProperInterior;
};
SegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal(li, bdyNodes) {
  for (var i = bdyNodes.iterator(); i.hasNext(); ) {
    var node = i.next();
    var pt = node.getCoordinate();
    if (li.isIntersection(pt)) {
      return true;
    }
  }
  return false;
};
SegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection2() {
  return this._hasProper;
};
SegmentIntersector$2.prototype.hasIntersection = function hasIntersection4() {
  return this._hasIntersection;
};
SegmentIntersector$2.prototype.isDone = function isDone9() {
  return this._isDone;
};
SegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint(li, bdyNodes) {
  if (bdyNodes === null) {
    return false;
  }
  if (this.isBoundaryPointInternal(li, bdyNodes[0])) {
    return true;
  }
  if (this.isBoundaryPointInternal(li, bdyNodes[1])) {
    return true;
  }
  return false;
};
SegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes(bdyNodes0, bdyNodes1) {
  this._bdyNodes = new Array(2).fill(null);
  this._bdyNodes[0] = bdyNodes0;
  this._bdyNodes[1] = bdyNodes1;
};
SegmentIntersector$2.prototype.addIntersections = function addIntersections2(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  this.numTests++;
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    if (this._recordIsolated) {
      e0.setIsolated(false);
      e1.setIsolated(false);
    }
    this._numIntersections++;
    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
      this._hasIntersection = true;
      if (this._includeProper || !this._li.isProper()) {
        e0.addIntersections(this._li, segIndex0, 0);
        e1.addIntersections(this._li, segIndex1, 1);
      }
      if (this._li.isProper()) {
        this._properIntersectionPoint = this._li.getIntersection(0).copy();
        this._hasProper = true;
        if (this._isDoneWhenProperInt) {
          this._isDone = true;
        }
        if (!this.isBoundaryPoint(this._li, this._bdyNodes)) {
          this._hasProperInterior = true;
        }
      }
    }
  }
};
SegmentIntersector$2.prototype.interfaces_ = function interfaces_153() {
  return [];
};
SegmentIntersector$2.prototype.getClass = function getClass152() {
  return SegmentIntersector$2;
};
SegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments2(i1, i2) {
  return Math.abs(i1 - i2) === 1;
};
var SimpleMCSweepLineIntersector = function(EdgeSetIntersector$$1) {
  function SimpleMCSweepLineIntersector2() {
    EdgeSetIntersector$$1.call(this);
    this.events = new ArrayList();
    this.nOverlaps = null;
  }
  if (EdgeSetIntersector$$1)
    SimpleMCSweepLineIntersector2.__proto__ = EdgeSetIntersector$$1;
  SimpleMCSweepLineIntersector2.prototype = Object.create(EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype);
  SimpleMCSweepLineIntersector2.prototype.constructor = SimpleMCSweepLineIntersector2;
  SimpleMCSweepLineIntersector2.prototype.prepareEvents = function prepareEvents() {
    var this$1$1 = this;
    Collections.sort(this.events);
    for (var i = 0; i < this.events.size(); i++) {
      var ev = this$1$1.events.get(i);
      if (ev.isDelete()) {
        ev.getInsertEvent().setDeleteEventIndex(i);
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.computeIntersections = function computeIntersections3() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var si = arguments[0];
      this.nOverlaps = 0;
      this.prepareEvents();
      for (var i = 0; i < this.events.size(); i++) {
        var ev = this$1$1.events.get(i);
        if (ev.isInsert()) {
          this$1$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
        }
        if (si.isDone()) {
          break;
        }
      }
    } else if (arguments.length === 3) {
      if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
        var edges0 = arguments[0];
        var edges1 = arguments[1];
        var si$1 = arguments[2];
        this.addEdges(edges0, edges0);
        this.addEdges(edges1, edges1);
        this.computeIntersections(si$1);
      } else if (typeof arguments[2] === "boolean" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {
        var edges2 = arguments[0];
        var si$2 = arguments[1];
        var testAllSegments = arguments[2];
        if (testAllSegments) {
          this.addEdges(edges2, null);
        } else {
          this.addEdges(edges2);
        }
        this.computeIntersections(si$2);
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.addEdge = function addEdge(edge, edgeSet) {
    var this$1$1 = this;
    var mce = edge.getMonotoneChainEdge();
    var startIndex = mce.getStartIndexes();
    for (var i = 0; i < startIndex.length - 1; i++) {
      var mc = new MonotoneChain$2(mce, i);
      var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
      this$1$1.events.add(insertEvent);
      this$1$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
    }
  };
  SimpleMCSweepLineIntersector2.prototype.processOverlaps = function processOverlaps(start2, end2, ev0, si) {
    var this$1$1 = this;
    var mc0 = ev0.getObject();
    for (var i = start2; i < end2; i++) {
      var ev1 = this$1$1.events.get(i);
      if (ev1.isInsert()) {
        var mc1 = ev1.getObject();
        if (!ev0.isSameLabel(ev1)) {
          mc0.computeIntersections(mc1, si);
          this$1$1.nOverlaps++;
        }
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.addEdges = function addEdges2() {
    var this$1$1 = this;
    if (arguments.length === 1) {
      var edges2 = arguments[0];
      for (var i = edges2.iterator(); i.hasNext(); ) {
        var edge = i.next();
        this$1$1.addEdge(edge, edge);
      }
    } else if (arguments.length === 2) {
      var edges$1 = arguments[0];
      var edgeSet = arguments[1];
      for (var i$1 = edges$1.iterator(); i$1.hasNext(); ) {
        var edge$1 = i$1.next();
        this$1$1.addEdge(edge$1, edgeSet);
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  SimpleMCSweepLineIntersector2.prototype.getClass = function getClass169() {
    return SimpleMCSweepLineIntersector2;
  };
  return SimpleMCSweepLineIntersector2;
}(EdgeSetIntersector);
var IntervalRTreeNode = function IntervalRTreeNode2() {
  this._min = Double.POSITIVE_INFINITY;
  this._max = Double.NEGATIVE_INFINITY;
};
var staticAccessors$45 = { NodeComparator: { configurable: true } };
IntervalRTreeNode.prototype.getMin = function getMin() {
  return this._min;
};
IntervalRTreeNode.prototype.intersects = function intersects6(queryMin, queryMax) {
  if (this._min > queryMax || this._max < queryMin) {
    return false;
  }
  return true;
};
IntervalRTreeNode.prototype.getMax = function getMax() {
  return this._max;
};
IntervalRTreeNode.prototype.toString = function toString24() {
  return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));
};
IntervalRTreeNode.prototype.interfaces_ = function interfaces_154() {
  return [];
};
IntervalRTreeNode.prototype.getClass = function getClass153() {
  return IntervalRTreeNode;
};
staticAccessors$45.NodeComparator.get = function() {
  return NodeComparator;
};
Object.defineProperties(IntervalRTreeNode, staticAccessors$45);
var NodeComparator = function NodeComparator2() {
};
NodeComparator.prototype.compare = function compare9(o1, o2) {
  var n1 = o1;
  var n2 = o2;
  var mid1 = (n1._min + n1._max) / 2;
  var mid2 = (n2._min + n2._max) / 2;
  if (mid1 < mid2) {
    return -1;
  }
  if (mid1 > mid2) {
    return 1;
  }
  return 0;
};
NodeComparator.prototype.interfaces_ = function interfaces_155() {
  return [Comparator];
};
NodeComparator.prototype.getClass = function getClass154() {
  return NodeComparator;
};
var IntervalRTreeLeafNode = function(IntervalRTreeNode$$1) {
  function IntervalRTreeLeafNode2() {
    IntervalRTreeNode$$1.call(this);
    this._item = null;
    var min5 = arguments[0];
    var max4 = arguments[1];
    var item = arguments[2];
    this._min = min5;
    this._max = max4;
    this._item = item;
  }
  if (IntervalRTreeNode$$1)
    IntervalRTreeLeafNode2.__proto__ = IntervalRTreeNode$$1;
  IntervalRTreeLeafNode2.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
  IntervalRTreeLeafNode2.prototype.constructor = IntervalRTreeLeafNode2;
  IntervalRTreeLeafNode2.prototype.query = function query5(queryMin, queryMax, visitor) {
    if (!this.intersects(queryMin, queryMax)) {
      return null;
    }
    visitor.visitItem(this._item);
  };
  IntervalRTreeLeafNode2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  IntervalRTreeLeafNode2.prototype.getClass = function getClass169() {
    return IntervalRTreeLeafNode2;
  };
  return IntervalRTreeLeafNode2;
}(IntervalRTreeNode);
var IntervalRTreeBranchNode = function(IntervalRTreeNode$$1) {
  function IntervalRTreeBranchNode2() {
    IntervalRTreeNode$$1.call(this);
    this._node1 = null;
    this._node2 = null;
    var n1 = arguments[0];
    var n2 = arguments[1];
    this._node1 = n1;
    this._node2 = n2;
    this.buildExtent(this._node1, this._node2);
  }
  if (IntervalRTreeNode$$1)
    IntervalRTreeBranchNode2.__proto__ = IntervalRTreeNode$$1;
  IntervalRTreeBranchNode2.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
  IntervalRTreeBranchNode2.prototype.constructor = IntervalRTreeBranchNode2;
  IntervalRTreeBranchNode2.prototype.buildExtent = function buildExtent(n1, n2) {
    this._min = Math.min(n1._min, n2._min);
    this._max = Math.max(n1._max, n2._max);
  };
  IntervalRTreeBranchNode2.prototype.query = function query5(queryMin, queryMax, visitor) {
    if (!this.intersects(queryMin, queryMax)) {
      return null;
    }
    if (this._node1 !== null) {
      this._node1.query(queryMin, queryMax, visitor);
    }
    if (this._node2 !== null) {
      this._node2.query(queryMin, queryMax, visitor);
    }
  };
  IntervalRTreeBranchNode2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  IntervalRTreeBranchNode2.prototype.getClass = function getClass169() {
    return IntervalRTreeBranchNode2;
  };
  return IntervalRTreeBranchNode2;
}(IntervalRTreeNode);
var SortedPackedIntervalRTree = function SortedPackedIntervalRTree2() {
  this._leaves = new ArrayList();
  this._root = null;
  this._level = 0;
};
SortedPackedIntervalRTree.prototype.buildTree = function buildTree() {
  var this$1$1 = this;
  Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
  var src2 = this._leaves;
  var temp2 = null;
  var dest = new ArrayList();
  while (true) {
    this$1$1.buildLevel(src2, dest);
    if (dest.size() === 1) {
      return dest.get(0);
    }
    temp2 = src2;
    src2 = dest;
    dest = temp2;
  }
};
SortedPackedIntervalRTree.prototype.insert = function insert4(min5, max4, item) {
  if (this._root !== null) {
    throw new Error("Index cannot be added to once it has been queried");
  }
  this._leaves.add(new IntervalRTreeLeafNode(min5, max4, item));
};
SortedPackedIntervalRTree.prototype.query = function query3(min5, max4, visitor) {
  this.init();
  this._root.query(min5, max4, visitor);
};
SortedPackedIntervalRTree.prototype.buildRoot = function buildRoot() {
  if (this._root !== null) {
    return null;
  }
  this._root = this.buildTree();
};
SortedPackedIntervalRTree.prototype.printNode = function printNode(node) {
  System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
};
SortedPackedIntervalRTree.prototype.init = function init6() {
  if (this._root !== null) {
    return null;
  }
  this.buildRoot();
};
SortedPackedIntervalRTree.prototype.buildLevel = function buildLevel(src2, dest) {
  this._level++;
  dest.clear();
  for (var i = 0; i < src2.size(); i += 2) {
    var n1 = src2.get(i);
    var n2 = i + 1 < src2.size() ? src2.get(i) : null;
    if (n2 === null) {
      dest.add(n1);
    } else {
      var node = new IntervalRTreeBranchNode(src2.get(i), src2.get(i + 1));
      dest.add(node);
    }
  }
};
SortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_156() {
  return [];
};
SortedPackedIntervalRTree.prototype.getClass = function getClass155() {
  return SortedPackedIntervalRTree;
};
var ArrayListVisitor = function ArrayListVisitor2() {
  this._items = new ArrayList();
};
ArrayListVisitor.prototype.visitItem = function visitItem2(item) {
  this._items.add(item);
};
ArrayListVisitor.prototype.getItems = function getItems() {
  return this._items;
};
ArrayListVisitor.prototype.interfaces_ = function interfaces_157() {
  return [ItemVisitor];
};
ArrayListVisitor.prototype.getClass = function getClass156() {
  return ArrayListVisitor;
};
var IndexedPointInAreaLocator = function IndexedPointInAreaLocator2() {
  this._index = null;
  var g = arguments[0];
  if (!hasInterface(g, Polygonal)) {
    throw new IllegalArgumentException("Argument must be Polygonal");
  }
  this._index = new IntervalIndexedGeometry(g);
};
var staticAccessors$44 = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
IndexedPointInAreaLocator.prototype.locate = function locate5(p) {
  var rcc = new RayCrossingCounter(p);
  var visitor = new SegmentVisitor(rcc);
  this._index.query(p.y, p.y, visitor);
  return rcc.getLocation();
};
IndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_158() {
  return [PointOnGeometryLocator];
};
IndexedPointInAreaLocator.prototype.getClass = function getClass157() {
  return IndexedPointInAreaLocator;
};
staticAccessors$44.SegmentVisitor.get = function() {
  return SegmentVisitor;
};
staticAccessors$44.IntervalIndexedGeometry.get = function() {
  return IntervalIndexedGeometry;
};
Object.defineProperties(IndexedPointInAreaLocator, staticAccessors$44);
var SegmentVisitor = function SegmentVisitor2() {
  this._counter = null;
  var counter = arguments[0];
  this._counter = counter;
};
SegmentVisitor.prototype.visitItem = function visitItem3(item) {
  var seg = item;
  this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
};
SegmentVisitor.prototype.interfaces_ = function interfaces_159() {
  return [ItemVisitor];
};
SegmentVisitor.prototype.getClass = function getClass158() {
  return SegmentVisitor;
};
var IntervalIndexedGeometry = function IntervalIndexedGeometry2() {
  this._index = new SortedPackedIntervalRTree();
  var geom = arguments[0];
  this.init(geom);
};
IntervalIndexedGeometry.prototype.init = function init7(geom) {
  var this$1$1 = this;
  var lines = LinearComponentExtracter.getLines(geom);
  for (var i = lines.iterator(); i.hasNext(); ) {
    var line = i.next();
    var pts = line.getCoordinates();
    this$1$1.addLine(pts);
  }
};
IntervalIndexedGeometry.prototype.addLine = function addLine(pts) {
  var this$1$1 = this;
  for (var i = 1; i < pts.length; i++) {
    var seg = new LineSegment(pts[i - 1], pts[i]);
    var min5 = Math.min(seg.p0.y, seg.p1.y);
    var max4 = Math.max(seg.p0.y, seg.p1.y);
    this$1$1._index.insert(min5, max4, seg);
  }
};
IntervalIndexedGeometry.prototype.query = function query4() {
  if (arguments.length === 2) {
    var min5 = arguments[0];
    var max4 = arguments[1];
    var visitor = new ArrayListVisitor();
    this._index.query(min5, max4, visitor);
    return visitor.getItems();
  } else if (arguments.length === 3) {
    var min$12 = arguments[0];
    var max$12 = arguments[1];
    var visitor$1 = arguments[2];
    this._index.query(min$12, max$12, visitor$1);
  }
};
IntervalIndexedGeometry.prototype.interfaces_ = function interfaces_160() {
  return [];
};
IntervalIndexedGeometry.prototype.getClass = function getClass159() {
  return IntervalIndexedGeometry;
};
var GeometryGraph = function(PlanarGraph$$1) {
  function GeometryGraph2() {
    PlanarGraph$$1.call(this);
    this._parentGeom = null;
    this._lineEdgeMap = new HashMap$1();
    this._boundaryNodeRule = null;
    this._useBoundaryDeterminationRule = true;
    this._argIndex = null;
    this._boundaryNodes = null;
    this._hasTooFewPoints = false;
    this._invalidPoint = null;
    this._areaPtLocator = null;
    this._ptLocator = new PointLocator();
    if (arguments.length === 2) {
      var argIndex = arguments[0];
      var parentGeom = arguments[1];
      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      this._argIndex = argIndex;
      this._parentGeom = parentGeom;
      this._boundaryNodeRule = boundaryNodeRule;
      if (parentGeom !== null) {
        this.add(parentGeom);
      }
    } else if (arguments.length === 3) {
      var argIndex$1 = arguments[0];
      var parentGeom$1 = arguments[1];
      var boundaryNodeRule$1 = arguments[2];
      this._argIndex = argIndex$1;
      this._parentGeom = parentGeom$1;
      this._boundaryNodeRule = boundaryNodeRule$1;
      if (parentGeom$1 !== null) {
        this.add(parentGeom$1);
      }
    }
  }
  if (PlanarGraph$$1)
    GeometryGraph2.__proto__ = PlanarGraph$$1;
  GeometryGraph2.prototype = Object.create(PlanarGraph$$1 && PlanarGraph$$1.prototype);
  GeometryGraph2.prototype.constructor = GeometryGraph2;
  GeometryGraph2.prototype.insertBoundaryPoint = function insertBoundaryPoint(argIndex, coord) {
    var n = this._nodes.addNode(coord);
    var lbl = n.getLabel();
    var boundaryCount = 1;
    var loc = Location.NONE;
    loc = lbl.getLocation(argIndex, Position.ON);
    if (loc === Location.BOUNDARY) {
      boundaryCount++;
    }
    var newLoc = GeometryGraph2.determineBoundary(this._boundaryNodeRule, boundaryCount);
    lbl.setLocation(argIndex, newLoc);
  };
  GeometryGraph2.prototype.computeSelfNodes = function computeSelfNodes() {
    if (arguments.length === 2) {
      var li = arguments[0];
      var computeRingSelfNodes = arguments[1];
      return this.computeSelfNodes(li, computeRingSelfNodes, false);
    } else if (arguments.length === 3) {
      var li$1 = arguments[0];
      var computeRingSelfNodes$1 = arguments[1];
      var isDoneIfProperInt = arguments[2];
      var si = new SegmentIntersector$2(li$1, true, false);
      si.setIsDoneIfProperInt(isDoneIfProperInt);
      var esi = this.createEdgeSetIntersector();
      var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon$2 || this._parentGeom instanceof MultiPolygon;
      var computeAllSegments = computeRingSelfNodes$1 || !isRings;
      esi.computeIntersections(this._edges, si, computeAllSegments);
      this.addSelfIntersectionNodes(this._argIndex);
      return si;
    }
  };
  GeometryGraph2.prototype.computeSplitEdges = function computeSplitEdges(edgelist) {
    for (var i = this._edges.iterator(); i.hasNext(); ) {
      var e2 = i.next();
      e2.eiList.addSplitEdges(edgelist);
    }
  };
  GeometryGraph2.prototype.computeEdgeIntersections = function computeEdgeIntersections(g, li, includeProper) {
    var si = new SegmentIntersector$2(li, includeProper, true);
    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
    var esi = this.createEdgeSetIntersector();
    esi.computeIntersections(this._edges, g._edges, si);
    return si;
  };
  GeometryGraph2.prototype.getGeometry = function getGeometry3() {
    return this._parentGeom;
  };
  GeometryGraph2.prototype.getBoundaryNodeRule = function getBoundaryNodeRule() {
    return this._boundaryNodeRule;
  };
  GeometryGraph2.prototype.hasTooFewPoints = function hasTooFewPoints() {
    return this._hasTooFewPoints;
  };
  GeometryGraph2.prototype.addPoint = function addPoint2() {
    if (arguments[0] instanceof Point$2) {
      var p = arguments[0];
      var coord = p.getCoordinate();
      this.insertPoint(this._argIndex, coord, Location.INTERIOR);
    } else if (arguments[0] instanceof Coordinate) {
      var pt = arguments[0];
      this.insertPoint(this._argIndex, pt, Location.INTERIOR);
    }
  };
  GeometryGraph2.prototype.addPolygon = function addPolygon2(p) {
    var this$1$1 = this;
    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
    for (var i = 0; i < p.getNumInteriorRing(); i++) {
      var hole = p.getInteriorRingN(i);
      this$1$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
    }
  };
  GeometryGraph2.prototype.addEdge = function addEdge(e2) {
    this.insertEdge(e2);
    var coord = e2.getCoordinates();
    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
  };
  GeometryGraph2.prototype.addLineString = function addLineString2(line) {
    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
    if (coord.length < 2) {
      this._hasTooFewPoints = true;
      this._invalidPoint = coord[0];
      return null;
    }
    var e2 = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));
    this._lineEdgeMap.put(line, e2);
    this.insertEdge(e2);
    Assert.isTrue(coord.length >= 2, "found LineString with single point");
    this.insertBoundaryPoint(this._argIndex, coord[0]);
    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
  };
  GeometryGraph2.prototype.getInvalidPoint = function getInvalidPoint() {
    return this._invalidPoint;
  };
  GeometryGraph2.prototype.getBoundaryPoints = function getBoundaryPoints() {
    var coll = this.getBoundaryNodes();
    var pts = new Array(coll.size()).fill(null);
    var i = 0;
    for (var it = coll.iterator(); it.hasNext(); ) {
      var node = it.next();
      pts[i++] = node.getCoordinate().copy();
    }
    return pts;
  };
  GeometryGraph2.prototype.getBoundaryNodes = function getBoundaryNodes2() {
    if (this._boundaryNodes === null) {
      this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
    }
    return this._boundaryNodes;
  };
  GeometryGraph2.prototype.addSelfIntersectionNode = function addSelfIntersectionNode(argIndex, coord, loc) {
    if (this.isBoundaryNode(argIndex, coord)) {
      return null;
    }
    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) {
      this.insertBoundaryPoint(argIndex, coord);
    } else {
      this.insertPoint(argIndex, coord, loc);
    }
  };
  GeometryGraph2.prototype.addPolygonRing = function addPolygonRing2(lr, cwLeft, cwRight) {
    if (lr.isEmpty()) {
      return null;
    }
    var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
    if (coord.length < 4) {
      this._hasTooFewPoints = true;
      this._invalidPoint = coord[0];
      return null;
    }
    var left = cwLeft;
    var right = cwRight;
    if (CGAlgorithms.isCCW(coord)) {
      left = cwRight;
      right = cwLeft;
    }
    var e2 = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
    this._lineEdgeMap.put(lr, e2);
    this.insertEdge(e2);
    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
  };
  GeometryGraph2.prototype.insertPoint = function insertPoint(argIndex, coord, onLocation) {
    var n = this._nodes.addNode(coord);
    var lbl = n.getLabel();
    if (lbl === null) {
      n._label = new Label(argIndex, onLocation);
    } else {
      lbl.setLocation(argIndex, onLocation);
    }
  };
  GeometryGraph2.prototype.createEdgeSetIntersector = function createEdgeSetIntersector() {
    return new SimpleMCSweepLineIntersector();
  };
  GeometryGraph2.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes(argIndex) {
    var this$1$1 = this;
    for (var i = this._edges.iterator(); i.hasNext(); ) {
      var e2 = i.next();
      var eLoc = e2.getLabel().getLocation(argIndex);
      for (var eiIt = e2.eiList.iterator(); eiIt.hasNext(); ) {
        var ei = eiIt.next();
        this$1$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
      }
    }
  };
  GeometryGraph2.prototype.add = function add16() {
    if (arguments.length === 1) {
      var g = arguments[0];
      if (g.isEmpty()) {
        return null;
      }
      if (g instanceof MultiPolygon) {
        this._useBoundaryDeterminationRule = false;
      }
      if (g instanceof Polygon$2) {
        this.addPolygon(g);
      } else if (g instanceof LineString) {
        this.addLineString(g);
      } else if (g instanceof Point$2) {
        this.addPoint(g);
      } else if (g instanceof MultiPoint) {
        this.addCollection(g);
      } else if (g instanceof MultiLineString) {
        this.addCollection(g);
      } else if (g instanceof MultiPolygon) {
        this.addCollection(g);
      } else if (g instanceof GeometryCollection) {
        this.addCollection(g);
      } else {
        throw new Error(g.getClass().getName());
      }
    } else {
      return PlanarGraph$$1.prototype.add.apply(this, arguments);
    }
  };
  GeometryGraph2.prototype.addCollection = function addCollection2(gc) {
    var this$1$1 = this;
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      var g = gc.getGeometryN(i);
      this$1$1.add(g);
    }
  };
  GeometryGraph2.prototype.locate = function locate6(pt) {
    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
      if (this._areaPtLocator === null) {
        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
      }
      return this._areaPtLocator.locate(pt);
    }
    return this._ptLocator.locate(pt, this._parentGeom);
  };
  GeometryGraph2.prototype.findEdge = function findEdge3() {
    if (arguments.length === 1) {
      var line = arguments[0];
      return this._lineEdgeMap.get(line);
    } else {
      return PlanarGraph$$1.prototype.findEdge.apply(this, arguments);
    }
  };
  GeometryGraph2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  GeometryGraph2.prototype.getClass = function getClass169() {
    return GeometryGraph2;
  };
  GeometryGraph2.determineBoundary = function determineBoundary(boundaryNodeRule, boundaryCount) {
    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;
  };
  return GeometryGraph2;
}(PlanarGraph);
var GeometryGraphOp = function GeometryGraphOp2() {
  this._li = new RobustLineIntersector();
  this._resultPrecisionModel = null;
  this._arg = null;
  if (arguments.length === 1) {
    var g0 = arguments[0];
    this.setComputationPrecision(g0.getPrecisionModel());
    this._arg = new Array(1).fill(null);
    this._arg[0] = new GeometryGraph(0, g0);
  } else if (arguments.length === 2) {
    var g0$1 = arguments[0];
    var g1 = arguments[1];
    var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
    if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) {
      this.setComputationPrecision(g0$1.getPrecisionModel());
    } else {
      this.setComputationPrecision(g1.getPrecisionModel());
    }
    this._arg = new Array(2).fill(null);
    this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);
    this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
  } else if (arguments.length === 3) {
    var g0$2 = arguments[0];
    var g1$1 = arguments[1];
    var boundaryNodeRule$1 = arguments[2];
    if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) {
      this.setComputationPrecision(g0$2.getPrecisionModel());
    } else {
      this.setComputationPrecision(g1$1.getPrecisionModel());
    }
    this._arg = new Array(2).fill(null);
    this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);
    this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);
  }
};
GeometryGraphOp.prototype.getArgGeometry = function getArgGeometry(i) {
  return this._arg[i].getGeometry();
};
GeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision(pm) {
  this._resultPrecisionModel = pm;
  this._li.setPrecisionModel(this._resultPrecisionModel);
};
GeometryGraphOp.prototype.interfaces_ = function interfaces_161() {
  return [];
};
GeometryGraphOp.prototype.getClass = function getClass160() {
  return GeometryGraphOp;
};
var GeometryMapper = function GeometryMapper2() {
};
GeometryMapper.prototype.interfaces_ = function interfaces_162() {
  return [];
};
GeometryMapper.prototype.getClass = function getClass161() {
  return GeometryMapper;
};
GeometryMapper.map = function map3() {
  if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
    var geom = arguments[0];
    var op = arguments[1];
    var mapped = new ArrayList();
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var g = op.map(geom.getGeometryN(i));
      if (g !== null) {
        mapped.add(g);
      }
    }
    return geom.getFactory().buildGeometry(mapped);
  } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
    var geoms = arguments[0];
    var op$1 = arguments[1];
    var mapped$1 = new ArrayList();
    for (var i$1 = geoms.iterator(); i$1.hasNext(); ) {
      var g$1 = i$1.next();
      var gr = op$1.map(g$1);
      if (gr !== null) {
        mapped$1.add(gr);
      }
    }
    return mapped$1;
  }
};
GeometryMapper.MapOp = function MapOp() {
};
var OverlayOp = function(GeometryGraphOp3) {
  function OverlayOp2() {
    var g0 = arguments[0];
    var g1 = arguments[1];
    GeometryGraphOp3.call(this, g0, g1);
    this._ptLocator = new PointLocator();
    this._geomFact = null;
    this._resultGeom = null;
    this._graph = null;
    this._edgeList = new EdgeList();
    this._resultPolyList = new ArrayList();
    this._resultLineList = new ArrayList();
    this._resultPointList = new ArrayList();
    this._graph = new PlanarGraph(new OverlayNodeFactory());
    this._geomFact = g0.getFactory();
  }
  if (GeometryGraphOp3)
    OverlayOp2.__proto__ = GeometryGraphOp3;
  OverlayOp2.prototype = Object.create(GeometryGraphOp3 && GeometryGraphOp3.prototype);
  OverlayOp2.prototype.constructor = OverlayOp2;
  OverlayOp2.prototype.insertUniqueEdge = function insertUniqueEdge2(e2) {
    var existingEdge = this._edgeList.findEqualEdge(e2);
    if (existingEdge !== null) {
      var existingLabel = existingEdge.getLabel();
      var labelToMerge = e2.getLabel();
      if (!existingEdge.isPointwiseEqual(e2)) {
        labelToMerge = new Label(e2.getLabel());
        labelToMerge.flip();
      }
      var depth2 = existingEdge.getDepth();
      if (depth2.isNull()) {
        depth2.add(existingLabel);
      }
      depth2.add(labelToMerge);
      existingLabel.merge(labelToMerge);
    } else {
      this._edgeList.add(e2);
    }
  };
  OverlayOp2.prototype.getGraph = function getGraph() {
    return this._graph;
  };
  OverlayOp2.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges() {
    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
      var de = it.next();
      var sym = de.getSym();
      if (de.isInResult() && sym.isInResult()) {
        de.setInResult(false);
        sym.setInResult(false);
      }
    }
  };
  OverlayOp2.prototype.isCoveredByLA = function isCoveredByLA(coord) {
    if (this.isCovered(coord, this._resultLineList)) {
      return true;
    }
    if (this.isCovered(coord, this._resultPolyList)) {
      return true;
    }
    return false;
  };
  OverlayOp2.prototype.computeGeometry = function computeGeometry2(resultPointList, resultLineList, resultPolyList, opcode) {
    var geomList = new ArrayList();
    geomList.addAll(resultPointList);
    geomList.addAll(resultLineList);
    geomList.addAll(resultPolyList);
    if (geomList.isEmpty()) {
      return OverlayOp2.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
    }
    return this._geomFact.buildGeometry(geomList);
  };
  OverlayOp2.prototype.mergeSymLabels = function mergeSymLabels() {
    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
      var node = nodeit.next();
      node.getEdges().mergeSymLabels();
    }
  };
  OverlayOp2.prototype.isCovered = function isCovered2(coord, geomList) {
    var this$1$1 = this;
    for (var it = geomList.iterator(); it.hasNext(); ) {
      var geom = it.next();
      var loc = this$1$1._ptLocator.locate(coord, geom);
      if (loc !== Location.EXTERIOR) {
        return true;
      }
    }
    return false;
  };
  OverlayOp2.prototype.replaceCollapsedEdges = function replaceCollapsedEdges() {
    var newEdges = new ArrayList();
    for (var it = this._edgeList.iterator(); it.hasNext(); ) {
      var e2 = it.next();
      if (e2.isCollapsed()) {
        it.remove();
        newEdges.add(e2.getCollapsedEdge());
      }
    }
    this._edgeList.addAll(newEdges);
  };
  OverlayOp2.prototype.updateNodeLabelling = function updateNodeLabelling() {
    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
      var node = nodeit.next();
      var lbl = node.getEdges().getLabel();
      node.getLabel().merge(lbl);
    }
  };
  OverlayOp2.prototype.getResultGeometry = function getResultGeometry4(overlayOpCode) {
    this.computeOverlay(overlayOpCode);
    return this._resultGeom;
  };
  OverlayOp2.prototype.insertUniqueEdges = function insertUniqueEdges(edges2) {
    var this$1$1 = this;
    for (var i = edges2.iterator(); i.hasNext(); ) {
      var e2 = i.next();
      this$1$1.insertUniqueEdge(e2);
    }
  };
  OverlayOp2.prototype.computeOverlay = function computeOverlay(opCode) {
    this.copyPoints(0);
    this.copyPoints(1);
    this._arg[0].computeSelfNodes(this._li, false);
    this._arg[1].computeSelfNodes(this._li, false);
    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
    var baseSplitEdges = new ArrayList();
    this._arg[0].computeSplitEdges(baseSplitEdges);
    this._arg[1].computeSplitEdges(baseSplitEdges);
    this.insertUniqueEdges(baseSplitEdges);
    this.computeLabelsFromDepths();
    this.replaceCollapsedEdges();
    EdgeNodingValidator.checkValid(this._edgeList.getEdges());
    this._graph.addEdges(this._edgeList.getEdges());
    this.computeLabelling();
    this.labelIncompleteNodes();
    this.findResultAreaEdges(opCode);
    this.cancelDuplicateResultEdges();
    var polyBuilder = new PolygonBuilder(this._geomFact);
    polyBuilder.add(this._graph);
    this._resultPolyList = polyBuilder.getPolygons();
    var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
    this._resultLineList = lineBuilder.build(opCode);
    var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
    this._resultPointList = pointBuilder.build(opCode);
    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
  };
  OverlayOp2.prototype.labelIncompleteNode = function labelIncompleteNode(n, targetIndex) {
    var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
    n.getLabel().setLocation(targetIndex, loc);
  };
  OverlayOp2.prototype.copyPoints = function copyPoints(argIndex) {
    var this$1$1 = this;
    for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {
      var graphNode = i.next();
      var newNode = this$1$1._graph.addNode(graphNode.getCoordinate());
      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
    }
  };
  OverlayOp2.prototype.findResultAreaEdges = function findResultAreaEdges(opCode) {
    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
      var de = it.next();
      var label = de.getLabel();
      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp2.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
        de.setInResult(true);
      }
    }
  };
  OverlayOp2.prototype.computeLabelsFromDepths = function computeLabelsFromDepths() {
    for (var it = this._edgeList.iterator(); it.hasNext(); ) {
      var e2 = it.next();
      var lbl = e2.getLabel();
      var depth2 = e2.getDepth();
      if (!depth2.isNull()) {
        depth2.normalize();
        for (var i = 0; i < 2; i++) {
          if (!lbl.isNull(i) && lbl.isArea() && !depth2.isNull(i)) {
            if (depth2.getDelta(i) === 0) {
              lbl.toLine(i);
            } else {
              Assert.isTrue(!depth2.isNull(i, Position.LEFT), "depth of LEFT side has not been initialized");
              lbl.setLocation(i, Position.LEFT, depth2.getLocation(i, Position.LEFT));
              Assert.isTrue(!depth2.isNull(i, Position.RIGHT), "depth of RIGHT side has not been initialized");
              lbl.setLocation(i, Position.RIGHT, depth2.getLocation(i, Position.RIGHT));
            }
          }
        }
      }
    }
  };
  OverlayOp2.prototype.computeLabelling = function computeLabelling2() {
    var this$1$1 = this;
    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
      var node = nodeit.next();
      node.getEdges().computeLabelling(this$1$1._arg);
    }
    this.mergeSymLabels();
    this.updateNodeLabelling();
  };
  OverlayOp2.prototype.labelIncompleteNodes = function labelIncompleteNodes() {
    var this$1$1 = this;
    for (var ni = this._graph.getNodes().iterator(); ni.hasNext(); ) {
      var n = ni.next();
      var label = n.getLabel();
      if (n.isIsolated()) {
        if (label.isNull(0)) {
          this$1$1.labelIncompleteNode(n, 0);
        } else {
          this$1$1.labelIncompleteNode(n, 1);
        }
      }
      n.getEdges().updateLabelling(label);
    }
  };
  OverlayOp2.prototype.isCoveredByA = function isCoveredByA(coord) {
    if (this.isCovered(coord, this._resultPolyList)) {
      return true;
    }
    return false;
  };
  OverlayOp2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  OverlayOp2.prototype.getClass = function getClass169() {
    return OverlayOp2;
  };
  return OverlayOp2;
}(GeometryGraphOp);
OverlayOp.overlayOp = function(geom0, geom1, opCode) {
  var gov = new OverlayOp(geom0, geom1);
  var geomOv = gov.getResultGeometry(opCode);
  return geomOv;
};
OverlayOp.intersection = function(g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());
  }
  if (g.isGeometryCollection()) {
    var g2 = other;
    return GeometryCollectionMapper.map(g, {
      interfaces_: function() {
        return [GeometryMapper.MapOp];
      },
      map: function(g3) {
        return g3.intersection(g2);
      }
    });
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);
};
OverlayOp.symDifference = function(g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    if (g.isEmpty() && other.isEmpty()) {
      return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());
    }
    if (g.isEmpty()) {
      return other.copy();
    }
    if (other.isEmpty()) {
      return g.copy();
    }
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);
};
OverlayOp.resultDimension = function(opCode, g0, g1) {
  var dim0 = g0.getDimension();
  var dim1 = g1.getDimension();
  var resultDimension = -1;
  switch (opCode) {
    case OverlayOp.INTERSECTION:
      resultDimension = Math.min(dim0, dim1);
      break;
    case OverlayOp.UNION:
      resultDimension = Math.max(dim0, dim1);
      break;
    case OverlayOp.DIFFERENCE:
      resultDimension = dim0;
      break;
    case OverlayOp.SYMDIFFERENCE:
      resultDimension = Math.max(dim0, dim1);
      break;
  }
  return resultDimension;
};
OverlayOp.createEmptyResult = function(overlayOpCode, a, b, geomFact) {
  var result = null;
  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
    case -1:
      result = geomFact.createGeometryCollection(new Array(0).fill(null));
      break;
    case 0:
      result = geomFact.createPoint();
      break;
    case 1:
      result = geomFact.createLineString();
      break;
    case 2:
      result = geomFact.createPolygon();
      break;
  }
  return result;
};
OverlayOp.difference = function(g, other) {
  if (g.isEmpty()) {
    return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());
  }
  if (other.isEmpty()) {
    return g.copy();
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);
};
OverlayOp.isResultOfOp = function() {
  if (arguments.length === 2) {
    var label = arguments[0];
    var opCode = arguments[1];
    var loc0 = label.getLocation(0);
    var loc1 = label.getLocation(1);
    return OverlayOp.isResultOfOp(loc0, loc1, opCode);
  } else if (arguments.length === 3) {
    var loc0$1 = arguments[0];
    var loc1$1 = arguments[1];
    var overlayOpCode = arguments[2];
    if (loc0$1 === Location.BOUNDARY) {
      loc0$1 = Location.INTERIOR;
    }
    if (loc1$1 === Location.BOUNDARY) {
      loc1$1 = Location.INTERIOR;
    }
    switch (overlayOpCode) {
      case OverlayOp.INTERSECTION:
        return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR;
      case OverlayOp.UNION:
        return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR;
      case OverlayOp.DIFFERENCE:
        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR;
      case OverlayOp.SYMDIFFERENCE:
        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR || loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR;
    }
    return false;
  }
};
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;
var FuzzyPointLocator = function FuzzyPointLocator2() {
  this._g = null;
  this._boundaryDistanceTolerance = null;
  this._linework = null;
  this._ptLocator = new PointLocator();
  this._seg = new LineSegment();
  var g = arguments[0];
  var boundaryDistanceTolerance = arguments[1];
  this._g = g;
  this._boundaryDistanceTolerance = boundaryDistanceTolerance;
  this._linework = this.extractLinework(g);
};
FuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary(pt) {
  var this$1$1 = this;
  for (var i = 0; i < this._linework.getNumGeometries(); i++) {
    var line = this$1$1._linework.getGeometryN(i);
    var seq = line.getCoordinateSequence();
    for (var j = 0; j < seq.size() - 1; j++) {
      seq.getCoordinate(j, this$1$1._seg.p0);
      seq.getCoordinate(j + 1, this$1$1._seg.p1);
      var dist3 = this$1$1._seg.distance(pt);
      if (dist3 <= this$1$1._boundaryDistanceTolerance) {
        return true;
      }
    }
  }
  return false;
};
FuzzyPointLocator.prototype.getLocation = function getLocation5(pt) {
  if (this.isWithinToleranceOfBoundary(pt)) {
    return Location.BOUNDARY;
  }
  return this._ptLocator.locate(pt, this._g);
};
FuzzyPointLocator.prototype.extractLinework = function extractLinework(g) {
  var extracter = new PolygonalLineworkExtracter();
  g.apply(extracter);
  var linework = extracter.getLinework();
  var lines = GeometryFactory.toLineStringArray(linework);
  return g.getFactory().createMultiLineString(lines);
};
FuzzyPointLocator.prototype.interfaces_ = function interfaces_163() {
  return [];
};
FuzzyPointLocator.prototype.getClass = function getClass162() {
  return FuzzyPointLocator;
};
var PolygonalLineworkExtracter = function PolygonalLineworkExtracter2() {
  this._linework = null;
  this._linework = new ArrayList();
};
PolygonalLineworkExtracter.prototype.getLinework = function getLinework() {
  return this._linework;
};
PolygonalLineworkExtracter.prototype.filter = function filter16(g) {
  var this$1$1 = this;
  if (g instanceof Polygon$2) {
    var poly = g;
    this._linework.add(poly.getExteriorRing());
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
      this$1$1._linework.add(poly.getInteriorRingN(i));
    }
  }
};
PolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_164() {
  return [GeometryFilter];
};
PolygonalLineworkExtracter.prototype.getClass = function getClass163() {
  return PolygonalLineworkExtracter;
};
var OffsetPointGenerator = function OffsetPointGenerator2() {
  this._g = null;
  this._doLeft = true;
  this._doRight = true;
  var g = arguments[0];
  this._g = g;
};
OffsetPointGenerator.prototype.extractPoints = function extractPoints(line, offsetDistance, offsetPts) {
  var this$1$1 = this;
  var pts = line.getCoordinates();
  for (var i = 0; i < pts.length - 1; i++) {
    this$1$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);
  }
};
OffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate(doLeft, doRight) {
  this._doLeft = doLeft;
  this._doRight = doRight;
};
OffsetPointGenerator.prototype.getPoints = function getPoints2(offsetDistance) {
  var this$1$1 = this;
  var offsetPts = new ArrayList();
  var lines = LinearComponentExtracter.getLines(this._g);
  for (var i = lines.iterator(); i.hasNext(); ) {
    var line = i.next();
    this$1$1.extractPoints(line, offsetDistance, offsetPts);
  }
  return offsetPts;
};
OffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints(p0, p1, offsetDistance, offsetPts) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  var len2 = Math.sqrt(dx * dx + dy * dy);
  var ux = offsetDistance * dx / len2;
  var uy = offsetDistance * dy / len2;
  var midX = (p1.x + p0.x) / 2;
  var midY = (p1.y + p0.y) / 2;
  if (this._doLeft) {
    var offsetLeft = new Coordinate(midX - uy, midY + ux);
    offsetPts.add(offsetLeft);
  }
  if (this._doRight) {
    var offsetRight = new Coordinate(midX + uy, midY - ux);
    offsetPts.add(offsetRight);
  }
};
OffsetPointGenerator.prototype.interfaces_ = function interfaces_165() {
  return [];
};
OffsetPointGenerator.prototype.getClass = function getClass164() {
  return OffsetPointGenerator;
};
var OverlayResultValidator = function OverlayResultValidator2() {
  this._geom = null;
  this._locFinder = null;
  this._location = new Array(3).fill(null);
  this._invalidLocation = null;
  this._boundaryDistanceTolerance = OverlayResultValidator2.TOLERANCE;
  this._testCoords = new ArrayList();
  var a = arguments[0];
  var b = arguments[1];
  var result = arguments[2];
  this._boundaryDistanceTolerance = OverlayResultValidator2.computeBoundaryDistanceTolerance(a, b);
  this._geom = [a, b, result];
  this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];
};
var staticAccessors$46 = { TOLERANCE: { configurable: true } };
OverlayResultValidator.prototype.reportResult = function reportResult(overlayOp3, location, expectedInterior) {
  System.out.println("Overlay result invalid - A:" + Location.toLocationSymbol(location[0]) + " B:" + Location.toLocationSymbol(location[1]) + " expected:" + (expectedInterior ? "i" : "e") + " actual:" + Location.toLocationSymbol(location[2]));
};
OverlayResultValidator.prototype.isValid = function isValid5(overlayOp3) {
  this.addTestPts(this._geom[0]);
  this.addTestPts(this._geom[1]);
  var isValid7 = this.checkValid(overlayOp3);
  return isValid7;
};
OverlayResultValidator.prototype.checkValid = function checkValid6() {
  var this$1$1 = this;
  if (arguments.length === 1) {
    var overlayOp3 = arguments[0];
    for (var i = 0; i < this._testCoords.size(); i++) {
      var pt = this$1$1._testCoords.get(i);
      if (!this$1$1.checkValid(overlayOp3, pt)) {
        this$1$1._invalidLocation = pt;
        return false;
      }
    }
    return true;
  } else if (arguments.length === 2) {
    var overlayOp$1 = arguments[0];
    var pt$1 = arguments[1];
    this._location[0] = this._locFinder[0].getLocation(pt$1);
    this._location[1] = this._locFinder[1].getLocation(pt$1);
    this._location[2] = this._locFinder[2].getLocation(pt$1);
    if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) {
      return true;
    }
    return this.isValidResult(overlayOp$1, this._location);
  }
};
OverlayResultValidator.prototype.addTestPts = function addTestPts(g) {
  var ptGen = new OffsetPointGenerator(g);
  this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));
};
OverlayResultValidator.prototype.isValidResult = function isValidResult(overlayOp3, location) {
  var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp3);
  var resultInInterior = location[2] === Location.INTERIOR;
  var isValid7 = !(expectedInterior ^ resultInInterior);
  if (!isValid7) {
    this.reportResult(overlayOp3, location, expectedInterior);
  }
  return isValid7;
};
OverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation() {
  return this._invalidLocation;
};
OverlayResultValidator.prototype.interfaces_ = function interfaces_166() {
  return [];
};
OverlayResultValidator.prototype.getClass = function getClass165() {
  return OverlayResultValidator;
};
OverlayResultValidator.hasLocation = function hasLocation(location, loc) {
  for (var i = 0; i < 3; i++) {
    if (location[i] === loc) {
      return true;
    }
  }
  return false;
};
OverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance(g0, g1) {
  return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1));
};
OverlayResultValidator.isValid = function isValid6(a, b, overlayOp3, result) {
  var validator2 = new OverlayResultValidator(a, b, result);
  return validator2.isValid(overlayOp3);
};
staticAccessors$46.TOLERANCE.get = function() {
  return 1e-6;
};
Object.defineProperties(OverlayResultValidator, staticAccessors$46);
var GeometryCombiner = function GeometryCombiner2(geoms) {
  this._geomFactory = null;
  this._skipEmpty = false;
  this._inputGeoms = null;
  this._geomFactory = GeometryCombiner2.extractFactory(geoms);
  this._inputGeoms = geoms;
};
GeometryCombiner.prototype.extractElements = function extractElements(geom, elems) {
  var this$1$1 = this;
  if (geom === null) {
    return null;
  }
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var elemGeom = geom.getGeometryN(i);
    if (this$1$1._skipEmpty && elemGeom.isEmpty()) {
      continue;
    }
    elems.add(elemGeom);
  }
};
GeometryCombiner.prototype.combine = function combine2() {
  var this$1$1 = this;
  var elems = new ArrayList();
  for (var i = this._inputGeoms.iterator(); i.hasNext(); ) {
    var g = i.next();
    this$1$1.extractElements(g, elems);
  }
  if (elems.size() === 0) {
    if (this._geomFactory !== null) {
      return this._geomFactory.createGeometryCollection(null);
    }
    return null;
  }
  return this._geomFactory.buildGeometry(elems);
};
GeometryCombiner.prototype.interfaces_ = function interfaces_167() {
  return [];
};
GeometryCombiner.prototype.getClass = function getClass166() {
  return GeometryCombiner;
};
GeometryCombiner.combine = function combine3() {
  if (arguments.length === 1) {
    var geoms = arguments[0];
    var combiner = new GeometryCombiner(geoms);
    return combiner.combine();
  } else if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
    return combiner$1.combine();
  } else if (arguments.length === 3) {
    var g0$1 = arguments[0];
    var g1$1 = arguments[1];
    var g2 = arguments[2];
    var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));
    return combiner$2.combine();
  }
};
GeometryCombiner.extractFactory = function extractFactory(geoms) {
  if (geoms.isEmpty()) {
    return null;
  }
  return geoms.iterator().next().getFactory();
};
GeometryCombiner.createList = function createList() {
  if (arguments.length === 2) {
    var obj0 = arguments[0];
    var obj1 = arguments[1];
    var list = new ArrayList();
    list.add(obj0);
    list.add(obj1);
    return list;
  } else if (arguments.length === 3) {
    var obj0$1 = arguments[0];
    var obj1$1 = arguments[1];
    var obj2 = arguments[2];
    var list$1 = new ArrayList();
    list$1.add(obj0$1);
    list$1.add(obj1$1);
    list$1.add(obj2);
    return list$1;
  }
};
var CascadedPolygonUnion = function CascadedPolygonUnion2() {
  this._inputPolys = null;
  this._geomFactory = null;
  var polys = arguments[0];
  this._inputPolys = polys;
  if (this._inputPolys === null) {
    this._inputPolys = new ArrayList();
  }
};
var staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };
CascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries(geomTree) {
  var this$1$1 = this;
  var geoms = new ArrayList();
  for (var i = geomTree.iterator(); i.hasNext(); ) {
    var o = i.next();
    var geom = null;
    if (hasInterface(o, List)) {
      geom = this$1$1.unionTree(o);
    } else if (o instanceof Geometry) {
      geom = o;
    }
    geoms.add(geom);
  }
  return geoms;
};
CascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope(env2, geom, disjointGeoms) {
  var intersectingGeoms = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var elem = geom.getGeometryN(i);
    if (elem.getEnvelopeInternal().intersects(env2)) {
      intersectingGeoms.add(elem);
    } else {
      disjointGeoms.add(elem);
    }
  }
  return this._geomFactory.buildGeometry(intersectingGeoms);
};
CascadedPolygonUnion.prototype.unionOptimized = function unionOptimized(g0, g1) {
  var g0Env = g0.getEnvelopeInternal();
  var g1Env = g1.getEnvelopeInternal();
  if (!g0Env.intersects(g1Env)) {
    var combo = GeometryCombiner.combine(g0, g1);
    return combo;
  }
  if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) {
    return this.unionActual(g0, g1);
  }
  var commonEnv = g0Env.intersection(g1Env);
  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
};
CascadedPolygonUnion.prototype.union = function union4() {
  if (this._inputPolys === null) {
    throw new Error("union() method cannot be called twice");
  }
  if (this._inputPolys.isEmpty()) {
    return null;
  }
  this._geomFactory = this._inputPolys.iterator().next().getFactory();
  var index2 = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
  for (var i = this._inputPolys.iterator(); i.hasNext(); ) {
    var item = i.next();
    index2.insert(item.getEnvelopeInternal(), item);
  }
  this._inputPolys = null;
  var itemTree = index2.itemsTree();
  var unionAll = this.unionTree(itemTree);
  return unionAll;
};
CascadedPolygonUnion.prototype.binaryUnion = function binaryUnion() {
  if (arguments.length === 1) {
    var geoms = arguments[0];
    return this.binaryUnion(geoms, 0, geoms.size());
  } else if (arguments.length === 3) {
    var geoms$1 = arguments[0];
    var start2 = arguments[1];
    var end2 = arguments[2];
    if (end2 - start2 <= 1) {
      var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start2);
      return this.unionSafe(g0, null);
    } else if (end2 - start2 === 2) {
      return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start2), CascadedPolygonUnion.getGeometry(geoms$1, start2 + 1));
    } else {
      var mid = Math.trunc((end2 + start2) / 2);
      var g0$1 = this.binaryUnion(geoms$1, start2, mid);
      var g1 = this.binaryUnion(geoms$1, mid, end2);
      return this.unionSafe(g0$1, g1);
    }
  }
};
CascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion(geoms) {
  var union8 = null;
  for (var i = geoms.iterator(); i.hasNext(); ) {
    var g = i.next();
    if (union8 === null) {
      union8 = g.copy();
    } else {
      union8 = union8.union(g);
    }
  }
  return union8;
};
CascadedPolygonUnion.prototype.unionSafe = function unionSafe(g0, g1) {
  if (g0 === null && g1 === null) {
    return null;
  }
  if (g0 === null) {
    return g1.copy();
  }
  if (g1 === null) {
    return g0.copy();
  }
  return this.unionOptimized(g0, g1);
};
CascadedPolygonUnion.prototype.unionActual = function unionActual(g0, g1) {
  return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));
};
CascadedPolygonUnion.prototype.unionTree = function unionTree(geomTree) {
  var geoms = this.reduceToGeometries(geomTree);
  var union8 = this.binaryUnion(geoms);
  return union8;
};
CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection(g0, g1, common) {
  var disjointPolys = new ArrayList();
  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
  var union8 = this.unionActual(g0Int, g1Int);
  disjointPolys.add(union8);
  var overallUnion = GeometryCombiner.combine(disjointPolys);
  return overallUnion;
};
CascadedPolygonUnion.prototype.bufferUnion = function bufferUnion() {
  if (arguments.length === 1) {
    var geoms = arguments[0];
    var factory = geoms.get(0).getFactory();
    var gColl = factory.buildGeometry(geoms);
    var unionAll = gColl.buffer(0);
    return unionAll;
  } else if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    var factory$1 = g0.getFactory();
    var gColl$1 = factory$1.createGeometryCollection([g0, g1]);
    var unionAll$1 = gColl$1.buffer(0);
    return unionAll$1;
  }
};
CascadedPolygonUnion.prototype.interfaces_ = function interfaces_168() {
  return [];
};
CascadedPolygonUnion.prototype.getClass = function getClass167() {
  return CascadedPolygonUnion;
};
CascadedPolygonUnion.restrictToPolygons = function restrictToPolygons(g) {
  if (hasInterface(g, Polygonal)) {
    return g;
  }
  var polygons2 = PolygonExtracter.getPolygons(g);
  if (polygons2.size() === 1) {
    return polygons2.get(0);
  }
  return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons2));
};
CascadedPolygonUnion.getGeometry = function getGeometry2(list, index2) {
  if (index2 >= list.size()) {
    return null;
  }
  return list.get(index2);
};
CascadedPolygonUnion.union = function union5(polys) {
  var op = new CascadedPolygonUnion(polys);
  return op.union();
};
staticAccessors$47.STRTREE_NODE_CAPACITY.get = function() {
  return 4;
};
Object.defineProperties(CascadedPolygonUnion, staticAccessors$47);
var UnionOp = function UnionOp2() {
};
UnionOp.prototype.interfaces_ = function interfaces_169() {
  return [];
};
UnionOp.prototype.getClass = function getClass168() {
  return UnionOp;
};
UnionOp.union = function union6(g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    if (g.isEmpty() && other.isEmpty()) {
      return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());
    }
    if (g.isEmpty()) {
      return other.copy();
    }
    if (other.isEmpty()) {
      return g.copy();
    }
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);
};
function adder() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = this.t = 0;
  },
  add: function(y2) {
    add$1(temp, y2, this.t);
    add$1(this, temp.s, this.s);
    if (this.s)
      this.t += temp.t;
    else
      this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add$1(adder2, a, b) {
  var x2 = adder2.s = a + b, bv = x2 - a, av = x2 - bv;
  adder2.t = a - av + (b - bv);
}
var epsilon = 1e-6;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs$1 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var sin = Math.sin;
var sqrt3 = Math.sqrt;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
}
function noop$1() {
}
function streamGeometry(geometry2, stream) {
  if (geometry2 && streamGeometryType.hasOwnProperty(geometry2.type)) {
    streamGeometryType[geometry2.type](geometry2, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features2 = object2.features, i = -1, n = features2.length;
    while (++i < n)
      streamGeometry(features2[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object2 = coordinates[i], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate2;
  stream.lineStart();
  while (++i < n)
    coordinate2 = coordinates[i], stream.point(coordinate2[0], coordinate2[1], coordinate2[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function geoStream(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}
adder();
adder();
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt3(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
adder();
function compose(a, b) {
  function compose2(x2, y2) {
    return x2 = a(x2, y2), b(x2[0], x2[1]);
  }
  if (a.invert && b.invert)
    compose2.invert = function(x2, y2) {
      return x2 = b.invert(x2, y2), x2 && a.invert(x2[0], x2[1]);
    };
  return compose2;
}
function rotationIdentity(lambda, phi) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan2(y2 * cosDeltaGamma - k * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan2(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function circleStream(stream, radius, delta2, direction, t0, t1) {
  if (!delta2)
    return;
  var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta2;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1)
      t0 += direction * tau;
  }
  for (var point4, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point4 = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point4[0], point4[1]);
  }
}
function circleRadius(cosRadius, point4) {
  point4 = cartesian(point4), point4[0] -= cosRadius;
  cartesianNormalizeInPlace(point4);
  var radius = acos(-point4[1]);
  return ((-point4[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}
function clipBuffer() {
  var lines = [], line;
  return {
    point: function(x2, y2) {
      line.push([x2, y2]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop$1,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}
function clipLine(a, b, x02, y02, x12, y12) {
  var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dx > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dx > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dy > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dy > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  if (t0 > 0)
    a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1)
    b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}
function pointEqual(a, b) {
  return abs$1(a[0] - b[0]) < epsilon && abs$1(a[1] - b[1]) < epsilon;
}
function Intersection(point4, points2, other, entry) {
  this.x = point4;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function clipPolygon(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip2 = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x2;
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n2; ++i)
        stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }
    subject.push(x2 = new Intersection(p0, segment, null, true));
    clip2.push(x2.o = new Intersection(p0, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip2.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length)
    return;
  clip2.sort(compareIntersection2);
  link(subject);
  link(clip2);
  for (i = 0, n = clip2.length; i < n; ++i) {
    clip2[i].e = startInside = !startInside;
  }
  var start2 = subject[0], points2, point4;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i)
            stream.point((point4 = points2[i])[0], point4[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i = points2.length - 1; i >= 0; --i)
            stream.point((point4 = points2[i])[0], point4[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array) {
  if (!(n = array.length))
    return;
  var n, i = 0, a = array[0], b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(compare11) {
  if (compare11.length === 1)
    compare11 = ascendingComparator(compare11);
  return {
    left: function(a, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare11(a[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare11(a[mid], x2) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x2) {
    return ascending(f(d), x2);
  };
}
bisector(ascending);
function merge$2(arrays) {
  var n = arrays.length, m2, i = -1, j = 0, merged, array;
  while (++i < n)
    j += arrays[i].length;
  merged = new Array(j);
  while (--n >= 0) {
    array = arrays[n];
    m2 = array.length;
    while (--m2 >= 0) {
      merged[--j] = array[m2];
    }
  }
  return merged;
}
var clipMax = 1e9, clipMin = -clipMax;
function clipExtent(x02, y02, x12, y12) {
  function visible(x2, y2) {
    return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
  }
  function interpolate2(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs$1(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs$1(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs$1(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a, b) {
    return comparePoint(a.x, b.x);
  }
  function comparePoint(a, b) {
    var ca = corner(a, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = clipBuffer(), segments, polygon4, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point4,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point4(x2, y2) {
      if (visible(x2, y2))
        activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon4.length; i < n; ++i) {
        for (var ring2 = polygon4[i], j = 1, m2 = ring2.length, point5 = ring2[0], a0, a1, b0 = point5[0], b1 = point5[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point5 = ring2[j], b0 = point5[0], b1 = point5[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon4 = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge$2(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          clipPolygon(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon4 = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon4)
        polygon4.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point4;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x2, y2) {
      var v = visible(x2, y2);
      if (polygon4)
        ring.push([x2, y2]);
      if (first) {
        x__ = x2, y__ = y2, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v && v_)
          activeStream.point(x2, y2);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (clipLine(a, b, x02, y02, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v;
    }
    return clipStream;
  };
}
var sum$1 = adder();
function polygonContains(polygon4, point4) {
  var lambda = point4[0], phi = point4[1], normal = [sin(lambda), -cos(lambda), 0], angle4 = 0, winding = 0;
  sum$1.reset();
  for (var i = 0, n = polygon4.length; i < n; ++i) {
    if (!(m2 = (ring = polygon4[i]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j = 0; j < m2; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta2 = lambda1 - lambda0, sign2 = delta2 >= 0 ? 1 : -1, absDelta = sign2 * delta2, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
      sum$1.add(atan2(k * sign2 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle4 += antimeridian ? delta2 + sign2 * tau : delta2;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection11 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection11);
        var phiArc = (antimeridian ^ delta2 >= 0 ? -1 : 1) * asin(intersection11[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta2 >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle4 < -epsilon || angle4 < epsilon && sum$1 < -epsilon) ^ winding & 1;
}
adder();
function identity$1(x2) {
  return x2;
}
adder();
adder();
var x0 = Infinity, y0 = x0, x1 = -x0, y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1,
  result: function() {
    var bounds2 = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds2;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x0)
    x0 = x2;
  if (x2 > x1)
    x1 = x2;
  if (y2 < y0)
    y0 = y2;
  if (y2 > y1)
    y1 = y2;
}
adder();
function clip$1(pointVisible, clipLine2, interpolate2, start2) {
  return function(rotate2, sink) {
    var line = clipLine2(sink), rotatedStart = rotate2.invert(start2[0], start2[1]), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon4, segments, ring;
    var clip2 = {
      point: point4,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip2.point = pointRing;
        clip2.lineStart = ringStart;
        clip2.lineEnd = ringEnd;
        segments = [];
        polygon4 = [];
      },
      polygonEnd: function() {
        clip2.point = point4;
        clip2.lineStart = lineStart;
        clip2.lineEnd = lineEnd;
        segments = merge$2(segments);
        var startInside = polygonContains(polygon4, rotatedStart);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          clipPolygon(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon4 = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point4(lambda, phi) {
      var point5 = rotate2(lambda, phi);
      if (pointVisible(lambda = point5[0], phi = point5[1]))
        sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      var point5 = rotate2(lambda, phi);
      line.point(point5[0], point5[1]);
    }
    function lineStart() {
      clip2.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip2.point = point4;
      line.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point5 = rotate2(lambda, phi);
      ringSink.point(point5[0], point5[1]);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point5;
      ring.pop();
      polygon4.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i)
            sink.point((point5 = segment[i])[0], point5[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip2;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}
var clipAntimeridian = clip$1(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi, delta2 = abs$1(lambda1 - lambda0);
      if (abs$1(delta2 - pi) < epsilon) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta2 >= pi) {
        if (abs$1(lambda0 - sign0) < epsilon)
          lambda0 -= sign0 * epsilon;
        if (abs$1(lambda1 - sign1) < epsilon)
          lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs$1(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs$1(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}
function clipCircle(radius, delta2) {
  var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs$1(cr) > epsilon;
  function interpolate2(from, to, direction, stream) {
    circleStream(stream, radius, delta2, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine2(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point22, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v))
          stream.lineStart();
        if (v !== v0) {
          point22 = intersect2(point0, point1);
          if (!point22 || pointEqual(point0, point22) || pointEqual(point1, point22)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect2(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect2(point0, point1);
            stream.point(point22[0], point22[1]);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c & c0) && (t = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a, b, two) {
    var pa = cartesian(a), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant2 = n2n2 - n1n2 * n1n2;
    if (!determinant2)
      return !two && a;
    var c1 = cr * n2n2 / determinant2, c2 = -cr * n1n2 / determinant2, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B2);
    var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
    if (t2 < 0)
      return;
    var t = sqrt3(t2), q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);
    if (!two)
      return q;
    var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;
    if (lambda1 < lambda0)
      z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta3 = lambda1 - lambda0, polar = abs$1(delta3 - pi) < epsilon, meridian = polar || delta3 < epsilon;
    if (!polar && phi1 < phi0)
      z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta3 > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi < -r)
      code2 |= 4;
    else if (phi > r)
      code2 |= 8;
    return code2;
  }
  return clip$1(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}
function transformer(methods) {
  return function(stream) {
    var s = new TransformStream();
    for (var key in methods)
      s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fitExtent(projection2, extent3, object2) {
  var w = extent3[1][0] - extent3[0][0], h = extent3[1][1] - extent3[0][1], clip2 = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip2 != null)
    projection2.clipExtent(null);
  geoStream(object2, projection2.stream(boundsStream));
  var b = boundsStream.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x2 = +extent3[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y2 = +extent3[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
  if (clip2 != null)
    projection2.clipExtent(clip2);
  return projection2.scale(k * 150).translate([x2, y2]);
}
function fitSize(projection2, size11, object2) {
  return fitExtent(projection2, [[0, 0], size11], object2);
}
var maxDepth = 16, cosMinDistance = cos(30 * radians);
function resample(project2, delta2) {
  return +delta2 ? resample$1(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x2, y2) {
      x2 = project2(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample$1(project2, delta2) {
  function resampleLineTo(x02, y02, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth2, stream) {
    var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth2--) {
      var a = a0 + a1, b = b0 + b1, c = c0 + c1, m2 = sqrt3(a * a + b * b + c * c), phi2 = asin(c /= m2), lambda2 = abs$1(abs$1(c) - 1) < epsilon || abs$1(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project2(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x02, y02, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m2, b /= m2, c, depth2, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x12, y12, lambda1, a1, b1, c1, depth2, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, lambda0, x02, y02, a0, b0, c0;
    var resampleStream = {
      point: point4,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point4(x2, y2) {
      x2 = project2(x2, y2);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x02 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project2(lambda, phi);
      resampleLineTo(x02, y02, lambda0, a0, b0, c0, x02 = p[0], y02 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x02, y02);
    }
    function lineEnd() {
      resampleStream.point = point4;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x02, y00 = y02, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x02, y02, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var transformRadians = transformer({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k = 150, x2 = 480, y2 = 250, dx, dy, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, projectRotate, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity$1, delta2 = 0.5, projectResample = resample(projectTransform, delta2), cache, cacheStream;
  function projection2(point4) {
    point4 = projectRotate(point4[0] * radians, point4[1] * radians);
    return [point4[0] * k + dx, dy - point4[1] * k];
  }
  function invert2(point4) {
    point4 = projectRotate.invert((point4[0] - dx) / k, (dy - point4[1]) / k);
    return point4 && [point4[0] * degrees, point4[1] * degrees];
  }
  function projectTransform(x3, y3) {
    return x3 = project2(x3, y3), [x3[0] * k + dx, dy - x3[1] * k];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate2, projectResample(postclip(cacheStream = stream))));
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity$1) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x2 = +_[0], y2 = +_[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt3(delta2);
  };
  projection2.fitExtent = function(extent3, object2) {
    return fitExtent(projection2, extent3, object2);
  };
  projection2.fitSize = function(size11, object2) {
    return fitSize(projection2, size11, object2);
  };
  function recenter() {
    projectRotate = compose(rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project2);
    var center2 = project2(lambda, phi);
    dx = x2 - center2[0] * k;
    dy = y2 + center2[1] * k;
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection2.invert = project2.invert && invert2;
    return recenter();
  };
}
function azimuthalRaw(scale4) {
  return function(x2, y2) {
    var cx = cos(x2), cy = cos(y2), k = scale4(cx * cy);
    return [
      k * cy * sin(x2),
      k * sin(y2)
    ];
  };
}
function azimuthalInvert(angle4) {
  return function(x2, y2) {
    var z = sqrt3(x2 * x2 + y2 * y2), c = angle4(z), sc = sin(c), cc = cos(c);
    return [
      atan2(x2 * sc, z * cc),
      asin(z && y2 * sc / z)
    ];
  };
}
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt3(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});
var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function geoAzimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function buffer2(geojson, radius, options) {
  options = options || {};
  var units = options.units || "kilometers";
  var steps = options.steps || 8;
  if (!geojson)
    throw new Error("geojson is required");
  if (typeof options !== "object")
    throw new Error("options must be an object");
  if (typeof steps !== "number")
    throw new Error("steps must be an number");
  if (radius === void 0)
    throw new Error("radius is required");
  if (steps <= 0)
    throw new Error("steps must be greater than 0");
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        var buffered = bufferFeature(geometry2, radius, units, steps);
        if (buffered)
          results.push(buffered);
      });
      return featureCollection$1(results);
    case "FeatureCollection":
      featureEach$1(geojson, function(feature2) {
        var multiBuffered = bufferFeature(feature2, radius, units, steps);
        if (multiBuffered) {
          featureEach$1(multiBuffered, function(buffered) {
            if (buffered)
              results.push(buffered);
          });
        }
      });
      return featureCollection$1(results);
  }
  return bufferFeature(geojson, radius, units, steps);
}
function bufferFeature(geojson, radius, units, steps) {
  var properties = geojson.properties || {};
  var geometry2 = geojson.type === "Feature" ? geojson.geometry : geojson;
  if (geometry2.type === "GeometryCollection") {
    var results = [];
    geomEach(geojson, function(geometry3) {
      var buffered2 = bufferFeature(geometry3, radius, units, steps);
      if (buffered2)
        results.push(buffered2);
    });
    return featureCollection$1(results);
  }
  var projection2 = defineProjection(geometry2);
  var projected = {
    type: geometry2.type,
    coordinates: projectCoords(geometry2.coordinates, projection2)
  };
  var reader = new GeoJSONReader();
  var geom = reader.read(projected);
  var distance11 = radiansToLength(lengthToRadians(radius, units), "meters");
  var buffered = BufferOp.bufferOp(geom, distance11, steps);
  var writer = new GeoJSONWriter();
  buffered = writer.write(buffered);
  if (coordsIsNaN(buffered.coordinates))
    return void 0;
  var result = {
    type: buffered.type,
    coordinates: unprojectCoords(buffered.coordinates, projection2)
  };
  return feature(result, properties);
}
function coordsIsNaN(coords) {
  if (Array.isArray(coords[0]))
    return coordsIsNaN(coords[0]);
  return isNaN(coords[0]);
}
function projectCoords(coords, proj) {
  if (typeof coords[0] !== "object")
    return proj(coords);
  return coords.map(function(coord) {
    return projectCoords(coord, proj);
  });
}
function unprojectCoords(coords, proj) {
  if (typeof coords[0] !== "object")
    return proj.invert(coords);
  return coords.map(function(coord) {
    return unprojectCoords(coord, proj);
  });
}
function defineProjection(geojson) {
  var coords = center$2(geojson).geometry.coordinates;
  var rotation = [-coords[0], -coords[1]];
  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);
}
function union7(poly1, poly2, options) {
  if (options === void 0) {
    options = {};
  }
  var geom1 = getGeom(poly1);
  var geom2 = getGeom(poly2);
  var unioned = polygonClipping.union(geom1.coordinates, geom2.coordinates);
  if (unioned.length === 0)
    return null;
  if (unioned.length === 1)
    return polygon(unioned[0], options.properties);
  else
    return multiPolygon(unioned, options.properties);
}
function intersect$1(poly1, poly2, options) {
  if (options === void 0) {
    options = {};
  }
  var geom1 = getGeom(poly1);
  var geom2 = getGeom(poly2);
  var intersection11 = polygonClipping.intersection(geom1.coordinates, geom2.coordinates);
  if (intersection11.length === 0)
    return null;
  if (intersection11.length === 1)
    return polygon(intersection11[0], options.properties);
  return multiPolygon(intersection11, options.properties);
}
function dissolve(fc, options) {
  options = options || {};
  if (!isObject$5(options))
    throw new Error("options is invalid");
  var propertyName = options.propertyName;
  collectionOf(fc, "Polygon", "dissolve");
  var outFeatures = [];
  if (!options.propertyName) {
    return flatten(
      multiPolygon(
        polygonClipping.union.apply(
          null,
          fc.features.map(function(f) {
            return f.geometry.coordinates;
          })
        )
      )
    );
  } else {
    var uniquePropertyVals = {};
    featureEach$1(fc, function(feature2) {
      if (!Object.prototype.hasOwnProperty.call(
        uniquePropertyVals,
        feature2.properties[propertyName]
      )) {
        uniquePropertyVals[feature2.properties[propertyName]] = [];
      }
      uniquePropertyVals[feature2.properties[propertyName]].push(feature2);
    });
    var vals = Object.keys(uniquePropertyVals);
    for (var i = 0; i < vals.length; i++) {
      var mp = multiPolygon(
        polygonClipping.union.apply(
          null,
          uniquePropertyVals[vals[i]].map(function(f) {
            return f.geometry.coordinates;
          })
        )
      );
      mp.properties[propertyName] = vals[i];
      outFeatures.push(mp);
    }
  }
  return flatten(featureCollection$1(outFeatures));
}
function hexGrid(bbox2, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  var clonedProperties = JSON.stringify(options.properties || {});
  var west = bbox2[0], south = bbox2[1], east = bbox2[2], north = bbox2[3];
  var centerY = (south + north) / 2;
  var centerX = (west + east) / 2;
  var xFraction = cellSide * 2 / distance$2([west, centerY], [east, centerY], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = cellSide * 2 / distance$2([centerX, south], [centerX, north], options);
  var cellHeight = yFraction * (north - south);
  var radius = cellWidth / 2;
  var hex_width = radius * 2;
  var hex_height = Math.sqrt(3) / 2 * cellHeight;
  var box_width = east - west;
  var box_height = north - south;
  var x_interval = 3 / 4 * hex_width;
  var y_interval = hex_height;
  var x_span = (box_width - hex_width) / (hex_width - radius / 2);
  var x_count = Math.floor(x_span);
  var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
  var y_count = Math.floor((box_height - hex_height) / hex_height);
  var y_adjust = (box_height - y_count * hex_height) / 2;
  var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
  if (hasOffsetY) {
    y_adjust -= hex_height / 4;
  }
  var cosines = [];
  var sines = [];
  for (var i = 0; i < 6; i++) {
    var angle4 = 2 * Math.PI / 6 * i;
    cosines.push(Math.cos(angle4));
    sines.push(Math.sin(angle4));
  }
  var results = [];
  for (var x2 = 0; x2 <= x_count; x2++) {
    for (var y2 = 0; y2 <= y_count; y2++) {
      var isOdd = x2 % 2 === 1;
      if (y2 === 0 && isOdd)
        continue;
      if (y2 === 0 && hasOffsetY)
        continue;
      var center_x = x2 * x_interval + west - x_adjust;
      var center_y = y2 * y_interval + south + y_adjust;
      if (isOdd) {
        center_y -= hex_height / 2;
      }
      if (options.triangles === true) {
        hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function(triangle) {
          if (options.mask) {
            if (intersect$1(options.mask, triangle))
              results.push(triangle);
          } else {
            results.push(triangle);
          }
        });
      } else {
        var hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
        if (options.mask) {
          if (intersect$1(options.mask, hex))
            results.push(hex);
        } else {
          results.push(hex);
        }
      }
    }
  }
  return featureCollection$1(results);
}
function hexagon(center2, rx, ry, properties, cosines, sines) {
  var vertices = [];
  for (var i = 0; i < 6; i++) {
    var x2 = center2[0] + rx * cosines[i];
    var y2 = center2[1] + ry * sines[i];
    vertices.push([x2, y2]);
  }
  vertices.push(vertices[0].slice());
  return polygon([vertices], properties);
}
function hexTriangles(center2, rx, ry, properties, cosines, sines) {
  var triangles = [];
  for (var i = 0; i < 6; i++) {
    var vertices = [];
    vertices.push(center2);
    vertices.push([center2[0] + rx * cosines[i], center2[1] + ry * sines[i]]);
    vertices.push([
      center2[0] + rx * cosines[(i + 1) % 6],
      center2[1] + ry * sines[(i + 1) % 6]
    ]);
    vertices.push(center2);
    triangles.push(polygon([vertices], properties));
  }
  return triangles;
}
function mask(polygon4, mask2) {
  var maskPolygon = createMask(mask2);
  var polygonOuters = null;
  if (polygon4.type === "FeatureCollection")
    polygonOuters = unionFc(polygon4);
  else
    polygonOuters = createGeomFromPolygonClippingOutput(
      polygonClipping.union(polygon4.geometry.coordinates)
    );
  polygonOuters.geometry.coordinates.forEach(function(contour) {
    maskPolygon.geometry.coordinates.push(contour[0]);
  });
  return maskPolygon;
}
function unionFc(fc) {
  var unioned = fc.features.length === 2 ? polygonClipping.union(
    fc.features[0].geometry.coordinates,
    fc.features[1].geometry.coordinates
  ) : polygonClipping.union.apply(
    polygonClipping,
    fc.features.map(function(f) {
      return f.geometry.coordinates;
    })
  );
  return createGeomFromPolygonClippingOutput(unioned);
}
function createGeomFromPolygonClippingOutput(unioned) {
  return multiPolygon(unioned);
}
function createMask(mask2) {
  var world = [
    [
      [180, 90],
      [-180, 90],
      [-180, -90],
      [180, -90],
      [180, 90]
    ]
  ];
  var coordinates = mask2 && mask2.geometry.coordinates || world;
  return polygon(coordinates);
}
function rectangleGrid(bbox2, cellWidth, cellHeight, options) {
  if (options === void 0) {
    options = {};
  }
  var results = [];
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  var xFraction = cellWidth / distance$2([west, south], [east, south], options);
  var cellWidthDeg = xFraction * (east - west);
  var yFraction = cellHeight / distance$2([west, south], [west, north], options);
  var cellHeightDeg = yFraction * (north - south);
  var bboxWidth = east - west;
  var bboxHeight = north - south;
  var columns = Math.floor(bboxWidth / cellWidthDeg);
  var rows = Math.floor(bboxHeight / cellHeightDeg);
  var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
  var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
  var currentX = west + deltaX;
  for (var column = 0; column < columns; column++) {
    var currentY = south + deltaY;
    for (var row = 0; row < rows; row++) {
      var cellPoly = polygon([
        [
          [currentX, currentY],
          [currentX, currentY + cellHeightDeg],
          [currentX + cellWidthDeg, currentY + cellHeightDeg],
          [currentX + cellWidthDeg, currentY],
          [currentX, currentY]
        ]
      ], options.properties);
      if (options.mask) {
        if (booleanIntersects(options.mask, cellPoly)) {
          results.push(cellPoly);
        }
      } else {
        results.push(cellPoly);
      }
      currentY += cellHeightDeg;
    }
    currentX += cellWidthDeg;
  }
  return featureCollection$1(results);
}
function squareGrid(bbox2, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  return rectangleGrid(bbox2, cellSide, cellSide, options);
}
function triangleGrid(bbox2, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  var results = [];
  var xFraction = cellSide / distance$2([bbox2[0], bbox2[1]], [bbox2[2], bbox2[1]], options);
  var cellWidth = xFraction * (bbox2[2] - bbox2[0]);
  var yFraction = cellSide / distance$2([bbox2[0], bbox2[1]], [bbox2[0], bbox2[3]], options);
  var cellHeight = yFraction * (bbox2[3] - bbox2[1]);
  var xi = 0;
  var currentX = bbox2[0];
  while (currentX <= bbox2[2]) {
    var yi = 0;
    var currentY = bbox2[1];
    while (currentY <= bbox2[3]) {
      var cellTriangle1 = null;
      var cellTriangle2 = null;
      if (xi % 2 === 0 && yi % 2 === 0) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY + cellHeight]
          ]
        ], options.properties);
      } else if (xi % 2 === 0 && yi % 2 === 1) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX, currentY]
          ]
        ], options.properties);
      } else if (yi % 2 === 0 && xi % 2 === 1) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
      } else if (yi % 2 === 1 && xi % 2 === 1) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY + cellHeight]
          ]
        ], options.properties);
      }
      if (options.mask) {
        if (intersect$1(options.mask, cellTriangle1))
          results.push(cellTriangle1);
        if (intersect$1(options.mask, cellTriangle2))
          results.push(cellTriangle2);
      } else {
        results.push(cellTriangle1);
        results.push(cellTriangle2);
      }
      currentY += cellHeight;
      yi++;
    }
    xi++;
    currentX += cellWidth;
  }
  return featureCollection$1(results);
}
function interpolate(points2, cellSize, options) {
  options = options || {};
  if (typeof options !== "object")
    throw new Error("options is invalid");
  var gridType = options.gridType;
  var property = options.property;
  var weight = options.weight;
  if (!points2)
    throw new Error("points is required");
  collectionOf(points2, "Point", "input must contain Points");
  if (!cellSize)
    throw new Error("cellSize is required");
  if (weight !== void 0 && typeof weight !== "number")
    throw new Error("weight must be a number");
  property = property || "elevation";
  gridType = gridType || "square";
  weight = weight || 1;
  var box2 = bbox$1(points2);
  var grid;
  switch (gridType) {
    case "point":
    case "points":
      grid = pointGrid(box2, cellSize, options);
      break;
    case "square":
    case "squares":
      grid = squareGrid(box2, cellSize, options);
      break;
    case "hex":
    case "hexes":
      grid = hexGrid(box2, cellSize, options);
      break;
    case "triangle":
    case "triangles":
      grid = triangleGrid(box2, cellSize, options);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var results = [];
  featureEach$1(grid, function(gridFeature) {
    var zw = 0;
    var sw = 0;
    featureEach$1(points2, function(point4) {
      var gridPoint = gridType === "point" ? gridFeature : centroid$2(gridFeature);
      var d = distance$2(gridPoint, point4, options);
      var zValue;
      if (property !== void 0)
        zValue = point4.properties[property];
      if (zValue === void 0)
        zValue = point4.geometry.coordinates[2];
      if (zValue === void 0)
        throw new Error("zValue is missing");
      if (d === 0)
        zw = zValue;
      var w = 1 / Math.pow(d, weight);
      sw += w;
      zw += w * zValue;
    });
    var newFeature = clone$5(gridFeature);
    newFeature.properties[property] = zw / sw;
    results.push(newFeature);
  });
  return featureCollection$1(results);
}
var turf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  projection: index$3,
  random: index$2,
  clusters: index$1,
  helpers: es$2,
  invariant: index$5,
  meta: es$1,
  isolines,
  convex,
  pointsWithinPolygon,
  within: pointsWithinPolygon,
  concave,
  collect: collect$1,
  flip,
  simplify: simplify$1,
  bezier,
  bezierSpline: bezier,
  tag,
  sample,
  envelope,
  square,
  circle,
  midpoint,
  center: center$2,
  centerOfMass,
  centroid: centroid$2,
  combine,
  distance: distance$2,
  explode: explode$1,
  bbox: bbox$1,
  tesselate,
  bboxPolygon,
  booleanPointInPolygon,
  inside: booleanPointInPolygon,
  nearest: nearestPoint,
  nearestPoint,
  nearestPointOnLine,
  pointOnLine: nearestPointOnLine,
  nearestPointToLine,
  planepoint,
  tin,
  bearing,
  destination,
  kinks,
  pointOnFeature,
  pointOnSurface: pointOnFeature,
  area,
  along,
  length: length$1,
  lineDistance: length$1,
  lineSlice,
  lineSliceAlong,
  pointGrid,
  truncate,
  flatten,
  lineIntersect,
  lineChunk,
  unkinkPolygon,
  greatCircle,
  lineSegment,
  lineSplit,
  lineArc,
  polygonToLine,
  polygonToLineString: polygonToLine,
  lineStringToPolygon: lineToPolygon,
  lineToPolygon,
  bboxClip,
  lineOverlap,
  sector,
  rhumbBearing,
  rhumbDistance,
  rhumbDestination,
  polygonTangents,
  rewind,
  isobands,
  transformRotate,
  transformScale,
  transformTranslate,
  lineOffset,
  polygonize,
  booleanDisjoint,
  booleanContains,
  booleanCrosses,
  booleanClockwise,
  booleanOverlap,
  booleanPointOnLine,
  booleanEqual,
  booleanWithin,
  booleanIntersects,
  clone: clone$5,
  cleanCoords,
  clustersDbscan,
  clustersKmeans,
  pointToLineDistance,
  booleanParallel,
  shortestPath,
  voronoi,
  ellipse,
  centerMean,
  centerMedian,
  standardDeviationalEllipse,
  angle,
  polygonSmooth,
  moranIndex: index$4,
  distanceWeight,
  bearingToAngle: bearingToAzimuth,
  convertDistance: convertLength,
  degrees2radians: degreesToRadians,
  distanceToDegrees: lengthToDegrees,
  distanceToRadians: lengthToRadians,
  radians2degrees: radiansToDegrees,
  radiansToDistance: radiansToLength,
  difference: difference2,
  buffer: buffer2,
  union: union7,
  intersect: intersect$1,
  dissolve,
  hexGrid,
  mask,
  squareGrid,
  triangleGrid,
  interpolate,
  toMercator,
  toWgs84,
  randomPosition,
  randomPoint,
  randomPolygon,
  randomLineString,
  getCluster,
  clusterEach,
  clusterReduce,
  createBins,
  applyFilter,
  propertiesContainsFilter,
  filterProperties,
  earthRadius,
  factors,
  unitsFactors,
  areaFactors,
  feature,
  geometry: geometry$1,
  point,
  points: points$3,
  polygon,
  polygons,
  lineString,
  lineStrings,
  featureCollection: featureCollection$1,
  multiLineString,
  multiPoint,
  multiPolygon,
  geometryCollection,
  round: round$4,
  radiansToLength,
  lengthToRadians,
  lengthToDegrees,
  bearingToAzimuth,
  radiansToDegrees,
  degreesToRadians,
  convertLength,
  convertArea,
  isNumber: isNumber$2,
  isObject: isObject$5,
  validateBBox,
  validateId,
  getCoord,
  getCoords,
  containsNumber,
  geojsonType,
  featureOf,
  collectionOf,
  getGeom,
  getType: getType$1,
  coordAll,
  coordEach,
  coordReduce,
  featureEach: featureEach$1,
  featureReduce,
  findPoint,
  findSegment,
  flattenEach,
  flattenReduce,
  geomEach,
  geomReduce,
  lineEach,
  lineReduce,
  propEach,
  propReduce,
  segmentEach,
  segmentReduce
}, Symbol.toStringTag, { value: "Module" }));
var axios$2 = { exports: {} };
var bind$4 = function bind2(fn, thisArg) {
  return function wrap2() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$3 = bind$4;
var toString25 = Object.prototype.toString;
function isArray$2(val) {
  return toString25.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString25.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$4(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString25.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString25.call(val) === "[object Date]";
}
function isFile(val) {
  return toString25.call(val) === "[object File]";
}
function isBlob(val) {
  return toString25.call(val) === "[object Blob]";
}
function isFunction$1(val) {
  return toString25.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$4(val) && isFunction$1(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim$2(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray$2(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}
function extend$1(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$3(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$d = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isObject: isObject$4,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$1,
  extend: extend$1,
  trim: trim$2,
  stripBOM
};
var utils$c = utils$d;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$c.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$c.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$c.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$c.forEach(val, function parseValue(v) {
        if (utils$c.isDate(v)) {
          v = v.toISOString();
        } else if (utils$c.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + "=" + encode(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$b = utils$d;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$b.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$a = utils$d;
var normalizeHeaderName$1 = function normalizeHeaderName(headers2, normalizedName) {
  utils$a.forEach(headers2, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers2[normalizedName] = value;
      delete headers2[name2];
    }
  });
};
var enhanceError$2 = function enhanceError(error2, config, code, request2, response) {
  error2.config = config;
  if (code) {
    error2.code = code;
  }
  error2.request = request2;
  error2.response = response;
  error2.isAxiosError = true;
  error2.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error2;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError(message, config, code, request2, response) {
  var error2 = new Error(message);
  return enhanceError$1(error2, config, code, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError$1(
      "Request failed with status code " + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};
var utils$9 = utils$d;
var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write5(name2, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils$9.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$9.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$9.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read4(name2) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove6(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write5() {
    },
    read: function read4() {
      return null;
    },
    remove: function remove6() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$8 = utils$d;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders(headers2) {
  var parsed = {};
  var key;
  var val;
  var i;
  if (!headers2) {
    return parsed;
  }
  utils$8.forEach(headers2.split("\n"), function parser(line) {
    i = line.indexOf(":");
    key = utils$8.trim(line.substr(0, i)).toLowerCase();
    val = utils$8.trim(line.substr(i + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$7 = utils$d;
var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var utils$6 = utils$d;
var settle2 = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath2 = buildFullPath$1;
var parseHeaders2 = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError2 = createError$2;
var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    if (utils$6.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config.auth) {
      var username = config.auth.username || "";
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath2(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle2(resolve, reject, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError2("Request aborted", config, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(createError2("Network Error", config, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError2(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
        request2
      ));
      request2 = null;
    };
    if (utils$6.isStandardBrowserEnv()) {
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$6.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", config.onDownloadProgress);
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config.onUploadProgress);
    }
    if (config.cancelToken) {
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request2) {
          return;
        }
        request2.abort();
        reject(cancel);
        request2 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$5 = utils$d;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers2, value) {
  if (!utils$5.isUndefined(headers2) && utils$5.isUndefined(headers2["Content-Type"])) {
    headers2["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$4 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers2) {
    normalizeHeaderName2(headers2, "Accept");
    normalizeHeaderName2(headers2, "Content-Type");
    if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
      return data;
    }
    if (utils$5.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$5.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers2, "application/x-www-form-urlencoded;charset=utf-8");
      return data.toString();
    }
    if (utils$5.isObject(data) || headers2 && headers2["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers2, "application/json");
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional2 = this.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError2(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$4.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$4.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$4.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$4;
var utils$4 = utils$d;
var defaults$3 = defaults_1;
var transformData$1 = function transformData(data, headers2, fns) {
  var context = this || defaults$3;
  utils$4.forEach(fns, function transform4(fn) {
    data = fn.call(context, data, headers2);
  });
  return data;
};
var isCancel$1 = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};
var utils$3 = utils$d;
var transformData2 = transformData$1;
var isCancel2 = isCancel$1;
var defaults$2 = defaults_1;
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData2.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$3.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults$2.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData2.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel2(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$d;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source2) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source2)) {
      return utils$2.merge(target, source2);
    } else if (utils$2.isPlainObject(source2)) {
      return utils$2.merge({}, source2);
    } else if (utils$2.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$2.forEach(directMergeKeys, function merge4(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils$2.forEach(otherKeys, mergeDeepProperties);
  return config;
};
const name = "axios";
const version = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
};
const repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
};
const keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = {
  url: "https://github.com/axios/axios/issues"
};
const homepage = "https://axios-http.com";
const devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
};
const browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
};
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = {
  "follow-redirects": "^1.14.0"
};
const bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
];
var require$$0 = {
  name,
  version,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys3 = Object.keys(options);
  var i = keys3.length;
  while (i-- > 0) {
    var opt = keys3[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$d;
var buildURL2 = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config) {
  if (typeof config === "string") {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional2 = config.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  return buildURL2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data
    }));
  };
});
var Axios_1 = Axios$1;
function Cancel$1(message) {
  this.message = message;
}
Cancel$1.prototype.toString = function toString26() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$1.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      return;
    }
    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils = utils$d;
var bind$2 = bind$4;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$1 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance2 = bind$2(Axios.prototype.request, context);
  utils.extend(instance2, Axios.prototype, context);
  utils.extend(instance2, context);
  return instance2;
}
var axios$1 = createInstance(defaults$1);
axios$1.Axios = Axios;
axios$1.create = function create4(instanceConfig) {
  return createInstance(mergeConfig2(axios$1.defaults, instanceConfig));
};
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
const http = axios.create({
  withCredentials: true
});
http.defaults.baseURL = "";
http.interceptors.request.use(
  (config) => {
    if (config.methods === "get") {
      config.params = config.data;
      delete config.data;
    }
    if (config.url.includes("guoxin"))
      ;
    else {
      config.headers["x-hw-id"] = "de712255-9e37-4544-931f-68016062dfa4";
      config.headers["x-hw-appkey"] = "ccce26b143c32ebe8bdd2a094942fd0f2ab0b93cb0b25b1869fb5e38c11ccdc0";
    }
    return config;
  },
  (error2) => {
    return Promise.reject(error2);
  }
);
http.interceptors.response.use(
  (res) => res.status === 200 ? Promise.resolve(res) : Promise.reject(res),
  (error2) => {
    const { response } = error2;
    if (response) {
      return Promise.reject(response);
    } else {
      if (!window.navigator.onLine)
        ;
      else {
        return Promise.reject(error2);
      }
    }
  }
);
let graphicLayer$1;
let colorList$1 = ["#54B5FF", "#00FFF9", "#F9E900", "#FFB713"];
let defalutWidth = 1500;
let defalutLength$1 = 1500;
let defaultTotalHeight$1 = 1e4;
const showStandColumn = (layer2, data, colors2, length3, width, totalHeight) => {
  if (!layer2)
    return;
  graphicLayer$1 = layer2;
  if (colors2 && colors2.length > 0) {
    colorList$1 = colors2;
  }
  if (length3) {
    defalutLength$1 = length3;
  }
  if (width) {
    defalutWidth = width;
  }
  if (totalHeight) {
    defaultTotalHeight$1 = totalHeight;
  }
  const maxValue = getMaxValue$1(data);
  data.forEach((item) => {
    item.html = getHtml$1(item);
    item.totalValue = getTotalValue$1(item);
    let height = 0;
    if (item.list && item.list.length > 0) {
      item.list.forEach((obj, index2) => {
        obj.height = maxValue > 0 ? Math.floor(Number(obj.value) / maxValue * defaultTotalHeight$1) : 0;
        const position2 = mars3d$1.Cesium.Cartesian3.fromDegrees(
          item.centerPoint[0],
          item.centerPoint[1],
          getHeight2(item, index2)
        );
        height = height + obj.height;
        createZT(position2, obj.height, colorList$1[index2], item.html);
      });
    }
    item.centerPoint[2] = height;
    divGraphicWhite(graphicLayer$1, item);
  });
  changeWriteMode();
};
const getHeight2 = (item, index2) => {
  let height = 0;
  item.list.forEach((obj, i) => {
    if (i <= index2) {
      height += i === index2 ? obj.height / 2 : obj.height;
    }
  });
  return height;
};
const getMaxValue$1 = (data) => {
  const numArray = data.map((item) => {
    if (item.list && item.list.length > 0) {
      return item.list.reduce((prev, next3) => {
        return Number(prev && prev.value || prev) + Number(next3.value);
      }, 0);
    } else {
      return 0;
    }
  });
  return Math.max.apply(null, numArray);
};
const getTotalValue$1 = (item) => {
  if (item.list && item.list.length > 0) {
    return item.list.reduce((prev, next3) => {
      return Number(prev && prev.value || prev) + Number(next3.value);
    }, 0);
  } else {
    return 0;
  }
};
const getHtml$1 = (item) => {
  let html = "";
  if (item.html) {
    html = item.html;
  } else {
    if (item.list && item.list.length > 0) {
      html = `${item.name}<br/>`;
      item.list.forEach((obj, index2) => {
        html += `<span style="color:${colorList$1[index2]}">${obj.label}\uFF1A${obj.value} ${obj.unit}</span><br/>`;
      });
      const arr = html.split("<br/>");
      const arr1 = [arr[0]];
      for (let i = 1; i < arr.length; i++) {
        arr1[arr.length - i] = arr[i] + "<br/>";
      }
      html = arr1.toString().replace(/,/g, "");
    }
  }
  return html;
};
const getColorRamp = (val) => {
  if (val == null) {
    val = { 0: "blue", 0.1: "cyan", 0.37: "lime", 0.54: "yellow", 1: "red" };
  }
  var ramp = document.createElement("canvas");
  ramp.width = 1;
  ramp.height = 100;
  var ctx = ramp.getContext("2d");
  var grd = ctx.createLinearGradient(0, 0, 0, 100);
  for (var key in val) {
    grd.addColorStop(1 - Number(key), val[key]);
  }
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, 1, 100);
  return ramp;
};
const createZT = (position2, len2, color, html) => {
  const rgba = mars3d$1.Cesium.Color.fromCssColorString(color);
  const graphic2 = new mars3d$1.graphic.BoxEntity({
    position: position2,
    style: {
      heading: 45,
      dimensions: new mars3d$1.Cesium.Cartesian3(defalutLength$1, defalutWidth, len2),
      color,
      outline: true,
      outlineColor: color,
      material: new mars3d$1.Cesium.ImageMaterialProperty({
        transparent: true,
        image: getColorRamp({
          0: rgba.withAlpha(1).toCssColorString().replace(")", ",1.0)"),
          0.6: rgba.withAlpha(0.4).toCssColorString(),
          1: rgba.withAlpha(0).toCssColorString()
        })
      })
    },
    tooltip: html,
    tooltipOptions: {
      direction: "right",
      template: ""
    }
  });
  graphicLayer$1.addGraphic(graphic2);
  return graphic2;
};
function divGraphicWhite(graphicLayer2, item) {
  const divGraphic = new mars3d$1.graphic.DivUpLabel({
    position: item.centerPoint,
    style: {
      text: item.totalValue,
      color: "#fff",
      font_size: 16,
      font_family: "\u5FAE\u8F6F\u96C5\u9ED1",
      lineHeight: 0,
      circleSize: 0
    }
  });
  graphicLayer2.addGraphic(divGraphic);
}
function changeWriteMode() {
  let node = document.getElementsByClassName("mars3d-divUpLabel-text");
  for (let i = 0; i < node.length; i++) {
    node[i].style.writingMode = "horizontal-tb";
  }
}
let graphicLayer;
let colorList = ["#00FF8E", "#F9E900", "#B620E0", "#FC2120"];
let defalutLength = 30;
let defaultTotalHeight = 120;
let tipsLayer = null;
const showStandColumn2D = (layer2, data, colors2, length3, totalHeight, options = {}) => {
  if (!layer2)
    return;
  graphicLayer = layer2;
  if (colors2 && colors2.length > 0) {
    colorList = colors2;
  }
  if (length3) {
    defalutLength = length3;
  }
  if (totalHeight) {
    defaultTotalHeight = totalHeight;
  }
  const maxValue = getMaxValue(data);
  data.forEach((item) => {
    item.html = getHtml(item);
    if (item.list && item.list.length > 0) {
      item.list.forEach((obj) => {
        obj.height = maxValue > 0 ? Math.floor(Number(obj.value) / maxValue * defaultTotalHeight) : 0;
      });
      item.totalValue = getTotalValue(item);
      const html = getPillarHtml(item);
      const graphic2 = new mars3d$1.graphic.DivGraphic({
        position: item.centerPoint,
        pointerEvents: true,
        attr: {
          ...item
        },
        style: {
          html,
          horizontalOrigin: mars3d$1.Cesium.HorizontalOrigin.LEFT,
          verticalOrigin: mars3d$1.Cesium.VerticalOrigin.BOTTOM,
          offsetX: options && options.offsetX || 0,
          offsetY: options && options.offsetY || 0,
          distanceDisplayCondition: new mars3d$1.Cesium.DistanceDisplayCondition(
            options && options.distanceDisplayConditionMin || 1e3,
            options && options.distanceDisplayConditionMax || 999999999999
          )
        }
      });
      graphicLayer.addGraphic(graphic2);
    }
  });
  graphicLayer.on(mars3d$1.EventType.mouseOver, function(event) {
    const tips = {
      name: event.graphic.attr.name,
      position: event.graphic.attr.centerPoint,
      html: event.graphic.attr.html
    };
    tipsLayer = window.etopMap.addDivLayer([{ ...tips }], {
      offsetX: 40,
      offsetY: -50
    }, null);
    options && options.mouseOverCallback;
  });
  graphicLayer.on(mars3d$1.EventType.mouseOut, function(event) {
    window.etopMap.removeLayerByLayer(tipsLayer);
    tipsLayer = null;
    options && options.mouseOutCallback;
  });
};
const getMaxValue = (data) => {
  const numArray = data.map((item) => {
    return getTotalValue(item);
  });
  return Math.max.apply(null, numArray);
};
const getTotalValue = (item) => {
  if (item.list && item.list.length > 0) {
    return item.list.reduce((prev, next3) => {
      return Number(prev && prev.value || prev) + Number(next3.value);
    }, 0);
  } else {
    return 0;
  }
};
const getPillarHtml = (item) => {
  let html = "";
  if (!(item && item.list && item.list.length > 0)) {
    return html;
  }
  for (let i = item.list.length - 1; i >= 0; i--) {
    html = `<div style="height: ${item.list[i].height}px;background-image: linear-gradient(to top, rgba(0,0,0,0), ${colorList[i]});"></div>` + html;
  }
  html = `<div style="width:${defalutLength}px">` + html;
  html += "</div>";
  html = `<div style="text-align:center;color:#e8d11a;font-width: 700;width:60px;transform: translateX(-15px);">${item.totalValue}</div>` + html;
  return html;
};
const getHtml = (item) => {
  let html = "";
  if (item.html) {
    html = item.html;
  } else {
    if (item.list && item.list.length > 0) {
      html = `<div style="padding: 10px; background: rgba(0,9,45,0.90);border: 1px solid rgba(84,181,255,0.50); position: relative;font-size:16px">
      <div style="position: absolute; width: 4px; height: 4px; left: 0; top: 0; background-color: #676a7a;"></div>
      <div style="position: absolute; width: 4px; height: 4px; right: 0; top: 0; background-color: #676a7a;"></div>
      <div style="position: absolute; width: 4px; height: 4px; left: 0; bottom: 0; background-color: #676a7a;"></div>
      <div style="position: absolute; width: 4px; height: 4px; right: 0; bottom: 0; background-color: #676a7a;"></div>
      <div style="color: #54CFFF; padding-bottom: 10px; border-bottom: rgba(255,255,255,0.2) solid 1px; margin-bottom: 10px;">${item.name}</div>`;
      item.list.forEach((obj, index2) => {
        html += '<div style="width: 180px; display: flex; justify-content: space-between; align-items: center;">';
        html += `<div style="display: flex; align-items: center;" ><div style="background-color: ${colorList[index2]}; margin-right: 4px; width: 8px; height: 8px"></div><div style="color: #54CFFF;">${obj.label}</div></div>`;
        html += `<div style="display: flex; align-items: center; color: #ffffff;"><div style="font-size: 24px">${obj.value}</div><div style="margin-left: 4px;">${obj.unit}</div></div>`;
        html += "</div>";
      });
      html += "</div>";
    }
  }
  return html;
};
let maxR = 4e3;
let minR = 0;
const deviationR = 10;
const colors = ["#FF0000", "#F9E900", "#00D0FF"];
const rounds = [1e3, 2e3, 4e3];
const getRound = () => {
  minR = minR + deviationR;
  if (minR >= maxR) {
    minR = 0;
  }
  return minR;
};
const addEmergencyFun = (map5, data) => {
  const roundArray = data && data.rounds && data.rounds.length === 3 ? data.rounds : rounds;
  const colorArray = data && data.colors && data.colors.length === 3 ? data.colors : colors;
  maxR = Math.max.apply(null, roundArray);
  map5.viewer.entities.add({
    name: "",
    position: mars3d$1.Cesium.Cartesian3.fromDegrees(data.lng, data.lat, data.height),
    ellipse: {
      semiMinorAxis: new mars3d$1.Cesium.CallbackProperty(getRound, false),
      semiMajorAxis: new mars3d$1.Cesium.CallbackProperty(getRound, false),
      height: data.height,
      material: new mars3d$1.Cesium.ImageMaterialProperty({
        repeat: new mars3d$1.Cesium.Cartesian2(1, 1),
        transparent: true,
        color: new mars3d$1.Cesium.CallbackProperty(function() {
          var alp = 1 - minR / maxR;
          if (minR < roundArray[0]) {
            return mars3d$1.Cesium.Color.fromCssColorString(colorArray[0]).withAlpha(0.5);
          } else if (minR < roundArray[1]) {
            return mars3d$1.Cesium.Color.fromCssColorString(colorArray[1]).withAlpha(0.4);
          } else if (minR < roundArray[2]) {
            return mars3d$1.Cesium.Color.fromCssColorString(colorArray[2]).withAlpha(
              alp > 0.38 ? 0.38 : alp
            );
          }
        }, false)
      })
    }
  });
};
let PROXY_IP$2 = "";
let ifProcess$1 = typeof process;
if (ifProcess$1 === "undefined") {
  PROXY_IP$2 = {}.VITE_APP_PROXY_NAME ? {}.VITE_APP_PROXY_NAME : "http://10.253.102.69";
} else {
  PROXY_IP$2 = {}.VUE_APP_PROXY_NAME ? {}.VUE_APP_PROXY_NAME : "http://10.253.102.69";
}
let headers = {
  "szvsud-license-key": "6THQPxvsWN98LkA4XwbMegmZHWgXxicMYG6HGFV6P4hRR9DaNiTeGWmrnVomPXYkgLn7wa1ACaov+jlOK+tecUbDzw710HvcXAfbWwKZL6M="
};
function getRegionData() {
  return http({
    url: PROXY_IP$2 + `/gw/OGC/GeoData/WFS/XZQH_YWTGQU_A?service=WFS&version=2.0.0&request=GetFeature&typeName=XZQH:qu_ywtg&outputFormat=application/json`,
    method: "get",
    headers
  });
}
var regionMask = {
  async showMaskByName({
    quName = "\u6DF1\u5733\u5E02",
    isLocate = true,
    maskColor = "#000217",
    opacity = 0.8,
    outlineStyleColor = "#000217",
    outlineWidth = 2,
    outlineOpacity = 1
  } = {}) {
    let xzqData = await this.getSzMaskData();
    if (quName === "\u6DF1\u5733\u5E02") {
      window.etopMap.clearLayerById("mask");
      window.etopMap.map.flyHome();
    } else {
      let geojsonFilter = xzqData.filter((v, i) => {
        return v.properties.QNAME === quName;
      });
      const featureCollection2 = featureCollection$1(geojsonFilter);
      if (isLocate) {
        const bbox2 = bbox$1(featureCollection2);
        window.etopMap.map.flyToExtent(
          {
            xmin: bbox2[0],
            ymin: bbox2[1],
            xmax: bbox2[2],
            ymax: bbox2[3]
          },
          { scale: 1.8, duration: 1.5 }
        );
      }
      this.addGeojsonLayer(featureCollection2, {
        id: "mask",
        mask: true,
        symbol: {
          styleOptions: {
            fill: true,
            color: maskColor,
            opacity,
            outline: true,
            outlineStyle: {
              color: outlineStyleColor,
              width: outlineWidth,
              opacity: outlineOpacity
            },
            arcType: mars3d$1.Cesium.ArcType.GEODESIC,
            clampToGround: true
          }
        }
      });
    }
    return "mask";
  },
  showMaskSzOutside({
    opacity = 0.8,
    maskColor = "#000217",
    maskOutLineColor = "#ededed",
    maskOutLineWidth = 1
  } = {}) {
    const geoJsonLayer = new mars3d$1.layer.GeoJsonLayer({
      url: "./map3d/region/szdistrict.json",
      id: "maskWw",
      mask: true,
      show: true,
      zIndex: 1,
      symbol: {
        styleOptions: {
          fill: true,
          color: maskColor,
          opacity,
          outline: true,
          outlineStyle: {
            color: maskOutLineColor,
            width: maskOutLineWidth,
            opacity: 1
          },
          arcType: mars3d$1.Cesium.ArcType.GEODESIC,
          clampToGround: true
        }
      }
    });
    window.etopMap.map.addLayer(geoJsonLayer);
    return "maskWw";
  },
  async getSzMaskData() {
    var _a2;
    let result;
    if ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2.VUE_APP_ETOPMAP_DEVELOPER)
      result = await http.get("/map3d/region/szxzq5.geojson");
    else
      result = await getRegionData();
    return result.data.features;
  },
  addGeojsonLayer(geojson, options) {
    if (window.etopMap.map.getLayer(options.id)) {
      window.etopMap.map.getLayer(options.id).load({
        data: geojson,
        symbol: options.symbol,
        zIndex: options.zIndex,
        flyTo: options.flyTo,
        pointerEvents: true
      });
      return null;
    }
    let geoJsonLayer = new mars3d$1.layer.GeoJsonLayer({
      id: options.id,
      mask: options.mask,
      data: geojson,
      symbol: options.symbol,
      zIndex: options.zIndex,
      flyTo: options.flyTo,
      pointerEvents: true
    });
    window.etopMap.map.addLayer(geoJsonLayer);
  }
};
var mapDraw = {
  drawCustom: (map5, options, drawCreatedCallback, editMovePointCallback, editRemovePointCallback) => {
    map5 = map5 || window.etopMap.map;
    let optionsT = {
      clearLast: options.clearLast !== void 0 ? options.clearLast : true,
      id: options.id || "drawMap",
      hasEdit: options.hasEdit !== void 0 ? options.hasEdit : false,
      isAutoEditing: options.isAutoEditing !== void 0 ? options.isAutoEditing : false,
      type: options.type || "polygon",
      style: {
        fill: options.style && options.style.fill !== void 0 ? options.style.fill : true,
        color: options.style && options.style.color || "#ff0000",
        opacity: options.style && options.style.opacity || 0.3,
        outline: (options.style && options.style.outline) !== void 0 ? options.style.outline : false,
        outlineStyle: options.style && options.style.outlineStyle || {
          color: "#ff0000",
          width: 3,
          opacity: 1,
          material: mars3d$1.MaterialUtil.createMaterialProperty(mars3d$1.MaterialType.PolylineDash, {
            color: "#ff0000"
          })
        },
        clampToGround: options.style && options.style.clampToGround || false,
        ...options.style
      }
    };
    let geoJsonDrawLayer = map5.getLayerById(optionsT.id);
    if (optionsT.clearLast && geoJsonDrawLayer) {
      geoJsonDrawLayer.clear();
    } else {
      if (!geoJsonDrawLayer) {
        geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
          id: optionsT.id,
          hasEdit: optionsT.hasEdit,
          isAutoEditing: optionsT.isAutoEditing
        });
        map5.addLayer(geoJsonDrawLayer);
      }
    }
    geoJsonDrawLayer.startDraw({
      type: optionsT.type,
      style: optionsT.style
    });
    drawCreatedCallback && geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, (event) => {
      drawCreatedCallback(event);
    });
    editMovePointCallback && geoJsonDrawLayer.on(mars3d$1.EventType.editMovePoint, (event) => {
      editMovePointCallback(event);
    });
    editRemovePointCallback && geoJsonDrawLayer.on(mars3d$1.EventType.editRemovePoint, (event) => {
      editRemovePointCallback(event);
    });
  },
  drawPolygon: (map5, options, drawCreatedCallback) => {
    const layer2 = window.etopMap.map.getLayerById("drawMap");
    layer2 ? window.etopMap.map.removeLayer(layer2) : "";
    const geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
      id: "drawMap"
    });
    map5.addLayer(geoJsonDrawLayer);
    geoJsonDrawLayer.startDraw({
      type: options && options.type || "polygon",
      style: options && options.style || {
        fill: true,
        color: "#ff0000",
        opacity: 0.3,
        outline: true,
        outlineStyle: {
          color: "#ff0000",
          width: 3,
          opacity: 1,
          material: mars3d$1.MaterialUtil.createMaterialProperty(mars3d$1.MaterialType.PolylineDash, {
            color: "#ff0000"
          })
        },
        clampToGround: false
      }
    });
    if (drawCreatedCallback) {
      geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, function(event) {
        drawCreatedCallback(event);
      });
    }
  },
  drawBillboard: (map5, options, drawCreatedCallback) => {
    const layer2 = window.etopMap.map.getLayerById("drawMap");
    layer2 ? window.etopMap.map.removeLayer(layer2) : "";
    const geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
      id: "drawMap"
    });
    map5.addLayer(geoJsonDrawLayer);
    geoJsonDrawLayer.startDraw({
      type: "billboard",
      style: options && options.style || {
        image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAABWCAYAAAC91tTcAAAMVUlEQVRoQ+2aeXRU5RXAf3feJCQhG2FLwIAgmyCLrFqxKNjq0YrbqagtVdwXFBcQA2pVlE0EkV0Uwa0uxYX2aFtF0VIVRQRkEQEBkSRCCCSEJJCZfD33zUwyQ2aSN5Ng+aP3nDmzve9+v3e/d++7935PiFGMMb2A84B+QBegFZDiV3cIyAW+A74CPhSRtbFMJdEMMsZkALcC1wEdoxkLbAUWA/NFpNDpWEeAxphE4AHgbiDVVl5QAGu+gY0bYfdu2LsPSkt98yYlQYvmkJ0N3bpB79OhWbMAUzHwNDBZRMrqAq0T0Bgz0H/mp2AMrF4Ny/4O69djf3ciItCjBwz9HfTtC/odtutKiMjK2lTUCmiMuQeYAsSxbTvMmw9bdaXqIR07wm23QodTVEkFMFZEZkTSGBHQGPMkMJrKSnj9Dd9LPzeEuFww7ErfSz/DNBEZE051WEBjzCT7mjt6FKZOgy+/bAismjr694f7R0N8vP6n12TOsQfVADTG3AgstOEemwDrvz0+cAGtPbrDww8FIG8SkeeCJwwBNMacBnyJeu2T02Dlf44vXED7wLNgzGh1HvXq/iKyIfBXFaAxRi8GXcs+LPsbPPe8MzjL8oWTY6W8HPLznenQo268AYZerJ++9kPaF3ww4E3As+Tmwp2joEIdzIGkpsLLL9Y8cN16eOhhBwr8h8TFwayZ0EpvSNwsIgurAI0xccA2oA0THoevVjtXnJQIr/2l5vGrv/Zdw9FIv77w0IM64kegg4hU2BY0xvwReIlt2+De0dGoBD3zpW/WHPPFKpiowSBKmT4NOnTQQcNF5OUA4IfAEJ6aAZ98Ep1GvSu8+3bNMStX+kJUtDJoENyn9weWi8h5YoxpCeyhvNxi+LVw5Ei0KuHtpaDOEiwrVsB0veVGKY0awUtLICHBC7RWwGHAa6xaBU/EsCQ6/xuvQ0KjUJIPPoRZs6Ok8x8+PgcGDNAvVyngLGAkzy+Cd5fFpvDVlyE5OXTs++/DvAWx6btkKNxwvY6drYC+609DgoaGWOTFxZCeHjoymlh67Jw9e8CEx3zXoTFmJ9CWG26CfftiwYPnF0Lz5qFj33obFi+JTZ/qUp2wSwEPAmkMuxrK6swfw0+4YB5kZYX+p9nPK6/GBpiYCK/bsbVIAfWW4eayK8CrjhODzJ4FbY653SmcQsYiGhE0MoBHAbXASebaEXDgQCzq4Onp0L596NglL8LSt2LT16QJLHlBx5Yo4EagK/eNiT1bnjYVOnUKhalPVNCs+ynNl9mkgHqnH25nL+p5scikidCta+jI+Qvgvfdj0ebLajS7gZcUcASwqF6BesKj0LNnKMzsOfCvD2IDrA7U1ytgW2AH5UeEa6+LzZM1I+7bJxRmxkz4+OPoAdWDlyzWO5OWjO0CyYKmzr/i6ZnwUQxKx+XAGfatqVo0I/93rRVlePjBg+Huu/S/z0TkrADgbcBcvt0A4+18LDrRdP1sLZ+DZOJk+OKL6PTo0U88Dt218uB2EZkXANSWxm7tCTDqHtixIzrFl1/mK8yD5dVX4fsoa+h27WCmXSJriyJbWyTBKf984BZ7iXWp/xdy9ygYfK7OvEBEtAcUUpNoh2ojHo+LW2+HvXt/WcQWLWD+XHC7tVjqJiLaGasG1C/GmHeBoXZ40DDxS8rIO+C3v9EZl4nIJYGpj62LewOr8XiE20dGVzaqF+t1ePiwr2z4aY/z08vMhLmz1XoaWvqKyJqwgH4raoFxqR0iNFQ4kVtuhosurD5SS1at6Jzml9VR4B0RuSx4ynCtD3XHNRhjcf9Y2PJ97YitW/vO3tdSq5YffoC776379Dp3gqlTdLymUr1FJCRrjtQ8WgSMYPN3MFb7lrVIv37w0PiaB2hn4cqr6gacMhlOVf/kBRGx8/xaLehf5taAmi6JmbNg+fLIE2nndOGCmlXdho0wLgx4sKYhQ2DUnfqLxr1OIlLjwq2tP/go8DBFxXD7HXBI08YIotnHiOuqITWvfPgR2LUr8piUFJg7B9LsjvJjIvLncAfXBqh96c12veIk7GhGfdppvj61tj1KSmpf3uqwomdxaqR+dV0t4MuBpXYvemwOfGfHzvpLly4wZVLAsa4QkYipt5Mm+j+A89mxE+69L/a6JXBaWm9Mfwranay//FNELqjtjJ0Aardb26yJ1KfOCFBccTlc+yf9piVkdxHRbn9EqRPQ79XaO55ot4U129kTxV0ieGqNmZqt+HrS40Skzl6LU0DtH2rns7sdGx/Icb5HEgDUQD55UiDm6Yr00f5fXRe0I0C/FfsCn9s19AuL4e136tId+v9ll/pCEXiAM0XEUZfUMaAfUjd17reX+p77fFtgTkR72DOeCiztVBEZ62SYHhMtYAKgu5ad7W7smLF1e7V67ZNTAztLW4BeIlJ+XAD9VjwD0GrIslsbdfVf/nCNb0cJNBkYKCJRFSpRWTBw1lU7UdrLyRkH36lhwkiXzqBFva/7GnYnqS5Lxgqo7VTdqO5u74Vo6Dm2M6b1rYYUTUZ9cbSfiETdX44J0L/U2kpYBTRi+Ucw85lQY4y6C4YM1t8UaoCIrKvLWuH+jxnQD6neONlWPPXJ6q0z3dq6v2rz8gERUe+PSeoLqNtnHwGD7OzlrlE+iGdmBnrWuqcxWERi3setF6Dfim0AXb501vqfm+ilz1ugndueIqK7RjFLvQH9kFcDx/Z7rxGRMHtk0bE2CKAf8iVAt9RUXhaR4dGhhD+6IQHT/EutM+nSFp1QgH4rDtF3EamlyooOu8EsGN20zo/+P6BzWx1HJzEgh3LuyIizJLXCfdTe9ozzxB+p8JrilElztAnp8BGlmpD1WuLd0+9JbFJQ0rnS62kr5SUJHCo2djKronVHSqqYhORyl+XedaBZ8pbse2dEvdcWM2Dxg7d1liOlp5G3w3Lt2V1O8aHw+2ipKVZl6+wEstp5TaOkDamPz4uQmzXQEps3fm+VrWvWz7s//2SzaW2pdTgC2DHzeRunWNK1V5LVNHNnYs+Cr+TKNx1tDEZtwdLxt53h/XlnW9f6b0rwav0ThVhuKnucnmy1PHlX0hPzHGXWUQHay1qQf7przeeHguEq0lpnl7Vsf4lJSOpFXHwG3ooyKS/f5i7Z/1HS7m8/RYKcRCF7n5limmV+42S5HQOqQ6TnFV5oVn1aEbysxSf3GUaL7GtIamy5EhKqOlymrBRTVoYpOrCp8a41E92HD2p2Y4u93AN+HXcwK+O9uhzHMWDJuJt6mR+3dHJt3nQ4MJHCmZZth1tNmuBKTrZfWG5tx9twlSUleIsOQmHhjuTNn4xxebSr6ZPKU7s2ljadv0+euLDWZ1sdAdpxbuyIodaXK0zAW4+ktWpzpHP/Wa6MppbVtBkByMDjKQroPXAAb2Eh3v0FuPbs/GvyjlX6DKtPUlMsb/9zJGXKC8tqi5OOAItz7mgqpXvPc638uKrpV9zp7JHSqs0FVrNmuDOzUEhXWhqiTyJ5vT7rFe63X578fDx5uWXpG5Zfg/doVbujcuC5ySapxYepk+bsj+RqjgDLHhzZzpO7tZ9r3ddVy1vU4/znrFYnZbozM21Ad4uWuDKaYqWmYo4esS3nyc/Ds28v3vx8KvLziN+2Nidx3/aqBxIre/Zp7G7V8avEx2dH3HtzBFj8yM1dZNvWHq7N31YD9r74LXdWVrwVAMzMIq71SVjNm9vWs+HUcvqem0vFTz9i7do8LTl304rq67B7Y9Oh4/rUR56N2BmNHbDXBa9Yrduk2dZTyOYt7HdXWjqmvNy+7tRqtvX2/IQ3Pw/3jg2PJeVvqXretPLUBgIMt8TFXc55VFqd1McHmIWVkYGV0RTRgt3r9TnI/gI8P//se8/LM403fHqdu6yw6npruCUO4ySlJ3UfVJHdaYxaLtiLJTHJ7ySH8BYV4S0osAEr83avTdu8ImQzusGcJFyYwSBF3QZPkeYtu1rpGXaYUeuJZjHqxYcPV8XBysL9R+O3fz068cCeH45LmFGl4QK1p3F6emn7ARNIS2vnSk7xAbrjMJ6KKitWFhcfjc/dOi0xd/NnwaGkQQO1Ko50q6t0JySUtul5lTcl4yKS9HlRX9PReLzGVXJwnTt/66IQyx2vW51OHClZsC1jxceVZWR38VqNmrrwlsYX7dse7BBV1jteyUJgghM63VLIEz5hrcpkTtSUP9gTT+iiKRj0hC07I6VIDfn7fwFCXjvwSWbQQQAAAABJRU5ErkJggg==", self.location).href,
        scale: 1,
        clampToGround: false
      }
    });
    if (drawCreatedCallback) {
      geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, function(event) {
        drawCreatedCallback(event);
      });
    }
  },
  drawCurve: (map5, options, drawCreatedCallback) => {
    const layer2 = window.etopMap.map.getLayerById("drawMap");
    layer2 ? window.etopMap.map.removeLayer(layer2) : "";
    const geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
      id: "drawMap"
    });
    map5.addLayer(geoJsonDrawLayer);
    geoJsonDrawLayer.startDraw({
      type: "curve",
      style: options && options.style || {
        color: "#3f65f6",
        width: 6
      }
    });
    if (drawCreatedCallback) {
      geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, function(event) {
        drawCreatedCallback(event);
      });
    }
  },
  drawRectangle: (map5, options, drawCreatedCallback) => {
    const layer2 = window.etopMap.map.getLayerById("drawMap");
    layer2 ? window.etopMap.map.removeLayer(layer2) : "";
    const geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
      id: "drawMap"
    });
    map5.addLayer(geoJsonDrawLayer);
    geoJsonDrawLayer.startDraw({
      type: "rectangle",
      style: options && options.style || {
        fill: true,
        color: "#797af3",
        opacity: 0.8,
        outline: true,
        outlineStyle: {
          material: mars3d$1.MaterialUtil.createMaterialProperty(mars3d$1.MaterialType.PolylineDash, {
            color: Cesium.Color.RED,
            gapColor: Cesium.Color.TRANSPARENT
          }),
          width: 6
        }
      }
    });
    if (drawCreatedCallback) {
      geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, function(event) {
        drawCreatedCallback(event);
      });
    }
  },
  drawCircle: (map5, options, drawCreatedCallback) => {
    const layer2 = window.etopMap.map.getLayerById("drawMap");
    layer2 ? window.etopMap.map.removeLayer(layer2) : "";
    const geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
      id: "drawMap"
    });
    map5.addLayer(geoJsonDrawLayer);
    geoJsonDrawLayer.startDraw({
      type: "circle",
      style: options && options.style || {
        fill: true,
        color: "#797af3",
        opacity: 0.4,
        outline: true,
        outlineWidth: 2,
        outlineColor: "#4869f5"
      }
    });
    if (drawCreatedCallback) {
      geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, function(event) {
        drawCreatedCallback(event);
      });
    }
  },
  drawLabel: (map5, options, drawCreatedCallback) => {
    const layer2 = window.etopMap.map.getLayerById("drawMap");
    layer2 ? window.etopMap.map.removeLayer(layer2) : "";
    const geoJsonDrawLayer = new mars3d$1.layer.GraphicLayer({
      id: "drawMap"
    });
    map5.addLayer(geoJsonDrawLayer);
    geoJsonDrawLayer.startDraw({
      type: "label",
      style: options && options.style || {
        text: "\u6587\u672C\u6807\u8BB0",
        color: "#4869f5",
        background: true,
        backgroundColor: "#ffffff"
      }
    });
    if (drawCreatedCallback) {
      geoJsonDrawLayer.on(mars3d$1.EventType.drawCreated, function(event) {
        drawCreatedCallback(event);
      });
    }
  }
};
var polylineUtils = {
  addPolylineEntity(layer2, startPoint, endPoint, polylineOptions) {
    if (!polylineOptions) {
      polylineOptions = {};
    }
    const sPoint = mars3d$1.Cesium.Cartesian3.fromDegrees(
      startPoint[0],
      startPoint[1],
      startPoint.length > 2 ? startPoint[2] : 0
    );
    const ePoint = mars3d$1.Cesium.Cartesian3.fromDegrees(
      endPoint[0],
      endPoint[1],
      endPoint.length > 2 ? endPoint[2] : 0
    );
    const positions = mars3d$1.PolyUtil.getLinkedPointList(
      sPoint,
      ePoint,
      polylineOptions.angularityFactor || 1e4,
      polylineOptions.numOfSingleLine || 20
    );
    const graphic2 = new mars3d$1.graphic.PolylineEntity({
      positions,
      style: {
        width: polylineOptions.width || 5,
        material: mars3d$1.MaterialUtil.createMaterialProperty(
          mars3d$1.MaterialType.LineFlowColor,
          {
            color: polylineOptions.materialColor || "#00ffff",
            speed: polylineOptions.materialSpeed || 30,
            percent: polylineOptions.materialPercent || 0.25,
            alpha: polylineOptions.materialAlpha || 0.6
          }
        )
      }
    });
    layer2.addGraphic(graphic2);
  },
  drawLineByPositions({
    positions,
    color = "#FFA14E",
    width = 3,
    closure = false,
    layerId
  } = {}) {
    const graphicLayer2 = new mars3d$1.layer.GraphicLayer({ id: layerId });
    this.map.addLayer(graphicLayer2);
    const primitive = new mars3d$1.graphic.PolylinePrimitive({
      positions,
      style: {
        width,
        closure,
        color,
        material: mars3d$1.MaterialUtil.createMaterial(
          mars3d$1.MaterialType.Color,
          {
            color,
            dashLength: 5
          }
        )
      }
    });
    graphicLayer2.addGraphic(primitive);
    return graphicLayer2;
  },
  drawDash2ColorPolyline(graphicLayer2, options) {
    const graphic2 = new mars3d$1.graphic.PolylineEntity({
      id: options.id,
      positions: options.positions,
      style: {
        width: options.width,
        material: mars3d$1.MaterialUtil.createMaterialProperty(
          mars3d$1.MaterialType.PolylineDash,
          {
            color: options.color,
            gapColor: options.gapColor,
            dashPattern: options.dashPattern
          }
        ),
        clampToGround: options.clampToGround,
        classificationType: options.classificationType,
        disableDepthTestDistance: Number.POSITIVE_INFINITY,
        depthFail: false
      }
    });
    graphicLayer2.addGraphic(graphic2);
    return graphicLayer2;
  }
};
let PROXY_IP$1 = "";
let ifProcess = typeof process;
if (ifProcess === "undefined") {
  PROXY_IP$1 = {}.VITE_APP_PROXY_NAME ? {}.VITE_APP_PROXY_NAME : "http://10.253.102.69";
} else {
  PROXY_IP$1 = {}.VUE_APP_PROXY_NAME ? {}.VUE_APP_PROXY_NAME : "http://10.253.102.69";
}
const fkqData = () => {
  return axios.get(
    PROXY_IP$1 + "/gw/OGC/GeoData/WFS/COVID_FKQ_A?format=image/png&service=WFS&version=1.1.1&request=GetFeature&typeName=covid-19:covid_fkq&outputFormat=application%2Fjson",
    {
      headers: {
        "szvsud-license-key": "X/RF5zkOrX9RkW/DuWoAn6p0iE7kZbHfDdVThH+vjey2Rfoz8tarcELoNAzNO8D7"
      }
    }
  );
};
const gkqData = () => {
  return axios.get(
    PROXY_IP$1 + "/gw/OGC/GeoData/WFS/COVID_GKQ_A?format=image/png&service=WFS&version=1.1.1&request=GetFeature&typeName=covid-19:covid_gkq&outputFormat=application%2Fjson",
    {
      headers: {
        "szvsud-license-key": "X/RF5zkOrX9RkW/DuWoAn6p0iE7kZbHfDdVThH+vjey2Rfoz8tarcELoNAzNO8D7"
      }
    }
  );
};
const ffqData = () => {
  return axios.get(
    PROXY_IP$1 + "/gw/OGC/GeoData/WFS/COVID_FFQ_A?format=image/png&service=WFS&version=1.1.1&request=GetFeature&typeName=covid-19:covid_ffq&outputFormat=application%2Fjson",
    {
      headers: {
        "szvsud-license-key": "X/RF5zkOrX9RkW/DuWoAn6p0iE7kZbHfDdVThH+vjey2Rfoz8tarcELoNAzNO8D7"
      }
    }
  );
};
var etopMapUtils = {
  getQhCenter(geometry2) {
    return centerOfMass(geometry2);
  },
  createPolygonGeoJson(positions) {
    return polygon(positions);
  },
  getQhCenterWithPositions(positions) {
    return centerOfMass(this.createPolygonGeoJson(positions));
  },
  async queryIsSanqu(point4) {
    const points2 = points$3(point4);
    const fkqArr = fkqData();
    const gkqArr = gkqData();
    const ffqArr = ffqData();
    const reslutsArr = await Promise.all([fkqArr, gkqArr, ffqArr]);
    const searchWithinArr = [];
    reslutsArr.map((resluts, index2) => {
      let typeName = "";
      resluts && resluts.data && resluts.data.features && resluts.data.features.map((features2) => {
        const polygonArr = [];
        features2 && features2.geometry && features2.geometry.coordinates && features2.geometry.coordinates.map((coordinates) => {
          const temp1 = [];
          coordinates.map((coord) => {
            coord.map((cord) => {
              temp1.push(cord);
            });
          });
          if (temp1[0] !== temp1[temp1.length - 1]) {
            temp1.push(temp1[0]);
          }
          polygonArr.push(temp1);
        });
        const searchWithin = polygon(polygonArr);
        const ptsWithin = pointsWithinPolygon(points2, searchWithin);
        if (index2 === 0) {
          typeName = "\u5C01\u63A7\u533A";
        } else if (index2 === 1) {
          typeName = "\u7BA1\u63A7\u533A";
        } else if (index2 === 2) {
          typeName = "\u9632\u8303\u533A";
        }
        if (ptsWithin.features.length) {
          searchWithinArr.push({
            typeName,
            features: features2
          });
        }
      });
    });
    return searchWithinArr;
  },
  calculateLeng({
    stPt,
    endPt,
    units = "kilometers",
    type = "distance"
  } = {}) {
    const from = point(stPt);
    const to = point(endPt);
    const options = {
      units
    };
    let distance11 = distance$2(from, to, options);
    if (type === "circle") {
      distance11 = rhumbDistance(from, to, options);
    }
    return distance11;
  },
  calculateSquare({
    centerPt,
    radius,
    units = "kilometers",
    type = "positive"
  } = {}) {
    const distance11 = Math.sqrt(Math.pow(radius, 2) + Math.pow(radius, 2));
    var point$1 = point(centerPt);
    var options = {
      units
    };
    var destination1 = destination(point$1, distance11, 45, options);
    var destination2 = destination(point$1, distance11, 135, options);
    var destination3 = destination(point$1, distance11, 225, options);
    var destination4 = destination(point$1, distance11, 315, options);
    if (type === "rotate") {
      destination1 = destination(point$1, radius, 0, options);
      destination2 = destination(point$1, radius, 90, options);
      destination3 = destination(point$1, radius, 180, options);
      destination4 = destination(point$1, radius, 270, options);
    }
    return [
      destination1.geometry.coordinates,
      destination2.geometry.coordinates,
      destination3.geometry.coordinates,
      destination4.geometry.coordinates
    ];
  },
  cartesian3ToPoint(cartesian2) {
    const result = window.etopMap.viewer.scene.globe.ellipsoid.cartesianToCartographic(
      cartesian2
    );
    return [
      mars3d$1.Cesium.Math.toDegrees(result.longitude),
      mars3d$1.Cesium.Math.toDegrees(result.latitude)
    ];
  }
};
class ControlUtils {
  constructor(map5) {
    __publicField(this, "map", null);
    __publicField(this, "compass", null);
    __publicField(this, "overviewMap", null);
    __publicField(this, "compassBaseConfig", { left: "19px", bottom: "205px" });
    __publicField(this, "overviewMapBaseConfig", {
      style: {
        left: "19px",
        top: "115px",
        width: "200px",
        height: "150px"
      },
      rectangle: {
        color: "#fecd78",
        outline: 1,
        outlineColor: "#ff7800"
      },
      basemap: {
        type: "group",
        layers: [
          { name: "\u5E95\u56FE", type: "tdt", layer: "vec_d" },
          { name: "\u6CE8\u8BB0", type: "tdt", layer: "vec_z" }
        ]
      }
    });
    this.map = map5;
  }
  addCompass(options = {}) {
    if (this.compass)
      return;
    const config = {
      ...this.compassBaseConfig,
      ...options
    };
    const compass = new mars3d$1.control.Compass(config);
    this.map.addControl(compass);
    this.compass = compass;
    return compass;
  }
  removeCompass() {
    this.map.removeControl(this.compass);
    this.compass = null;
  }
  addOverviewMap(options = {}) {
    if (this.overviewMap)
      return;
    const { style, rectangle, basemap } = options;
    const styleConfig = {
      ...{ style: this.overviewMapBaseConfig.style },
      ...style
    };
    const rectangleConfig = {
      ...{ rectangle: this.overviewMapBaseConfig.rectangle },
      ...rectangle
    };
    const basemapConfig = {
      ...{ basemap: this.overviewMapBaseConfig.basemap },
      ...basemap
    };
    const config = {
      ...this.baseConfig,
      ...options,
      ...styleConfig,
      ...rectangleConfig,
      ...basemapConfig
    };
    const overviewMap = new mars3d$1.control.OverviewMap(config);
    this.map.addControl(overviewMap);
    this.overviewMap = overviewMap;
    return overviewMap;
  }
  removeOverviewMap() {
    this.map.removeControl(this.overviewMap);
    this.overviewMap = null;
  }
}
class BaseBoxEntityUtils {
  constructor(map5) {
    __publicField(this, "map", null);
    __publicField(this, "graphicLayer", null);
    this.map = map5;
  }
  initGraphicLayer(options) {
    if (!this.graphicLayer) {
      this.graphicLayer = new mars3d$1.layer.GraphicLayer(options || {});
      this.map.addLayer(this.graphicLayer);
    }
    return this.graphicLayer;
  }
  getPositionList(position2, length3, offset) {
    const divide2 = (length3 + 1) / 2;
    const [lng] = position2;
    const lngStart = lng - divide2 * offset;
    const lngArr = [];
    for (let i = 0; i < length3; i++)
      lngArr.push(lngStart + offset * i);
    return lngArr;
  }
  addBoxEntityBar({
    position: position2,
    dimensions = [900, 900],
    data = [],
    offset = 0.015
  }) {
    this.initGraphicLayer({});
    const lngArr = this.getPositionList(position2, data.length, offset);
    const [, lat2, alt] = position2;
    const [length3, width, height] = dimensions;
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const style = {
        dimensions: new mars3d$1.Cesium.Cartesian3(
          length3,
          width,
          (item == null ? void 0 : item.value) || height
        ),
        heading: 45,
        addHeight: ((item == null ? void 0 : item.value) || height) / 2,
        setHeight: 3e3,
        ...item.style
      };
      const boxEntity = new mars3d$1.graphic.BoxEntity({
        position: new mars3d$1.LngLatPoint(lngArr[i], lat2, alt),
        style
      });
      boxEntity.attr.data = data[i];
      this.graphicLayer.addGraphic(boxEntity);
    }
  }
  addBoxEntityBarList(list) {
    for (const item of list)
      this.addBoxEntityBar(item);
    return this.graphicLayer;
  }
  removeBoxEntityBar() {
    this.graphicLayer.clear();
  }
  bindLayerPopup(graphicLayer2) {
    graphicLayer2.bindPopup(function(event) {
      const attr = event.graphic.attr || {};
      attr["\u7C7B\u578B"] = event.graphic.type;
      attr["\u6570\u503C"] = JSON.stringify(event.graphic.attr.data);
      attr["\u5C4F\u5E55\u5750\u6807"] = event.position;
      attr["BOX\u5750\u6807"] = event.graphic.points[0];
      attr["\u5907\u6CE8"] = "\u6211\u652F\u6301\u9F20\u6807\u4EA4\u4E92";
      return mars3d$1.Util.getTemplateHtml({ title: "\u6570\u636E\u5C55\u793A", template: "all", attr });
    });
  }
}
var flyToUtils = {
  flyByTypes(type = "graphic", geomObj, optionsObj = {}) {
    if (!geomObj) {
      return;
    }
    switch (type) {
      case "graphic":
        window.etopMap.map.flyToGraphic(geomObj, optionsObj);
        break;
      case "pointP":
        window.etopMap.map.flyToPoint(geomObj, optionsObj);
        break;
      case "positions":
        window.etopMap.map.flyToPositions(geomObj, optionsObj);
        break;
      case "extent":
        window.etopMap.map.flyToExtent(geomObj, optionsObj);
        break;
      case "home":
        window.etopMap.map.flyHome(optionsObj);
        break;
      case "target":
        window.etopMap.map.flyTo(geomObj, optionsObj);
        break;
    }
  },
  flyToPoint({ lng, lat: lat2, alt = 0, options = {} }) {
    const point4 = new mars3d$1.LngLatPoint(lng, lat2, alt);
    window.etopMap.map.flyToPoint(point4, {
      radius: options.radius || 1e3,
      heading: options.heading || 0,
      pitch: options.pitch || -45,
      roll: options.roll || 0,
      duration: options.duration || 1,
      clampToGround: options.clampToGround || false,
      complete: options.complete || (() => {
      }),
      cancel: options.cancel || (() => {
      })
    });
  },
  flyToExtent({ xmin, xmax, ymin, ymax, height = 0, options = {} }) {
    const extent3 = {
      xmin,
      xmax,
      ymin,
      ymax,
      height
    };
    window.etopMap.map.flyToExtent(extent3, {
      scale: options.scale || 3,
      minHeight: options.minHeight || 200,
      maxHeight: options.maxHeight || 2e3,
      heading: options.heading || 0,
      pitch: options.pitch || -45,
      roll: options.roll || 0,
      duration: options.duration || 1,
      complete: options.complete || (() => {
      }),
      cancel: options.cancel || (() => {
      })
    });
  },
  flyToGraphic(graphic2, options = {}) {
    let sr;
    if (graphic2.type === "point" || graphic2.type === "pointP") {
      sr = {
        radius: options.radius || 1e3
      };
    } else {
      sr = {
        scale: options.scale || 3
      };
    }
    window.etopMap.map.flyToGraphic(graphic2, { ...sr, ...{
      minHeight: options.minHeight || 200,
      maxHeight: options.maxHeight || 2e3,
      heading: options.heading || 0,
      pitch: options.pitch || -45,
      roll: options.roll || 0,
      duration: options.duration || 1,
      complete: options.complete || (() => {
      }),
      cancel: options.cancel || (() => {
      })
    } });
  },
  flyToPositions(positionArr, options = {}) {
    window.etopMap.map.flyToPositions(positionArr, {
      radius: options.radius || 1e3,
      scale: options.scale || 3,
      minHeight: options.minHeight || 200,
      maxHeight: options.maxHeight || 2e3,
      heading: options.heading || 0,
      pitch: options.pitch || -45,
      roll: options.roll || 0,
      duration: options.duration || 1,
      complete: options.complete || (() => {
      }),
      cancel: options.cancel || (() => {
      })
    });
  },
  flyTo(target, options = {}) {
    window.etopMap.map.flyTo(target, {
      maximumHeight: options.maximumHeight || 2e3,
      duration: options.duration || 1,
      offset: options.offset || 3
    });
  }
};
var tiandituUtils = {
  addTiandituLayers({
    type = "img",
    isLabelShow = true,
    token = mars3d$1.Token.tiandituArr
  } = {}) {
    this.removeTiandituLayers();
    const tdtLayer = new mars3d$1.layer.TdtLayer({
      layer: `${type}_d`,
      key: token,
      name: "\u5929\u5730\u56FE\u56FE\u5C42",
      id: "tiandituLayer"
    });
    const tdtLabel = new mars3d$1.layer.TdtLayer({
      layer: `${type}_z`,
      key: token,
      name: "\u5929\u5730\u56FE\u6CE8\u8BB0",
      id: "tiandituLabel",
      show: isLabelShow
    });
    window.etopMap.map.addLayer(tdtLayer);
    window.etopMap.map.addLayer(tdtLabel);
  },
  removeTiandituLayers() {
    const tdtLayer = window.etopMap.map.getLayerById("tiandituLayer");
    const tdtLabel = window.etopMap.map.getLayerById("tiandituLabel");
    tdtLayer && window.etopMap.map.removeLayer(tdtLayer);
    tdtLabel && window.etopMap.map.removeLayer(tdtLabel);
  }
};
class Terrain {
  constructor(map5, options) {
    this.map = map5;
    this.PROXY_IP = options.gz_path;
    this.SZVSUD_LICENSE_KEY = options.licenseKey;
    this.gz_terrain = options.terrain;
  }
  toggleTerrainProvider(type) {
    const map5 = window.etopMap.map;
    switch (type) {
      case "none":
        map5.terrainProvider = mars3d$1.LayerUtil.getNoTerrainProvider();
        break;
      case "xyz":
        map5.terrainProvider = mars3d$1.LayerUtil.createTerrainProvider({
          url: "http://data.mars3d.cn/terrain"
        });
        break;
      case "arcgis":
        map5.terrainProvider = mars3d$1.LayerUtil.createTerrainProvider({
          type: "arcgis",
          url: "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer"
        });
        break;
      case "ion":
        map5.terrainProvider = mars3d$1.LayerUtil.createTerrainProvider({
          type: "ion"
        });
        break;
      case "gee":
        map5.terrainProvider = mars3d$1.LayerUtil.createTerrainProvider({
          type: "gee",
          url: "http://www.earthenterprise.org/3d",
          proxy: "//server.mars3d.cn/proxy/"
        });
        break;
      case "vr":
        map5.terrainProvider = mars3d$1.LayerUtil.createTerrainProvider({
          type: "vr",
          url: "https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/"
        });
        break;
      default:
        const url = new mars3d$1.Cesium.Resource({
          url: PROXY_IP + this.gz_terrain.url,
          queryParameters: this.gz_terrain.queryParameters,
          headers: {
            "szvsud-license-key": SZVSUD_LICENSE_KEY
          }
        });
        map5.terrainProvider = mars3d$1.LayerUtil.createTerrainProvider({
          url
        });
        break;
    }
  }
  enableTerrain(val) {
    window.etopMap.map.hasTerrain = val;
  }
  enabledTerrainSJW(val) {
    window.etopMap.map.scene.globe._surface.tileProvider._debug.wireframe = val;
  }
}
class BaseRoamLineUtils {
  constructor(map5) {
    __publicField(this, "map", null);
    __publicField(this, "graphicLayer", null);
    this.map = map5;
  }
  initGraphicLayer(options) {
    if (!this.graphicLayer) {
      this.graphicLayer = new mars3d$1.layer.GraphicLayer(options || {});
      this.map.addLayer(this.graphicLayer);
    }
    return this.graphicLayer;
  }
  addRoamLine(options = {}) {
    this.initGraphicLayer();
    const params = {
      ...options
    };
    const roamLine = new mars3d$1.graphic.RoamLine(params);
    this.graphicLayer.addGraphic(roamLine);
    return roamLine;
  }
  addRoamLineList(list) {
    return list.map((team) => this.addRoamLine(team));
  }
  removeLayer() {
    this.graphicLayer && this.map.removeLayer(this.graphicLayer, true);
    this.graphicLayer = null;
  }
}
class TilesetUtils {
  constructor(map5) {
    __publicField(this, "map", null);
    __publicField(this, "tilesetLayer", null);
    this.map = map5;
  }
  addTilesetLayer(options = {}) {
    if (this.tilesetLayer)
      return;
    this.tilesetLayer = new mars3d$1.layer.TilesetLayer(options);
    this.map.addLayer(this.tilesetLayer);
    return this.tilesetLayer;
  }
  addTilesetFlood(options = {}) {
    if (!this.tilesetLayer)
      this.addTilesetLayer();
    const tilesetFlood = new mars3d$1.thing.TilesetFlood({
      layer: this.tilesetLayer,
      floodAll: true,
      ...options
    });
    this.map.addThing(tilesetFlood);
    return tilesetFlood;
  }
  removeTilesetFlood(tilesetFlood, hasDestroy) {
    this.map.removeThing(tilesetFlood, hasDestroy);
  }
  removeTilesetLayer() {
    this.tilesetLayer && this.map.removeLayer(this.tilesetLayer);
  }
  addTilesetShadows(options = {}) {
    if (!this.tilesetLayer)
      this.addTilesetLayer();
    this.map.fixedLight = false;
    const shadows = new mars3d$1.thing.Shadows({
      multiplier: 1600,
      ...options
    });
    this.map.addThing(shadows);
    return shadows;
  }
  removeTilesetShadows(tilesetShadows, hasDestroy) {
    this.map.removeThing(tilesetShadows, hasDestroy);
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Browser = function() {
  function Browser2() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
  return Browser2;
}();
var Env = function() {
  function Env2() {
    this.browser = new Browser();
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
  return Env2;
}();
var env = new Env();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (typeof navigator === "undefined") {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua, env2) {
  var browser2 = env2.browser;
  var firefox = ua.match(/Firefox\/([\d.]+)/);
  var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge?\/([\d.]+)/);
  var weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser2.firefox = true;
    browser2.version = firefox[1];
  }
  if (ie) {
    browser2.ie = true;
    browser2.version = ie[1];
  }
  if (edge) {
    browser2.edge = true;
    browser2.version = edge[1];
    browser2.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser2.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser2.ie && !browser2.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser2.edge || browser2.ie && +browser2.version >= 11);
  env2.domSupported = typeof document !== "undefined";
  var style = document.documentElement.style;
  env2.transform3dSupported = (browser2.ie && "transition" in style || browser2.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
  env2.transformSupported = env2.transform3dSupported || browser2.ie && +browser2.version >= 9;
}
var env$1 = env;
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
  var map5 = {};
  if (typeof JSON === "undefined") {
    return map5;
  }
  for (var i = 0; i < mapStr.length; i++) {
    var char = String.fromCharCode(i + 32);
    var size11 = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
    map5[char] = size11;
  }
  return map5;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas: function() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    var _ctx;
    var _cachedFont;
    return function(text, font) {
      if (!_ctx) {
        var canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text);
      } else {
        text = text || "";
        font = font || DEFAULT_FONT;
        var res = /^([0-9]*?)px$/.exec(font);
        var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
        var width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text.length;
        } else {
          for (var i = 0; i < text.length; i++) {
            var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return { width };
      }
    };
  }(),
  loadImage: function(src2, onload, onerror) {
    var image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src2;
    return image;
  }
};
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(obj, val) {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(obj, val) {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
  return idStart++;
}
function logError() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone$4(source2) {
  if (source2 == null || typeof source2 !== "object") {
    return source2;
  }
  var result = source2;
  var typeStr = objToString.call(source2);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source2)) {
      result = [];
      for (var i = 0, len2 = source2.length; i < len2; i++) {
        result[i] = clone$4(source2[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source2)) {
      var Ctor = source2.constructor;
      if (Ctor.from) {
        result = Ctor.from(source2);
      } else {
        result = new Ctor(source2.length);
        for (var i = 0, len2 = source2.length; i < len2; i++) {
          result[i] = source2[i];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source2) && !isDom(source2)) {
    result = {};
    for (var key in source2) {
      if (source2.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone$4(source2[key]);
      }
    }
  }
  return result;
}
function merge3(target, source2, overwrite) {
  if (!isObject$3(source2) || !isObject$3(target)) {
    return overwrite ? clone$4(source2) : target;
  }
  for (var key in source2) {
    if (source2.hasOwnProperty(key) && key !== protoKey) {
      var targetProp = target[key];
      var sourceProp = source2[key];
      if (isObject$3(sourceProp) && isObject$3(targetProp) && !isArray$1(sourceProp) && !isArray$1(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge3(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone$4(source2[key]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];
  for (var i = 1, len2 = targetAndSources.length; i < len2; i++) {
    result = merge3(result, targetAndSources[i], overwrite);
  }
  return result;
}
function extend2(target, source2) {
  if (Object.assign) {
    Object.assign(target, source2);
  } else {
    for (var key in source2) {
      if (source2.hasOwnProperty(key) && key !== protoKey) {
        target[key] = source2[key];
      }
    }
  }
  return target;
}
function defaults(target, source2, overlay) {
  var keysArr = keys2(source2);
  for (var i = 0; i < keysArr.length; i++) {
    var key = keysArr[i];
    if (overlay ? source2[key] != null : target[key] == null) {
      target[key] = source2[key];
    }
  }
  return target;
}
platformApi.createCanvas;
function indexOf2(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (var i = 0, len2 = array.length; i < len2; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;
  function F() {
  }
  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();
  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin(target, source2, override) {
  target = "prototype" in target ? target.prototype : target;
  source2 = "prototype" in source2 ? source2.prototype : source2;
  if (Object.getOwnPropertyNames) {
    var keyList = Object.getOwnPropertyNames(source2);
    for (var i = 0; i < keyList.length; i++) {
      var key = keyList[i];
      if (key !== "constructor") {
        if (override ? source2[key] != null : target[key] == null) {
          target[key] = source2[key];
        }
      }
    }
  } else {
    defaults(target, source2, override);
  }
}
function isArrayLike(data) {
  if (!data) {
    return false;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each$f(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      cb.call(context, arr[i], i, arr);
    }
  } else {
    for (var key in arr) {
      if (arr.hasOwnProperty(key)) {
        cb.call(context, arr[key], key, arr);
      }
    }
  }
}
function map$1(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    var result = [];
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      result.push(cb.call(context, arr[i], i, arr));
    }
    return result;
  }
}
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len2 = arr.length; i < len2; i++) {
    memo = cb.call(context, memo, arr[i], i, arr);
  }
  return memo;
}
function filter17(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    var result = [];
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        result.push(arr[i]);
      }
    }
    return result;
  }
}
function find3(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len2 = arr.length; i < len2; i++) {
    if (cb.call(context, arr[i], i, arr)) {
      return arr[i];
    }
  }
}
function keys2(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keyList = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
function bindPolyfill(func, context) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind$1 = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry$1(func) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray$1(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction(value) {
  return typeof value === "function";
}
function isString(value) {
  return typeof value === "string";
}
function isStringSafe(value) {
  return objToString.call(value) === "[object String]";
}
function isNumber(value) {
  return typeof value === "number";
}
function isObject$3(value) {
  var type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
  return value.colorStops != null;
}
function isImagePatternObject(value) {
  return value.image != null;
}
function isRegExp(value) {
  return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  for (var i = 0, len2 = args.length; i < len2; i++) {
    if (args[i] != null) {
      return args[i];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray$1(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  var len2 = val.length;
  if (len2 === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len2 === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function trim$1(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var HashMap = function() {
  function HashMap2(obj) {
    this.data = {};
    var isArr = isArray$1(obj);
    this.data = {};
    var thisMap = this;
    obj instanceof HashMap2 ? obj.each(visit) : obj && each$f(obj, visit);
    function visit(value, key) {
      isArr ? thisMap.set(value, key) : thisMap.set(key, value);
    }
  }
  HashMap2.prototype.get = function(key) {
    return this.data.hasOwnProperty(key) ? this.data[key] : null;
  };
  HashMap2.prototype.set = function(key, value) {
    return this.data[key] = value;
  };
  HashMap2.prototype.each = function(cb, context) {
    for (var key in this.data) {
      if (this.data.hasOwnProperty(key)) {
        cb.call(context, this.data[key], key);
      }
    }
  };
  HashMap2.prototype.keys = function() {
    return keys2(this.data);
  };
  HashMap2.prototype.removeKey = function(key) {
    delete this.data[key];
  };
  return HashMap2;
}();
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a, b) {
  var newArray = new a.constructor(a.length + b.length);
  for (var i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }
  var offset = a.length;
  for (var i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }
  return newArray;
}
function createObject(proto2, properties) {
  var obj;
  if (Object.create) {
    obj = Object.create(proto2);
  } else {
    var StyleCtor = function() {
    };
    StyleCtor.prototype = proto2;
    obj = new StyleCtor();
  }
  if (properties) {
    extend2(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  var domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function create$2(x2, y2) {
  if (x2 == null) {
    x2 = 0;
  }
  if (y2 == null) {
    y2 = 0;
  }
  return [x2, y2];
}
function copy$1(out2, v) {
  out2[0] = v[0];
  out2[1] = v[1];
  return out2;
}
function clone$3(v) {
  return [v[0], v[1]];
}
function set$1(out2, a, b) {
  out2[0] = a;
  out2[1] = b;
  return out2;
}
function add15(out2, v12, v22) {
  out2[0] = v12[0] + v22[0];
  out2[1] = v12[1] + v22[1];
  return out2;
}
function scaleAndAdd$1(out2, v12, v22, a) {
  out2[0] = v12[0] + v22[0] * a;
  out2[1] = v12[1] + v22[1] * a;
  return out2;
}
function sub(out2, v12, v22) {
  out2[0] = v12[0] - v22[0];
  out2[1] = v12[1] - v22[1];
  return out2;
}
function len(v) {
  return Math.sqrt(lenSquare(v));
}
function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}
function scale$2(out2, v, s) {
  out2[0] = v[0] * s;
  out2[1] = v[1] * s;
  return out2;
}
function normalize$3(out2, v) {
  var d = len(v);
  if (d === 0) {
    out2[0] = 0;
    out2[1] = 0;
  } else {
    out2[0] = v[0] / d;
    out2[1] = v[1] / d;
  }
  return out2;
}
function distance10(v12, v22) {
  return Math.sqrt((v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]));
}
var dist$1 = distance10;
function distanceSquare(v12, v22) {
  return (v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]);
}
var distSquare = distanceSquare;
function lerp$1(out2, v12, v22, t) {
  out2[0] = v12[0] + t * (v22[0] - v12[0]);
  out2[1] = v12[1] + t * (v22[1] - v12[1]);
  return out2;
}
function applyTransform$1(out2, v, m2) {
  var x2 = v[0];
  var y2 = v[1];
  out2[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
  out2[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
  return out2;
}
function min$1(out2, v12, v22) {
  out2[0] = Math.min(v12[0], v22[0]);
  out2[1] = Math.min(v12[1], v22[1]);
  return out2;
}
function max$1(out2, v12, v22) {
  out2[0] = Math.max(v12[0], v22[0]);
  out2[1] = Math.max(v12[1], v22[1]);
  return out2;
}
var Param = function() {
  function Param2(target, e2) {
    this.target = target;
    this.topTarget = e2 && e2.topTarget;
  }
  return Param2;
}();
var Draggable = function() {
  function Draggable2(handler) {
    this.handler = handler;
    handler.on("mousedown", this._dragStart, this);
    handler.on("mousemove", this._drag, this);
    handler.on("mouseup", this._dragEnd, this);
  }
  Draggable2.prototype._dragStart = function(e2) {
    var draggingTarget = e2.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e2.offsetX;
      this._y = e2.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
    }
  };
  Draggable2.prototype._drag = function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      var x2 = e2.offsetX;
      var y2 = e2.offsetY;
      var dx = x2 - this._x;
      var dy = y2 - this._y;
      this._x = x2;
      this._y = y2;
      draggingTarget.drift(dx, dy, e2);
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
      var dropTarget = this.handler.findHover(x2, y2, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
        }
      }
    }
  };
  Draggable2.prototype._dragEnd = function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  };
  return Draggable2;
}();
var Draggable$1 = Draggable;
var Eventful = function() {
  function Eventful2(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  Eventful2.prototype.on = function(event, query5, handler, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    var _h = this._$handlers;
    if (typeof query5 === "function") {
      context = handler;
      handler = query5;
      query5 = null;
    }
    if (!handler || !event) {
      return this;
    }
    var eventProcessor = this._$eventProcessor;
    if (query5 != null && eventProcessor && eventProcessor.normalizeQuery) {
      query5 = eventProcessor.normalizeQuery(query5);
    }
    if (!_h[event]) {
      _h[event] = [];
    }
    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }
    var wrap2 = {
      h: handler,
      query: query5,
      ctx: context || this,
      callAtLast: handler.zrEventfulCallAtLast
    };
    var lastIndex = _h[event].length - 1;
    var lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap2) : _h[event].push(wrap2);
    return this;
  };
  Eventful2.prototype.isSilent = function(eventName) {
    var _h = this._$handlers;
    return !_h || !_h[eventName] || !_h[eventName].length;
  };
  Eventful2.prototype.off = function(eventType, handler) {
    var _h = this._$handlers;
    if (!_h) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[eventType]) {
        var newList = [];
        for (var i = 0, l = _h[eventType].length; i < l; i++) {
          if (_h[eventType][i].h !== handler) {
            newList.push(_h[eventType][i]);
          }
        }
        _h[eventType] = newList;
      }
      if (_h[eventType] && _h[eventType].length === 0) {
        delete _h[eventType];
      }
    } else {
      delete _h[eventType];
    }
    return this;
  };
  Eventful2.prototype.trigger = function(eventType) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[eventType];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var len2 = _h.length;
      for (var i = 0; i < len2; i++) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  };
  Eventful2.prototype.triggerWithContext = function(type) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var ctx = args[argLen - 1];
      var len2 = _h.length;
      for (var i = 0; i < len2; i++) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  };
  return Eventful2;
}();
var Eventful$1 = Eventful;
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + "-" + colMask;
  var fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  var sum2 = 0;
  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
    var colTag = 1 << j;
    if (!(colTag & colMask)) {
      sum2 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum2;
  return sum2;
}
function buildTransformer(src2, dest) {
  var mA = [
    [src2[0], src2[1], 1, 0, 0, 0, -dest[0] * src2[0], -dest[0] * src2[1]],
    [0, 0, 0, src2[0], src2[1], 1, -dest[1] * src2[0], -dest[1] * src2[1]],
    [src2[2], src2[3], 1, 0, 0, 0, -dest[2] * src2[2], -dest[2] * src2[3]],
    [0, 0, 0, src2[2], src2[3], 1, -dest[3] * src2[2], -dest[3] * src2[3]],
    [src2[4], src2[5], 1, 0, 0, 0, -dest[4] * src2[4], -dest[4] * src2[5]],
    [0, 0, 0, src2[4], src2[5], 1, -dest[5] * src2[4], -dest[5] * src2[5]],
    [src2[6], src2[7], 1, 0, 0, 0, -dest[6] * src2[6], -dest[6] * src2[7]],
    [0, 0, 0, src2[6], src2[7], 1, -dest[7] * src2[6], -dest[7] * src2[7]]
  ];
  var detCache = {};
  var det2 = determinant(mA, 8, 0, 0, 0, detCache);
  if (det2 === 0) {
    return;
  }
  var vh = [];
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det2 * dest[i];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut$1 = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env$1.domSupported && !isCanvasEl(el)) {
    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el, saved);
    var transformer2 = preparePointerTransformer(markers, saved, inverse);
    if (transformer2) {
      transformer2(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  var markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  var propLR = ["left", "right"];
  var propTB = ["top", "bottom"];
  for (var i = 0; i < 4; i++) {
    var marker = document.createElement("div");
    var stl = marker.style;
    var idxLR = i % 2;
    var idxTB = (i >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? "invTrans" : "trans";
  var transformer2 = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var srcCoords = [];
  var destCoords = [];
  var oldCoordTheSame = true;
  for (var i = 0; i < 4; i++) {
    var rect = markers[i].getBoundingClientRect();
    var ii = 2 * i;
    var x2 = rect.left;
    var y2 = rect.top;
    srcCoords.push(x2, y2);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x2 === oldSrcCoords[ii] && y2 === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  }
  return oldCoordTheSame && transformer2 ? transformer2 : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source2) {
  return source2 == null ? "" : (source2 + "").replace(replaceReg, function(str, c) {
    return replaceMap[c];
  });
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
var firefoxNotSupportOffsetXY = env$1.browser.firefox && +env$1.browser.version.split(".")[0] < 39;
function clientToLocal(el, e2, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el, e2, out2);
  } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
    out2.zrX = e2.layerX;
    out2.zrY = e2.layerY;
  } else if (e2.offsetX != null) {
    out2.zrX = e2.offsetX;
    out2.zrY = e2.offsetY;
  } else {
    calculateZrXY(el, e2, out2);
  }
  return out2;
}
function calculateZrXY(el, e2, out2) {
  if (env$1.domSupported && el.getBoundingClientRect) {
    var ex = e2.clientX;
    var ey = e2.clientY;
    if (isCanvasEl(el)) {
      var box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
        out2.zrX = _calcOut[0];
        out2.zrY = _calcOut[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e2) {
  return e2 || window.event;
}
function normalizeEvent(el, e2, calculate) {
  e2 = getNativeEvent(e2);
  if (e2.zrX != null) {
    return e2;
  }
  var eventType = e2.type;
  var isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e2, e2, calculate);
    var wheelDelta = getWheelDeltaMayPolyfill(e2);
    e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
  } else {
    var touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
    touch && clientToLocal(el, touch, e2, calculate);
  }
  var button = e2.button;
  if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
    e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e2;
}
function getWheelDeltaMayPolyfill(e2) {
  var rawWheelDelta = e2.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  var deltaX = e2.deltaX;
  var deltaY = e2.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  var delta2 = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  var sign2 = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta2 * sign2;
}
function addEventListener(el, name2, handler, opt) {
  el.addEventListener(name2, handler, opt);
}
function removeEventListener(el, name2, handler, opt) {
  el.removeEventListener(name2, handler, opt);
}
var stop = function(e2) {
  e2.preventDefault();
  e2.stopPropagation();
  e2.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e2) {
  return e2.which === 2 || e2.which === 3;
}
var GestureMgr = function() {
  function GestureMgr2() {
    this._track = [];
  }
  GestureMgr2.prototype.recognize = function(event, target, root) {
    this._doTrack(event, target, root);
    return this._recognize(event);
  };
  GestureMgr2.prototype.clear = function() {
    this._track.length = 0;
    return this;
  };
  GestureMgr2.prototype._doTrack = function(event, target, root) {
    var touches = event.touches;
    if (!touches) {
      return;
    }
    var trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (var i = 0, len2 = touches.length; i < len2; i++) {
      var touch = touches[i];
      var pos = clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  };
  GestureMgr2.prototype._recognize = function(event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  };
  return GestureMgr2;
}();
function dist2(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center$1(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    var trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    var pinchEnd = (tracks[trackLen - 1] || {}).points;
    var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist2(pinchEnd) / dist2(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center$1(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};
function create$1() {
  return [1, 0, 0, 1, 0, 0];
}
function identity(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
}
function copy7(out2, m2) {
  out2[0] = m2[0];
  out2[1] = m2[1];
  out2[2] = m2[2];
  out2[3] = m2[3];
  out2[4] = m2[4];
  out2[5] = m2[5];
  return out2;
}
function mul(out2, m1, m2) {
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out22 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out2[0] = out0;
  out2[1] = out1;
  out2[2] = out22;
  out2[3] = out3;
  out2[4] = out4;
  out2[5] = out5;
  return out2;
}
function translate2(out2, a, v) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4] + v[0];
  out2[5] = a[5] + v[1];
  return out2;
}
function rotate(out2, a, rad2) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab2 = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad2);
  var ct = Math.cos(rad2);
  out2[0] = aa * ct + ab2 * st;
  out2[1] = -aa * st + ab2 * ct;
  out2[2] = ac * ct + ad * st;
  out2[3] = -ac * st + ct * ad;
  out2[4] = ct * atx + st * aty;
  out2[5] = ct * aty - st * atx;
  return out2;
}
function scale$1(out2, a, v) {
  var vx = v[0];
  var vy = v[1];
  out2[0] = a[0] * vx;
  out2[1] = a[1] * vy;
  out2[2] = a[2] * vx;
  out2[3] = a[3] * vy;
  out2[4] = a[4] * vx;
  out2[5] = a[5] * vy;
  return out2;
}
function invert(out2, a) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab2 = a[1];
  var ad = a[3];
  var aty = a[5];
  var det2 = aa * ad - ab2 * ac;
  if (!det2) {
    return null;
  }
  det2 = 1 / det2;
  out2[0] = ad * det2;
  out2[1] = -ab2 * det2;
  out2[2] = -ac * det2;
  out2[3] = aa * det2;
  out2[4] = (ac * aty - ad * atx) * det2;
  out2[5] = (ab2 * atx - aa * aty) * det2;
  return out2;
}
function clone$2(a) {
  var b = create$1();
  copy7(b, a);
  return b;
}
var Point = function() {
  function Point2(x2, y2) {
    this.x = x2 || 0;
    this.y = y2 || 0;
  }
  Point2.prototype.copy = function(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  };
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.set = function(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  };
  Point2.prototype.equal = function(other) {
    return other.x === this.x && other.y === this.y;
  };
  Point2.prototype.add = function(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  };
  Point2.prototype.scale = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  };
  Point2.prototype.scaleAndAdd = function(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  };
  Point2.prototype.sub = function(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  };
  Point2.prototype.dot = function(other) {
    return this.x * other.x + this.y * other.y;
  };
  Point2.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Point2.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  };
  Point2.prototype.normalize = function() {
    var len2 = this.len();
    this.x /= len2;
    this.y /= len2;
    return this;
  };
  Point2.prototype.distance = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.prototype.distanceSquare = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return dx * dx + dy * dy;
  };
  Point2.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  Point2.prototype.transform = function(m2) {
    if (!m2) {
      return;
    }
    var x2 = this.x;
    var y2 = this.y;
    this.x = m2[0] * x2 + m2[2] * y2 + m2[4];
    this.y = m2[1] * x2 + m2[3] * y2 + m2[5];
    return this;
  };
  Point2.prototype.toArray = function(out2) {
    out2[0] = this.x;
    out2[1] = this.y;
    return out2;
  };
  Point2.prototype.fromArray = function(input) {
    this.x = input[0];
    this.y = input[1];
  };
  Point2.set = function(p, x2, y2) {
    p.x = x2;
    p.y = y2;
  };
  Point2.copy = function(p, p2) {
    p.x = p2.x;
    p.y = p2.y;
  };
  Point2.len = function(p) {
    return Math.sqrt(p.x * p.x + p.y * p.y);
  };
  Point2.lenSquare = function(p) {
    return p.x * p.x + p.y * p.y;
  };
  Point2.dot = function(p0, p1) {
    return p0.x * p1.x + p0.y * p1.y;
  };
  Point2.add = function(out2, p0, p1) {
    out2.x = p0.x + p1.x;
    out2.y = p0.y + p1.y;
  };
  Point2.sub = function(out2, p0, p1) {
    out2.x = p0.x - p1.x;
    out2.y = p0.y - p1.y;
  };
  Point2.scale = function(out2, p0, scalar) {
    out2.x = p0.x * scalar;
    out2.y = p0.y * scalar;
  };
  Point2.scaleAndAdd = function(out2, p0, p1, scalar) {
    out2.x = p0.x + p1.x * scalar;
    out2.y = p0.y + p1.y * scalar;
  };
  Point2.lerp = function(out2, p0, p1, t) {
    var onet = 1 - t;
    out2.x = onet * p0.x + t * p1.x;
    out2.y = onet * p0.y + t * p1.y;
  };
  return Point2;
}();
var Point$1 = Point;
var mathMin$a = Math.min;
var mathMax$a = Math.max;
var lt2 = new Point$1();
var rb = new Point$1();
var lb = new Point$1();
var rt = new Point$1();
var minTv$1 = new Point$1();
var maxTv$1 = new Point$1();
var BoundingRect = function() {
  function BoundingRect2(x2, y2, width, height) {
    if (width < 0) {
      x2 = x2 + width;
      width = -width;
    }
    if (height < 0) {
      y2 = y2 + height;
      height = -height;
    }
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
  }
  BoundingRect2.prototype.union = function(other) {
    var x2 = mathMin$a(other.x, this.x);
    var y2 = mathMin$a(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax$a(other.x + other.width, this.x + this.width) - x2;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax$a(other.y + other.height, this.y + this.height) - y2;
    } else {
      this.height = other.height;
    }
    this.x = x2;
    this.y = y2;
  };
  BoundingRect2.prototype.applyTransform = function(m2) {
    BoundingRect2.applyTransform(this, this, m2);
  };
  BoundingRect2.prototype.calculateTransform = function(b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m2 = create$1();
    translate2(m2, m2, [-a.x, -a.y]);
    scale$1(m2, m2, [sx, sy]);
    translate2(m2, m2, [b.x, b.y]);
    return m2;
  };
  BoundingRect2.prototype.intersect = function(b, mtv) {
    if (!b) {
      return false;
    }
    if (!(b instanceof BoundingRect2)) {
      b = BoundingRect2.create(b);
    }
    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    var overlap2 = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (mtv) {
      var dMin = Infinity;
      var dMax = 0;
      var d0 = Math.abs(ax1 - bx0);
      var d1 = Math.abs(bx1 - ax0);
      var d2 = Math.abs(ay1 - by0);
      var d3 = Math.abs(by1 - ay0);
      var dx = Math.min(d0, d1);
      var dy = Math.min(d2, d3);
      if (ax1 < bx0 || bx1 < ax0) {
        if (dx > dMax) {
          dMax = dx;
          if (d0 < d1) {
            Point$1.set(maxTv$1, -d0, 0);
          } else {
            Point$1.set(maxTv$1, d1, 0);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d0 < d1) {
            Point$1.set(minTv$1, d0, 0);
          } else {
            Point$1.set(minTv$1, -d1, 0);
          }
        }
      }
      if (ay1 < by0 || by1 < ay0) {
        if (dy > dMax) {
          dMax = dy;
          if (d2 < d3) {
            Point$1.set(maxTv$1, 0, -d2);
          } else {
            Point$1.set(maxTv$1, 0, d3);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d2 < d3) {
            Point$1.set(minTv$1, 0, d2);
          } else {
            Point$1.set(minTv$1, 0, -d3);
          }
        }
      }
    }
    if (mtv) {
      Point$1.copy(mtv, overlap2 ? minTv$1 : maxTv$1);
    }
    return overlap2;
  };
  BoundingRect2.prototype.contain = function(x2, y2) {
    var rect = this;
    return x2 >= rect.x && x2 <= rect.x + rect.width && y2 >= rect.y && y2 <= rect.y + rect.height;
  };
  BoundingRect2.prototype.clone = function() {
    return new BoundingRect2(this.x, this.y, this.width, this.height);
  };
  BoundingRect2.prototype.copy = function(other) {
    BoundingRect2.copy(this, other);
  };
  BoundingRect2.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  };
  BoundingRect2.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  };
  BoundingRect2.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  };
  BoundingRect2.create = function(rect) {
    return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
  };
  BoundingRect2.copy = function(target, source2) {
    target.x = source2.x;
    target.y = source2.y;
    target.width = source2.width;
    target.height = source2.height;
  };
  BoundingRect2.applyTransform = function(target, source2, m2) {
    if (!m2) {
      if (target !== source2) {
        BoundingRect2.copy(target, source2);
      }
      return;
    }
    if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
      var sx = m2[0];
      var sy = m2[3];
      var tx = m2[4];
      var ty = m2[5];
      target.x = source2.x * sx + tx;
      target.y = source2.y * sy + ty;
      target.width = source2.width * sx;
      target.height = source2.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt2.x = lb.x = source2.x;
    lt2.y = rt.y = source2.y;
    rb.x = rt.x = source2.x + source2.width;
    rb.y = lb.y = source2.y + source2.height;
    lt2.transform(m2);
    rt.transform(m2);
    rb.transform(m2);
    lb.transform(m2);
    target.x = mathMin$a(lt2.x, rb.x, lb.x, rt.x);
    target.y = mathMin$a(lt2.y, rb.y, lb.y, rt.y);
    var maxX2 = mathMax$a(lt2.x, rb.x, lb.x, rt.x);
    var maxY2 = mathMax$a(lt2.y, rb.y, lb.y, rt.y);
    target.width = maxX2 - target.x;
    target.height = maxY2 - target.y;
  };
  return BoundingRect2;
}();
var BoundingRect$1 = BoundingRect;
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(_super) {
  __extends(EmptyProxy2, _super);
  function EmptyProxy2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.handler = null;
    return _this;
  }
  EmptyProxy2.prototype.dispose = function() {
  };
  EmptyProxy2.prototype.setCursor = function() {
  };
  return EmptyProxy2;
}(Eventful$1);
var HoveredResult = function() {
  function HoveredResult2(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  return HoveredResult2;
}();
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var tmpRect$1 = new BoundingRect$1(0, 0, 0, 0);
var Handler = function(_super) {
  __extends(Handler2, _super);
  function Handler2(storage2, painter, proxy, painterRoot, pointerSize) {
    var _this = _super.call(this) || this;
    _this._hovered = new HoveredResult(0, 0);
    _this.storage = storage2;
    _this.painter = painter;
    _this.painterRoot = painterRoot;
    _this._pointerSize = pointerSize;
    proxy = proxy || new EmptyProxy();
    _this.proxy = null;
    _this.setHandlerProxy(proxy);
    _this._draggingMgr = new Draggable$1(_this);
    return _this;
  }
  Handler2.prototype.setHandlerProxy = function(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each$f(handlerNames, function(name2) {
        proxy.on && proxy.on(name2, this[name2], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  };
  Handler2.prototype.mousemove = function(event) {
    var x2 = event.zrX;
    var y2 = event.zrY;
    var isOutside = isOutsideBoundary(this, x2, y2);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    var hovered = this._hovered = isOutside ? new HoveredResult(x2, y2) : this.findHover(x2, y2);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  };
  Handler2.prototype.mouseout = function(event) {
    var eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", { type: "globalout", event });
    }
  };
  Handler2.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  };
  Handler2.prototype.dispatch = function(eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  };
  Handler2.prototype.dispose = function() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  };
  Handler2.prototype.setCursorStyle = function(cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  };
  Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    var eventKey = "on" + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el) {
      el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.__hostTarget ? el.__hostTarget : el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer2) {
          if (typeof layer2[eventKey] === "function") {
            layer2[eventKey].call(layer2, eventPacket);
          }
          if (layer2.trigger) {
            layer2.trigger(eventName, eventPacket);
          }
        });
      }
    }
  };
  Handler2.prototype.findHover = function(x2, y2, exclude) {
    var list = this.storage.getDisplayList();
    var out2 = new HoveredResult(x2, y2);
    setHoverTarget(list, out2, x2, y2, exclude);
    if (this._pointerSize && !out2.target) {
      var candidates = [];
      var pointerSize = this._pointerSize;
      var targetSizeHalf = pointerSize / 2;
      var pointerRect = new BoundingRect$1(x2 - targetSizeHalf, y2 - targetSizeHalf, pointerSize, pointerSize);
      for (var i = list.length - 1; i >= 0; i--) {
        var el = list[i];
        if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
          tmpRect$1.copy(el.getBoundingRect());
          if (el.transform) {
            tmpRect$1.applyTransform(el.transform);
          }
          if (tmpRect$1.intersect(pointerRect)) {
            candidates.push(el);
          }
        }
      }
      if (candidates.length) {
        var rStep = 4;
        var thetaStep = Math.PI / 12;
        var PI22 = Math.PI * 2;
        for (var r = 0; r < targetSizeHalf; r += rStep) {
          for (var theta = 0; theta < PI22; theta += thetaStep) {
            var x12 = x2 + r * Math.cos(theta);
            var y12 = y2 + r * Math.sin(theta);
            setHoverTarget(candidates, out2, x12, y12, exclude);
            if (out2.target) {
              return out2;
            }
          }
        }
      }
    }
    return out2;
  };
  Handler2.prototype.processGesture = function(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    var gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      var type = gestureInfo.type;
      event.gestureEvent = type;
      var res = new HoveredResult();
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type, gestureInfo.event);
    }
  };
  return Handler2;
}(Eventful$1);
each$f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name2) {
  Handler.prototype[name2] = function(event) {
    var x2 = event.zrX;
    var y2 = event.zrY;
    var isOutside = isOutsideBoundary(this, x2, y2);
    var hovered;
    var hoveredTarget;
    if (name2 !== "mouseup" || !isOutside) {
      hovered = this.findHover(x2, y2);
      hoveredTarget = hovered.target;
    }
    if (name2 === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name2 === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name2 === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name2, event);
  };
});
function isHover(displayable, x2, y2) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x2, y2)) {
    var el = displayable;
    var isSilent = void 0;
    var ignoreClip = false;
    while (el) {
      if (el.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        var clipPath = el.getClipPath();
        if (clipPath && !clipPath.contain(x2, y2)) {
          return false;
        }
        if (el.silent) {
          isSilent = true;
        }
      }
      var hostEl = el.__hostTarget;
      el = hostEl ? hostEl : el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function setHoverTarget(list, out2, x2, y2, exclude) {
  for (var i = list.length - 1; i >= 0; i--) {
    var el = list[i];
    var hoverCheckResult = void 0;
    if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x2, y2))) {
      !out2.topTarget && (out2.topTarget = el);
      if (hoverCheckResult !== SILENT) {
        out2.target = el;
        break;
      }
    }
  }
}
function isOutsideBoundary(handlerInstance, x2, y2) {
  var painter = handlerInstance.painter;
  return x2 < 0 || x2 > painter.getWidth() || y2 < 0 || y2 > painter.getHeight();
}
var Handler$1 = Handler;
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
  var r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array, lo, hi, compare11) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare11(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare11(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare11(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}
function binaryInsertionSort(array, lo, hi, start2, compare11) {
  if (start2 === lo) {
    start2++;
  }
  for (; start2 < hi; start2++) {
    var pivot = array[start2];
    var left = lo;
    var right = start2;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare11(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n = start2 - left;
    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];
      case 2:
        array[left + 2] = array[left + 1];
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }
    }
    array[left] = pivot;
  }
}
function gallopLeft(value, array, start2, length3, hint, compare11) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare11(value, array[start2 + hint]) > 0) {
    maxOffset = length3 - hint;
    while (offset < maxOffset && compare11(value, array[start2 + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare11(value, array[start2 + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare11(value, array[start2 + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset = m2;
    }
  }
  return offset;
}
function gallopRight(value, array, start2, length3, hint, compare11) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare11(value, array[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare11(value, array[start2 + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length3 - hint;
    while (offset < maxOffset && compare11(value, array[start2 + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare11(value, array[start2 + m2]) < 0) {
      offset = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset;
}
function TimSort(array, compare11) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var runStart;
  var runLength;
  var stackSize = 0;
  array.length;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }
      mergeAt(n);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }
      mergeAt(n);
    }
  }
  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length22 = runLength[i + 1];
    runLength[i] = length1 + length22;
    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }
    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare11);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length22 = gallopLeft(array[start1 + length1 - 1], array, start2, length22, length22 - 1, compare11);
    if (length22 === 0) {
      return;
    }
    if (length1 <= length22) {
      mergeLow(start1, length1, start2, length22);
    } else {
      mergeHigh(start1, length1, start2, length22);
    }
  }
  function mergeLow(start1, length1, start2, length22) {
    var i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length22 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length22; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length22] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count22;
    var exit;
    while (1) {
      count1 = 0;
      count22 = 0;
      exit = false;
      do {
        if (compare11(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count22++;
          count1 = 0;
          if (--length22 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count22 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count22) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare11);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length22 === 0) {
          exit = true;
          break;
        }
        count22 = gallopLeft(tmp[cursor1], array, cursor2, length22, 0, compare11);
        if (count22 !== 0) {
          for (i = 0; i < count22; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          dest += count22;
          cursor2 += count22;
          length22 -= count22;
          if (length22 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i = 0; i < length22; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length22] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length22) {
    var i = 0;
    for (i = 0; i < length22; i++) {
      tmp[i] = array[start2 + i];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length22 - 1;
    var dest = start2 + length22 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length22 - 1);
      for (i = 0; i < length22; i++) {
        array[customCursor + i] = tmp[i];
      }
      return;
    }
    if (length22 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count22 = 0;
      var exit = false;
      do {
        if (compare11(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count22 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count22++;
          count1 = 0;
          if (--length22 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count22) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare11);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length22 === 1) {
          exit = true;
          break;
        }
        count22 = length22 - gallopLeft(array[cursor1], tmp, 0, length22, length22 - 1, compare11);
        if (count22 !== 0) {
          dest -= count22;
          cursor2 -= count22;
          length22 -= count22;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count22; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }
          if (length22 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length22 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
    } else if (length22 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length22 - 1);
      for (i = 0; i < length22; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort$2(array, compare11, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare11);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare11);
    return;
  }
  var ts = TimSort(array, compare11);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare11);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare11);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      return a.z2 - b.z2;
    }
    return a.z - b.z;
  }
  return a.zlevel - b.zlevel;
}
var Storage = function() {
  function Storage2() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  Storage2.prototype.traverse = function(cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  };
  Storage2.prototype.getDisplayList = function(update, includeIgnore) {
    includeIgnore = includeIgnore || false;
    var displayList = this._displayList;
    if (update || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  };
  Storage2.prototype.updateDisplayList = function(includeIgnore) {
    this._displayListLen = 0;
    var roots2 = this._roots;
    var displayList = this._displayList;
    for (var i = 0, len2 = roots2.length; i < len2; i++) {
      this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort$2(displayList, shapeCompareFunc);
  };
  Storage2.prototype._updateAndAddDisplayable = function(el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    el.update();
    el.afterUpdate();
    var userSetClipPath = el.getClipPath();
    if (el.ignoreClip) {
      clipPaths = null;
    } else if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      var currentClipPath = userSetClipPath;
      var parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (el.childrenRef) {
      var children = el.childrenRef();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (el.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el.__dirty = 0;
    } else {
      var disp = el;
      if (clipPaths && clipPaths.length) {
        disp.__clipPaths = clipPaths;
      } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
        disp.__clipPaths = [];
      }
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    var decalEl = el.getDecalElement && el.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
    }
    var textGuide = el.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
    }
    var textEl = el.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
    }
  };
  Storage2.prototype.addRoot = function(el) {
    if (el.__zr && el.__zr.storage === this) {
      return;
    }
    this._roots.push(el);
  };
  Storage2.prototype.delRoot = function(el) {
    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }
      return;
    }
    var idx = indexOf2(this._roots, el);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  };
  Storage2.prototype.delAllRoots = function() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  };
  Storage2.prototype.getRoots = function() {
    return this._roots;
  };
  Storage2.prototype.dispose = function() {
    this._displayList = null;
    this._roots = null;
  };
  return Storage2;
}();
var Storage$1 = Storage;
var requestAnimationFrame;
requestAnimationFrame = env$1.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame$1 = requestAnimationFrame;
var easingFuncs = {
  linear: function(k) {
    return k;
  },
  quadraticIn: function(k) {
    return k * k;
  },
  quadraticOut: function(k) {
    return k * (2 - k);
  },
  quadraticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  },
  cubicIn: function(k) {
    return k * k * k;
  },
  cubicOut: function(k) {
    return --k * k * k + 1;
  },
  cubicInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k + 2);
  },
  quarticIn: function(k) {
    return k * k * k * k;
  },
  quarticOut: function(k) {
    return 1 - --k * k * k * k;
  },
  quarticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }
    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  quinticIn: function(k) {
    return k * k * k * k * k;
  },
  quinticOut: function(k) {
    return --k * k * k * k * k + 1;
  },
  quinticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  sinusoidalIn: function(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },
  sinusoidalOut: function(k) {
    return Math.sin(k * Math.PI / 2);
  },
  sinusoidalInOut: function(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  exponentialIn: function(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },
  exponentialOut: function(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },
  exponentialInOut: function(k) {
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  circularIn: function(k) {
    return 1 - Math.sqrt(1 - k * k);
  },
  circularOut: function(k) {
    return Math.sqrt(1 - --k * k);
  },
  circularInOut: function(k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  elasticIn: function(k) {
    var s;
    var a = 0.1;
    var p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },
  elasticOut: function(k) {
    var s;
    var a = 0.1;
    var p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },
  elasticInOut: function(k) {
    var s;
    var a = 0.1;
    var p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }
    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  backIn: function(k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },
  backOut: function(k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },
  backInOut: function(k) {
    var s = 1.70158 * 1.525;
    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }
    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  bounceIn: function(k) {
    return 1 - easingFuncs.bounceOut(1 - k);
  },
  bounceOut: function(k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },
  bounceInOut: function(k) {
    if (k < 0.5) {
      return easingFuncs.bounceIn(k * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var easingFuncs$1 = easingFuncs;
var mathPow$2 = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$4 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = create$2();
var _v1 = create$2();
var _v2 = create$2();
function isAroundZero$1(val) {
  return val > -EPSILON$4 && val < EPSILON$4;
}
function isNotAroundZero$1(val) {
  return val > EPSILON$4 || val < -EPSILON$4;
}
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  var a = p3 + 3 * (p1 - p2) - p0;
  var b = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d = p0 - val;
  var A = b * b - 3 * a * c;
  var B2 = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;
  if (isAroundZero$1(A) && isAroundZero$1(B2)) {
    if (isAroundZero$1(b)) {
      roots2[0] = 0;
    } else {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = B2 * B2 - 4 * A * C;
    if (isAroundZero$1(disc)) {
      var K = B2 / A;
      var t1 = -b / a + K;
      var t2 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var Y1 = A * b + 1.5 * a * (-B2 + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B2 - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow$2(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow$2(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow$2(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow$2(Y2, ONE_THIRD);
      }
      var t1 = (-b - (Y1 + Y2)) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B2) / (2 * mathSqrt$3(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt$3(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n++] = t3;
      }
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  var b = 6 * p2 - 12 * p1 + 6 * p0;
  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;
  if (isAroundZero$1(a)) {
    if (isNotAroundZero$1(b)) {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isAroundZero$1(disc)) {
      extrema2[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n++] = t2;
      }
    }
  }
  return n;
}
function cubicSubdivide(p0, p1, p2, p3, t, out2) {
  var p012 = (p1 - p0) * t + p0;
  var p122 = (p2 - p1) * t + p1;
  var p232 = (p3 - p2) * t + p2;
  var p0122 = (p122 - p012) * t + p012;
  var p123 = (p232 - p122) * t + p122;
  var p0123 = (p123 - p0122) * t + p0122;
  out2[0] = p0;
  out2[1] = p012;
  out2[2] = p0122;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p232;
  out2[7] = p3;
}
function cubicProjectPoint(x02, y02, x12, y12, x2, y2, x3, y3, x4, y4, out2) {
  var t;
  var interval = 5e-3;
  var d = Infinity;
  var prev;
  var next3;
  var d1;
  var d2;
  _v0[0] = x4;
  _v0[1] = y4;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x02, x12, x2, x3, _t);
    _v1[1] = cubicAt(y02, y12, y2, y3, _t);
    d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t - interval;
    next3 = t + interval;
    _v1[0] = cubicAt(x02, x12, x2, x3, prev);
    _v1[1] = cubicAt(y02, y12, y2, y3, prev);
    d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = cubicAt(x02, x12, x2, x3, next3);
      _v2[1] = cubicAt(y02, y12, y2, y3, next3);
      d2 = distSquare(_v2, _v0);
      if (next3 <= 1 && d2 < d) {
        t = next3;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt(x02, x12, x2, x3, t);
    out2[1] = cubicAt(y02, y12, y2, y3, t);
  }
  return mathSqrt$3(d);
}
function cubicLength(x02, y02, x12, y12, x2, y2, x3, y3, iteration) {
  var px = x02;
  var py = y02;
  var d = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x4 = cubicAt(x02, x12, x2, x3, t);
    var y4 = cubicAt(y02, y12, y2, y3, t);
    var dx = x4 - px;
    var dy = y4 - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x4;
    py = y4;
  }
  return d;
}
function quadraticAt$1(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  var a = p0 - 2 * p1 + p2;
  var b = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;
  if (isAroundZero$1(a)) {
    if (isNotAroundZero$1(b)) {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isAroundZero$1(disc)) {
      var t1 = -b / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide(p0, p1, p2, t, out2) {
  var p012 = (p1 - p0) * t + p0;
  var p122 = (p2 - p1) * t + p1;
  var p0122 = (p122 - p012) * t + p012;
  out2[0] = p0;
  out2[1] = p012;
  out2[2] = p0122;
  out2[3] = p0122;
  out2[4] = p122;
  out2[5] = p2;
}
function quadraticProjectPoint(x02, y02, x12, y12, x2, y2, x3, y3, out2) {
  var t;
  var interval = 5e-3;
  var d = Infinity;
  _v0[0] = x3;
  _v0[1] = y3;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt$1(x02, x12, x2, _t);
    _v1[1] = quadraticAt$1(y02, y12, y2, _t);
    var d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    var prev = t - interval;
    var next3 = t + interval;
    _v1[0] = quadraticAt$1(x02, x12, x2, prev);
    _v1[1] = quadraticAt$1(y02, y12, y2, prev);
    var d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = quadraticAt$1(x02, x12, x2, next3);
      _v2[1] = quadraticAt$1(y02, y12, y2, next3);
      var d2 = distSquare(_v2, _v0);
      if (next3 <= 1 && d2 < d) {
        t = next3;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt$1(x02, x12, x2, t);
    out2[1] = quadraticAt$1(y02, y12, y2, t);
  }
  return mathSqrt$3(d);
}
function quadraticLength(x02, y02, x12, y12, x2, y2, iteration) {
  var px = x02;
  var py = y02;
  var d = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x3 = quadraticAt$1(x02, x12, x2, t);
    var y3 = quadraticAt$1(y02, y12, y2, t);
    var dx = x3 - px;
    var dy = y3 - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x3;
    py = y3;
  }
  return d;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic) {
    var points2 = cubic[1].split(",");
    var a_1 = +trim$1(points2[0]);
    var b_1 = +trim$1(points2[1]);
    var c_1 = +trim$1(points2[2]);
    var d_1 = +trim$1(points2[3]);
    if (isNaN(a_1 + b_1 + c_1 + d_1)) {
      return;
    }
    var roots_1 = [];
    return function(p) {
      return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
    };
  }
}
var Clip = function() {
  function Clip2(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1e3;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop;
    this.ondestroy = opts.ondestroy || noop;
    this.onrestart = opts.onrestart || noop;
    opts.easing && this.setEasing(opts.easing);
  }
  Clip2.prototype.step = function(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    var life = this._life;
    var elapsedTime = globalTime - this._startTime - this._pausedTime;
    var percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    var easingFunc = this.easingFunc;
    var schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        var remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  };
  Clip2.prototype.pause = function() {
    this._paused = true;
  };
  Clip2.prototype.resume = function() {
    this._paused = false;
  };
  Clip2.prototype.setEasing = function(easing) {
    this.easing = easing;
    this.easingFunc = isFunction(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
  };
  return Clip2;
}();
var Clip$1 = Clip;
var Entry = function() {
  function Entry2(val) {
    this.value = val;
  }
  return Entry2;
}();
var LinkedList2 = function() {
  function LinkedList3() {
    this._len = 0;
  }
  LinkedList3.prototype.insert = function(val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  };
  LinkedList3.prototype.insertEntry = function(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  };
  LinkedList3.prototype.remove = function(entry) {
    var prev = entry.prev;
    var next3 = entry.next;
    if (prev) {
      prev.next = next3;
    } else {
      this.head = next3;
    }
    if (next3) {
      next3.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  };
  LinkedList3.prototype.len = function() {
    return this._len;
  };
  LinkedList3.prototype.clear = function() {
    this.head = this.tail = null;
    this._len = 0;
  };
  return LinkedList3;
}();
var LRU = function() {
  function LRU2(maxSize) {
    this._list = new LinkedList2();
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  LRU2.prototype.put = function(key, value) {
    var list = this._list;
    var map5 = this._map;
    var removed = null;
    if (map5[key] == null) {
      var len2 = list.len();
      var entry = this._lastRemovedEntry;
      if (len2 >= this._maxSize && len2 > 0) {
        var leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map5[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }
      entry.key = key;
      list.insertEntry(entry);
      map5[key] = entry;
    }
    return removed;
  };
  LRU2.prototype.get = function(key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  };
  LRU2.prototype.clear = function() {
    this._list.clear();
    this._map = {};
  };
  LRU2.prototype.len = function() {
    return this._list.len();
  };
  return LRU2;
}();
var LRU$1 = LRU;
var kCSSColorTable = {
  "transparent": [0, 0, 0, 0],
  "aliceblue": [240, 248, 255, 1],
  "antiquewhite": [250, 235, 215, 1],
  "aqua": [0, 255, 255, 1],
  "aquamarine": [127, 255, 212, 1],
  "azure": [240, 255, 255, 1],
  "beige": [245, 245, 220, 1],
  "bisque": [255, 228, 196, 1],
  "black": [0, 0, 0, 1],
  "blanchedalmond": [255, 235, 205, 1],
  "blue": [0, 0, 255, 1],
  "blueviolet": [138, 43, 226, 1],
  "brown": [165, 42, 42, 1],
  "burlywood": [222, 184, 135, 1],
  "cadetblue": [95, 158, 160, 1],
  "chartreuse": [127, 255, 0, 1],
  "chocolate": [210, 105, 30, 1],
  "coral": [255, 127, 80, 1],
  "cornflowerblue": [100, 149, 237, 1],
  "cornsilk": [255, 248, 220, 1],
  "crimson": [220, 20, 60, 1],
  "cyan": [0, 255, 255, 1],
  "darkblue": [0, 0, 139, 1],
  "darkcyan": [0, 139, 139, 1],
  "darkgoldenrod": [184, 134, 11, 1],
  "darkgray": [169, 169, 169, 1],
  "darkgreen": [0, 100, 0, 1],
  "darkgrey": [169, 169, 169, 1],
  "darkkhaki": [189, 183, 107, 1],
  "darkmagenta": [139, 0, 139, 1],
  "darkolivegreen": [85, 107, 47, 1],
  "darkorange": [255, 140, 0, 1],
  "darkorchid": [153, 50, 204, 1],
  "darkred": [139, 0, 0, 1],
  "darksalmon": [233, 150, 122, 1],
  "darkseagreen": [143, 188, 143, 1],
  "darkslateblue": [72, 61, 139, 1],
  "darkslategray": [47, 79, 79, 1],
  "darkslategrey": [47, 79, 79, 1],
  "darkturquoise": [0, 206, 209, 1],
  "darkviolet": [148, 0, 211, 1],
  "deeppink": [255, 20, 147, 1],
  "deepskyblue": [0, 191, 255, 1],
  "dimgray": [105, 105, 105, 1],
  "dimgrey": [105, 105, 105, 1],
  "dodgerblue": [30, 144, 255, 1],
  "firebrick": [178, 34, 34, 1],
  "floralwhite": [255, 250, 240, 1],
  "forestgreen": [34, 139, 34, 1],
  "fuchsia": [255, 0, 255, 1],
  "gainsboro": [220, 220, 220, 1],
  "ghostwhite": [248, 248, 255, 1],
  "gold": [255, 215, 0, 1],
  "goldenrod": [218, 165, 32, 1],
  "gray": [128, 128, 128, 1],
  "green": [0, 128, 0, 1],
  "greenyellow": [173, 255, 47, 1],
  "grey": [128, 128, 128, 1],
  "honeydew": [240, 255, 240, 1],
  "hotpink": [255, 105, 180, 1],
  "indianred": [205, 92, 92, 1],
  "indigo": [75, 0, 130, 1],
  "ivory": [255, 255, 240, 1],
  "khaki": [240, 230, 140, 1],
  "lavender": [230, 230, 250, 1],
  "lavenderblush": [255, 240, 245, 1],
  "lawngreen": [124, 252, 0, 1],
  "lemonchiffon": [255, 250, 205, 1],
  "lightblue": [173, 216, 230, 1],
  "lightcoral": [240, 128, 128, 1],
  "lightcyan": [224, 255, 255, 1],
  "lightgoldenrodyellow": [250, 250, 210, 1],
  "lightgray": [211, 211, 211, 1],
  "lightgreen": [144, 238, 144, 1],
  "lightgrey": [211, 211, 211, 1],
  "lightpink": [255, 182, 193, 1],
  "lightsalmon": [255, 160, 122, 1],
  "lightseagreen": [32, 178, 170, 1],
  "lightskyblue": [135, 206, 250, 1],
  "lightslategray": [119, 136, 153, 1],
  "lightslategrey": [119, 136, 153, 1],
  "lightsteelblue": [176, 196, 222, 1],
  "lightyellow": [255, 255, 224, 1],
  "lime": [0, 255, 0, 1],
  "limegreen": [50, 205, 50, 1],
  "linen": [250, 240, 230, 1],
  "magenta": [255, 0, 255, 1],
  "maroon": [128, 0, 0, 1],
  "mediumaquamarine": [102, 205, 170, 1],
  "mediumblue": [0, 0, 205, 1],
  "mediumorchid": [186, 85, 211, 1],
  "mediumpurple": [147, 112, 219, 1],
  "mediumseagreen": [60, 179, 113, 1],
  "mediumslateblue": [123, 104, 238, 1],
  "mediumspringgreen": [0, 250, 154, 1],
  "mediumturquoise": [72, 209, 204, 1],
  "mediumvioletred": [199, 21, 133, 1],
  "midnightblue": [25, 25, 112, 1],
  "mintcream": [245, 255, 250, 1],
  "mistyrose": [255, 228, 225, 1],
  "moccasin": [255, 228, 181, 1],
  "navajowhite": [255, 222, 173, 1],
  "navy": [0, 0, 128, 1],
  "oldlace": [253, 245, 230, 1],
  "olive": [128, 128, 0, 1],
  "olivedrab": [107, 142, 35, 1],
  "orange": [255, 165, 0, 1],
  "orangered": [255, 69, 0, 1],
  "orchid": [218, 112, 214, 1],
  "palegoldenrod": [238, 232, 170, 1],
  "palegreen": [152, 251, 152, 1],
  "paleturquoise": [175, 238, 238, 1],
  "palevioletred": [219, 112, 147, 1],
  "papayawhip": [255, 239, 213, 1],
  "peachpuff": [255, 218, 185, 1],
  "peru": [205, 133, 63, 1],
  "pink": [255, 192, 203, 1],
  "plum": [221, 160, 221, 1],
  "powderblue": [176, 224, 230, 1],
  "purple": [128, 0, 128, 1],
  "red": [255, 0, 0, 1],
  "rosybrown": [188, 143, 143, 1],
  "royalblue": [65, 105, 225, 1],
  "saddlebrown": [139, 69, 19, 1],
  "salmon": [250, 128, 114, 1],
  "sandybrown": [244, 164, 96, 1],
  "seagreen": [46, 139, 87, 1],
  "seashell": [255, 245, 238, 1],
  "sienna": [160, 82, 45, 1],
  "silver": [192, 192, 192, 1],
  "skyblue": [135, 206, 235, 1],
  "slateblue": [106, 90, 205, 1],
  "slategray": [112, 128, 144, 1],
  "slategrey": [112, 128, 144, 1],
  "snow": [255, 250, 250, 1],
  "springgreen": [0, 255, 127, 1],
  "steelblue": [70, 130, 180, 1],
  "tan": [210, 180, 140, 1],
  "teal": [0, 128, 128, 1],
  "thistle": [216, 191, 216, 1],
  "tomato": [255, 99, 71, 1],
  "turquoise": [64, 224, 208, 1],
  "violet": [238, 130, 238, 1],
  "wheat": [245, 222, 179, 1],
  "white": [255, 255, 255, 1],
  "whitesmoke": [245, 245, 245, 1],
  "yellow": [255, 255, 0, 1],
  "yellowgreen": [154, 205, 50, 1]
};
function clampCssByte(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f) {
  return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}
function setRgba(out2, r, g, b, a) {
  out2[0] = r;
  out2[1] = g;
  out2[2] = b;
  out2[3] = a;
  return out2;
}
function copyRgba(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
}
var colorCache = new LRU$1(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse2(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  var strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      var iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      var iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op = str.indexOf("(");
  var ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === strLen) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length >= 3) {
          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B2 = rgba[2] / 255;
  var vMin = Math.min(R, G, B2);
  var vMax = Math.max(R, G, B2);
  var delta2 = vMax - vMin;
  var L = (vMax + vMin) / 2;
  var H;
  var S;
  if (delta2 === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta2 / (vMax + vMin);
    } else {
      S = delta2 / (2 - vMax - vMin);
    }
    var deltaR = ((vMax - R) / 6 + delta2 / 2) / delta2;
    var deltaG = ((vMax - G) / 6 + delta2 / 2) / delta2;
    var deltaB = ((vMax - B2) / 6 + delta2 / 2) / delta2;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B2 === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  var hsla = [H * 360, S, L];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color, level) {
  var colorArr = parse2(color);
  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (colorArr[i] < 0) {
        colorArr[i] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function fastLerp(normalizedValue, colors2, out2) {
  if (!(colors2 && colors2.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  var value = normalizedValue * (colors2.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors2[leftIndex];
  var rightColor = colors2[rightIndex];
  var dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
}
function lerp(normalizedValue, colors2, fullOutput) {
  if (!(colors2 && colors2.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value = normalizedValue * (colors2.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse2(colors2[leftIndex]);
  var rightColor = parse2(colors2[rightIndex]);
  var dv = value - leftIndex;
  var color = stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color,
    leftIndex,
    rightIndex,
    value
  } : color;
}
function modifyHSL(color, h, s, l) {
  var colorArr = parse2(color);
  if (color) {
    colorArr = rgba2hsla(colorArr);
    h != null && (colorArr[0] = clampCssAngle(h));
    s != null && (colorArr[1] = parseCssFloat(s));
    l != null && (colorArr[2] = parseCssFloat(l));
    return stringify(hsla2rgba(colorArr), "rgba");
  }
}
function modifyAlpha(color, alpha) {
  var colorArr = parse2(color);
  if (colorArr && alpha != null) {
    colorArr[3] = clampCssFloat(alpha);
    return stringify(colorArr, "rgba");
  }
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
function lum(color, backgroundLum) {
  var arr = parse2(color);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
var mathRound$1 = Math.round;
function normalizeColor(color) {
  var opacity;
  if (!color || color === "transparent") {
    color = "none";
  } else if (typeof color === "string" && color.indexOf("rgba") > -1) {
    var arr = parse2(color);
    if (arr) {
      color = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
      opacity = arr[3];
    }
  }
  return {
    color,
    opacity: opacity == null ? 1 : opacity
  };
}
var EPSILON$3 = 1e-4;
function isAroundZero(transform4) {
  return transform4 < EPSILON$3 && transform4 > -EPSILON$3;
}
function round3(transform4) {
  return mathRound$1(transform4 * 1e3) / 1e3;
}
function round4(transform4) {
  return mathRound$1(transform4 * 1e4) / 1e4;
}
function getMatrixStr(m2) {
  return "matrix(" + round3(m2[0]) + "," + round3(m2[1]) + "," + round3(m2[2]) + "," + round3(m2[3]) + "," + round4(m2[4]) + "," + round4(m2[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY$1(y2, lineHeight, textBaseline) {
  if (textBaseline === "top") {
    y2 += lineHeight / 2;
  } else if (textBaseline === "bottom") {
    y2 -= lineHeight / 2;
  }
  return y2;
}
function hasShadow(style) {
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
  var style = displayable.style;
  var globalScale = displayable.getGlobalScale();
  return [
    style.shadowColor,
    (style.shadowBlur || 0).toFixed(2),
    (style.shadowOffsetX || 0).toFixed(2),
    (style.shadowOffsetY || 0).toFixed(2),
    globalScale[0],
    globalScale[1]
  ].join(",");
}
function isImagePattern(val) {
  return val && !!val.image;
}
function isSVGPattern(val) {
  return val && !!val.svgElement;
}
function isPattern(val) {
  return isImagePattern(val) || isSVGPattern(val);
}
function isLinearGradient(val) {
  return val.type === "linear";
}
function isRadialGradient(val) {
  return val.type === "radial";
}
function isGradient(val) {
  return val && (val.type === "linear" || val.type === "radial");
}
function getIdURL(id) {
  return "url(#" + id + ")";
}
function getPathPrecision(el) {
  var scale4 = el.getGlobalScale();
  var size11 = Math.max(scale4[0], scale4[1]);
  return Math.max(Math.ceil(Math.log(size11) / Math.log(10)), 1);
}
function getSRTTransformString(transform4) {
  var x2 = transform4.x || 0;
  var y2 = transform4.y || 0;
  var rotation = (transform4.rotation || 0) * RADIAN_TO_DEGREE;
  var scaleX = retrieve2(transform4.scaleX, 1);
  var scaleY = retrieve2(transform4.scaleY, 1);
  var skewX = transform4.skewX || 0;
  var skewY = transform4.skewY || 0;
  var res = [];
  if (x2 || y2) {
    res.push("translate(" + x2 + "px," + y2 + "px)");
  }
  if (rotation) {
    res.push("rotate(" + rotation + ")");
  }
  if (scaleX !== 1 || scaleY !== 1) {
    res.push("scale(" + scaleX + "," + scaleY + ")");
  }
  if (skewX || skewY) {
    res.push("skew(" + mathRound$1(skewX * RADIAN_TO_DEGREE) + "deg, " + mathRound$1(skewY * RADIAN_TO_DEGREE) + "deg)");
  }
  return res.join(" ");
}
var encodeBase64 = function() {
  if (env$1.hasGlobalWindow && isFunction(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(str));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    {
      logError("Base64 isn't natively supported in the current environment.");
    }
    return null;
  };
}();
var arraySlice = Array.prototype.slice;
function interpolateNumber$1(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out2, p0, p1, percent) {
  var len2 = p0.length;
  for (var i = 0; i < len2; i++) {
    out2[i] = interpolateNumber$1(p0[i], p1[i], percent);
  }
  return out2;
}
function interpolate2DArray(out2, p0, p1, percent) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (var j = 0; j < len22; j++) {
      out2[i][j] = interpolateNumber$1(p0[i][j], p1[i][j], percent);
    }
  }
  return out2;
}
function add1DArray(out2, p0, p1, sign2) {
  var len2 = p0.length;
  for (var i = 0; i < len2; i++) {
    out2[i] = p0[i] + p1[i] * sign2;
  }
  return out2;
}
function add2DArray(out2, p0, p1, sign2) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (var j = 0; j < len22; j++) {
      out2[i][j] = p0[i][j] + p1[i][j] * sign2;
    }
  }
  return out2;
}
function fillColorStops(val0, val1) {
  var len0 = val0.length;
  var len1 = val1.length;
  var shorterArr = len0 > len1 ? val1 : val0;
  var shorterLen = Math.min(len0, len1);
  var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
  for (var i = shorterLen; i < Math.max(len0, len1); i++) {
    shorterArr.push({
      offset: last.offset,
      color: last.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  var arr0 = val0;
  var arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    var isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  }
  var len2 = arr0[0] && arr0[0].length;
  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
function cloneValue(value) {
  if (isArrayLike(value)) {
    var len2 = value.length;
    if (isArrayLike(value[0])) {
      var ret = [];
      for (var i = 0; i < len2; i++) {
        ret.push(arraySlice.call(value[i]));
      }
      return ret;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
  return isArrayLike(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = function() {
  function Track2(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  Track2.prototype.isFinished = function() {
    return this._finished;
  };
  Track2.prototype.setFinished = function() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  };
  Track2.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  };
  Track2.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  };
  Track2.prototype.addKeyframe = function(time, rawValue, easing) {
    this._needsSort = true;
    var keyframes = this.keyframes;
    var len2 = keyframes.length;
    var discrete = false;
    var valType = VALUE_TYPE_UNKOWN;
    var value = rawValue;
    if (isArrayLike(rawValue)) {
      var arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          var colorArray = parse2(rawValue);
          if (colorArray) {
            value = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        var parsedGradient = extend2({}, value);
        parsedGradient.colorStops = map$1(rawValue.colorStops, function(colorStop) {
          return {
            offset: colorStop.offset,
            color: parse2(colorStop.color)
          };
        });
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    var kf = {
      time,
      value,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf.easing = easing;
      kf.easingFunc = isFunction(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf);
    return kf;
  };
  Track2.prototype.prepare = function(maxTime, additiveTrack) {
    var kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a, b) {
        return a.time - b.time;
      });
    }
    var valType = this.valType;
    var kfsLen = kfs.length;
    var lastKf = kfs[kfsLen - 1];
    var isDiscrete = this.discrete;
    var isArr = isArrayValueType(valType);
    var isGradient2 = isGradientValueType(valType);
    for (var i = 0; i < kfsLen; i++) {
      var kf = kfs[i];
      var value = kf.value;
      var lastValue = lastKf.value;
      kf.percent = kf.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i !== kfsLen - 1) {
          fillArray(value, lastValue, valType);
        } else if (isGradient2) {
          fillColorStops(value.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      var startValue = kfs[0].value;
      for (var i = 0; i < kfsLen; i++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i].additiveValue = kfs[i].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
        }
      }
    }
  };
  Track2.prototype.step = function(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    var isAdditive = this._additiveTrack != null;
    var valueKey = isAdditive ? "additiveValue" : "value";
    var valType = this.valType;
    var keyframes = this.keyframes;
    var kfsNum = keyframes.length;
    var propName = this.propName;
    var isValueColor = valType === VALUE_TYPE_COLOR;
    var frameIdx;
    var lastFrame = this._lastFr;
    var mathMin2 = Math.min;
    var frame;
    var nextFrame;
    if (kfsNum === 1) {
      frame = nextFrame = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        var start2 = mathMin2(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
      }
      nextFrame = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    var interval = nextFrame.percent - frame.percent;
    var w = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
    if (nextFrame.easingFunc) {
      w = nextFrame.easingFunc(w);
    }
    var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
    } else if (isGradientValueType(valType)) {
      var val = frame[valueKey];
      var nextVal_1 = nextFrame[valueKey];
      var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient_1 ? "linear" : "radial",
        x: interpolateNumber$1(val.x, nextVal_1.x, w),
        y: interpolateNumber$1(val.y, nextVal_1.y, w),
        colorStops: map$1(val.colorStops, function(colorStop, idx) {
          var nextColorStop = nextVal_1.colorStops[idx];
          return {
            offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
          };
        }),
        global: nextVal_1.global
      };
      if (isLinearGradient_1) {
        target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w);
        target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w);
      } else {
        target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      var value = interpolateNumber$1(frame[valueKey], nextFrame[valueKey], w);
      if (isAdditive) {
        this._additiveValue = value;
      } else {
        target[propName] = value;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  };
  Track2.prototype._addToTarget = function(target) {
    var valType = this.valType;
    var propName = this.propName;
    var additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse2(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  };
  return Track2;
}();
var Animator = function() {
  function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop;
    if (loop && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  Animator2.prototype.getMaxTime = function() {
    return this._maxTime;
  };
  Animator2.prototype.getDelay = function() {
    return this._delay;
  };
  Animator2.prototype.getLoop = function() {
    return this._loop;
  };
  Animator2.prototype.getTarget = function() {
    return this._target;
  };
  Animator2.prototype.changeTarget = function(target) {
    this._target = target;
  };
  Animator2.prototype.when = function(time, props, easing) {
    return this.whenWithKeys(time, props, keys2(props), easing);
  };
  Animator2.prototype.whenWithKeys = function(time, props, propNames, easing) {
    var tracks = this._tracks;
    for (var i = 0; i < propNames.length; i++) {
      var propName = propNames[i];
      var track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        var initialValue = void 0;
        var additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          var addtiveTrackKfs = additiveTrack.keyframes;
          var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time, cloneValue(props[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time);
    return this;
  };
  Animator2.prototype.pause = function() {
    this._clip.pause();
    this._paused = true;
  };
  Animator2.prototype.resume = function() {
    this._clip.resume();
    this._paused = false;
  };
  Animator2.prototype.isPaused = function() {
    return !!this._paused;
  };
  Animator2.prototype.duration = function(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  };
  Animator2.prototype._doneCallback = function() {
    this._setTracksFinished();
    this._clip = null;
    var doneList = this._doneCbs;
    if (doneList) {
      var len2 = doneList.length;
      for (var i = 0; i < len2; i++) {
        doneList[i].call(this);
      }
    }
  };
  Animator2.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var animation = this.animation;
    var abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (var i = 0; i < abortedList.length; i++) {
        abortedList[i].call(this);
      }
    }
  };
  Animator2.prototype._setTracksFinished = function() {
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i = 0; i < tracksKeys.length; i++) {
      tracks[tracksKeys[i]].setFinished();
    }
  };
  Animator2.prototype._getAdditiveTrack = function(trackName) {
    var additiveTrack;
    var additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (var i = 0; i < additiveAnimators.length; i++) {
        var track = additiveAnimators[i].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  };
  Animator2.prototype.start = function(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    var self2 = this;
    var tracks = [];
    var maxTime = this._maxTime || 0;
    for (var i = 0; i < this._trackKeys.length; i++) {
      var propName = this._trackKeys[i];
      var track = this._tracks[propName];
      var additiveTrack = this._getAdditiveTrack(propName);
      var kfs = track.keyframes;
      var kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          var lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      var clip2 = new Clip$1({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe: function(percent) {
          self2._started = 2;
          var additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            var stillHasAdditiveAnimator = false;
            for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
              if (additiveAnimators[i2]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (var i2 = 0; i2 < tracks.length; i2++) {
            tracks[i2].step(self2._target, percent);
          }
          var onframeList = self2._onframeCbs;
          if (onframeList) {
            for (var i2 = 0; i2 < onframeList.length; i2++) {
              onframeList[i2](self2._target, percent);
            }
          }
        },
        ondestroy: function() {
          self2._doneCallback();
        }
      });
      this._clip = clip2;
      if (this.animation) {
        this.animation.addClip(clip2);
      }
      if (easing) {
        clip2.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  };
  Animator2.prototype.stop = function(forwardToLast) {
    if (!this._clip) {
      return;
    }
    var clip2 = this._clip;
    if (forwardToLast) {
      clip2.onframe(1);
    }
    this._abortedCallback();
  };
  Animator2.prototype.delay = function(time) {
    this._delay = time;
    return this;
  };
  Animator2.prototype.during = function(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.done = function(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.aborted = function(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.getClip = function() {
    return this._clip;
  };
  Animator2.prototype.getTrack = function(propName) {
    return this._tracks[propName];
  };
  Animator2.prototype.getTracks = function() {
    var _this = this;
    return map$1(this._trackKeys, function(key) {
      return _this._tracks[key];
    });
  };
  Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i = 0; i < propNames.length; i++) {
      var track = tracks[propNames[i]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    var allAborted = true;
    for (var i = 0; i < tracksKeys.length; i++) {
      if (!tracks[tracksKeys[i]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  };
  Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (var i = 0; i < trackKeys.length; i++) {
      var propName = trackKeys[i];
      var track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      var kfs = track.keyframes;
      var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf) {
        target[propName] = cloneValue(kf.rawValue);
      }
    }
  };
  Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
    trackKeys = trackKeys || keys2(finalProps);
    for (var i = 0; i < trackKeys.length; i++) {
      var propName = trackKeys[i];
      var track = this._tracks[propName];
      if (!track) {
        continue;
      }
      var kfs = track.keyframes;
      if (kfs.length > 1) {
        var lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  };
  return Animator2;
}();
function getTime() {
  return new Date().getTime();
}
var Animation = function(_super) {
  __extends(Animation2, _super);
  function Animation2(opts) {
    var _this = _super.call(this) || this;
    _this._running = false;
    _this._time = 0;
    _this._pausedTime = 0;
    _this._pauseStart = 0;
    _this._paused = false;
    opts = opts || {};
    _this.stage = opts.stage || {};
    return _this;
  }
  Animation2.prototype.addClip = function(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  };
  Animation2.prototype.addAnimator = function(animator) {
    animator.animation = this;
    var clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  };
  Animation2.prototype.removeClip = function(clip2) {
    if (!clip2.animation) {
      return;
    }
    var prev = clip2.prev;
    var next3 = clip2.next;
    if (prev) {
      prev.next = next3;
    } else {
      this._head = next3;
    }
    if (next3) {
      next3.prev = prev;
    } else {
      this._tail = prev;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  };
  Animation2.prototype.removeAnimator = function(animator) {
    var clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  };
  Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
    var time = getTime() - this._pausedTime;
    var delta2 = time - this._time;
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      var finished = clip2.step(time, delta2);
      if (finished) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta2);
      this.stage.update && this.stage.update();
    }
  };
  Animation2.prototype._startLoop = function() {
    var self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame$1(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame$1(step);
  };
  Animation2.prototype.start = function() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  };
  Animation2.prototype.stop = function() {
    this._running = false;
  };
  Animation2.prototype.pause = function() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  };
  Animation2.prototype.resume = function() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  };
  Animation2.prototype.clear = function() {
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  };
  Animation2.prototype.isFinished = function() {
    return this._head == null;
  };
  Animation2.prototype.animate = function(target, options) {
    options = options || {};
    this.start();
    var animator = new Animator(target, options.loop);
    this.addAnimator(animator);
    return animator;
  };
  return Animation2;
}(Eventful$1);
var Animation$1 = Animation;
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env$1.domSupported;
var localNativeListenerNames = function() {
  var mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = map$1(mouseHandlerNames, function(name2) {
    var nm = name2.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name2;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance2, event) {
  return normalizeEvent(instance2.dom, new FakeGlobalEvent(instance2, event), true);
}
function isLocalEl(instance2, el) {
  var elTmp = el;
  var isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance2.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = function() {
  function FakeGlobalEvent2(instance2, event) {
    this.stopPropagation = noop;
    this.stopImmediatePropagation = noop;
    this.preventDefault = noop;
    this.type = event.type;
    this.target = this.currentTarget = instance2.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
  return FakeGlobalEvent2;
}();
var localDOMHandlers = {
  mousedown: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove: function(event) {
    event = normalizeEvent(this.dom, event);
    var downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout: function(event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel: function(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel: function(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date();
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown: function(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each$f(["click", "dblclick", "contextmenu"], function(name2) {
  localDOMHandlers[name2] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name2, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    var pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance2, scope) {
  var domHandlers = scope.domHandlers;
  if (env$1.pointerEventsSupported) {
    each$f(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance2, event);
      });
    });
  } else {
    if (env$1.touchEventsSupported) {
      each$f(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance2, event);
          setTouchTimer(scope);
        });
      });
    }
    each$f(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance2, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance2, scope) {
  if (env$1.pointerEventsSupported) {
    each$f(globalNativeListenerNames.pointer, mount);
  } else if (!env$1.touchEventsSupported) {
    each$f(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance2, event.target)) {
        event = normalizeGlobalEvent(instance2, event);
        scope.domHandlers[nativeEventName].call(instance2, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  var mounted = scope.mounted;
  for (var nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = function() {
  function DOMHandlerScope2(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
  return DOMHandlerScope2;
}();
var HandlerDomProxy = function(_super) {
  __extends(HandlerDomProxy2, _super);
  function HandlerDomProxy2(dom, painterRoot) {
    var _this = _super.call(this) || this;
    _this.__pointerCapturing = false;
    _this.dom = dom;
    _this.painterRoot = painterRoot;
    _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(_this, _this._localHandlerScope);
    return _this;
  }
  HandlerDomProxy2.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  };
  HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  };
  HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      var globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  };
  return HandlerDomProxy2;
}(Eventful$1);
var HandlerProxy = HandlerDomProxy;
var dpr = 1;
if (env$1.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";
var mIdentity = identity;
var EPSILON$2 = 5e-5;
function isNotAroundZero(val) {
  return val > EPSILON$2 || val < -EPSILON$2;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create$1();
var abs2 = Math.abs;
var Transformable = function() {
  function Transformable2() {
  }
  Transformable2.prototype.getLocalTransform = function(m2) {
    return Transformable2.getLocalTransform(this, m2);
  };
  Transformable2.prototype.setPosition = function(arr) {
    this.x = arr[0];
    this.y = arr[1];
  };
  Transformable2.prototype.setScale = function(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  };
  Transformable2.prototype.setSkew = function(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  };
  Transformable2.prototype.setOrigin = function(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  };
  Transformable2.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  };
  Transformable2.prototype.updateTransform = function() {
    var parentTransform = this.parent && this.parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m2 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      m2 && mIdentity(m2);
      return;
    }
    m2 = m2 || create$1();
    if (needLocalTransform) {
      this.getLocalTransform(m2);
    } else {
      mIdentity(m2);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul(m2, parentTransform, m2);
      } else {
        copy7(m2, parentTransform);
      }
    }
    this.transform = m2;
    this._resolveGlobalScaleRatio(m2);
  };
  Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
    var globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      var relX = scaleTmp[0] < 0 ? -1 : 1;
      var relY = scaleTmp[1] < 0 ? -1 : 1;
      var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m2[0] *= sx;
      m2[1] *= sx;
      m2[2] *= sy;
      m2[3] *= sy;
    }
    this.invTransform = this.invTransform || create$1();
    invert(this.invTransform, m2);
  };
  Transformable2.prototype.getComputedTransform = function() {
    var transformNode = this;
    var ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  };
  Transformable2.prototype.setLocalTransform = function(m2) {
    if (!m2) {
      return;
    }
    var sx = m2[0] * m2[0] + m2[1] * m2[1];
    var sy = m2[2] * m2[2] + m2[3] * m2[3];
    var rotation = Math.atan2(m2[1], m2[0]);
    var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m2[4];
    this.y = +m2[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  };
  Transformable2.prototype.decomposeTransform = function() {
    if (!this.transform) {
      return;
    }
    var parent = this.parent;
    var m2 = this.transform;
    if (parent && parent.transform) {
      mul(tmpTransform, parent.invTransform, m2);
      m2 = tmpTransform;
    }
    var ox = this.originX;
    var oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul(tmpTransform, m2, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m2 = tmpTransform;
    }
    this.setLocalTransform(m2);
  };
  Transformable2.prototype.getGlobalScale = function(out2) {
    var m2 = this.transform;
    out2 = out2 || [];
    if (!m2) {
      out2[0] = 1;
      out2[1] = 1;
      return out2;
    }
    out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
    out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
    if (m2[0] < 0) {
      out2[0] = -out2[0];
    }
    if (m2[3] < 0) {
      out2[1] = -out2[1];
    }
    return out2;
  };
  Transformable2.prototype.transformCoordToLocal = function(x2, y2) {
    var v22 = [x2, y2];
    var invTransform = this.invTransform;
    if (invTransform) {
      applyTransform$1(v22, v22, invTransform);
    }
    return v22;
  };
  Transformable2.prototype.transformCoordToGlobal = function(x2, y2) {
    var v22 = [x2, y2];
    var transform4 = this.transform;
    if (transform4) {
      applyTransform$1(v22, v22, transform4);
    }
    return v22;
  };
  Transformable2.prototype.getLineScale = function() {
    var m2 = this.transform;
    return m2 && abs2(m2[0] - 1) > 1e-10 && abs2(m2[3] - 1) > 1e-10 ? Math.sqrt(abs2(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  };
  Transformable2.prototype.copyTransform = function(source2) {
    copyTransform(this, source2);
  };
  Transformable2.getLocalTransform = function(target, m2) {
    m2 = m2 || [];
    var ox = target.originX || 0;
    var oy = target.originY || 0;
    var sx = target.scaleX;
    var sy = target.scaleY;
    var ax = target.anchorX;
    var ay = target.anchorY;
    var rotation = target.rotation || 0;
    var x2 = target.x;
    var y2 = target.y;
    var skewX = target.skewX ? Math.tan(target.skewX) : 0;
    var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      var dx = ox + ax;
      var dy = oy + ay;
      m2[4] = -dx * sx - skewX * dy * sy;
      m2[5] = -dy * sy - skewY * dx * sx;
    } else {
      m2[4] = m2[5] = 0;
    }
    m2[0] = sx;
    m2[3] = sy;
    m2[1] = skewY * sx;
    m2[2] = skewX * sy;
    rotation && rotate(m2, m2, rotation);
    m2[4] += ox + x2;
    m2[5] += oy + y2;
    return m2;
  };
  Transformable2.initDefaultProps = function() {
    var proto2 = Transformable2.prototype;
    proto2.scaleX = proto2.scaleY = proto2.globalScaleRatio = 1;
    proto2.x = proto2.y = proto2.originX = proto2.originY = proto2.skewX = proto2.skewY = proto2.rotation = proto2.anchorX = proto2.anchorY = 0;
  }();
  return Transformable2;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source2) {
  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    var propName = TRANSFORMABLE_PROPS[i];
    target[propName] = source2[propName];
  }
}
var Transformable$1 = Transformable;
var textWidthCache = {};
function getWidth2(text, font) {
  font = font || DEFAULT_FONT;
  var cacheOfFont = textWidthCache[font];
  if (!cacheOfFont) {
    cacheOfFont = textWidthCache[font] = new LRU$1(500);
  }
  var width = cacheOfFont.get(text);
  if (width == null) {
    width = platformApi.measureText(text, font).width;
    cacheOfFont.put(text, width);
  }
  return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
  var width = getWidth2(text, font);
  var height = getLineHeight(font);
  var x2 = adjustTextX(0, width, textAlign);
  var y2 = adjustTextY(0, height, textBaseline);
  var rect = new BoundingRect$1(x2, y2, width, height);
  return rect;
}
function getBoundingRect(text, font, textAlign, textBaseline) {
  var textLines = ((text || "") + "").split("\n");
  var len2 = textLines.length;
  if (len2 === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    var uniondRect = new BoundingRect$1(0, 0, 0, 0);
    for (var i = 0; i < textLines.length; i++) {
      var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
      i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x2, width, textAlign) {
  if (textAlign === "right") {
    x2 -= width;
  } else if (textAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
function adjustTextY(y2, height, verticalAlign) {
  if (verticalAlign === "middle") {
    y2 -= height / 2;
  } else if (verticalAlign === "bottom") {
    y2 -= height;
  }
  return y2;
}
function getLineHeight(font) {
  return getWidth2("\u56FD", font);
}
function parsePercent$1(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function calculateTextPosition(out2, opts, rect) {
  var textPosition = opts.position || "inside";
  var distance11 = opts.distance != null ? opts.distance : 5;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var x2 = rect.x;
  var y2 = rect.y;
  var textAlign = "left";
  var textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x2 += parsePercent$1(textPosition[0], rect.width);
    y2 += parsePercent$1(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x2 -= distance11;
        y2 += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x2 += distance11 + width;
        y2 += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x2 += width / 2;
        y2 -= distance11;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x2 += width / 2;
        y2 += height + distance11;
        textAlign = "center";
        break;
      case "inside":
        x2 += width / 2;
        y2 += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x2 += distance11;
        y2 += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x2 += width - distance11;
        y2 += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x2 += width / 2;
        y2 += distance11;
        textAlign = "center";
        break;
      case "insideBottom":
        x2 += width / 2;
        y2 += height - distance11;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x2 += distance11;
        y2 += distance11;
        break;
      case "insideTopRight":
        x2 += width - distance11;
        y2 += distance11;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x2 += distance11;
        y2 += height - distance11;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x2 += width - distance11;
        y2 += height - distance11;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out2 = out2 || {};
  out2.x = x2;
  out2.y = y2;
  out2.align = textAlign;
  out2.verticalAlign = textVerticalAlign;
  return out2;
}
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key) {
  obj[key] = true;
  return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0);
var Element = function() {
  function Element2(props) {
    this.id = guid();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props);
  }
  Element2.prototype._init = function(props) {
    this.attr(props);
  };
  Element2.prototype.drift = function(dx, dy, e2) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    var m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  };
  Element2.prototype.beforeUpdate = function() {
  };
  Element2.prototype.afterUpdate = function() {
  };
  Element2.prototype.update = function() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  };
  Element2.prototype.updateInnerText = function(forceUpdate) {
    var textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      var textConfig = this.textConfig;
      var isLocal = textConfig.local;
      var innerTransformable = textEl.innerTransformable;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      var innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      if (textConfig.position != null) {
        var layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        var textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          var relOriginX = void 0;
          var relOriginY = void 0;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent$1(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent$1(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      var textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      var isInside2 = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      var textFill = void 0;
      var textStroke = void 0;
      var autoStroke = void 0;
      if (isInside2 && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  };
  Element2.prototype.canBeInsideText = function() {
    return true;
  };
  Element2.prototype.getInsideTextFill = function() {
    return "#fff";
  };
  Element2.prototype.getInsideTextStroke = function(textFill) {
    return "#000";
  };
  Element2.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  };
  Element2.prototype.getOutsideStroke = function(textFill) {
    var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
    var colorArr = typeof backgroundColor2 === "string" && parse2(backgroundColor2);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    var alpha = colorArr[3];
    var isDark = this.__zr.isDarkMode();
    for (var i = 0; i < 3; i++) {
      colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  };
  Element2.prototype.traverse = function(cb, context) {
  };
  Element2.prototype.attrKV = function(key, value) {
    if (key === "textConfig") {
      this.setTextConfig(value);
    } else if (key === "textContent") {
      this.setTextContent(value);
    } else if (key === "clipPath") {
      this.setClipPath(value);
    } else if (key === "extra") {
      this.extra = this.extra || {};
      extend2(this.extra, value);
    } else {
      this[key] = value;
    }
  };
  Element2.prototype.hide = function() {
    this.ignore = true;
    this.markRedraw();
  };
  Element2.prototype.show = function() {
    this.ignore = false;
    this.markRedraw();
  };
  Element2.prototype.attr = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value);
    } else if (isObject$3(keyOrObj)) {
      var obj = keyOrObj;
      var keysArr = keys2(obj);
      for (var i = 0; i < keysArr.length; i++) {
        var key = keysArr[i];
        this.attrKV(key, keyOrObj[key]);
      }
    }
    this.markRedraw();
    return this;
  };
  Element2.prototype.saveCurrentToNormalState = function(toState) {
    this._innerSaveToNormal(toState);
    var normalState = this._normalState;
    for (var i = 0; i < this.animators.length; i++) {
      var animator = this.animators[i];
      var fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      var targetName = animator.targetName;
      var target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  };
  Element2.prototype._innerSaveToNormal = function(toState) {
    var normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
  };
  Element2.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
    for (var i = 0; i < primaryKeys.length; i++) {
      var key = primaryKeys[i];
      if (toState[key] != null && !(key in normalState)) {
        normalState[key] = this[key];
      }
    }
  };
  Element2.prototype.hasState = function() {
    return this.currentStates.length > 0;
  };
  Element2.prototype.getState = function(name2) {
    return this.states[name2];
  };
  Element2.prototype.ensureState = function(name2) {
    var states = this.states;
    if (!states[name2]) {
      states[name2] = {};
    }
    return states[name2];
  };
  Element2.prototype.clearStates = function(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  };
  Element2.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    var toNormalState = stateName === PRESERVED_NORMAL_STATE;
    var hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    var currentStates = this.currentStates;
    var animationCfg = this.stateTransition;
    if (indexOf2(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    var state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError("State " + stateName + " not exists.");
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  };
  Element2.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      var stateObjects = [];
      var currentStates = this.currentStates;
      var len2 = states.length;
      var notChange = len2 === currentStates.length;
      if (notChange) {
        for (var i = 0; i < len2; i++) {
          if (states[i] !== currentStates[i]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (var i = 0; i < len2; i++) {
        var stateName = states[i];
        var stateObj = void 0;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      var lastStateObj = stateObjects[len2 - 1];
      var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      var mergedState = this._mergeStates(stateObjects);
      var animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  };
  Element2.prototype._updateAnimationTargets = function() {
    for (var i = 0; i < this.animators.length; i++) {
      var animator = this.animators[i];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  };
  Element2.prototype.removeState = function(state) {
    var idx = indexOf2(this.currentStates, state);
    if (idx >= 0) {
      var currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  };
  Element2.prototype.replaceState = function(oldState, newState, forceAdd) {
    var currentStates = this.currentStates.slice();
    var idx = indexOf2(currentStates, oldState);
    var newStateExists = indexOf2(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  };
  Element2.prototype.toggleState = function(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  };
  Element2.prototype._mergeStates = function(states) {
    var mergedState = {};
    var mergedTextConfig;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      extend2(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend2(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  };
  Element2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    var needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend2({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend2(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    var transitionTarget = {};
    var hasTransition = false;
    for (var i = 0; i < PRIMARY_STATES_KEYS$1.length; i++) {
      var key = PRIMARY_STATES_KEYS$1[i];
      var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
      if (state && state[key] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key] = state[key];
        } else {
          this[key] = state[key];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = normalState[key];
          } else {
            this[key] = normalState[key];
          }
        }
      }
    }
    if (!transition) {
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        var targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  };
  Element2.prototype._attachComponent = function(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      {
        throw new Error("Text element has been added to zrender.");
      }
    }
    if (componentEl === this) {
      {
        throw new Error("Recursive component attachment.");
      }
    }
    var zr = this.__zr;
    if (zr) {
      componentEl.addSelfToZr(zr);
    }
    componentEl.__zr = zr;
    componentEl.__hostTarget = this;
  };
  Element2.prototype._detachComponent = function(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  };
  Element2.prototype.getClipPath = function() {
    return this._clipPath;
  };
  Element2.prototype.setClipPath = function(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  };
  Element2.prototype.removeClipPath = function() {
    var clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextContent = function() {
    return this._textContent;
  };
  Element2.prototype.setTextContent = function(textEl) {
    var previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    {
      if (textEl.__zr && !textEl.__hostTarget) {
        throw new Error("Text element has been added to zrender.");
      }
    }
    textEl.innerTransformable = new Transformable$1();
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  };
  Element2.prototype.setTextConfig = function(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend2(this.textConfig, cfg);
    this.markRedraw();
  };
  Element2.prototype.removeTextConfig = function() {
    this.textConfig = null;
    this.markRedraw();
  };
  Element2.prototype.removeTextContent = function() {
    var textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextGuideLine = function() {
    return this._textGuide;
  };
  Element2.prototype.setTextGuideLine = function(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  };
  Element2.prototype.removeTextGuideLine = function() {
    var textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  };
  Element2.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var zr = this.__zr;
    if (zr) {
      if (this.__inHover) {
        zr.refreshHover();
      } else {
        zr.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  };
  Element2.prototype.dirty = function() {
    this.markRedraw();
  };
  Element2.prototype._toggleHoverLayerFlag = function(inHover) {
    this.__inHover = inHover;
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  };
  Element2.prototype.addSelfToZr = function(zr) {
    if (this.__zr === zr) {
      return;
    }
    this.__zr = zr;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr);
    }
  };
  Element2.prototype.removeSelfFromZr = function(zr) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr);
    }
  };
  Element2.prototype.animate = function(key, loop, allowDiscreteAnimation) {
    var target = key ? this[key] : this;
    {
      if (!target) {
        logError('Property "' + key + '" is not existed in element ' + this.id);
        return;
      }
    }
    var animator = new Animator(target, loop, allowDiscreteAnimation);
    key && (animator.targetName = key);
    this.addAnimator(animator, key);
    return animator;
  };
  Element2.prototype.addAnimator = function(animator, key) {
    var zr = this.__zr;
    var el = this;
    animator.during(function() {
      el.updateDuringAnimation(key);
    }).done(function() {
      var animators = el.animators;
      var idx = indexOf2(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    zr && zr.wakeUp();
  };
  Element2.prototype.updateDuringAnimation = function(key) {
    this.markRedraw();
  };
  Element2.prototype.stopAnimation = function(scope, forwardToLast) {
    var animators = this.animators;
    var len2 = animators.length;
    var leftAnimators = [];
    for (var i = 0; i < len2; i++) {
      var animator = animators[i];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  };
  Element2.prototype.animateTo = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  };
  Element2.prototype.animateFrom = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  };
  Element2.prototype._transitionState = function(stateName, target, cfg, animationProps) {
    var animators = animateTo(this, target, cfg, animationProps);
    for (var i = 0; i < animators.length; i++) {
      animators[i].__fromStateTransition = stateName;
    }
  };
  Element2.prototype.getBoundingRect = function() {
    return null;
  };
  Element2.prototype.getPaintRect = function() {
    return null;
  };
  Element2.initDefaultProps = function() {
    var elProto = Element2.prototype;
    elProto.type = "element";
    elProto.name = "";
    elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
    elProto.__dirty = REDRAW_BIT;
    var logs = {};
    function logDeprecatedError(key, xKey, yKey) {
      if (!logs[key + xKey + yKey]) {
        console.warn("DEPRECATED: '" + key + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
        logs[key + xKey + yKey] = true;
      }
    }
    function createLegacyProperty(key, privateKey, xKey, yKey) {
      Object.defineProperty(elProto, key, {
        get: function() {
          {
            logDeprecatedError(key, xKey, yKey);
          }
          if (!this[privateKey]) {
            var pos = this[privateKey] = [];
            enhanceArray(this, pos);
          }
          return this[privateKey];
        },
        set: function(pos) {
          {
            logDeprecatedError(key, xKey, yKey);
          }
          this[xKey] = pos[0];
          this[yKey] = pos[1];
          this[privateKey] = pos;
          enhanceArray(this, pos);
        }
      });
      function enhanceArray(self2, pos) {
        Object.defineProperty(pos, 0, {
          get: function() {
            return self2[xKey];
          },
          set: function(val) {
            self2[xKey] = val;
          }
        });
        Object.defineProperty(pos, 1, {
          get: function() {
            return self2[yKey];
          },
          set: function(val) {
            self2[yKey] = val;
          }
        });
      }
    }
    if (Object.defineProperty) {
      createLegacyProperty("position", "_legacyPos", "x", "y");
      createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
      createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
    }
  }();
  return Element2;
}();
mixin(Element, Eventful$1);
mixin(Element, Transformable$1);
function animateTo(animatable, target, cfg, animationProps, reverse5) {
  cfg = cfg || {};
  var animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse5);
  var finishCount = animators.length;
  var doneHappened = false;
  var cfgDone = cfg.done;
  var cfgAborted = cfg.aborted;
  var doneCb = function() {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  var abortedCb = function() {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during(function(target2, percent) {
      cfg.during(percent);
    });
  }
  for (var i = 0; i < animators.length; i++) {
    var animator = animators[i];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source2, target, len2) {
  for (var i = 0; i < len2; i++) {
    source2[i] = target[i];
  }
}
function is2DArray(value) {
  return isArrayLike(value[0]);
}
function copyValue(target, source2, key) {
  if (isArrayLike(source2[key])) {
    if (!isArrayLike(target[key])) {
      target[key] = [];
    }
    if (isTypedArray(source2[key])) {
      var len2 = source2[key].length;
      if (target[key].length !== len2) {
        target[key] = new source2[key].constructor(len2);
        copyArrShallow(target[key], source2[key], len2);
      }
    } else {
      var sourceArr = source2[key];
      var targetArr = target[key];
      var len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        var len1 = sourceArr[0].length;
        for (var i = 0; i < len0; i++) {
          if (!targetArr[i]) {
            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
          } else {
            copyArrShallow(targetArr[i], sourceArr[i], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key] = source2[key];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  var len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (var i = 0; i < len2; i++) {
    if (arr0[i] !== arr1[i]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse5) {
  var targetKeys = keys2(target);
  var duration = cfg.duration;
  var delay = cfg.delay;
  var additive = cfg.additive;
  var setToFinal = cfg.setToFinal;
  var animateAll = !isObject$3(animationProps);
  var existsAnimators = animatable.animators;
  var animationKeys = [];
  for (var k = 0; k < targetKeys.length; k++) {
    var innerKey = targetKeys[k];
    var targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject$3(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse5) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse5);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse5) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  var keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (var i = 0; i < existsAnimators.length; i++) {
      var animator = existsAnimators[i];
      if (animator.targetName === topKey) {
        var allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          var idx = indexOf2(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter17(animationKeys, function(key) {
      return !isValueSame(target[key], animateObj[key]);
    });
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    var revertedSource = void 0;
    var reversedTarget = void 0;
    var sourceClone = void 0;
    if (reverse5) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (var i = 0; i < keyLen; i++) {
        var innerKey = animationKeys[i];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (var i = 0; i < keyLen; i++) {
        var innerKey = animationKeys[i];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue(animateObj, target, innerKey);
      }
    }
    var animator = new Animator(animateObj, false, false, additive ? filter17(existsAnimators, function(animator2) {
      return animator2.targetName === topKey;
    }) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse5 ? reversedTarget : target, animationKeys).delay(delay || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element$1 = Element;
var Group$3 = function(_super) {
  __extends(Group2, _super);
  function Group2(opts) {
    var _this = _super.call(this) || this;
    _this.isGroup = true;
    _this._children = [];
    _this.attr(opts);
    return _this;
  }
  Group2.prototype.childrenRef = function() {
    return this._children;
  };
  Group2.prototype.children = function() {
    return this._children.slice();
  };
  Group2.prototype.childAt = function(idx) {
    return this._children[idx];
  };
  Group2.prototype.childOfName = function(name2) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name2) {
        return children[i];
      }
    }
  };
  Group2.prototype.childCount = function() {
    return this._children.length;
  };
  Group2.prototype.add = function(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
      {
        if (child.__hostTarget) {
          throw "This elemenet has been used as an attachment";
        }
      }
    }
    return this;
  };
  Group2.prototype.addBefore = function(child, nextSibling2) {
    if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling2);
      if (idx >= 0) {
        children.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.replace = function(oldChild, newChild) {
    var idx = indexOf2(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  };
  Group2.prototype.replaceAt = function(child, index2) {
    var children = this._children;
    var old = children[index2];
    if (child && child !== this && child.parent !== this && child !== old) {
      children[index2] = child;
      old.parent = null;
      var zr = this.__zr;
      if (zr) {
        old.removeSelfFromZr(zr);
      }
      this._doAdd(child);
    }
    return this;
  };
  Group2.prototype._doAdd = function(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    var zr = this.__zr;
    if (zr && zr !== child.__zr) {
      child.addSelfToZr(zr);
    }
    zr && zr.refresh();
  };
  Group2.prototype.remove = function(child) {
    var zr = this.__zr;
    var children = this._children;
    var idx = indexOf2(children, child);
    if (idx < 0) {
      return this;
    }
    children.splice(idx, 1);
    child.parent = null;
    if (zr) {
      child.removeSelfFromZr(zr);
    }
    zr && zr.refresh();
    return this;
  };
  Group2.prototype.removeAll = function() {
    var children = this._children;
    var zr = this.__zr;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      child.parent = null;
    }
    children.length = 0;
    return this;
  };
  Group2.prototype.eachChild = function(cb, context) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }
    return this;
  };
  Group2.prototype.traverse = function(cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      var stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  };
  Group2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.addSelfToZr(zr);
    }
  };
  Group2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.removeSelfFromZr(zr);
    }
  };
  Group2.prototype.getBoundingRect = function(includeChildren) {
    var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];
    var rect = null;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.ignore || child.invisible) {
        continue;
      }
      var childRect = child.getBoundingRect();
      var transform4 = child.getLocalTransform(tmpMat);
      if (transform4) {
        BoundingRect$1.applyTransform(tmpRect2, childRect, transform4);
        rect = rect || tmpRect2.clone();
        rect.union(tmpRect2);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect2;
  };
  return Group2;
}(Element$1);
Group$3.prototype.type = "group";
var Group$4 = Group$3;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances$1 = {};
function delInstance(id) {
  delete instances$1[id];
}
function isDarkMode(backgroundColor2) {
  if (!backgroundColor2) {
    return false;
  }
  if (typeof backgroundColor2 === "string") {
    return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor2.colorStops) {
    var colorStops = backgroundColor2.colorStops;
    var totalLum = 0;
    var len2 = colorStops.length;
    for (var i = 0; i < len2; i++) {
      totalLum += lum(colorStops[i].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = function() {
  function ZRender2(id, dom, opts) {
    var _this = this;
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    var storage2 = new Storage$1();
    var rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys2(painterCtors)[0];
    }
    {
      if (!painterCtors[rendererType]) {
        throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
      }
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    var painter = new painterCtors[rendererType](dom, storage2, opts, id);
    var ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage2;
    this.painter = painter;
    var handerProxy = !env$1.node && !env$1.worker && !ssrMode ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
    var useCoarsePointer = opts.useCoarsePointer;
    var usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env$1.touchEventsSupported : !!useCoarsePointer;
    var defaultPointerSize = 44;
    var pointerSize;
    if (usePointerSize) {
      pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
    }
    this.handler = new Handler$1(storage2, painter, handerProxy, painter.root, pointerSize);
    this.animation = new Animation$1({
      stage: {
        update: ssrMode ? null : function() {
          return _this._flush(true);
        }
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  ZRender2.prototype.add = function(el) {
    if (!el) {
      return;
    }
    this.storage.addRoot(el);
    el.addSelfToZr(this);
    this.refresh();
  };
  ZRender2.prototype.remove = function(el) {
    if (!el) {
      return;
    }
    this.storage.delRoot(el);
    el.removeSelfFromZr(this);
    this.refresh();
  };
  ZRender2.prototype.configLayer = function(zLevel, config) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }
    this.refresh();
  };
  ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor2);
    }
    this.refresh();
    this._backgroundColor = backgroundColor2;
    this._darkMode = isDarkMode(backgroundColor2);
  };
  ZRender2.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  };
  ZRender2.prototype.setDarkMode = function(darkMode) {
    this._darkMode = darkMode;
  };
  ZRender2.prototype.isDarkMode = function() {
    return this._darkMode;
  };
  ZRender2.prototype.refreshImmediately = function(fromInside) {
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  };
  ZRender2.prototype.refresh = function() {
    this._needsRefresh = true;
    this.animation.start();
  };
  ZRender2.prototype.flush = function() {
    this._flush(false);
  };
  ZRender2.prototype._flush = function(fromInside) {
    var triggerRendered;
    var start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    var end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  };
  ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  };
  ZRender2.prototype.wakeUp = function() {
    this.animation.start();
    this._stillFrameAccum = 0;
  };
  ZRender2.prototype.refreshHover = function() {
    this._needsRefreshHover = true;
  };
  ZRender2.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  };
  ZRender2.prototype.resize = function(opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  };
  ZRender2.prototype.clearAnimation = function() {
    this.animation.clear();
  };
  ZRender2.prototype.getWidth = function() {
    return this.painter.getWidth();
  };
  ZRender2.prototype.getHeight = function() {
    return this.painter.getHeight();
  };
  ZRender2.prototype.setCursorStyle = function(cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  };
  ZRender2.prototype.findHover = function(x2, y2) {
    return this.handler.findHover(x2, y2);
  };
  ZRender2.prototype.on = function(eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
    return this;
  };
  ZRender2.prototype.off = function(eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  };
  ZRender2.prototype.trigger = function(eventName, event) {
    this.handler.trigger(eventName, event);
  };
  ZRender2.prototype.clear = function() {
    var roots2 = this.storage.getRoots();
    for (var i = 0; i < roots2.length; i++) {
      if (roots2[i] instanceof Group$4) {
        roots2[i].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  };
  ZRender2.prototype.dispose = function() {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  };
  return ZRender2;
}();
function init$1(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances$1[zr.id] = zr;
  return zr;
}
function registerPainter(name2, Ctor) {
  painterCtors[name2] = Ctor;
}
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function linearMap$2(val, domain, range, clamp3) {
  var d0 = domain[0];
  var d1 = domain[1];
  var r0 = range[0];
  var r1 = range[1];
  var subDomain = d1 - d0;
  var subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp3) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }
    if (val === d1) {
      return r1;
    }
  }
  return (val - d0) / subDomain * subRange + r0;
}
function parsePercent(percent, all2) {
  switch (percent) {
    case "center":
    case "middle":
      percent = "50%";
      break;
    case "left":
    case "top":
      percent = "0%";
      break;
    case "right":
    case "bottom":
      percent = "100%";
      break;
  }
  if (isString(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all2;
    }
    return parseFloat(percent);
  }
  return percent == null ? NaN : +percent;
}
function round$3(x2, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x2 = (+x2).toFixed(precision);
  return returnStr ? x2 : +x2;
}
function asc$2(arr) {
  arr.sort(function(a, b) {
    return a - b;
  });
  return arr;
}
function getPrecision(val) {
  val = +val;
  if (isNaN(val)) {
    return 0;
  }
  if (val > 1e-14) {
    var e2 = 1;
    for (var i = 0; i < 15; i++, e2 *= 10) {
      if (Math.round(val * e2) / e2 === val) {
        return i;
      }
    }
  }
  return getPrecisionSafe(val);
}
function getPrecisionSafe(val) {
  var str = val.toString().toLowerCase();
  var eIndex = str.indexOf("e");
  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  var significandPartLen = eIndex > 0 ? eIndex : str.length;
  var dotIndex = str.indexOf(".");
  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  var log2 = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log2(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log2(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentSeats(valueList, precision) {
  var sum2 = reduce(valueList, function(acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);
  if (sum2 === 0) {
    return [];
  }
  var digits = Math.pow(10, precision);
  var votesPerQuota = map$1(valueList, function(val) {
    return (isNaN(val) ? 0 : val) / sum2 * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = map$1(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  var currentSum = reduce(seats, function(acc, val) {
    return acc + val;
  }, 0);
  var remainder = map$1(votesPerQuota, function(votes, idx) {
    return votes - seats[idx];
  });
  while (currentSum < targetSeats) {
    var max4 = Number.NEGATIVE_INFINITY;
    var maxId = null;
    for (var i = 0, len2 = remainder.length; i < len2; ++i) {
      if (remainder[i] > max4) {
        max4 = remainder[i];
        maxId = i;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return map$1(seats, function(seat) {
    return seat / digits;
  });
}
function addSafe(val0, val1) {
  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  var sum2 = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum2 : round$3(sum2, maxPrecision);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString(value)) {
    var match = TIME_REG.exec(value);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      var hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value));
}
function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }
  var exp = Math.floor(Math.log(val) / Math.LN10);
  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val, round2) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10;
  var nf;
  if (round2) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  val = nf * exp10;
  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
function quantile(ascArr, p) {
  var H = (ascArr.length - 1) * p + 1;
  var h = Math.floor(H);
  var v = +ascArr[h - 1];
  var e2 = H - h;
  return e2 ? v + e2 * (ascArr[h] - v) : v;
}
function reformIntervals(list) {
  list.sort(function(a, b) {
    return littleThan2(a, b, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;
  for (var i = 0; i < list.length; ) {
    var interval = list[i].interval;
    var close_1 = list[i].close;
    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close_1[lg] = !lg ? 1 - currClose : 1;
      }
      curr = interval[lg];
      currClose = close_1[lg];
    }
    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }
  return list;
  function littleThan2(a, b, lg2) {
    return a.interval[lg2] < b.interval[lg2] || a.interval[lg2] === b.interval[lg2] && (a.close[lg2] - b.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan2(a, b, 1));
  }
}
function numericToNumber(val) {
  var valFloat = parseFloat(val);
  return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a, b) {
  if (b === 0) {
    return a;
  }
  return getGreatestCommonDividor(b, a % b);
}
function getLeastCommonMultiple(a, b) {
  if (a == null) {
    return b;
  }
  if (b == null) {
    return a;
  }
  return a * b / getGreatestCommonDividor(a, b);
}
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
  if (hasConsole) {
    if (onlyOnce) {
      if (storedLogs[str]) {
        return;
      }
      storedLogs[str] = true;
    }
    console[type](ECHARTS_PREFIX + str);
  }
}
function log(str, onlyOnce) {
  outputLog("log", str, onlyOnce);
}
function warn(str, onlyOnce) {
  outputLog("warn", str, onlyOnce);
}
function error(str, onlyOnce) {
  outputLog("error", str, onlyOnce);
}
function deprecateLog(str) {
  {
    outputLog("warn", "DEPRECATED: " + str, true);
  }
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
  {
    deprecateLog((scope ? "[" + scope + "]" : "") + (oldOpt + " is deprecated, use " + newOpt + " instead."));
  }
}
function makePrintable() {
  var hintInfo = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    hintInfo[_i] = arguments[_i];
  }
  var msg = "";
  {
    var makePrintableStringIfPossible_1 = function(val) {
      return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
    };
    msg = map$1(hintInfo, function(arg) {
      if (isString(arg)) {
        return arg;
      } else {
        var printableStr = makePrintableStringIfPossible_1(arg);
        if (printableStr != null) {
          return printableStr;
        } else if (typeof JSON !== "undefined" && JSON.stringify) {
          try {
            return JSON.stringify(arg, function(n, val) {
              var printableStr2 = makePrintableStringIfPossible_1(val);
              return printableStr2 == null ? val : printableStr2;
            });
          } catch (err) {
            return "?";
          }
        } else {
          return "?";
        }
      }
    }).join(" ");
  }
  return msg;
}
function throwError(msg) {
  throw new Error(msg);
}
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (var i = 0, len2 = subOpts.length; i < len2; i++) {
      var subOptName = subOpts[i];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(dataItem) {
  return isObject$3(dataItem) && !isArray$1(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject$3(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  var isNormalMergeMode = mode === "normalMerge";
  var isReplaceMergeMode = mode === "replaceMerge";
  var isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  var existingIdIdxMap = createHashMap();
  each$f(newCmptOptions, function(cmptOption, index2) {
    if (!isObject$3(cmptOption)) {
      newCmptOptions[index2] = null;
      return;
    }
    {
      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
        warnInvalidateIdOrName(cmptOption.id);
      }
      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
        warnInvalidateIdOrName(cmptOption.name);
      }
    }
  });
  var result = prepareResult2(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult2(existings, existingIdIdxMap, mode) {
  var result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (var index2 = 0; index2 < existings.length; index2++) {
    var existing = existings[index2];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index2);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each$f(newCmptOptions, function(cmptOption, index2) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    var optionId = makeComparableKey(cmptOption.id);
    var existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      var resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index2] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each$f(newCmptOptions, function(cmptOption, index2) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (var i = 0; i < result.length; i++) {
      var existing = result[i].existing;
      if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i].newOption = cmptOption;
        newCmptOptions[index2] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each$f(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    var resultItem;
    var nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each$f(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  var idMap = createHashMap();
  each$f(mapResult, function(item) {
    var existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each$f(mapResult, function(item) {
    var opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each$f(mapResult, function(item, index2) {
    var existing = item.existing;
    var opt = item.newOption;
    var keyInfo = item.keyInfo;
    if (!isObject$3(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index2;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      var idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr, obj1, obj2) {
  var key1 = convertOptionIdName(obj1[attr], null);
  var key2 = convertOptionIdName(obj2[attr], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val) {
  {
    if (val == null) {
      throw new Error();
    }
  }
  return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function warnInvalidateIdOrName(idOrName) {
  {
    warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
  }
}
function isValidIdOrName(idOrName) {
  return isStringSafe(idOrName) || isNumeric(idOrName);
}
function isNameSpecified(componentModel) {
  var name2 = componentModel.name;
  return !!(name2 && name2.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each$f(mappingResult, function(item) {
    var newOption = item.newOption;
    if (isObject$3(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];
  function makeMap(sourceBatch, map5, otherMap) {
    for (var i = 0, len2 = sourceBatch.length; i < len2; i++) {
      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
      if (seriesId == null) {
        return;
      }
      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];
      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];
        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map5[seriesId] || (map5[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }
  function mapToArray(map5, isData) {
    var result = [];
    for (var i in map5) {
      if (map5.hasOwnProperty(i) && map5[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map5[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }
    return result;
  }
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray$1(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray$1(payload.name) ? map$1(payload.name, function(value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner() {
  var key = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder$1(ecModel, finderInput, opt) {
  var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
  var result = others;
  var defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  var finder;
  if (isString(finderInput)) {
    var obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  var queryOptionMap = createHashMap();
  var others = {};
  var mainTypeSpecified = false;
  each$f(finder, function(value, key) {
    if (key === "dataIndex" || key === "dataIndexInside") {
      others[key] = value;
      return;
    }
    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf2(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {
    mainTypeSpecified,
    queryOptionMap,
    others
  };
}
var SINGLE_REFERRING = {
  useDefault: true,
  enableAll: false,
  enableNone: false
};
var MULTIPLE_REFERRING = {
  useDefault: false,
  enableAll: true,
  enableNone: true
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  var indexOption = userOption.index;
  var idOption = userOption.id;
  var nameOption = userOption.name;
  var result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    var firstCmpt = void 0;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  }
  if (indexOption === "all") {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env$1.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function groupData(array, getKey2) {
  var buckets = createHashMap();
  var keys3 = [];
  each$f(array, function(item) {
    var key = getKey2(item);
    (buckets.get(key) || (keys3.push(key), buckets.set(key, []))).push(item);
  });
  return {
    keys: keys3,
    buckets
  };
}
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  var isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber(targetValue)) {
    var value = interpolateNumber(sourceValue || 0, targetValue, percent);
    return round$3(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    var interpolated = [];
    var leftArr = sourceValue;
    var rightArr = targetValue;
    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (var i = 0; i < length_1; ++i) {
      var info = data.getDimensionInfo(i);
      if (info && info.type === "ordinal") {
        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
      } else {
        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
        var rightVal = rightArr[i];
        var value = interpolateNumber(leftVal, rightVal, percent);
        interpolated[i] = round$3(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  var ret = {
    main: "",
    sub: ""
  };
  if (componentType) {
    var typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || "";
    ret.sub = typeArr[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto2) {
    {
      each$f(mandatoryMethods, function(method) {
        if (!proto2[method]) {
          console.warn("Method `" + method + "` should be implemented" + (proto2.type ? " in " + proto2.type : "") + ".");
        }
      });
    }
    var superClass = this;
    var ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = function(_super) {
        __extends$1(class_1, _super);
        function class_1() {
          return _super.apply(this, arguments) || this;
        }
        return class_1;
      }(superClass);
    } else {
      ExtendedClass = function() {
        (proto2.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend2(ExtendedClass.prototype, proto2);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn) {
  return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  var classAttr = ["__\0is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  {
    assert(!target.isInstance, 'The method "is" can not be defined.');
  }
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  var storage2 = {};
  target.registerClass = function(clz) {
    var componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      var componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        {
          if (storage2[componentTypeInfo.main]) {
            console.warn(componentTypeInfo.main + " exists.");
          }
        }
        storage2[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        var container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    var clz = storage2[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var result = [];
    var obj = storage2[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each$f(obj, function(o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    return !!storage2[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    var types = [];
    each$f(storage2, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var obj = storage2[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    var container = storage2[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage2[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}
function makeStyleMapper(properties, ignoreParent) {
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes) {
    var style = {};
    for (var i2 = 0; i2 < properties.length; i2++) {
      var propName = properties[i2][1];
      if (excludes && indexOf2(excludes, propName) >= 0 || includes && indexOf2(includes, propName) < 0) {
        continue;
      }
      var val = model.getShallow(propName, ignoreParent);
      if (val != null) {
        style[properties[i2][0]] = val;
      }
    }
    return style;
  };
}
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
  function AreaStyleMixin2() {
  }
  AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  };
  return AreaStyleMixin2;
}();
var globalImageCache = new LRU$1(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = { hostEl, cb: onload, cbPayload };
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return "";
  }
  var textLines = (text + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  for (var i = 0, len2 = textLines.length; i < len2; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }
  return textLines.join("\n");
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  var preparedOpts = extend2({}, options);
  preparedOpts.font = font;
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  preparedOpts.cnCharWidth = getWidth2("\u56FD", font);
  var ascCharWidth = preparedOpts.ascCharWidth = getWidth2("a", font);
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }
  var ellipsisWidth = getWidth2(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;
  if (!containerWidth) {
    return "";
  }
  var lineWidth = getWidth2(textLine, font);
  if (lineWidth <= containerWidth) {
    return textLine;
  }
  for (var j = 0; ; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth2(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  return textLine;
}
function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;
  for (var len2 = text.length; i < len2 && width < contentWidth; i++) {
    var charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i;
}
function parsePlainText(text, style) {
  text != null && (text += "");
  var overflow = style.overflow;
  var padding = style.padding;
  var font = style.font;
  var truncate2 = overflow === "truncate";
  var calculatedLineHeight = getLineHeight(font);
  var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  var bgColorDrawn = !!style.backgroundColor;
  var truncateLineOverflow = style.lineOverflow === "truncate";
  var width = style.width;
  var lines;
  if (width != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text ? text.split("\n") : [];
  }
  var contentHeight = lines.length * lineHeight;
  var height = retrieve2(style.height, contentHeight);
  if (contentHeight > height && truncateLineOverflow) {
    var lineCount = Math.floor(height / lineHeight);
    lines = lines.slice(0, lineCount);
  }
  if (text && truncate2 && width != null) {
    var options = prepareTruncateOptions(width, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    for (var i = 0; i < lines.length; i++) {
      lines[i] = truncateSingleLine(lines[i], options);
    }
  }
  var outerHeight = height;
  var contentWidth = 0;
  for (var i = 0; i < lines.length; i++) {
    contentWidth = Math.max(getWidth2(lines[i], font), contentWidth);
  }
  if (width == null) {
    width = contentWidth;
  }
  var outerWidth = contentWidth;
  if (padding) {
    outerHeight += padding[0] + padding[2];
    outerWidth += padding[1] + padding[3];
    width += padding[1] + padding[3];
  }
  if (bgColorDrawn) {
    outerWidth = width;
  }
  return {
    lines,
    height,
    outerWidth,
    outerHeight,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width
  };
}
var RichTextToken = function() {
  function RichTextToken2() {
  }
  return RichTextToken2;
}();
var RichTextLine = function() {
  function RichTextLine2(tokens) {
    this.tokens = [];
    if (tokens) {
      this.tokens = tokens;
    }
  }
  return RichTextLine2;
}();
var RichTextContentBlock = function() {
  function RichTextContentBlock2() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
  }
  return RichTextContentBlock2;
}();
function parseRichText(text, style) {
  var contentBlock = new RichTextContentBlock();
  text != null && (text += "");
  if (!text) {
    return contentBlock;
  }
  var topWidth = style.width;
  var topHeight = style.height;
  var overflow = style.overflow;
  var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;
  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
  }
  var pendingList = [];
  var calculatedHeight = 0;
  var calculatedWidth = 0;
  var stlPadding = style.padding;
  var truncate2 = overflow === "truncate";
  var truncateLine = style.lineOverflow === "truncate";
  function finishLine(line2, lineWidth2, lineHeight2) {
    line2.width = lineWidth2;
    line2.lineHeight = lineHeight2;
    calculatedHeight += lineHeight2;
    calculatedWidth = Math.max(calculatedWidth, lineWidth2);
  }
  outer:
    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j = 0; j < line.tokens.length; j++) {
        var token = line.tokens[j];
        var tokenStyle = token.styleName && style.rich[token.styleName] || {};
        var textPadding = token.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || style.align;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          if (j > 0) {
            line.tokens = line.tokens.slice(0, j);
            finishLine(line, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i);
          }
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = getWidth2(token.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate2 && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token.width = token.contentWidth = getWidth2(token.text, font);
            }
          } else {
            token.contentWidth = getWidth2(token.text, font);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  var isEmptyStr = str === "";
  var tokenStyle = styleName && style.rich[styleName] || {};
  var lines = block.lines;
  var font = tokenStyle.font || style.font;
  var newLine = false;
  var strLines;
  var linesWidths;
  if (wrapInfo) {
    var tokenPadding = tokenStyle.padding;
    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      var outerWidth_1 = parsePercent$1(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split("\n");
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth_1;
    } else {
      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  } else {
    strLines = str.split("\n");
  }
  for (var i = 0; i < strLines.length; i++) {
    var text = strLines[i];
    var token = new RichTextToken();
    token.styleName = styleName;
    token.text = text;
    token.isLineHolder = !text && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token.width = tokenStyle.width;
    } else {
      token.width = linesWidths ? linesWidths[i] : getWidth2(text, font);
    }
    if (!i && !newLine) {
      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } else {
      lines.push(new RichTextLine([token]));
    }
  }
}
function isLatin(ch) {
  var code = ch.charCodeAt(0);
  return code >= 33 && code <= 383;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
  obj[ch] = true;
  return obj;
}, {});
function isWordBreakChar(ch) {
  if (isLatin(ch)) {
    if (breakCharMap[ch]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
  var lines = [];
  var linesWidths = [];
  var line = "";
  var currentWord = "";
  var currentWordWidth = 0;
  var accumWidth = 0;
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch === "\n") {
      if (currentWord) {
        line += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line);
      linesWidths.push(accumWidth);
      line = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    var chWidth = getWidth2(ch, font);
    var inWord = isBreakAll ? false : !isWordBreakChar(ch);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch);
          linesWidths.push(chWidth);
        }
      } else if (line || currentWord) {
        if (inWord) {
          if (!line) {
            line = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch;
          currentWordWidth += chWidth;
          line = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line);
          linesWidths.push(accumWidth);
          line = ch;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line += ch;
    }
  }
  if (!lines.length && !line) {
    line = text;
    currentWord = "";
    currentWordWidth = 0;
  }
  if (currentWord) {
    line += currentWord;
  }
  if (line) {
    lines.push(line);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable = function(_super) {
  __extends(Displayable2, _super);
  function Displayable2(props) {
    return _super.call(this, props) || this;
  }
  Displayable2.prototype._init = function(props) {
    var keysArr = keys2(props);
    for (var i = 0; i < keysArr.length; i++) {
      var key = keysArr[i];
      if (key === "style") {
        this.useStyle(props[key]);
      } else {
        _super.prototype.attrKV.call(this, key, props[key]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Displayable2.prototype.beforeBrush = function() {
  };
  Displayable2.prototype.afterBrush = function() {
  };
  Displayable2.prototype.innerBeforeBrush = function() {
  };
  Displayable2.prototype.innerAfterBrush = function() {
  };
  Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    var m2 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths) {
      for (var i = 0; i < this.__clipPaths.length; ++i) {
        if (this.__clipPaths[i].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      var parent_1 = this.parent;
      while (parent_1) {
        if (parent_1.ignore) {
          return false;
        }
        parent_1 = parent_1.parent;
      }
    }
    return true;
  };
  Displayable2.prototype.contain = function(x2, y2) {
    return this.rectContain(x2, y2);
  };
  Displayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  Displayable2.prototype.rectContain = function(x2, y2) {
    var coord = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  };
  Displayable2.prototype.getPaintRect = function() {
    var rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var transform4 = this.transform;
      var elRect = this.getBoundingRect();
      var style = this.style;
      var shadowSize = style.shadowBlur || 0;
      var shadowOffsetX = style.shadowOffsetX || 0;
      var shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0));
      if (transform4) {
        BoundingRect$1.applyTransform(rect, elRect, transform4);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      var tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  };
  Displayable2.prototype.setPrevPaintRect = function(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  };
  Displayable2.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  };
  Displayable2.prototype.animateStyle = function(loop) {
    return this.animate("style", loop);
  };
  Displayable2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  };
  Displayable2.prototype.attrKV = function(key, value) {
    if (key !== "style") {
      _super.prototype.attrKV.call(this, key, value);
    } else {
      if (!this.style) {
        this.useStyle(value);
      } else {
        this.setStyle(value);
      }
    }
  };
  Displayable2.prototype.setStyle = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value;
    } else {
      extend2(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  };
  Displayable2.prototype.dirtyStyle = function(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  };
  Displayable2.prototype.dirty = function() {
    this.dirtyStyle();
  };
  Displayable2.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  };
  Displayable2.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  };
  Displayable2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  };
  Displayable2.prototype.useStyle = function(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  };
  Displayable2.prototype.isStyleObject = function(obj) {
    return obj[STYLE_MAGIC_KEY];
  };
  Displayable2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  };
  Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetStyle;
    if (state && state.style) {
      if (transition) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition) {
        var sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          var changedKeys = keys2(sourceStyle);
          for (var i = 0; i < changedKeys.length; i++) {
            var key = changedKeys[i];
            if (key in targetStyle) {
              targetStyle[key] = targetStyle[key];
              this.style[key] = sourceStyle[key];
            }
          }
        }
        var targetKeys = keys2(targetStyle);
        for (var i = 0; i < targetKeys.length; i++) {
          var key = targetKeys[i];
          this.style[key] = this.style[key];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
    for (var i = 0; i < statesKeys.length; i++) {
      var key = statesKeys[i];
      if (state && state[key] != null) {
        this[key] = state[key];
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          this[key] = normalState[key];
        }
      }
    }
  };
  Displayable2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedStyle;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  };
  Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    extend2(targetStyle, sourceStyle);
    return targetStyle;
  };
  Displayable2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  };
  Displayable2.initDefaultProps = function() {
    var dispProto = Displayable2.prototype;
    dispProto.type = "displayable";
    dispProto.invisible = false;
    dispProto.z = 0;
    dispProto.z2 = 0;
    dispProto.zlevel = 0;
    dispProto.culling = false;
    dispProto.cursor = "pointer";
    dispProto.rectHover = false;
    dispProto.incremental = false;
    dispProto._rect = null;
    dispProto.dirtyRectTolerance = 0;
    dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }();
  return Displayable2;
}(Element$1);
var tmpRect = new BoundingRect$1(0, 0, 0, 0);
var viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}
var Displayable$1 = Displayable;
var mathMin$9 = Math.min;
var mathMax$9 = Math.max;
var mathSin$4 = Math.sin;
var mathCos$4 = Math.cos;
var PI2$8 = Math.PI * 2;
var start = create$2();
var end = create$2();
var extremity = create$2();
function fromPoints(points2, min5, max4) {
  if (points2.length === 0) {
    return;
  }
  var p = points2[0];
  var left = p[0];
  var right = p[0];
  var top = p[1];
  var bottom = p[1];
  for (var i = 1; i < points2.length; i++) {
    p = points2[i];
    left = mathMin$9(left, p[0]);
    right = mathMax$9(right, p[0]);
    top = mathMin$9(top, p[1]);
    bottom = mathMax$9(bottom, p[1]);
  }
  min5[0] = left;
  min5[1] = top;
  max4[0] = right;
  max4[1] = bottom;
}
function fromLine(x02, y02, x12, y12, min5, max4) {
  min5[0] = mathMin$9(x02, x12);
  min5[1] = mathMin$9(y02, y12);
  max4[0] = mathMax$9(x02, x12);
  max4[1] = mathMax$9(y02, y12);
}
var xDim = [];
var yDim = [];
function fromCubic(x02, y02, x12, y12, x2, y2, x3, y3, min5, max4) {
  var cubicExtrema$1 = cubicExtrema;
  var cubicAt$1 = cubicAt;
  var n = cubicExtrema$1(x02, x12, x2, x3, xDim);
  min5[0] = Infinity;
  min5[1] = Infinity;
  max4[0] = -Infinity;
  max4[1] = -Infinity;
  for (var i = 0; i < n; i++) {
    var x4 = cubicAt$1(x02, x12, x2, x3, xDim[i]);
    min5[0] = mathMin$9(x4, min5[0]);
    max4[0] = mathMax$9(x4, max4[0]);
  }
  n = cubicExtrema$1(y02, y12, y2, y3, yDim);
  for (var i = 0; i < n; i++) {
    var y4 = cubicAt$1(y02, y12, y2, y3, yDim[i]);
    min5[1] = mathMin$9(y4, min5[1]);
    max4[1] = mathMax$9(y4, max4[1]);
  }
  min5[0] = mathMin$9(x02, min5[0]);
  max4[0] = mathMax$9(x02, max4[0]);
  min5[0] = mathMin$9(x3, min5[0]);
  max4[0] = mathMax$9(x3, max4[0]);
  min5[1] = mathMin$9(y02, min5[1]);
  max4[1] = mathMax$9(y02, max4[1]);
  min5[1] = mathMin$9(y3, min5[1]);
  max4[1] = mathMax$9(y3, max4[1]);
}
function fromQuadratic(x02, y02, x12, y12, x2, y2, min5, max4) {
  var quadraticExtremum$1 = quadraticExtremum;
  var quadraticAt2 = quadraticAt$1;
  var tx = mathMax$9(mathMin$9(quadraticExtremum$1(x02, x12, x2), 1), 0);
  var ty = mathMax$9(mathMin$9(quadraticExtremum$1(y02, y12, y2), 1), 0);
  var x3 = quadraticAt2(x02, x12, x2, tx);
  var y3 = quadraticAt2(y02, y12, y2, ty);
  min5[0] = mathMin$9(x02, x2, x3);
  min5[1] = mathMin$9(y02, y2, y3);
  max4[0] = mathMax$9(x02, x2, x3);
  max4[1] = mathMax$9(y02, y2, y3);
}
function fromArc(x2, y2, rx, ry, startAngle, endAngle, anticlockwise, min5, max4) {
  var vec2Min = min$1;
  var vec2Max = max$1;
  var diff2 = Math.abs(startAngle - endAngle);
  if (diff2 % PI2$8 < 1e-4 && diff2 > 1e-4) {
    min5[0] = x2 - rx;
    min5[1] = y2 - ry;
    max4[0] = x2 + rx;
    max4[1] = y2 + ry;
    return;
  }
  start[0] = mathCos$4(startAngle) * rx + x2;
  start[1] = mathSin$4(startAngle) * ry + y2;
  end[0] = mathCos$4(endAngle) * rx + x2;
  end[1] = mathSin$4(endAngle) * ry + y2;
  vec2Min(min5, start, end);
  vec2Max(max4, start, end);
  startAngle = startAngle % PI2$8;
  if (startAngle < 0) {
    startAngle = startAngle + PI2$8;
  }
  endAngle = endAngle % PI2$8;
  if (endAngle < 0) {
    endAngle = endAngle + PI2$8;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2$8;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2$8;
  }
  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (var angle4 = 0; angle4 < endAngle; angle4 += Math.PI / 2) {
    if (angle4 > startAngle) {
      extremity[0] = mathCos$4(angle4) * rx + x2;
      extremity[1] = mathSin$4(angle4) * ry + y2;
      vec2Min(min5, extremity, min5);
      vec2Max(max4, extremity, max4);
    }
  }
}
var CMD$4 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min4 = [];
var max3 = [];
var min22 = [];
var max22 = [];
var mathMin$8 = Math.min;
var mathMax$8 = Math.max;
var mathCos$3 = Math.cos;
var mathSin$3 = Math.sin;
var mathAbs$2 = Math.abs;
var PI$8 = Math.PI;
var PI2$7 = PI$8 * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  var n = Math.round(radian / PI$8 * 1e8) / 1e8;
  return n % 2 * PI$8;
}
function normalizeArcAngles(angles, anticlockwise) {
  var newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI2$7;
  }
  var delta2 = newStartAngle - angles[0];
  var newEndAngle = angles[1];
  newEndAngle += delta2;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI2$7) {
    newEndAngle = newStartAngle + PI2$7;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$7) {
    newEndAngle = newStartAngle - PI2$7;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI2$7 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI2$7 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy = function() {
  function PathProxy2(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  PathProxy2.prototype.increaseVersion = function() {
    this._version++;
  };
  PathProxy2.prototype.getVersion = function() {
    return this._version;
  };
  PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs$2(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs$2(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  };
  PathProxy2.prototype.setDPR = function(dpr2) {
    this.dpr = dpr2;
  };
  PathProxy2.prototype.setContext = function(ctx) {
    this._ctx = ctx;
  };
  PathProxy2.prototype.getContext = function() {
    return this._ctx;
  };
  PathProxy2.prototype.beginPath = function() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  };
  PathProxy2.prototype.reset = function() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  };
  PathProxy2.prototype.moveTo = function(x2, y2) {
    this._drawPendingPt();
    this.addData(CMD$4.M, x2, y2);
    this._ctx && this._ctx.moveTo(x2, y2);
    this._x0 = x2;
    this._y0 = y2;
    this._xi = x2;
    this._yi = y2;
    return this;
  };
  PathProxy2.prototype.lineTo = function(x2, y2) {
    var dx = mathAbs$2(x2 - this._xi);
    var dy = mathAbs$2(y2 - this._yi);
    var exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD$4.L, x2, y2);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x2, y2);
    }
    if (exceedUnit) {
      this._xi = x2;
      this._yi = y2;
      this._pendingPtDist = 0;
    } else {
      var d2 = dx * dx + dy * dy;
      if (d2 > this._pendingPtDist) {
        this._pendingPtX = x2;
        this._pendingPtY = y2;
        this._pendingPtDist = d2;
      }
    }
    return this;
  };
  PathProxy2.prototype.bezierCurveTo = function(x12, y12, x2, y2, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD$4.C, x12, y12, x2, y2, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x12, y12, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  };
  PathProxy2.prototype.quadraticCurveTo = function(x12, y12, x2, y2) {
    this._drawPendingPt();
    this.addData(CMD$4.Q, x12, y12, x2, y2);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x12, y12, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  };
  PathProxy2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    var delta2 = endAngle - startAngle;
    this.addData(CMD$4.A, cx, cy, r, r, startAngle, delta2, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos$3(endAngle) * r + cx;
    this._yi = mathSin$3(endAngle) * r + cy;
    return this;
  };
  PathProxy2.prototype.arcTo = function(x12, y12, x2, y2, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x12, y12, x2, y2, radius);
    }
    return this;
  };
  PathProxy2.prototype.rect = function(x2, y2, w, h) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x2, y2, w, h);
    this.addData(CMD$4.R, x2, y2, w, h);
    return this;
  };
  PathProxy2.prototype.closePath = function() {
    this._drawPendingPt();
    this.addData(CMD$4.Z);
    var ctx = this._ctx;
    var x02 = this._x0;
    var y02 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x02;
    this._yi = y02;
    return this;
  };
  PathProxy2.prototype.fill = function(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  };
  PathProxy2.prototype.stroke = function(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  };
  PathProxy2.prototype.len = function() {
    return this._len;
  };
  PathProxy2.prototype.setData = function(data) {
    var len2 = data.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (var i = 0; i < len2; i++) {
      this.data[i] = data[i];
    }
    this._len = len2;
  };
  PathProxy2.prototype.appendPath = function(path) {
    if (!(path instanceof Array)) {
      path = [path];
    }
    var len2 = path.length;
    var appendSize = 0;
    var offset = this._len;
    for (var i = 0; i < len2; i++) {
      appendSize += path[i].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }
    for (var i = 0; i < len2; i++) {
      var appendPathData = path[i].data;
      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }
    this._len = offset;
  };
  PathProxy2.prototype.addData = function(cmd, a, b, c, d, e2, f, g, h) {
    if (!this._saveData) {
      return;
    }
    var data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }
  };
  PathProxy2.prototype._drawPendingPt = function() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  };
  PathProxy2.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      var newData = [];
      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
  };
  PathProxy2.prototype.toStatic = function() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    var data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data);
      }
    }
  };
  PathProxy2.prototype.getBoundingRect = function() {
    min4[0] = min4[1] = min22[0] = min22[1] = Number.MAX_VALUE;
    max3[0] = max3[1] = max22[0] = max22[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x02 = 0;
    var y02 = 0;
    var i;
    for (i = 0; i < this._len; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x02 = xi;
        y02 = yi;
      }
      switch (cmd) {
        case CMD$4.M:
          xi = x02 = data[i++];
          yi = y02 = data[i++];
          min22[0] = x02;
          min22[1] = y02;
          max22[0] = x02;
          max22[1] = y02;
          break;
        case CMD$4.L:
          fromLine(xi, yi, data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$4.C:
          fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$4.Q:
          fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$4.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle;
          i += 1;
          var anticlockwise = !data[i++];
          if (isFirst) {
            x02 = mathCos$3(startAngle) * rx + cx;
            y02 = mathSin$3(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min22, max22);
          xi = mathCos$3(endAngle) * rx + cx;
          yi = mathSin$3(endAngle) * ry + cy;
          break;
        case CMD$4.R:
          x02 = xi = data[i++];
          y02 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          fromLine(x02, y02, x02 + width, y02 + height, min22, max22);
          break;
        case CMD$4.Z:
          xi = x02;
          yi = y02;
          break;
      }
      min$1(min4, min4, min22);
      max$1(max3, max3, max22);
    }
    if (i === 0) {
      min4[0] = min4[1] = max3[0] = max3[1] = 0;
    }
    return new BoundingRect$1(min4[0], min4[1], max3[0] - min4[0], max3[1] - min4[1]);
  };
  PathProxy2.prototype._calculateLength = function() {
    var data = this.data;
    var len2 = this._len;
    var ux = this._ux;
    var uy = this._uy;
    var xi = 0;
    var yi = 0;
    var x02 = 0;
    var y02 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    var pathSegLen = this._pathSegLen;
    var pathTotalLen = 0;
    var segCount = 0;
    for (var i = 0; i < len2; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x02 = xi;
        y02 = yi;
      }
      var l = -1;
      switch (cmd) {
        case CMD$4.M:
          xi = x02 = data[i++];
          yi = y02 = data[i++];
          break;
        case CMD$4.L: {
          var x2 = data[i++];
          var y2 = data[i++];
          var dx = x2 - xi;
          var dy = y2 - yi;
          if (mathAbs$2(dx) > ux || mathAbs$2(dy) > uy || i === len2 - 1) {
            l = Math.sqrt(dx * dx + dy * dy);
            xi = x2;
            yi = y2;
          }
          break;
        }
        case CMD$4.C: {
          var x12 = data[i++];
          var y12 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          var x3 = data[i++];
          var y3 = data[i++];
          l = cubicLength(xi, yi, x12, y12, x2, y2, x3, y3, 10);
          xi = x3;
          yi = y3;
          break;
        }
        case CMD$4.Q: {
          var x12 = data[i++];
          var y12 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          l = quadraticLength(xi, yi, x12, y12, x2, y2, 10);
          xi = x2;
          yi = y2;
          break;
        }
        case CMD$4.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var delta2 = data[i++];
          var endAngle = delta2 + startAngle;
          i += 1;
          !data[i++];
          if (isFirst) {
            x02 = mathCos$3(startAngle) * rx + cx;
            y02 = mathSin$3(startAngle) * ry + cy;
          }
          l = mathMax$8(rx, ry) * mathMin$8(PI2$7, Math.abs(delta2));
          xi = mathCos$3(endAngle) * rx + cx;
          yi = mathSin$3(endAngle) * ry + cy;
          break;
        case CMD$4.R: {
          x02 = xi = data[i++];
          y02 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          l = width * 2 + height * 2;
          break;
        }
        case CMD$4.Z: {
          var dx = x02 - xi;
          var dy = y02 - yi;
          l = Math.sqrt(dx * dx + dy * dy);
          xi = x02;
          yi = y02;
          break;
        }
      }
      if (l >= 0) {
        pathSegLen[segCount++] = l;
        pathTotalLen += l;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  };
  PathProxy2.prototype.rebuildPath = function(ctx, percent) {
    var d = this.data;
    var ux = this._ux;
    var uy = this._uy;
    var len2 = this._len;
    var x02;
    var y02;
    var xi;
    var yi;
    var x2;
    var y2;
    var drawPart = percent < 1;
    var pathSegLen;
    var pathTotalLen;
    var accumLength = 0;
    var segCount = 0;
    var displayedLength;
    var pendingPtDist = 0;
    var pendingPtX;
    var pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (var i = 0; i < len2; ) {
        var cmd = d[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = d[i];
          yi = d[i + 1];
          x02 = xi;
          y02 = yi;
        }
        if (cmd !== CMD$4.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD$4.M:
            x02 = xi = d[i++];
            y02 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD$4.L: {
            x2 = d[i++];
            y2 = d[i++];
            var dx = mathAbs$2(x2 - xi);
            var dy = mathAbs$2(y2 - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l;
                  ctx.lineTo(xi * (1 - t) + x2 * t, yi * (1 - t) + y2 * t);
                  break lo;
                }
                accumLength += l;
              }
              ctx.lineTo(x2, y2);
              xi = x2;
              yi = y2;
              pendingPtDist = 0;
            } else {
              var d2 = dx * dx + dy * dy;
              if (d2 > pendingPtDist) {
                pendingPtX = x2;
                pendingPtY = y2;
                pendingPtDist = d2;
              }
            }
            break;
          }
          case CMD$4.C: {
            var x12 = d[i++];
            var y12 = d[i++];
            var x22 = d[i++];
            var y22 = d[i++];
            var x3 = d[i++];
            var y3 = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                cubicSubdivide(xi, x12, x22, x3, t, tmpOutX);
                cubicSubdivide(yi, y12, y22, y3, t, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l;
            }
            ctx.bezierCurveTo(x12, y12, x22, y22, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$4.Q: {
            var x12 = d[i++];
            var y12 = d[i++];
            var x22 = d[i++];
            var y22 = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                quadraticSubdivide(xi, x12, x22, t, tmpOutX);
                quadraticSubdivide(yi, y12, y22, t, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l;
            }
            ctx.quadraticCurveTo(x12, y12, x22, y22);
            xi = x22;
            yi = y22;
            break;
          }
          case CMD$4.A:
            var cx = d[i++];
            var cy = d[i++];
            var rx = d[i++];
            var ry = d[i++];
            var startAngle = d[i++];
            var delta2 = d[i++];
            var psi = d[i++];
            var anticlockwise = !d[i++];
            var r = rx > ry ? rx : ry;
            var isEllipse = mathAbs$2(rx - ry) > 1e-3;
            var endAngle = startAngle + delta2;
            var breakBuild = false;
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                endAngle = startAngle + delta2 * (displayedLength - accumLength) / l;
                breakBuild = true;
              }
              accumLength += l;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x02 = mathCos$3(startAngle) * rx + cx;
              y02 = mathSin$3(startAngle) * ry + cy;
            }
            xi = mathCos$3(endAngle) * rx + cx;
            yi = mathSin$3(endAngle) * ry + cy;
            break;
          case CMD$4.R:
            x02 = xi = d[i];
            y02 = yi = d[i + 1];
            x2 = d[i++];
            y2 = d[i++];
            var width = d[i++];
            var height = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + mathMin$8(d_1, width), y2);
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + width, y2 + mathMin$8(d_1, height));
                }
                d_1 -= height;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + mathMax$8(width - d_1, 0), y2 + height);
                }
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x2, y2 + mathMax$8(height - d_1, 0));
                }
                break lo;
              }
              accumLength += l;
            }
            ctx.rect(x2, y2, width, height);
            break;
          case CMD$4.Z:
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                ctx.lineTo(xi * (1 - t) + x02 * t, yi * (1 - t) + y02 * t);
                break lo;
              }
              accumLength += l;
            }
            ctx.closePath();
            xi = x02;
            yi = y02;
        }
      }
  };
  PathProxy2.prototype.clone = function() {
    var newProxy = new PathProxy2();
    var data = this.data;
    newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
    newProxy._len = this._len;
    return newProxy;
  };
  PathProxy2.CMD = CMD$4;
  PathProxy2.initDefaultProps = function() {
    var proto2 = PathProxy2.prototype;
    proto2._saveData = true;
    proto2._ux = 0;
    proto2._uy = 0;
    proto2._pendingPtDist = 0;
    proto2._version = 0;
  }();
  return PathProxy2;
}();
function containStroke$4(x02, y02, x12, y12, lineWidth, x2, y2) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  var _a2 = 0;
  var _b2 = x02;
  if (y2 > y02 + _l && y2 > y12 + _l || y2 < y02 - _l && y2 < y12 - _l || x2 > x02 + _l && x2 > x12 + _l || x2 < x02 - _l && x2 < x12 - _l) {
    return false;
  }
  if (x02 !== x12) {
    _a2 = (y02 - y12) / (x02 - x12);
    _b2 = (x02 * y12 - x12 * y02) / (x02 - x12);
  } else {
    return Math.abs(x2 - x02) <= _l / 2;
  }
  var tmp = _a2 * x2 - y2 + _b2;
  var _s = tmp * tmp / (_a2 * _a2 + 1);
  return _s <= _l / 2 * _l / 2;
}
function containStroke$3(x02, y02, x12, y12, x2, y2, x3, y3, lineWidth, x4, y4) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y4 > y02 + _l && y4 > y12 + _l && y4 > y2 + _l && y4 > y3 + _l || y4 < y02 - _l && y4 < y12 - _l && y4 < y2 - _l && y4 < y3 - _l || x4 > x02 + _l && x4 > x12 + _l && x4 > x2 + _l && x4 > x3 + _l || x4 < x02 - _l && x4 < x12 - _l && x4 < x2 - _l && x4 < x3 - _l) {
    return false;
  }
  var d = cubicProjectPoint(x02, y02, x12, y12, x2, y2, x3, y3, x4, y4, null);
  return d <= _l / 2;
}
function containStroke$2(x02, y02, x12, y12, x2, y2, lineWidth, x3, y3) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y3 > y02 + _l && y3 > y12 + _l && y3 > y2 + _l || y3 < y02 - _l && y3 < y12 - _l && y3 < y2 - _l || x3 > x02 + _l && x3 > x12 + _l && x3 > x2 + _l || x3 < x02 - _l && x3 < x12 - _l && x3 < x2 - _l) {
    return false;
  }
  var d = quadraticProjectPoint(x02, y02, x12, y12, x2, y2, x3, y3, null);
  return d <= _l / 2;
}
var PI2$6 = Math.PI * 2;
function normalizeRadian(angle4) {
  angle4 %= PI2$6;
  if (angle4 < 0) {
    angle4 += PI2$6;
  }
  return angle4;
}
var PI2$5 = Math.PI * 2;
function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x2, y2) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  x2 -= cx;
  y2 -= cy;
  var d = Math.sqrt(x2 * x2 + y2 * y2);
  if (d - _l > r || d + _l < r) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI2$5 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$5;
  }
  var angle4 = Math.atan2(y2, x2);
  if (angle4 < 0) {
    angle4 += PI2$5;
  }
  return angle4 >= startAngle && angle4 <= endAngle || angle4 + PI2$5 >= startAngle && angle4 + PI2$5 <= endAngle;
}
function windingLine(x02, y02, x12, y12, x2, y2) {
  if (y2 > y02 && y2 > y12 || y2 < y02 && y2 < y12) {
    return 0;
  }
  if (y12 === y02) {
    return 0;
  }
  var t = (y2 - y02) / (y12 - y02);
  var dir3 = y12 < y02 ? 1 : -1;
  if (t === 1 || t === 0) {
    dir3 = y12 < y02 ? 0.5 : -0.5;
  }
  var x_ = t * (x12 - x02) + x02;
  return x_ === x2 ? Infinity : x_ > x2 ? dir3 : 0;
}
var CMD$3 = PathProxy.CMD;
var PI2$4 = Math.PI * 2;
var EPSILON$1 = 1e-4;
function isAroundEqual$1(a, b) {
  return Math.abs(a - b) < EPSILON$1;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x02, y02, x12, y12, x2, y2, x3, y3, x4, y4) {
  if (y4 > y02 && y4 > y12 && y4 > y2 && y4 > y3 || y4 < y02 && y4 < y12 && y4 < y2 && y4 < y3) {
    return 0;
  }
  var nRoots = cubicRootAt(y02, y12, y2, y3, y4, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_ = void 0;
    var y1_ = void 0;
    for (var i = 0; i < nRoots; i++) {
      var t = roots[i];
      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = cubicAt(x02, x12, x2, x3, t);
      if (x_ < x4) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y02, y12, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y02, y12, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y02, y12, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t < extrema[0]) {
          w += y0_ < y02 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t < extrema[0]) {
          w += y0_ < y02 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w;
  }
}
function windingQuadratic(x02, y02, x12, y12, x2, y2, x3, y3) {
  if (y3 > y02 && y3 > y12 && y3 > y2 || y3 < y02 && y3 < y12 && y3 < y2) {
    return 0;
  }
  var nRoots = quadraticRootAt(y02, y12, y2, y3, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var t = quadraticExtremum(y02, y12, y2);
    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = quadraticAt$1(y02, y12, y2, t);
      for (var i = 0; i < nRoots; i++) {
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = quadraticAt$1(x02, x12, x2, roots[i]);
        if (x_ < x3) {
          continue;
        }
        if (roots[i] < t) {
          w += y_ < y02 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }
      return w;
    } else {
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = quadraticAt$1(x02, x12, x2, roots[0]);
      if (x_ < x3) {
        return 0;
      }
      return y2 < y02 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x2, y2) {
  y2 -= cy;
  if (y2 > r || y2 < -r) {
    return 0;
  }
  var tmp = Math.sqrt(r * r - y2 * y2);
  roots[0] = -tmp;
  roots[1] = tmp;
  var dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) {
    return 0;
  }
  if (dTheta >= PI2$4 - 1e-4) {
    startAngle = 0;
    endAngle = PI2$4;
    var dir3 = anticlockwise ? 1 : -1;
    if (x2 >= roots[0] + cx && x2 <= roots[1] + cx) {
      return dir3;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    var tmp_1 = startAngle;
    startAngle = endAngle;
    endAngle = tmp_1;
  }
  if (startAngle < 0) {
    startAngle += PI2$4;
    endAngle += PI2$4;
  }
  var w = 0;
  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];
    if (x_ + cx > x2) {
      var angle4 = Math.atan2(y2, x_);
      var dir3 = anticlockwise ? 1 : -1;
      if (angle4 < 0) {
        angle4 = PI2$4 + angle4;
      }
      if (angle4 >= startAngle && angle4 <= endAngle || angle4 + PI2$4 >= startAngle && angle4 + PI2$4 <= endAngle) {
        if (angle4 > Math.PI / 2 && angle4 < Math.PI * 1.5) {
          dir3 = -dir3;
        }
        w += dir3;
      }
    }
  }
  return w;
}
function containPath(path, lineWidth, isStroke, x2, y2) {
  var data = path.data;
  var len2 = path.len();
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x02 = 0;
  var y02 = 0;
  var x12;
  var y12;
  for (var i = 0; i < len2; ) {
    var cmd = data[i++];
    var isFirst = i === 1;
    if (cmd === CMD$3.M && i > 1) {
      if (!isStroke) {
        w += windingLine(xi, yi, x02, y02, x2, y2);
      }
    }
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x02 = xi;
      y02 = yi;
    }
    switch (cmd) {
      case CMD$3.M:
        x02 = data[i++];
        y02 = data[i++];
        xi = x02;
        yi = y02;
        break;
      case CMD$3.L:
        if (isStroke) {
          if (containStroke$4(xi, yi, data[i], data[i + 1], lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, data[i], data[i + 1], x2, y2) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$3.C:
        if (isStroke) {
          if (containStroke$3(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x2, y2) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$3.Q:
        if (isStroke) {
          if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x2, y2) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$3.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        i += 1;
        var anticlockwise = !!(1 - data[i++]);
        x12 = Math.cos(theta) * rx + cx;
        y12 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w += windingLine(xi, yi, x12, y12, x2, y2);
        } else {
          x02 = x12;
          y02 = y12;
        }
        var _x = (x2 - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y2)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y2);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$3.R:
        x02 = xi = data[i++];
        y02 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        x12 = x02 + width;
        y12 = y02 + height;
        if (isStroke) {
          if (containStroke$4(x02, y02, x12, y02, lineWidth, x2, y2) || containStroke$4(x12, y02, x12, y12, lineWidth, x2, y2) || containStroke$4(x12, y12, x02, y12, lineWidth, x2, y2) || containStroke$4(x02, y12, x02, y02, lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w += windingLine(x12, y02, x12, y12, x2, y2);
          w += windingLine(x02, y12, x02, y02, x2, y2);
        }
        break;
      case CMD$3.Z:
        if (isStroke) {
          if (containStroke$4(xi, yi, x02, y02, lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, x02, y02, x2, y2);
        }
        xi = x02;
        yi = y02;
        break;
    }
  }
  if (!isStroke && !isAroundEqual$1(yi, y02)) {
    w += windingLine(xi, yi, x02, y02, x2, y2) || 0;
  }
  return w !== 0;
}
function contain$2(pathProxy, x2, y2) {
  return containPath(pathProxy, 0, false, x2, y2);
}
function containStroke(pathProxy, lineWidth, x2, y2) {
  return containPath(pathProxy, lineWidth, true, x2, y2);
}
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path = function(_super) {
  __extends(Path2, _super);
  function Path2(opts) {
    return _super.call(this, opts) || this;
  }
  Path2.prototype.update = function() {
    var _this = this;
    _super.prototype.update.call(this);
    var style = this.style;
    if (style.decal) {
      var decalEl = this._decalEl = this._decalEl || new Path2();
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = function(ctx) {
          _this.buildPath(ctx, _this.shape);
        };
      }
      decalEl.silent = true;
      var decalElStyle = decalEl.style;
      for (var key in style) {
        if (decalElStyle[key] !== style[key]) {
          decalElStyle[key] = style[key];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (var i = 0; i < pathCopyParams.length; ++i) {
        decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  };
  Path2.prototype.getDecalElement = function() {
    return this._decalEl;
  };
  Path2.prototype._init = function(props) {
    var keysArr = keys2(props);
    this.shape = this.getDefaultShape();
    var defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (var i = 0; i < keysArr.length; i++) {
      var key = keysArr[i];
      var value = props[key];
      if (key === "style") {
        if (!this.style) {
          this.useStyle(value);
        } else {
          extend2(this.style, value);
        }
      } else if (key === "shape") {
        extend2(this.shape, value);
      } else {
        _super.prototype.attrKV.call(this, key, value);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Path2.prototype.getDefaultStyle = function() {
    return null;
  };
  Path2.prototype.getDefaultShape = function() {
    return {};
  };
  Path2.prototype.canBeInsideText = function() {
    return this.hasFill();
  };
  Path2.prototype.getInsideTextFill = function() {
    var pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString(pathFill)) {
        var fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  };
  Path2.prototype.getInsideTextStroke = function(textFill) {
    var pathFill = this.style.fill;
    if (isString(pathFill)) {
      var zr = this.__zr;
      var isDarkMode2 = !!(zr && zr.isDarkMode());
      var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode2 === isDarkLabel) {
        return pathFill;
      }
    }
  };
  Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
  };
  Path2.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  };
  Path2.prototype.getUpdatedPathProxy = function(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  };
  Path2.prototype.createPathProxy = function() {
    this.path = new PathProxy(false);
  };
  Path2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  };
  Path2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  Path2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;
    if (needsUpdateRect) {
      var firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      var path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        var w = style.lineWidth;
        if (!this.hasFill()) {
          var strokeContainThreshold = this.strokeContainThreshold;
          w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 1e-10) {
          rectStroke.width += w / lineScale;
          rectStroke.height += w / lineScale;
          rectStroke.x -= w / lineScale / 2;
          rectStroke.y -= w / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  };
  Path2.prototype.contain = function(x2, y2) {
    var localPos = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    var style = this.style;
    x2 = localPos[0];
    y2 = localPos[1];
    if (rect.contain(x2, y2)) {
      var pathProxy = this.path;
      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke(pathProxy, lineWidth / lineScale, x2, y2)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain$2(pathProxy, x2, y2);
      }
    }
    return false;
  };
  Path2.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  };
  Path2.prototype.dirty = function() {
    this.dirtyStyle();
    this.dirtyShape();
  };
  Path2.prototype.animateShape = function(loop) {
    return this.animate("shape", loop);
  };
  Path2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  };
  Path2.prototype.attrKV = function(key, value) {
    if (key === "shape") {
      this.setShape(value);
    } else {
      _super.prototype.attrKV.call(this, key, value);
    }
  };
  Path2.prototype.setShape = function(keyOrObj, value) {
    var shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value;
    } else {
      extend2(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  };
  Path2.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  };
  Path2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  };
  Path2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend2({}, this.shape);
    }
  };
  Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetShape;
    if (state && state.shape) {
      if (transition) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend2({}, normalState.shape);
          extend2(targetShape, state.shape);
        }
      } else {
        targetShape = extend2({}, keepCurrentStates ? this.shape : normalState.shape);
        extend2(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition) {
        this.shape = extend2({}, this.shape);
        var targetShapePrimaryProps = {};
        var shapeKeys = keys2(targetShape);
        for (var i = 0; i < shapeKeys.length; i++) {
          var key = shapeKeys[i];
          if (typeof targetShape[key] === "object") {
            this.shape[key] = targetShape[key];
          } else {
            targetShapePrimaryProps[key] = targetShape[key];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  };
  Path2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedShape;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  };
  Path2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  };
  Path2.prototype.isZeroArea = function() {
    return false;
  };
  Path2.extend = function(defaultProps) {
    var Sub = function(_super2) {
      __extends(Sub2, _super2);
      function Sub2(opts) {
        var _this = _super2.call(this, opts) || this;
        defaultProps.init && defaultProps.init.call(_this, opts);
        return _this;
      }
      Sub2.prototype.getDefaultStyle = function() {
        return clone$4(defaultProps.style);
      };
      Sub2.prototype.getDefaultShape = function() {
        return clone$4(defaultProps.shape);
      };
      return Sub2;
    }(Path2);
    for (var key in defaultProps) {
      if (typeof defaultProps[key] === "function") {
        Sub.prototype[key] = defaultProps[key];
      }
    }
    return Sub;
  };
  Path2.initDefaultProps = function() {
    var pathProto = Path2.prototype;
    pathProto.type = "path";
    pathProto.strokeContainThreshold = 5;
    pathProto.segmentIgnoreThreshold = 0;
    pathProto.subPixelOptimize = false;
    pathProto.autoBatch = false;
    pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }();
  return Path2;
}(Displayable$1);
var Path$1 = Path;
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = function(_super) {
  __extends(TSpan2, _super);
  function TSpan2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TSpan2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  };
  TSpan2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  TSpan2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  };
  TSpan2.prototype.setBoundingRect = function(rect) {
    this._rect = rect;
  };
  TSpan2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      var text = style.text;
      text != null ? text += "" : text = "";
      var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        var w = style.lineWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }
      this._rect = rect;
    }
    return this._rect;
  };
  TSpan2.initDefaultProps = function() {
    var tspanProto = TSpan2.prototype;
    tspanProto.dirtyRectTolerance = 10;
  }();
  return TSpan2;
}(Displayable$1);
TSpan.prototype.type = "tspan";
var TSpan$1 = TSpan;
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike$1(source2) {
  return !!(source2 && typeof source2 !== "string" && source2.width && source2.height);
}
var ZRImage = function(_super) {
  __extends(ZRImage2, _super);
  function ZRImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ZRImage2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  };
  ZRImage2.prototype._getSize = function(dim) {
    var style = this.style;
    var size11 = style[dim];
    if (size11 != null) {
      return size11;
    }
    var imageSource = isImageLike$1(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    var otherDim = dim === "width" ? "height" : "width";
    var otherDimSize = style[otherDim];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim] * otherDimSize;
    }
  };
  ZRImage2.prototype.getWidth = function() {
    return this._getSize("width");
  };
  ZRImage2.prototype.getHeight = function() {
    return this._getSize("height");
  };
  ZRImage2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  };
  ZRImage2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect$1(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  };
  return ZRImage2;
}(Displayable$1);
ZRImage.prototype.type = "image";
var ZRImage$1 = ZRImage;
function buildPath$2(ctx, shape) {
  var x2 = shape.x;
  var y2 = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4;
  if (width < 0) {
    x2 = x2 + width;
    width = -width;
  }
  if (height < 0) {
    y2 = y2 + height;
    height = -height;
  }
  if (typeof r === "number") {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }
  var total;
  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }
  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }
  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x2 + r1, y2);
  ctx.lineTo(x2 + width - r2, y2);
  r2 !== 0 && ctx.arc(x2 + width - r2, y2 + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x2 + width, y2 + height - r3);
  r3 !== 0 && ctx.arc(x2 + width - r3, y2 + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x2 + r4, y2 + height);
  r4 !== 0 && ctx.arc(x2 + r4, y2 + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x2, y2 + r1);
  r1 !== 0 && ctx.arc(x2 + r1, y2 + r1, r1, Math.PI, Math.PI * 1.5);
}
var round$2 = Math.round;
function subPixelOptimizeLine$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var x12 = inputShape.x1;
  var x2 = inputShape.x2;
  var y12 = inputShape.y1;
  var y2 = inputShape.y2;
  outputShape.x1 = x12;
  outputShape.x2 = x2;
  outputShape.y1 = y12;
  outputShape.y2 = y2;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round$2(x12 * 2) === round$2(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x12, lineWidth, true);
  }
  if (round$2(y12 * 2) === round$2(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y12, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
  outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize$1(position2, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position2;
  }
  var doubledPosition = round$2(position2 * 2);
  return (doubledPosition + round$2(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}
var RectShape = function() {
  function RectShape2() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
  return RectShape2;
}();
var subPixelOptimizeOutputShape$1 = {};
var Rect$2 = function(_super) {
  __extends(Rect2, _super);
  function Rect2(opts) {
    return _super.call(this, opts) || this;
  }
  Rect2.prototype.getDefaultShape = function() {
    return new RectShape();
  };
  Rect2.prototype.buildPath = function(ctx, shape) {
    var x2;
    var y2;
    var width;
    var height;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
      x2 = optimizedShape.x;
      y2 = optimizedShape.y;
      width = optimizedShape.width;
      height = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x2 = shape.x;
      y2 = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x2, y2, width, height);
    } else {
      buildPath$2(ctx, shape);
    }
  };
  Rect2.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  };
  return Rect2;
}(Path$1);
Rect$2.prototype.type = "rect";
var Rect$3 = Rect$2;
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = function(_super) {
  __extends(ZRText2, _super);
  function ZRText2(opts) {
    var _this = _super.call(this) || this;
    _this.type = "text";
    _this._children = [];
    _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    _this.attr(opts);
    return _this;
  }
  ZRText2.prototype.childrenRef = function() {
    return this._children;
  };
  ZRText2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  };
  ZRText2.prototype.updateTransform = function() {
    var innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      _super.prototype.updateTransform.call(this);
    }
  };
  ZRText2.prototype.getLocalTransform = function(m2) {
    var innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
  };
  ZRText2.prototype.getComputedTransform = function() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return _super.prototype.getComputedTransform.call(this);
  };
  ZRText2.prototype._updateSubTexts = function() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  };
  ZRText2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      this._children[i].__zr = zr;
    }
  };
  ZRText2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      this._children[i].__zr = null;
    }
  };
  ZRText2.prototype.getBoundingRect = function() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
      var children = this._children;
      var tmpMat = [];
      var rect = null;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        var childRect = child.getBoundingRect();
        var transform4 = child.getLocalTransform(tmpMat);
        if (transform4) {
          tmpRect2.copy(childRect);
          tmpRect2.applyTransform(transform4);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect2;
    }
    return this._rect;
  };
  ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  };
  ZRText2.prototype.setTextContent = function(textContent) {
    {
      throw new Error("Can't attach text on another text");
    }
  };
  ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    var sourceRich = sourceStyle.rich;
    var targetRich = targetStyle.rich || sourceRich && {};
    extend2(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  };
  ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
    var richNames = keys2(sourceRich);
    for (var i = 0; i < richNames.length; i++) {
      var richName = richNames[i];
      targetRich[richName] = targetRich[richName] || {};
      extend2(targetRich[richName], sourceRich[richName]);
    }
  };
  ZRText2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  };
  ZRText2.prototype._getOrCreateChild = function(Ctor) {
    var child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor();
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  };
  ZRText2.prototype._updatePlainTexts = function() {
    var style = this.style;
    var textFont = style.font || DEFAULT_FONT;
    var textPadding = style.padding;
    var text = getStyleText(style);
    var contentBlock = parsePlainText(text, style);
    var needDrawBg = needDrawBackground(style);
    var bgColorDrawn = !!style.backgroundColor;
    var outerHeight = contentBlock.outerHeight;
    var outerWidth = contentBlock.outerWidth;
    var contentWidth = contentBlock.contentWidth;
    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;
    var defaultStyle = this._defaultStyle;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.align || defaultStyle.align || "left";
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    var textX = baseX;
    var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    var defaultLineWidth = 0;
    var useDefaultFill = false;
    var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow2 = style.textShadowBlur > 0;
    var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    var calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (var i = 0; i < textLines.length; i++) {
      var el = this._getOrCreateChild(TSpan$1);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      subElStyle.text = textLines[i];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow2) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  };
  ZRText2.prototype._updateRichTexts = function() {
    var style = this.style;
    var text = getStyleText(style);
    var contentBlock = parseRichText(text, style);
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.padding;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var defaultStyle = this._defaultStyle;
    var textAlign = style.align || defaultStyle.align;
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    var boxX = adjustTextX(baseX, outerWidth, textAlign);
    var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    var bgColorDrawn = !!style.backgroundColor;
    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var tokens = line.tokens;
      var tokenCount = tokens.length;
      var lineHeight = line.lineHeight;
      var remainedWidth = line.width;
      var leftIndex = 0;
      var lineXLeft = xLeft;
      var lineXRight = xRight;
      var rightIndex = tokenCount - 1;
      var token = void 0;
      while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.align || token.align === "left")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token = tokens[rightIndex], token.align === "right")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token = tokens[leftIndex];
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
        lineXLeft += token.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  };
  ZRText2.prototype._placeToken = function(token, style, lineHeight, lineTop, x2, textAlign, parentBgColorDrawn) {
    var tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text;
    var verticalAlign = token.verticalAlign;
    var y2 = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y2 = lineTop + token.height / 2;
    } else if (verticalAlign === "bottom") {
      y2 = lineTop + lineHeight - token.height / 2;
    }
    var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x2 - token.width : textAlign === "center" ? x2 - token.width / 2 : x2, y2 - token.height / 2, token.width, token.height);
    var bgColorDrawn = !!tokenStyle.backgroundColor;
    var textPadding = token.textPadding;
    if (textPadding) {
      x2 = getTextXForPadding(x2, textAlign, textPadding);
      y2 -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
    }
    var el = this._getOrCreateChild(TSpan$1);
    var subElStyle = el.createStyle();
    el.useStyle(subElStyle);
    var defaultStyle = this._defaultStyle;
    var useDefaultFill = false;
    var defaultLineWidth = 0;
    var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow2 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token.text;
    subElStyle.x = x2;
    subElStyle.y = y2;
    if (hasShadow2) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    var textWidth = token.contentWidth;
    var textHeight = token.contentHeight;
    el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  };
  ZRText2.prototype._renderBackground = function(style, topStyle, x2, y2, width, height) {
    var textBackgroundColor = style.backgroundColor;
    var textBorderWidth = style.borderWidth;
    var textBorderColor = style.borderColor;
    var isImageBg = textBackgroundColor && textBackgroundColor.image;
    var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    var textBorderRadius = style.borderRadius;
    var self2 = this;
    var rectEl;
    var imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect$3);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      var rectShape = rectEl.shape;
      rectShape.x = x2;
      rectShape.y = y2;
      rectShape.width = width;
      rectShape.height = height;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      var rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(ZRImage$1);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      var imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x2;
      imgStyle.y = y2;
      imgStyle.width = width;
      imgStyle.height = height;
    }
    if (textBorderWidth && textBorderColor) {
      var rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    var commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  };
  ZRText2.makeFont = function(style) {
    var font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim$1(font) || style.textFont || style.font;
  };
  return ZRText2;
}(Displayable$1);
var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (var i = 0; i < FONT_PARTS.length; i++) {
    var fontProp = FONT_PARTS[i];
    var val = sourceStyle[fontProp];
    if (val != null) {
      targetStyle[fontProp] = val;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each$f(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    var textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    var verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    var textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray$1(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x2, textAlign, textPadding) {
  return textAlign === "right" ? x2 - textPadding[1] : textAlign === "center" ? x2 + textPadding[3] / 2 - textPadding[1] / 2 : x2 + textPadding[3];
}
function getStyleText(style) {
  var text = style.text;
  text != null && (text += "");
  return text;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var ZRText$1 = ZRText;
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
  if (el) {
    var ecData = getECData(el);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    if (el.type === "group") {
      el.traverse(function(child) {
        var childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
      });
    }
  }
};
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
var liftedColorCache = new LRU$1(100);
function liftColor(color) {
  if (isString(color)) {
    var liftedColor = liftedColorCache.get(color);
    if (!liftedColor) {
      liftedColor = lift(color, -0.1);
      liftedColorCache.put(color, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color)) {
    var ret = extend2({}, color);
    ret.colorStops = map$1(color.colorStops, function(stop2) {
      return {
        offset: stop2.offset,
        color: lift(stop2.color, -0.1)
      };
    });
    return ret;
  }
  return color;
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }
  el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
  doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el) {
  doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el) {
  el.selected = true;
}
function singleLeaveSelect(el) {
  el.selected = false;
}
function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el, stateName) {
  switch (stateName) {
    case "emphasis":
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el.selected = true;
  }
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
  var style = el.style;
  var fromState = {};
  for (var i = 0; i < props.length; i++) {
    var propName = props[i];
    var val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }
  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
  var hasSelect = targetStates && indexOf2(targetStates, "select") >= 0;
  var cloned = false;
  if (el instanceof Path$1) {
    var store = getSavedStates(el);
    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      var emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend2({}, state);
        emphasisStyle = extend2({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend2({}, state);
        emphasisStyle = extend2({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend2({}, state);
          emphasisStyle = extend2({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend2({}, state);
      }
      var z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend2({}, state);
      var z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el, stateName, state) {
  var hasBlur = indexOf2(el.currentStates, stateName) >= 0;
  var currentOpacity = el.style.opacity;
  var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  var blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend2({}, state);
    blurStyle = extend2({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  var state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  var textContent = el.getTextContent();
  var textGuide = el.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e2) {
  return el.__highDownSilentOnTouch && e2.zrByTouch;
}
function allLeaveBlur(api) {
  var model = api.getModel();
  var leaveBlurredSeries = [];
  var allComponentViews = [];
  model.eachComponent(function(componentType, componentModel) {
    var componentStates = getComponentStates(componentModel);
    var isSeries2 = componentType === "series";
    var view = isSeries2 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
    !isSeries2 && allComponentViews.push(view);
    if (componentStates.isBlured) {
      view.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
      isSeries2 && leaveBlurredSeries.push(componentModel);
    }
    componentStates.isBlured = false;
  });
  each$f(allComponentViews, function(view) {
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
  var ecModel = api.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data, dataIndices) {
    for (var i = 0; i < dataIndices.length; i++) {
      var itemEl = data.getItemGraphicEl(dataIndices[i]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus || focus === "none") {
    return;
  }
  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  var targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  var blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    var sameSeries = targetSeriesModel === seriesModel;
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
      var view = api.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function(child) {
        singleEnterBlur(child);
      });
      if (isArrayLike(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject$3(focus)) {
        var dataTypes = keys2(focus);
        for (var d = 0; d < dataTypes.length; d++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    var view = api.getViewOfComponentModel(componentModel);
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.focusBlurEnabled) {
    return;
  }
  view.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
  var seriesIndex = seriesModel.seriesIndex;
  var data = seriesModel.getData(payload.dataType);
  if (!data) {
    {
      error("Unknown dataType " + payload.dataType);
    }
    return;
  }
  var dataIndex = queryDataIndex(data, payload);
  dataIndex = (isArray$1(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  var el = data.getItemGraphicEl(dataIndex);
  if (!el) {
    var count3 = data.count();
    var current = 0;
    while (!el && current < count3) {
      el = data.getItemGraphicEl(current++);
    }
  }
  if (el) {
    var ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
  } else {
    var focus_1 = seriesModel.get(["emphasis", "focus"]);
    var blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus_1 != null) {
      blurSeries(seriesIndex, focus_1, blurScope, api);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name2, api) {
  var ret = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name2 == null) {
    return ret;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret;
  }
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.findHighDownDispatchers) {
    return ret;
  }
  var dispatchers = view.findHighDownDispatchers(name2);
  var focusSelf;
  for (var i = 0; i < dispatchers.length; i++) {
    if (!isHighDownDispatcher(dispatchers[i])) {
      error("param should be highDownDispatcher");
    }
    if (getECData(dispatchers[i]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {
    focusSelf,
    dispatchers
  };
}
function handleGlobalMouseOverForHighDown(dispatcher, e2, api) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  var ecData = getECData(dispatcher);
  var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    each$f(dispatchers, function(dispatcher2) {
      return enterEmphasisWhenMouseOver(dispatcher2, e2);
    });
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    enterEmphasisWhenMouseOver(dispatcher, e2);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e2, api) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  allLeaveBlur(api);
  var ecData = getECData(dispatcher);
  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
  if (dispatchers) {
    each$f(dispatchers, function(dispatcher2) {
      return leaveEmphasisWhenMouseOut(dispatcher2, e2);
    });
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e2);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  var dataType = payload.dataType;
  var data = seriesModel.getData(dataType);
  var dataIndex = queryDataIndex(data, payload);
  if (!isArray$1(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  var allData = seriesModel.getAllData();
  each$f(allData, function(_a2) {
    var data = _a2.data, type = _a2.type;
    data.eachItemGraphicEl(function(el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  var ret = [];
  ecModel.eachSeries(function(seriesModel) {
    var allData = seriesModel.getAllData();
    each$f(allData, function(_a2) {
      _a2.data;
      var type = _a2.type;
      var dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        var item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type != null) {
          item.dataType = type;
        }
        ret.push(item);
      }
    });
  });
  return ret;
}
function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  var ecData = getECData(el);
  if (focus != null) {
    ecData.focus = focus;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (var i = 0; i < OTHER_STATES.length; i++) {
    var stateName = OTHER_STATES[i];
    var model = itemModel.getModel([stateName, styleType]);
    var state = el.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el, asDispatcher) {
  var disable = asDispatcher === false;
  var extendedEl = el;
  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
  var ecData = getECData(el);
  ecData.componentMainType = componentModel.mainType;
  ecData.componentIndex = componentModel.componentIndex;
  ecData.componentHighDownName = componentHighDownName;
}
function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  var payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  var payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  var store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  var selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}
var CMD$2 = PathProxy.CMD;
var points$2 = [[], [], []];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m2) {
  if (!m2) {
    return;
  }
  var data = path.data;
  var len2 = path.len();
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p;
  var M = CMD$2.M;
  var C = CMD$2.C;
  var L = CMD$2.L;
  var R = CMD$2.R;
  var A = CMD$2.A;
  var Q = CMD$2.Q;
  for (i = 0, j = 0; i < len2; ) {
    cmd = data[i++];
    j = i;
    nPoint = 0;
    switch (cmd) {
      case M:
        nPoint = 1;
        break;
      case L:
        nPoint = 1;
        break;
      case C:
        nPoint = 3;
        break;
      case Q:
        nPoint = 2;
        break;
      case A:
        var x2 = m2[4];
        var y2 = m2[5];
        var sx = mathSqrt$2(m2[0] * m2[0] + m2[1] * m2[1]);
        var sy = mathSqrt$2(m2[2] * m2[2] + m2[3] * m2[3]);
        var angle4 = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data[i] *= sx;
        data[i++] += x2;
        data[i] *= sy;
        data[i++] += y2;
        data[i++] *= sx;
        data[i++] *= sy;
        data[i++] += angle4;
        data[i++] += angle4;
        i += 2;
        j = i;
        break;
      case R:
        p[0] = data[i++];
        p[1] = data[i++];
        applyTransform$1(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
        p[0] += data[i++];
        p[1] += data[i++];
        applyTransform$1(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
    }
    for (k = 0; k < nPoint; k++) {
      var p_1 = points$2[k];
      p_1[0] = data[i++];
      p_1[1] = data[i++];
      applyTransform$1(p_1, p_1, m2);
      data[j++] = p_1[0];
      data[j++] = p_1[1];
    }
  }
  path.increaseVersion();
}
var mathSqrt$1 = Math.sqrt;
var mathSin$2 = Math.sin;
var mathCos$2 = Math.cos;
var PI$7 = Math.PI;
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function processArc(x12, y12, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI$7 / 180);
  var xp = mathCos$2(psi) * (x12 - x2) / 2 + mathSin$2(psi) * (y12 - y2) / 2;
  var yp = -1 * mathSin$2(psi) * (x12 - x2) / 2 + mathCos$2(psi) * (y12 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt$1(lambda);
    ry *= mathSqrt$1(lambda);
  }
  var f = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x12 + x2) / 2 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
  var cy = (y12 + y2) / 2 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = PI$7;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    var n = Math.round(dTheta / PI$7 * 1e6) / 1e6;
    dTheta = PI$7 * 2 + n % 2 * PI$7;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  var path = new PathProxy();
  if (!data) {
    return path;
  }
  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var CMD2 = PathProxy.CMD;
  var cmdList = data.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (var l = 0; l < cmdList.length; l++) {
    var cmdText = cmdList[l];
    var cmdStr = cmdText.charAt(0);
    var cmd = void 0;
    var p = cmdText.match(numberReg$1) || [];
    var pLen = p.length;
    for (var i = 0; i < pLen; i++) {
      p[i] = parseFloat(p[i]);
    }
    var off = 0;
    while (off < pLen) {
      var ctlPtx = void 0;
      var ctlPty = void 0;
      var rx = void 0;
      var ry = void 0;
      var psi = void 0;
      var fa = void 0;
      var fs = void 0;
      var x12 = cpx;
      var y12 = cpy;
      var len2 = void 0;
      var pathData = void 0;
      switch (cmdStr) {
        case "l":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD2.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;
        case "c":
          cmd = CMD2.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x12 = p[off++];
          y12 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x12, y12, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x12 = cpx + p[off++];
          y12 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x12, y12, cpx, cpy);
          break;
        case "Q":
          x12 = p[off++];
          y12 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, x12, y12, cpx, cpy);
          break;
        case "q":
          x12 = p[off++] + cpx;
          y12 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, x12, y12, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x12 = cpx, y12 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.A;
          processArc(x12, y12, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x12 = cpx, y12 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.A;
          processArc(x12, y12, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD2.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = function(_super) {
  __extends(SVGPath2, _super);
  function SVGPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SVGPath2.prototype.applyTransform = function(m2) {
  };
  return SVGPath2;
}(Path$1);
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  var innerOpts = extend2({}, opts);
  innerOpts.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.setData(pathProxy.data);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx, 1);
    }
  };
  innerOpts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  var innerOpts = createPathOptions(str, defaultOpts);
  var Sub = function(_super) {
    __extends(Sub2, _super);
    function Sub2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.applyTransform = innerOpts.applyTransform;
      _this.buildPath = innerOpts.buildPath;
      return _this;
    }
    return Sub2;
  }(SVGPath);
  return Sub;
}
function mergePath$1(pathEls, opts) {
  var pathList = [];
  var len2 = pathEls.length;
  for (var i = 0; i < len2; i++) {
    var pathEl = pathEls[i];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  var pathBundle = new Path$1(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}
function clonePath(sourcePath, opts) {
  opts = opts || {};
  var path = new Path$1();
  if (sourcePath.shape) {
    path.setShape(sourcePath.shape);
  }
  path.setStyle(sourcePath.style);
  if (opts.bakeTransform) {
    transformPath(path.path, sourcePath.getComputedTransform());
  } else {
    if (opts.toLocal) {
      path.setLocalTransform(sourcePath.getComputedTransform());
    } else {
      path.copyTransform(sourcePath);
    }
  }
  path.buildPath = sourcePath.buildPath;
  path.applyTransform = path.applyTransform;
  path.z = sourcePath.z;
  path.z2 = sourcePath.z2;
  path.zlevel = sourcePath.zlevel;
  return path;
}
var CircleShape = function() {
  function CircleShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
  return CircleShape2;
}();
var Circle = function(_super) {
  __extends(Circle2, _super);
  function Circle2(opts) {
    return _super.call(this, opts) || this;
  }
  Circle2.prototype.getDefaultShape = function() {
    return new CircleShape();
  };
  Circle2.prototype.buildPath = function(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  };
  return Circle2;
}(Path$1);
Circle.prototype.type = "circle";
var Circle$1 = Circle;
var EllipseShape = function() {
  function EllipseShape2() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
  return EllipseShape2;
}();
var Ellipse = function(_super) {
  __extends(Ellipse2, _super);
  function Ellipse2(opts) {
    return _super.call(this, opts) || this;
  }
  Ellipse2.prototype.getDefaultShape = function() {
    return new EllipseShape();
  };
  Ellipse2.prototype.buildPath = function(ctx, shape) {
    var k = 0.5522848;
    var x2 = shape.cx;
    var y2 = shape.cy;
    var a = shape.rx;
    var b = shape.ry;
    var ox = a * k;
    var oy = b * k;
    ctx.moveTo(x2 - a, y2);
    ctx.bezierCurveTo(x2 - a, y2 - oy, x2 - ox, y2 - b, x2, y2 - b);
    ctx.bezierCurveTo(x2 + ox, y2 - b, x2 + a, y2 - oy, x2 + a, y2);
    ctx.bezierCurveTo(x2 + a, y2 + oy, x2 + ox, y2 + b, x2, y2 + b);
    ctx.bezierCurveTo(x2 - ox, y2 + b, x2 - a, y2 + oy, x2 - a, y2);
    ctx.closePath();
  };
  return Ellipse2;
}(Path$1);
Ellipse.prototype.type = "ellipse";
var Ellipse$1 = Ellipse;
var PI$6 = Math.PI;
var PI2$3 = PI$6 * 2;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs$1 = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$7 = Math.max;
var mathMin$7 = Math.min;
var e = 1e-4;
function intersect(x02, y02, x12, y12, x2, y2, x3, y3) {
  var dx10 = x12 - x02;
  var dy10 = y12 - y02;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y02 - y2) - dy32 * (x02 - x2)) / t;
  return [x02 + t * dx10, y02 + t * dy10];
}
function computeCornerTangents(x02, y02, x12, y12, radius, cr, clockwise) {
  var x01 = x02 - x12;
  var y01 = y02 - y12;
  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x02 + ox;
  var y11 = y02 + oy;
  var x10 = x12 + ox;
  var y10 = y12 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d2 = dx * dx + dy * dy;
  var r = radius - cr;
  var s = x11 * y10 - x10 * y11;
  var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$7(0, r * r * d2 - s * s));
  var cx0 = (s * dy - dx * d) / d2;
  var cy0 = (-s * dx - dy * d) / d2;
  var cx1 = (s * dy + dx * d) / d2;
  var cy1 = (-s * dx + dy * d) / d2;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function normalizeCornerRadius(cr) {
  var arr;
  if (isArray$1(cr)) {
    var len2 = cr.length;
    if (!len2) {
      return cr;
    }
    if (len2 === 1) {
      arr = [cr[0], cr[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr[0], cr[0], cr[1], cr[1]];
    } else if (len2 === 3) {
      arr = cr.concat(cr[2]);
    } else {
      arr = cr;
    }
  } else {
    arr = [cr, cr, cr, cr];
  }
  return arr;
}
function buildPath$1(ctx, shape) {
  var _a2;
  var radius = mathMax$7(shape.r, 0);
  var innerRadius = mathMax$7(shape.r0 || 0, 0);
  var hasRadius = radius > 0;
  var hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    var tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  var startAngle = shape.startAngle, endAngle = shape.endAngle;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  var cx = shape.cx, cy = shape.cy;
  var clockwise = !!shape.clockwise;
  var arc = mathAbs$1(endAngle - startAngle);
  var mod = arc > PI2$3 && arc % PI2$3;
  mod > e && (arc = mod);
  if (!(radius > e)) {
    ctx.moveTo(cx, cy);
  } else if (arc > PI2$3 - e) {
    ctx.moveTo(cx + radius * mathCos$1(startAngle), cy + radius * mathSin$1(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e) {
      ctx.moveTo(cx + innerRadius * mathCos$1(endAngle), cy + innerRadius * mathSin$1(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    var icrStart = void 0;
    var icrEnd = void 0;
    var ocrStart = void 0;
    var ocrEnd = void 0;
    var ocrs = void 0;
    var ocre = void 0;
    var icrs = void 0;
    var icre = void 0;
    var ocrMax = void 0;
    var icrMax = void 0;
    var limitedOcrMax = void 0;
    var limitedIcrMax = void 0;
    var xre = void 0;
    var yre = void 0;
    var xirs = void 0;
    var yirs = void 0;
    var xrs = radius * mathCos$1(startAngle);
    var yrs = radius * mathSin$1(startAngle);
    var xire = innerRadius * mathCos$1(endAngle);
    var yire = innerRadius * mathSin$1(endAngle);
    var hasArc = arc > e;
    if (hasArc) {
      var cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
      }
      var halfRd = mathAbs$1(radius - innerRadius) / 2;
      ocrs = mathMin$7(halfRd, ocrStart);
      ocre = mathMin$7(halfRd, ocrEnd);
      icrs = mathMin$7(halfRd, icrStart);
      icre = mathMin$7(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax$7(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax$7(icrs, icre);
      if (ocrMax > e || icrMax > e) {
        xre = radius * mathCos$1(endAngle);
        yre = radius * mathSin$1(endAngle);
        xirs = innerRadius * mathCos$1(startAngle);
        yirs = innerRadius * mathSin$1(startAngle);
        if (arc < PI$6) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x02 = xrs - it_1[0];
            var y02 = yrs - it_1[1];
            var x12 = xre - it_1[0];
            var y12 = yre - it_1[1];
            var a = 1 / mathSin$1(mathACos((x02 * x12 + y02 * y12) / (mathSqrt(x02 * x02 + y02 * y02) * mathSqrt(x12 * x12 + y12 * y12))) / 2);
            var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOcrMax = mathMin$7(ocrMax, (radius - b) / (a + 1));
            limitedIcrMax = mathMin$7(icrMax, (innerRadius - b) / (a - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e) {
      var crStart = mathMin$7(ocrStart, limitedOcrMax);
      var crEnd = mathMin$7(ocrEnd, limitedOcrMax);
      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e) {
      var crStart = mathMin$7(icrStart, limitedIcrMax);
      var crEnd = mathMin$7(icrEnd, limitedIcrMax);
      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}
var SectorShape = function() {
  function SectorShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
  return SectorShape2;
}();
var Sector = function(_super) {
  __extends(Sector2, _super);
  function Sector2(opts) {
    return _super.call(this, opts) || this;
  }
  Sector2.prototype.getDefaultShape = function() {
    return new SectorShape();
  };
  Sector2.prototype.buildPath = function(ctx, shape) {
    buildPath$1(ctx, shape);
  };
  Sector2.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  };
  return Sector2;
}(Path$1);
Sector.prototype.type = "sector";
var Sector$1 = Sector;
var RingShape = function() {
  function RingShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
  return RingShape2;
}();
var Ring = function(_super) {
  __extends(Ring2, _super);
  function Ring2(opts) {
    return _super.call(this, opts) || this;
  }
  Ring2.prototype.getDefaultShape = function() {
    return new RingShape();
  };
  Ring2.prototype.buildPath = function(ctx, shape) {
    var x2 = shape.cx;
    var y2 = shape.cy;
    var PI22 = Math.PI * 2;
    ctx.moveTo(x2 + shape.r, y2);
    ctx.arc(x2, y2, shape.r, 0, PI22, false);
    ctx.moveTo(x2 + shape.r0, y2);
    ctx.arc(x2, y2, shape.r0, 0, PI22, true);
  };
  return Ring2;
}(Path$1);
Ring.prototype.type = "ring";
var Ring$1 = Ring;
function smoothBezier(points2, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v12 = [];
  var v22 = [];
  var prevPoint;
  var nextPoint;
  var min5;
  var max4;
  if (constraint) {
    min5 = [Infinity, Infinity];
    max4 = [-Infinity, -Infinity];
    for (var i = 0, len2 = points2.length; i < len2; i++) {
      min$1(min5, min5, points2[i]);
      max$1(max4, max4, points2[i]);
    }
    min$1(min5, min5, constraint[0]);
    max$1(max4, max4, constraint[1]);
  }
  for (var i = 0, len2 = points2.length; i < len2; i++) {
    var point4 = points2[i];
    if (isLoop) {
      prevPoint = points2[i ? i - 1 : len2 - 1];
      nextPoint = points2[(i + 1) % len2];
    } else {
      if (i === 0 || i === len2 - 1) {
        cps.push(clone$3(points2[i]));
        continue;
      } else {
        prevPoint = points2[i - 1];
        nextPoint = points2[i + 1];
      }
    }
    sub(v, nextPoint, prevPoint);
    scale$2(v, v, smooth);
    var d0 = distance10(point4, prevPoint);
    var d1 = distance10(point4, nextPoint);
    var sum2 = d0 + d1;
    if (sum2 !== 0) {
      d0 /= sum2;
      d1 /= sum2;
    }
    scale$2(v12, v, -d0);
    scale$2(v22, v, d1);
    var cp0 = add15([], point4, v12);
    var cp1 = add15([], point4, v22);
    if (constraint) {
      max$1(cp0, cp0, min5);
      min$1(cp0, cp0, max4);
      max$1(cp1, cp1, min5);
      min$1(cp1, cp1, max4);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function buildPath(ctx, shape, closePath) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (points2 && points2.length >= 2) {
    if (smooth) {
      var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points2[0][0], points2[0][1]);
      var len2 = points2.length;
      for (var i = 0; i < (closePath ? len2 : len2 - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p = points2[(i + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      ctx.moveTo(points2[0][0], points2[0][1]);
      for (var i = 1, l = points2.length; i < l; i++) {
        ctx.lineTo(points2[i][0], points2[i][1]);
      }
    }
    closePath && ctx.closePath();
  }
}
var PolygonShape = function() {
  function PolygonShape2() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolygonShape2;
}();
var Polygon = function(_super) {
  __extends(Polygon2, _super);
  function Polygon2(opts) {
    return _super.call(this, opts) || this;
  }
  Polygon2.prototype.getDefaultShape = function() {
    return new PolygonShape();
  };
  Polygon2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, true);
  };
  return Polygon2;
}(Path$1);
Polygon.prototype.type = "polygon";
var Polygon$1 = Polygon;
var PolylineShape = function() {
  function PolylineShape2() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolylineShape2;
}();
var Polyline$2 = function(_super) {
  __extends(Polyline2, _super);
  function Polyline2(opts) {
    return _super.call(this, opts) || this;
  }
  Polyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Polyline2.prototype.getDefaultShape = function() {
    return new PolylineShape();
  };
  Polyline2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, false);
  };
  return Polyline2;
}(Path$1);
Polyline$2.prototype.type = "polyline";
var Polyline$3 = Polyline$2;
var subPixelOptimizeOutputShape = {};
var LineShape = function() {
  function LineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return LineShape2;
}();
var Line$2 = function(_super) {
  __extends(Line2, _super);
  function Line2(opts) {
    return _super.call(this, opts) || this;
  }
  Line2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Line2.prototype.getDefaultShape = function() {
    return new LineShape();
  };
  Line2.prototype.buildPath = function(ctx, shape) {
    var x12;
    var y12;
    var x2;
    var y2;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
      x12 = optimizedShape.x1;
      y12 = optimizedShape.y1;
      x2 = optimizedShape.x2;
      y2 = optimizedShape.y2;
    } else {
      x12 = shape.x1;
      y12 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x12, y12);
    if (percent < 1) {
      x2 = x12 * (1 - percent) + x2 * percent;
      y2 = y12 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  };
  Line2.prototype.pointAt = function(p) {
    var shape = this.shape;
    return [
      shape.x1 * (1 - p) + shape.x2 * p,
      shape.y1 * (1 - p) + shape.y2 * p
    ];
  };
  return Line2;
}(Path$1);
Line$2.prototype.type = "line";
var Line$3 = Line$2;
var out = [];
var BezierCurveShape = function() {
  function BezierCurveShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
  return BezierCurveShape2;
}();
function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt$1)(shape.x1, shape.cpx1, shape.x2, t),
      (isTangent ? quadraticDerivativeAt : quadraticAt$1)(shape.y1, shape.cpy1, shape.y2, t)
    ];
  }
}
var BezierCurve = function(_super) {
  __extends(BezierCurve2, _super);
  function BezierCurve2(opts) {
    return _super.call(this, opts) || this;
  }
  BezierCurve2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  BezierCurve2.prototype.getDefaultShape = function() {
    return new BezierCurveShape();
  };
  BezierCurve2.prototype.buildPath = function(ctx, shape) {
    var x12 = shape.x1;
    var y12 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x12, y12);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x12, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y12, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x12, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y12, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  };
  BezierCurve2.prototype.pointAt = function(t) {
    return someVectorAt(this.shape, t, false);
  };
  BezierCurve2.prototype.tangentAt = function(t) {
    var p = someVectorAt(this.shape, t, true);
    return normalize$3(p, p);
  };
  return BezierCurve2;
}(Path$1);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve$1 = BezierCurve;
var ArcShape = function() {
  function ArcShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return ArcShape2;
}();
var Arc = function(_super) {
  __extends(Arc2, _super);
  function Arc2(opts) {
    return _super.call(this, opts) || this;
  }
  Arc2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Arc2.prototype.getDefaultShape = function() {
    return new ArcShape();
  };
  Arc2.prototype.buildPath = function(ctx, shape) {
    var x2 = shape.cx;
    var y2 = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x2, unitY * r + y2);
    ctx.arc(x2, y2, r, startAngle, endAngle, !clockwise);
  };
  return Arc2;
}(Path$1);
Arc.prototype.type = "arc";
var Arc$1 = Arc;
var CompoundPath = function(_super) {
  __extends(CompoundPath2, _super);
  function CompoundPath2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "compound";
    return _this;
  }
  CompoundPath2.prototype._updatePathDirty = function() {
    var paths = this.shape.paths;
    var dirtyPath = this.shapeChanged();
    for (var i = 0; i < paths.length; i++) {
      dirtyPath = dirtyPath || paths[i].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  };
  CompoundPath2.prototype.beforeBrush = function() {
    this._updatePathDirty();
    var paths = this.shape.paths || [];
    var scale4 = this.getGlobalScale();
    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }
      paths[i].path.setScale(scale4[0], scale4[1], paths[i].segmentIgnoreThreshold);
    }
  };
  CompoundPath2.prototype.buildPath = function(ctx, shape) {
    var paths = shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  };
  CompoundPath2.prototype.afterBrush = function() {
    var paths = this.shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].pathUpdated();
    }
  };
  CompoundPath2.prototype.getBoundingRect = function() {
    this._updatePathDirty.call(this);
    return Path$1.prototype.getBoundingRect.call(this);
  };
  return CompoundPath2;
}(Path$1);
var CompoundPath$1 = CompoundPath;
var Gradient = function() {
  function Gradient2(colorStops) {
    this.colorStops = colorStops || [];
  }
  Gradient2.prototype.addColorStop = function(offset, color) {
    this.colorStops.push({
      offset,
      color
    });
  };
  return Gradient2;
}();
var Gradient$1 = Gradient;
var LinearGradient = function(_super) {
  __extends(LinearGradient2, _super);
  function LinearGradient2(x2, y2, x22, y22, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x2 == null ? 0 : x2;
    _this.y = y2 == null ? 0 : y2;
    _this.x2 = x22 == null ? 1 : x22;
    _this.y2 = y22 == null ? 0 : y22;
    _this.type = "linear";
    _this.global = globalCoord || false;
    return _this;
  }
  return LinearGradient2;
}(Gradient$1);
var LinearGradient$1 = LinearGradient;
var RadialGradient = function(_super) {
  __extends(RadialGradient2, _super);
  function RadialGradient2(x2, y2, r, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x2 == null ? 0.5 : x2;
    _this.y = y2 == null ? 0.5 : y2;
    _this.r = r == null ? 0.5 : r;
    _this.type = "radial";
    _this.global = globalCoord || false;
    return _this;
  }
  return RadialGradient2;
}(Gradient$1);
var RadialGradient$1 = RadialGradient;
var extent = [0, 0];
var extent2 = [0, 0];
var minTv = new Point$1();
var maxTv = new Point$1();
var OrientedBoundingRect = function() {
  function OrientedBoundingRect2(rect, transform4) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (var i = 0; i < 4; i++) {
      this._corners[i] = new Point$1();
    }
    for (var i = 0; i < 2; i++) {
      this._axes[i] = new Point$1();
    }
    if (rect) {
      this.fromBoundingRect(rect, transform4);
    }
  }
  OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform4) {
    var corners = this._corners;
    var axes = this._axes;
    var x2 = rect.x;
    var y2 = rect.y;
    var x22 = x2 + rect.width;
    var y22 = y2 + rect.height;
    corners[0].set(x2, y2);
    corners[1].set(x22, y2);
    corners[2].set(x22, y22);
    corners[3].set(x2, y22);
    if (transform4) {
      for (var i = 0; i < 4; i++) {
        corners[i].transform(transform4);
      }
    }
    Point$1.sub(axes[0], corners[1], corners[0]);
    Point$1.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (var i = 0; i < 2; i++) {
      this._origin[i] = axes[i].dot(corners[0]);
    }
  };
  OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
    var overlapped = true;
    var noMtv = !mtv;
    minTv.set(Infinity, Infinity);
    maxTv.set(0, 0);
    if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv) {
      Point$1.copy(mtv, overlapped ? minTv : maxTv);
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv2, maxTv2, noMtv, inverse) {
    var overlapped = true;
    for (var i = 0; i < 2; i++) {
      var axis = this._axes[i];
      this._getProjMinMaxOnAxis(i, self2._corners, extent);
      this._getProjMinMaxOnAxis(i, other._corners, extent2);
      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) > maxTv2.len()) {
          if (dist0 < dist1) {
            Point$1.scale(maxTv2, axis, -dist0 * inverse);
          } else {
            Point$1.scale(maxTv2, axis, dist1 * inverse);
          }
        }
      } else if (minTv2) {
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) < minTv2.len()) {
          if (dist0 < dist1) {
            Point$1.scale(minTv2, axis, dist0 * inverse);
          } else {
            Point$1.scale(minTv2, axis, -dist1 * inverse);
          }
        }
      }
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
    var axis = this._axes[dim];
    var origin = this._origin;
    var proj = corners[0].dot(axis) + origin[dim];
    var min5 = proj;
    var max4 = proj;
    for (var i = 1; i < corners.length; i++) {
      var proj_1 = corners[i].dot(axis) + origin[dim];
      min5 = Math.min(proj_1, min5);
      max4 = Math.max(proj_1, max4);
    }
    out2[0] = min5;
    out2[1] = max4;
  };
  return OrientedBoundingRect2;
}();
var OrientedBoundingRect$1 = OrientedBoundingRect;
var m = [];
var IncrementalDisplayable = function(_super) {
  __extends(IncrementalDisplayable2, _super);
  function IncrementalDisplayable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.notClear = true;
    _this.incremental = true;
    _this._displayables = [];
    _this._temporaryDisplayables = [];
    _this._cursor = 0;
    return _this;
  }
  IncrementalDisplayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  IncrementalDisplayable2.prototype.useStyle = function() {
    this.style = {};
  };
  IncrementalDisplayable2.prototype.getCursor = function() {
    return this._cursor;
  };
  IncrementalDisplayable2.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  };
  IncrementalDisplayable2.prototype.clearDisplaybles = function() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  };
  IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  };
  IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  };
  IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (var i = 0; i < displayables.length; i++) {
      this.addDisplayable(displayables[i], notPersistent);
    }
  };
  IncrementalDisplayable2.prototype.getDisplayables = function() {
    return this._displayables;
  };
  IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  };
  IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
    for (var i = this._cursor; i < this._displayables.length; i++) {
      cb && cb(this._displayables[i]);
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      cb && cb(this._temporaryDisplayables[i]);
    }
  };
  IncrementalDisplayable2.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var displayable = this._temporaryDisplayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  };
  IncrementalDisplayable2.prototype.getBoundingRect = function() {
    if (!this._rect) {
      var rect = new BoundingRect$1(Infinity, Infinity, -Infinity, -Infinity);
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        var childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  };
  IncrementalDisplayable2.prototype.contain = function(x2, y2) {
    var localPos = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        if (displayable.contain(x2, y2)) {
          return true;
        }
      }
    }
    return false;
  };
  return IncrementalDisplayable2;
}(Displayable$1);
var IncrementalDisplayable$1 = IncrementalDisplayable;
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  var animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === "update";
  if (animationEnabled) {
    var duration = void 0;
    var easing = void 0;
    var delay = void 0;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }
    if (isFunction(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }
    if (isFunction(duration)) {
      duration = duration(dataIndex);
    }
    var config = {
      duration: duration || 0,
      delay,
      easing
    };
    return config;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;
  if (isFunction(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject$3(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  var isRemove = animationType === "leave";
  if (!isRemove) {
    el.stopAnimation("leave");
  }
  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation();
    !isFrom && el.attr(props);
    during && during(1);
    cb && cb();
  }
}
function updateProps$1(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }
  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el)) {
    return;
  }
  animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  }
  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}
function getOldStyle(el) {
  return transitionStore(el).oldStyle;
}
var mathMax$6 = Math.max;
var mathMin$6 = Math.min;
var _customShapeMap = {};
function extendShape(opts) {
  return Path$1.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name2, ShapeClass) {
  _customShapeMap[name2] = ShapeClass;
}
function getShapeClass(name2) {
  if (_customShapeMap.hasOwnProperty(name2)) {
    return _customShapeMap[name2];
  }
}
function makePath(pathData, opts, rect, layout2) {
  var path = createFromString(pathData, opts);
  if (rect) {
    if (layout2 === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout2) {
  var zrImg = new ZRImage$1({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function(img) {
      if (layout2 === "center") {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath = mergePath$1;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  var pathRect = path.getBoundingRect();
  var m2 = pathRect.calculateTransform(rect);
  path.applyTransform(m2);
}
function subPixelOptimizeLine(shape, lineWidth) {
  subPixelOptimizeLine$1(shape, shape, {
    lineWidth
  });
  return shape;
}
function subPixelOptimizeRect(param) {
  subPixelOptimizeRect$1(param.shape, param.shape, param.style);
  return param;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform$1(target, ancestor) {
  var mat = identity([]);
  while (target && target !== ancestor) {
    mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform(target, transform4, invert$1) {
  if (transform4 && !isArrayLike(transform4)) {
    transform4 = Transformable$1.getLocalTransform(transform4);
  }
  if (invert$1) {
    transform4 = invert([], transform4);
  }
  return applyTransform$1([], target, transform4);
}
function transformDirection(direction, transform4, invert2) {
  var hBase = transform4[4] === 0 || transform4[5] === 0 || transform4[0] === 0 ? 1 : Math.abs(2 * transform4[4] / transform4[0]);
  var vBase = transform4[4] === 0 || transform4[5] === 0 || transform4[2] === 0 ? 1 : Math.abs(2 * transform4[4] / transform4[2]);
  var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
  vertex = applyTransform(vertex, transform4, invert2);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
  return !el.isGroup;
}
function isPath$1(el) {
  return el.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g) {
    var elMap = {};
    g.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    var obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };
    if (isPath$1(el)) {
      obj.shape = extend2({}, el.shape);
    }
    return obj;
  }
  var elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (isNotGroup(el) && el.anid) {
      var oldEl = elMap1[el.anid];
      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps$1(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points2, rect) {
  return map$1(points2, function(point4) {
    var x2 = point4[0];
    x2 = mathMax$6(x2, rect.x);
    x2 = mathMin$6(x2, rect.x + rect.width);
    var y2 = point4[1];
    y2 = mathMax$6(y2, rect.y);
    y2 = mathMin$6(y2, rect.y + rect.height);
    return [x2, y2];
  });
}
function clipRectByRect(targetRect, rect) {
  var x2 = mathMax$6(targetRect.x, rect.x);
  var x22 = mathMin$6(targetRect.x + targetRect.width, rect.x + rect.width);
  var y2 = mathMax$6(targetRect.y, rect.y);
  var y22 = mathMin$6(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x22 >= x2 && y22 >= y2) {
    return {
      x: x2,
      y: y2,
      width: x22 - x2,
      height: y22 - y2
    };
  }
}
function createIcon(iconStr, opt, rect) {
  var innerOpts = extend2({
    rectHover: true
  }, opt);
  var style = innerOpts.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage$1(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
  for (var i = 0, p2 = points2[points2.length - 1]; i < points2.length; i++) {
    var p = points2[i];
    if (lineLineIntersect$1(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
      return true;
    }
    p2 = p;
  }
}
function lineLineIntersect$1(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d$1(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q = crossProduct2d$1(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q < 0 || q > 1) {
    return false;
  }
  var p = crossProduct2d$1(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return false;
  }
  return true;
}
function crossProduct2d$1(x12, y12, x2, y2) {
  return x12 * y2 - x2 * y12;
}
function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}
function setTooltipConfig(opt) {
  var itemTooltipOption = opt.itemTooltipOption;
  var componentModel = opt.componentModel;
  var itemName = opt.itemName;
  var itemTooltipOptionObj = isString(itemTooltipOption) ? {
    formatter: itemTooltipOption
  } : itemTooltipOption;
  var mainType = componentModel.mainType;
  var componentIndex = componentModel.componentIndex;
  var formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  var formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each$f(keys2(formatterParamsExtra), function(key) {
      if (!hasOwn(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }
  var ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el, cb) {
  var stopped;
  if (el.isGroup) {
    stopped = cb(el);
  }
  if (!stopped) {
    el.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray$1(els)) {
      for (var i = 0; i < els.length; i++) {
        traverseElement(els[i], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
registerShape("circle", Circle$1);
registerShape("ellipse", Ellipse$1);
registerShape("sector", Sector$1);
registerShape("ring", Ring$1);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$3);
registerShape("rect", Rect$3);
registerShape("line", Line$3);
registerShape("bezierCurve", BezierCurve$1);
registerShape("arc", Arc$1);
var graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  updateProps: updateProps$1,
  initProps,
  removeElement,
  removeElementWithFadeOut,
  isElementRemoved,
  extendShape,
  extendPath,
  registerShape,
  getShapeClass,
  makePath,
  makeImage,
  mergePath,
  resizePath,
  subPixelOptimizeLine,
  subPixelOptimizeRect,
  subPixelOptimize,
  getTransform: getTransform$1,
  applyTransform,
  transformDirection,
  groupTransition,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  linePolygonIntersect,
  lineLineIntersect: lineLineIntersect$1,
  setTooltipConfig,
  traverseElements,
  Group: Group$4,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$3,
  Rect: Rect$3,
  Line: Line$3,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Point: Point$1,
  Path: Path$1
}, Symbol.toStringTag, { value: "Module" }));
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var text = labelTexts[stateName];
    var state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text;
  }
  var oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({
    text: labelTexts.normal
  });
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var normalModel = stateModels.normal;
  var baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  var statesText = {
    normal: baseText
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  var isSetOnText = targetEl instanceof ZRText$1;
  var needsCreateText = false;
  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateModel = labelStatesModels[DISPLAY_STATES[i]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new ZRText$1();
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    var labelStatesTexts = getLabelText(opt, labelStatesModels);
    var normalModel = labelStatesModels.normal;
    var showNormal = !!normalModel.getShallow("show");
    var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var stateModel = labelStatesModels[stateName];
      if (stateModel) {
        var stateObj = textContent.ensureState(stateName);
        var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          var targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  var statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  var textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend2(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  var textConfig = {};
  var labelPosition;
  var labelRotate = textStyleModel.getShallow("rotate");
  var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  var labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle;
  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;
  if (richItemNames) {
    richResult = {};
    for (var name_1 in richItemNames) {
      if (richItemNames.hasOwnProperty(name_1)) {
        var richTextStyle = textStyleModel.getModel(["rich", name_1]);
        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  var overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  var margin = textStyleModel.get("minMargin");
  if (margin != null) {
    textStyle.margin = margin;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  var richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      var richKeys = keys2(rich);
      for (var i = 0; i < richKeys.length; i++) {
        var richKey = richKeys[i];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign"];
var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  var inheritColor = opt && opt.inheritColor;
  var fillColor = textStyleModel.getShallow("color");
  var strokeColor = textStyleModel.getShallow("textBorderColor");
  var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    {
      if (fillColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    {
      if (strokeColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
    var key = TEXT_PROPS_WITH_GLOBAL[i];
    var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
    var key = TEXT_PROPS_SELF[i];
    var val = textStyleModel.getShallow(key);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  if (textStyle.verticalAlign == null) {
    var baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
      var key = TEXT_PROPS_BOX[i];
      var val = textStyleModel.getShallow(key);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    var borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      {
        if (textStyle.backgroundColor === "auto") {
          deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
        }
      }
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      {
        if (textStyle.borderColor === "auto") {
          deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
        }
      }
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim$1([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }
  var obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  var normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
  var labelInnerStore = labelInner(textEl);
  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
    return;
  }
  var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
  var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
  var targetValue = labelInnerStore.value;
  function during(percent) {
    var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
    var labelText = getLabelText({
      labelDataIndex: dataIndex,
      labelFetcher,
      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
    }, labelInnerStore.statesModels, interpolated);
    setLabelText(textEl, labelText);
  }
  textEl.percent = 0;
  (labelInnerStore.prevValue == null ? initProps : updateProps$1)(textEl, {
    percent: 1
  }, animatableModel, dataIndex, null, during);
}
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
var tmpText = new ZRText$1();
var TextStyleMixin = function() {
  function TextStyleMixin2() {
  }
  TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  };
  TextStyleMixin2.prototype.getFont = function() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  };
  TextStyleMixin2.prototype.getTextRect = function(text) {
    var style = {
      text,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (var i = 0; i < textStyleParams.length; i++) {
      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  };
  return TextStyleMixin2;
}();
var TextStyleMixin$1 = TextStyleMixin;
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
  function LineStyleMixin2() {
  }
  LineStyleMixin2.prototype.getLineStyle = function(excludes) {
    return getLineStyle(this, excludes);
  };
  return LineStyleMixin2;
}();
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
  function ItemStyleMixin2() {
  }
  ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes) {
    return getItemStyle(this, excludes, includes);
  };
  return ItemStyleMixin2;
}();
var Model = function() {
  function Model2(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model2.prototype.init = function(option, parentModel, ecModel) {
  };
  Model2.prototype.mergeOption = function(option, ecModel) {
    merge3(this.option, option, true);
  };
  Model2.prototype.get = function(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  };
  Model2.prototype.getShallow = function(key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];
    if (val == null && !ignoreParent) {
      var parentModel = this.parentModel;
      if (parentModel) {
        val = parentModel.getShallow(key);
      }
    }
    return val;
  };
  Model2.prototype.getModel = function(path, parentModel) {
    var hasPath = path != null;
    var pathFinal = hasPath ? this.parsePath(path) : null;
    var obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model2(obj, parentModel, this.ecModel);
  };
  Model2.prototype.isEmpty = function() {
    return this.option == null;
  };
  Model2.prototype.restoreData = function() {
  };
  Model2.prototype.clone = function() {
    var Ctor = this.constructor;
    return new Ctor(clone$4(this.option));
  };
  Model2.prototype.parsePath = function(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  };
  Model2.prototype.resolveParentPath = function(path) {
    return path;
  };
  Model2.prototype.isAnimationEnabled = function() {
    if (!env$1.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  };
  Model2.prototype._doGet = function(pathArr, parentModel) {
    var obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (var i = 0; i < pathArr.length; i++) {
      if (!pathArr[i]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  };
  return Model2;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, TextStyleMixin$1);
var Model$1 = Model;
var base = Math.round(Math.random() * 10);
function getUID(type) {
  return [type || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  var subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    var componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    var type = option.type;
    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var noEntryList = result.noEntryList;
    var targetNameSet = {};
    each$f(targetNameList, function(name2) {
      targetNameSet[name2] = true;
    });
    while (noEntryList.length) {
      var currComponentType = noEntryList.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each$f(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each$f(targetNameSet, function() {
      var errMsg = "";
      {
        errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
      }
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    each$f(fullNameList, function(name2) {
      var thisItem = createDependencyGraphItem(graph, name2);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name2);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name2);
      }
      each$f(availableDeps, function(dependentName) {
        if (indexOf2(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        var thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf2(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name2);
        }
      });
    });
    return {
      graph,
      noEntryList
    };
  }
  function createDependencyGraphItem(graph, name2) {
    if (!graph[name2]) {
      graph[name2] = {
        predecessor: [],
        successor: []
      };
    }
    return graph[name2];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    each$f(originalDeps, function(dep) {
      indexOf2(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge3(merge3({}, superOption, true), subOption, true);
}
var langEN = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};
var langZH = {
  time: {
    month: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
    monthAbbr: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
    dayOfWeek: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"],
    dayOfWeekAbbr: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]
  },
  legend: {
    selector: {
      all: "\u5168\u9009",
      inverse: "\u53CD\u9009"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "\u77E9\u5F62\u9009\u62E9",
        polygon: "\u5708\u9009",
        lineX: "\u6A2A\u5411\u9009\u62E9",
        lineY: "\u7EB5\u5411\u9009\u62E9",
        keep: "\u4FDD\u6301\u9009\u62E9",
        clear: "\u6E05\u9664\u9009\u62E9"
      }
    },
    dataView: {
      title: "\u6570\u636E\u89C6\u56FE",
      lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
    },
    dataZoom: {
      title: {
        zoom: "\u533A\u57DF\u7F29\u653E",
        back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
      }
    },
    magicType: {
      title: {
        line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
        bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
        stack: "\u5207\u6362\u4E3A\u5806\u53E0",
        tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
      }
    },
    restore: {
      title: "\u8FD8\u539F"
    },
    saveAsImage: {
      title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
      lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
    }
  },
  series: {
    typeNames: {
      pie: "\u997C\u56FE",
      bar: "\u67F1\u72B6\u56FE",
      line: "\u6298\u7EBF\u56FE",
      scatter: "\u6563\u70B9\u56FE",
      effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
      radar: "\u96F7\u8FBE\u56FE",
      tree: "\u6811\u56FE",
      treemap: "\u77E9\u5F62\u6811\u56FE",
      boxplot: "\u7BB1\u578B\u56FE",
      candlestick: "K\u7EBF\u56FE",
      k: "K\u7EBF\u56FE",
      heatmap: "\u70ED\u529B\u56FE",
      map: "\u5730\u56FE",
      parallel: "\u5E73\u884C\u5750\u6807\u56FE",
      lines: "\u7EBF\u56FE",
      graph: "\u5173\u7CFB\u56FE",
      sankey: "\u6851\u57FA\u56FE",
      funnel: "\u6F0F\u6597\u56FE",
      gauge: "\u4EEA\u8868\u76D8\u56FE",
      pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
      themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
      sunburst: "\u65ED\u65E5\u56FE"
    }
  },
  aria: {
    general: {
      withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
      withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
    },
    series: {
      single: {
        prefix: "",
        withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
        withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
      },
      multiple: {
        prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
        withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
        withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
        separator: {
          middle: "\uFF1B",
          end: "\u3002"
        }
      }
    },
    data: {
      allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
      partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
      withName: "{name}\u7684\u6570\u636E\u662F{value}",
      withoutName: "{value}",
      separator: {
        middle: "\uFF0C",
        end: ""
      }
    }
  }
};
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env$1.domSupported ? DEFAULT_LOCALE : function() {
  var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model$1(localeObj);
  localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
  if (isString(locale)) {
    var localeObj = localeStorage[locale.toUpperCase()] || {};
    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone$4(localeObj);
    } else {
      return merge3(clone$4(localeObj), clone$4(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge3(clone$4(locale), clone$4(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
};
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format(time, template, isUTC, lang) {
  var date = parseDate(time);
  var y2 = date[fullYearGetterName(isUTC)]();
  var M = date[monthGetterName(isUTC)]() + 1;
  var q = Math.floor((M - 1) / 3) + 1;
  var d = date[dateGetterName(isUTC)]();
  var e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  var H = date[hoursGetterName(isUTC)]();
  var h = (H - 1) % 12 + 1;
  var m2 = date[minutesGetterName(isUTC)]();
  var s = date[secondsGetterName(isUTC)]();
  var S = date[millisecondsGetterName(isUTC)]();
  var localeModel = lang instanceof Model$1 ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  var timeModel = localeModel.getModel("time");
  var month = timeModel.get("month");
  var monthAbbr = timeModel.get("monthAbbr");
  var dayOfWeek = timeModel.get("dayOfWeek");
  var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template || "").replace(/{yyyy}/g, y2 + "").replace(/{yy}/g, y2 % 100 + "").replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  var template = null;
  if (isString(formatter)) {
    template = formatter;
  } else if (isFunction(formatter)) {
    template = formatter(tick.value, idx, {
      level: tick.level
    });
  } else {
    var defaults$12 = extend2({}, defaultLeveledFormatter);
    if (tick.level > 0) {
      for (var i = 0; i < primaryTimeUnits.length; ++i) {
        defaults$12[primaryTimeUnits[i]] = "{primary|" + defaults$12[primaryTimeUnits[i]] + "}";
      }
    }
    var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults$12) : defaults$12;
    var unit = getUnitFromValue(tick.value, isUTC);
    if (mergedFormatter[unit]) {
      template = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      var targetId = timeUnits.indexOf(unit);
      for (var i = targetId - 1; i >= 0; --i) {
        if (mergedFormatter[unit]) {
          template = mergedFormatter[unit];
          break;
        }
      }
      template = template || defaults$12.none;
    }
    if (isArray$1(template)) {
      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
      levelId = Math.min(levelId, template.length - 1);
      template = template[levelId];
    }
  }
  return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  var date = parseDate(value);
  var M = date[monthGetterName(isUTC)]() + 1;
  var d = date[dateGetterName(isUTC)]();
  var h = date[hoursGetterName(isUTC)]();
  var m2 = date[minutesGetterName(isUTC)]();
  var s = date[secondsGetterName(isUTC)]();
  var S = date[millisecondsGetterName(isUTC)]();
  var isSecond = S === 0;
  var isMinute = isSecond && s === 0;
  var isHour = isMinute && m2 === 0;
  var isDay = isHour && h === 0;
  var isMonth = isDay && d === 1;
  var isYear = isMonth && M === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function getUnitValue(value, unit, isUTC) {
  var date = isNumber(value) ? parseDate(value) : value;
  unit = unit || getUnitFromValue(value, isUTC);
  switch (unit) {
    case "year":
      return date[fullYearGetterName(isUTC)]();
    case "half-year":
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
    case "month":
      return date[monthGetterName(isUTC)]();
    case "day":
      return date[dateGetterName(isUTC)]();
    case "half-day":
      return date[hoursGetterName(isUTC)]() / 24;
    case "hour":
      return date[hoursGetterName(isUTC)]();
    case "minute":
      return date[minutesGetterName(isUTC)]();
    case "second":
      return date[secondsGetterName(isUTC)]();
    case "millisecond":
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}
function addCommas(x2) {
  if (!isNumeric(x2)) {
    return isString(x2) ? x2 : "-";
  }
  var parts = (x2 + "").split(".");
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray = normalizeCssArray$1;
function makeValueReadable(value, valueType, useUTC) {
  var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim$1(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  var isTypeTime = valueType === "time";
  var isValueDate = value instanceof Date;
  if (isTypeTime || isValueDate) {
    var date = isTypeTime ? parseDate(value) : value;
    if (!isNaN(+date)) {
      return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
  }
  var numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList, encode2) {
  if (!isArray$1(paramsList)) {
    paramsList = [paramsList];
  }
  var seriesLen = paramsList.length;
  if (!seriesLen) {
    return "";
  }
  var $vars = paramsList[0].$vars || [];
  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }
  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode2 ? encodeHTML(val) : val);
    }
  }
  return tpl;
}
function formatTplSimple(tpl, param, encode2) {
  each$f(param, function(value, key) {
    tpl = tpl.replace("{" + key + "}", encode2 ? encodeHTML(value) : value);
  });
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  var opt = isString(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  var color = opt.color;
  var type = opt.type;
  extraCssText = opt.extraCssText;
  var renderMode = opt.renderMode || "html";
  if (!color) {
    return "";
  }
  if (renderMode === "html") {
    return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>';
  } else {
    var markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color
      }
    };
  }
}
function convertToColorString(color, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString(color) ? color : isObject$3(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link2, target) {
  if (target === "_blank" || target === "blank") {
    var blank = window.open();
    blank.opener = null;
    blank.location.href = link2;
  } else {
    window.open(link2, target);
  }
}
var each$e = each$f;
var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(orient2, group, gap, maxWidth, maxHeight) {
  var x2 = 0;
  var y2 = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  var currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;
    if (orient2 === "horizontal") {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x2 + moveX;
      if (nextX > maxWidth || child.newline) {
        x2 = 0;
        nextX = moveX;
        y2 += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y2 + moveY;
      if (nextY > maxHeight || child.newline) {
        x2 += currentLineMaxSize + gap;
        y2 = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x2;
    child.y = y2;
    child.markRedraw();
    orient2 === "horizontal" ? x2 = nextX + gap : y2 = nextY + gap;
  });
}
var box = boxLayout;
curry$1(boxLayout, "vertical");
curry$1(boxLayout, "horizontal");
function getAvailableSize(positionInfo, containerRect, margin) {
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var x2 = parsePercent(positionInfo.left, containerWidth);
  var y2 = parsePercent(positionInfo.top, containerHeight);
  var x22 = parsePercent(positionInfo.right, containerWidth);
  var y22 = parsePercent(positionInfo.bottom, containerHeight);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.left))) && (x2 = 0);
  (isNaN(x22) || isNaN(parseFloat(positionInfo.right))) && (x22 = containerWidth);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.top))) && (y2 = 0);
  (isNaN(y22) || isNaN(parseFloat(positionInfo.bottom))) && (y22 = containerHeight);
  margin = normalizeCssArray(margin || 0);
  return {
    width: Math.max(x22 - x2 - margin[1] - margin[3], 0),
    height: Math.max(y22 - y2 - margin[0] - margin[2], 0)
  };
}
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }
  var rect = new BoundingRect$1(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function positionElement(el, positionInfo, containerRect, margin, opt, out2) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || "all";
  out2 = out2 || el;
  out2.x = el.x;
  out2.y = el.y;
  if (!h && !v) {
    return false;
  }
  var rect;
  if (boundingMode === "raw") {
    rect = el.type === "group" ? new BoundingRect$1(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();
    if (el.needLocalTransform()) {
      var transform4 = el.getLocalTransform();
      rect = rect.clone();
      rect.applyTransform(transform4);
    }
  }
  var layoutRect = getLayoutRect(defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin);
  var dx = h ? layoutRect.x - rect.x : 0;
  var dy = v ? layoutRect.y - rect.y : 0;
  if (boundingMode === "raw") {
    out2.x = dx;
    out2.y = dy;
  } else {
    out2.x += dx;
    out2.y += dy;
  }
  if (out2 === el) {
    el.markRedraw();
  }
  return true;
}
function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject$3(layoutMode) ? layoutMode : layoutMode ? {
    type: layoutMode
  } : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  var ignoreSize = opt && opt.ignoreSize;
  !isArray$1(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge4(HV_NAMES[0], 0);
  var vResult = merge4(HV_NAMES[1], 1);
  copy8(HV_NAMES[0], targetOption, hResult);
  copy8(HV_NAMES[1], targetOption, vResult);
  function merge4(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each$e(names, function(name2) {
      merged[name2] = targetOption[name2];
    });
    each$e(names, function(name2) {
      hasProp(newOption, name2) && (newParams[name2] = merged[name2] = newOption[name2]);
      hasValue(newParams, name2) && newValueCount++;
      hasValue(merged, name2) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (var i = 0; i < names.length; i++) {
        var name_1 = names[i];
        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
          newParams[name_1] = targetOption[name_1];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name2) {
    return obj.hasOwnProperty(name2);
  }
  function hasValue(obj, name2) {
    return obj[name2] != null && obj[name2] !== "auto";
  }
  function copy8(names, target, source2) {
    each$e(names, function(name2) {
      target[name2] = source2[name2];
    });
  }
}
function getLayoutParams(source2) {
  return copyLayoutParams({}, source2);
}
function copyLayoutParams(target, source2) {
  source2 && target && each$e(LOCATION_PARAMS, function(name2) {
    source2.hasOwnProperty(name2) && (target[name2] = source2[name2]);
  });
  return target;
}
var inner$l = makeInner();
var ComponentModel = function(_super) {
  __extends$1(ComponentModel2, _super);
  function ComponentModel2(option, parentModel, ecModel) {
    var _this = _super.call(this, option, parentModel, ecModel) || this;
    _this.uid = getUID("ec_cpt_model");
    return _this;
  }
  ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    merge3(option, themeModel.get(this.mainType));
    merge3(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  ComponentModel2.prototype.mergeOption = function(option, ecModel) {
    merge3(this.option, option, true);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  };
  ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
  };
  ComponentModel2.prototype.getDefaultOption = function() {
    var ctor = this.constructor;
    if (!isExtendedClass(ctor)) {
      return ctor.defaultOption;
    }
    var fields = inner$l(this);
    if (!fields.defaultOption) {
      var optList = [];
      var clz = ctor;
      while (clz) {
        var opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      var defaultOption2 = {};
      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption2 = merge3(defaultOption2, optList[i], true);
      }
      fields.defaultOption = defaultOption2;
    }
    return fields.defaultOption;
  };
  ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
    var indexKey = mainType + "Index";
    var idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  };
  ComponentModel2.prototype.getBoxLayoutParams = function() {
    var boxLayoutModel = this;
    return {
      left: boxLayoutModel.get("left"),
      top: boxLayoutModel.get("top"),
      right: boxLayoutModel.get("right"),
      bottom: boxLayoutModel.get("bottom"),
      width: boxLayoutModel.get("width"),
      height: boxLayoutModel.get("height")
    };
  };
  ComponentModel2.prototype.getZLevelKey = function() {
    return "";
  };
  ComponentModel2.prototype.setZLevel = function(zlevel) {
    this.option.zlevel = zlevel;
  };
  ComponentModel2.protoInitialize = function() {
    var proto2 = ComponentModel2.prototype;
    proto2.type = "component";
    proto2.id = "";
    proto2.name = "";
    proto2.mainType = "";
    proto2.subType = "";
    proto2.componentIndex = 0;
  }();
  return ComponentModel2;
}(Model$1);
mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  var deps = [];
  each$f(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map$1(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && indexOf2(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var ComponentModel$1 = ComponentModel;
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var globalDefault = {
  darkMode: "auto",
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: false
};
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source2) {
  var encode2 = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode2;
  }
  var encodeItemName = [];
  var encodeSeriesName = [];
  var ecModel = seriesModel.ecModel;
  var datasetMap = innerGlobalModel(ecModel).datasetMap;
  var key = datasetModel.uid + "_" + source2.seriesLayoutBy;
  var baseCategoryDimIndex;
  var categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each$f(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    var coordDimInfo = isObject$3(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
      name: coordDimInfoLoose
    };
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode2[coordDimInfo.name] = [];
  });
  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
    categoryWayDim: categoryWayValueDimStart,
    valueWayDim: 0
  });
  each$f(coordDimensions, function(coordDimInfo, coordDimIdx) {
    var coordDimName = coordDimInfo.name;
    var count3 = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      var start2 = datasetRecord.valueWayDim;
      pushDim(encode2[coordDimName], start2, count3);
      pushDim(encodeSeriesName, start2, count3);
      datasetRecord.valueWayDim += count3;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode2[coordDimName], 0, count3);
      pushDim(encodeItemName, 0, count3);
    } else {
      var start2 = datasetRecord.categoryWayDim;
      pushDim(encode2[coordDimName], start2, count3);
      pushDim(encodeSeriesName, start2, count3);
      datasetRecord.categoryWayDim += count3;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (var i = 0; i < idxCount; i++) {
      dimIdxArr.push(idxFrom + i);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    var dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode2.itemName = encodeItemName);
  encodeSeriesName.length && (encode2.seriesName = encodeSeriesName);
  return encode2;
}
function makeSeriesEncodeForNameBased(seriesModel, source2, dimCount) {
  var encode2 = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode2;
  }
  var sourceFormat = source2.sourceFormat;
  var dimensionsDefine = source2.dimensionsDefine;
  var potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each$f(dimensionsDefine, function(dim, idx) {
      if ((isObject$3(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  var idxResult = function() {
    var idxRes0 = {};
    var idxRes1 = {};
    var guessRecords = [];
    for (var i = 0, len2 = Math.min(5, dimCount); i < len2; i++) {
      var guessResult = doGuessOrdinal(source2.data, sourceFormat, source2.seriesLayoutBy, dimensionsDefine, source2.startIndex, i);
      guessRecords.push(guessResult);
      var isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
        idxRes0.v = i;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
          idxRes1.v = i;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode2.value = [idxResult.v];
    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode2.itemName = [nameDimIndex];
    encode2.seriesName = [nameDimIndex];
  }
  return encode2;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  var thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source2, dimIndex) {
  return doGuessOrdinal(source2.data, source2.sourceFormat, source2.seriesLayoutBy, source2.dimensionsDefine, source2.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result;
  var maxLoop = 5;
  if (isTypedArray(data)) {
    return BE_ORDINAL.Not;
  }
  var dimName;
  var dimType;
  if (dimensionsDefine) {
    var dimDefItem = dimensionsDefine[dimIndex];
    if (isObject$3(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample2 = dataArrayRows[dimIndex];
      for (var i = 0; i < (sample2 || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample2[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
        var row = dataArrayRows[startIndex + i];
        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var dataObjectRows = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
      var item = dataObjectRows[i];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    var dataKeyedColumns = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    var sample2 = dataKeyedColumns[dimName];
    if (!sample2 || isTypedArray(sample2)) {
      return BE_ORDINAL.Not;
    }
    for (var i = 0; i < sample2.length && i < maxLoop; i++) {
      if ((result = detectValue(sample2[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var dataOriginal = data;
    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
      var item = dataOriginal[i];
      var val = getDataItemValue(item);
      if (!isArray$1(val)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val2) {
    var beStr = isString(val2);
    if (val2 != null && isFinite(val2) && val2 !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val2 !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
  assert(internalOptionCreatorMap.get(mainType) == null && creator);
  internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  var internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  var internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  {
    for (var i = 0; i < internalOptions.length; i++) {
      assert(isComponentIdInternal(internalOptions[i]));
    }
  }
  return newCmptOptionList.concat(internalOptions);
}
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = function() {
  function PaletteMixin2() {
  }
  PaletteMixin2.prototype.getColorFromPalette = function(name2, scope, requestNum) {
    var defaultPalette = normalizeToArray(this.get("color", true));
    var layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name2, scope, requestNum);
  };
  PaletteMixin2.prototype.clearColorPalette = function() {
    clearPalette(this, innerColor);
  };
  return PaletteMixin2;
}();
function getDecalFromPalette(ecModel, name2, scope, requestNum) {
  var defaultDecals = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name2, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
  var paletteNum = palettes.length;
  for (var i = 0; i < paletteNum; i++) {
    if (palettes[i].length > requestColorNum) {
      return palettes[i];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner2, defaultPalette, layeredPalette, name2, scope, requestNum) {
  scope = scope || that;
  var scopeFields = inner2(scope);
  var paletteIdx = scopeFields.paletteIdx || 0;
  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name2)) {
    return paletteNameMap[name2];
  }
  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  var pickedPaletteItem = palette[paletteIdx];
  if (name2) {
    paletteNameMap[name2] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner2) {
  inner2(that).paletteIdx = 0;
  inner2(that).paletteNameMap = {};
}
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
};
var BUILTIN_CHARTS_MAP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
};
var componetsMissingLogPrinted = {};
function checkMissingComponents(option) {
  each$f(option, function(componentOption, mainType) {
    if (!ComponentModel$1.hasClass(mainType)) {
      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];
      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
        error("Component " + mainType + " is used but not imported.\nimport { " + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + "]);");
        componetsMissingLogPrinted[componentImportName] = true;
      }
    }
  });
}
var GlobalModel = function(_super) {
  __extends$1(GlobalModel2, _super);
  function GlobalModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model$1(theme2);
    this._locale = new Model$1(locale);
    this._optionManager = optionManager;
  };
  GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
    {
      assert(option != null, "option is null/undefined");
      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
    }
    var innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
    this._resetOption(null, innerOpt);
  };
  GlobalModel2.prototype.resetOption = function(type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  };
  GlobalModel2.prototype._resetOption = function(type, opt) {
    var optionChanged = false;
    var optionManager = this._optionManager;
    if (!type || type === "recreate") {
      var baseOption = optionManager.mountOption(type === "recreate");
      {
        checkMissingComponents(baseOption);
      }
      if (!this.option || type === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      var timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type || type === "recreate" || type === "media") {
      var mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each$f(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  };
  GlobalModel2.prototype.mergeOption = function(option) {
    this._mergeOption(option, null);
  };
  GlobalModel2.prototype._mergeOption = function(newOption, opt) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var componentsCount = this._componentsCount;
    var newCmptTypes = [];
    var newCmptTypeMap = createHashMap();
    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each$f(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!ComponentModel$1.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone$4(componentOption) : merge3(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
        if (ComponentModel$1.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    ComponentModel$1.topologicalTravel(newCmptTypes, ComponentModel$1.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      var oldCmptList = componentsMap.get(mainType);
      var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel$1);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      var optionsByMainType = [];
      var cmptsByMainType = [];
      var cmptsCountByMainType = 0;
      var tooltipExists;
      var tooltipWarningLogged;
      each$f(mappingResult, function(resultItem, index2) {
        var componentModel = resultItem.existing;
        var newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          var isSeriesType = mainType === "series";
          var ComponentModelClass = ComponentModel$1.getClass(
            mainType,
            resultItem.keyInfo.subType,
            !isSeriesType
          );
          if (!ComponentModelClass) {
            {
              var subType = resultItem.keyInfo.subType;
              var seriesImportName = BUILTIN_CHARTS_MAP[subType];
              if (!componetsMissingLogPrinted[subType]) {
                componetsMissingLogPrinted[subType] = true;
                if (seriesImportName) {
                  error("Series " + subType + " is used but not imported.\nimport { " + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + "]);");
                } else {
                  error("Unkown series " + subType);
                }
              }
            }
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              {
                if (!tooltipWarningLogged) {
                  warn("Currently only one tooltip component is allowed.");
                  tooltipWarningLogged = true;
                }
              }
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            var extraOpt = extend2({
              componentIndex: index2
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend2(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  };
  GlobalModel2.prototype.getOption = function() {
    var option = clone$4(this.option);
    each$f(option, function(optInMainType, mainType) {
      if (ComponentModel$1.hasClass(mainType)) {
        var opts = normalizeToArray(optInMainType);
        var realLen = opts.length;
        var metNonInner = false;
        for (var i = realLen - 1; i >= 0; i--) {
          if (opts[i] && !isComponentIdInternal(opts[i])) {
            metNonInner = true;
          } else {
            opts[i] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  };
  GlobalModel2.prototype.getTheme = function() {
    return this._theme;
  };
  GlobalModel2.prototype.getLocaleModel = function() {
    return this._locale;
  };
  GlobalModel2.prototype.setUpdatePayload = function(payload) {
    this._payload = payload;
  };
  GlobalModel2.prototype.getUpdatePayload = function() {
    return this._payload;
  };
  GlobalModel2.prototype.getComponent = function(mainType, idx) {
    var list = this._componentsMap.get(mainType);
    if (list) {
      var cmpt = list[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (var i = 0; i < list.length; i++) {
          if (list[i]) {
            return list[i];
          }
        }
      }
    }
  };
  GlobalModel2.prototype.queryComponents = function(condition) {
    var mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    var index2 = condition.index;
    var id = condition.id;
    var name2 = condition.name;
    var cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    var result;
    if (index2 != null) {
      result = [];
      each$f(normalizeToArray(index2), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName("id", id, cmpts);
    } else if (name2 != null) {
      result = queryByIdOrName("name", name2, cmpts);
    } else {
      result = filter17(cmpts, function(cmpt) {
        return !!cmpt;
      });
    }
    return filterBySubType(result, condition);
  };
  GlobalModel2.prototype.findComponents = function(condition) {
    var query5 = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query5);
    var result = queryCond ? this.queryComponents(queryCond) : filter17(this._componentsMap.get(mainType), function(cmpt) {
      return !!cmpt;
    });
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q) {
      var indexAttr = mainType + "Index";
      var idAttr = mainType + "Id";
      var nameAttr = mainType + "Name";
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType,
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter17(res, condition.filter) : res;
    }
  };
  GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
    var componentsMap = this._componentsMap;
    if (isFunction(mainType)) {
      var ctxForAll_1 = cb;
      var cbForAll_1 = mainType;
      componentsMap.each(function(cmpts2, componentType) {
        for (var i2 = 0; cmpts2 && i2 < cmpts2.length; i2++) {
          var cmpt2 = cmpts2[i2];
          cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
        }
      });
    } else {
      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject$3(mainType) ? this.findComponents(mainType) : null;
      for (var i = 0; cmpts && i < cmpts.length; i++) {
        var cmpt = cmpts[i];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  };
  GlobalModel2.prototype.getSeriesByName = function(name2) {
    var nameStr = convertOptionIdName(name2, null);
    return filter17(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
    });
  };
  GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  };
  GlobalModel2.prototype.getSeriesByType = function(subType) {
    return filter17(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && oneSeries.subType === subType;
    });
  };
  GlobalModel2.prototype.getSeries = function() {
    return filter17(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries;
    });
  };
  GlobalModel2.prototype.getSeriesCount = function() {
    return this._componentsCount.get("series");
  };
  GlobalModel2.prototype.eachSeries = function(cb, context) {
    assertSeriesInitialized(this);
    each$f(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  };
  GlobalModel2.prototype.eachRawSeries = function(cb, context) {
    each$f(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  };
  GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
    assertSeriesInitialized(this);
    each$f(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  };
  GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
    return each$f(this.getSeriesByType(subType), cb, context);
  };
  GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  };
  GlobalModel2.prototype.getCurrentSeriesIndices = function() {
    return (this._seriesIndices || []).slice();
  };
  GlobalModel2.prototype.filterSeries = function(cb, context) {
    assertSeriesInitialized(this);
    var newSeriesIndices = [];
    each$f(this._seriesIndices, function(seriesRawIdx) {
      var series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  };
  GlobalModel2.prototype.restoreData = function(payload) {
    reCreateSeriesIndices(this);
    var componentsMap = this._componentsMap;
    var componentTypes = [];
    componentsMap.each(function(components, componentType) {
      if (ComponentModel$1.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    ComponentModel$1.topologicalTravel(componentTypes, ComponentModel$1.getAllClassMainTypes(), function(componentType) {
      each$f(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  };
  GlobalModel2.internalField = function() {
    reCreateSeriesIndices = function(ecModel) {
      var seriesIndices = ecModel._seriesIndices = [];
      each$f(ecModel._componentsMap.get("series"), function(series) {
        series && seriesIndices.push(series.componentIndex);
      });
      ecModel._seriesIndicesMap = createHashMap(seriesIndices);
    };
    assertSeriesInitialized = function(ecModel) {
      {
        if (!ecModel._seriesIndices) {
          throw new Error("Option should contains series.");
        }
      }
    };
    initBase = function(ecModel, baseOption) {
      ecModel.option = {};
      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
      ecModel._componentsMap = createHashMap({
        series: []
      });
      ecModel._componentsCount = createHashMap();
      var airaOption = baseOption.aria;
      if (isObject$3(airaOption) && airaOption.enabled == null) {
        airaOption.enabled = true;
      }
      mergeTheme(baseOption, ecModel._theme.option);
      merge3(baseOption, globalDefault, false);
      ecModel._mergeOption(baseOption, null);
    };
  }();
  return GlobalModel2;
}(Model$1);
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index2 = payload.seriesIndex;
    var id = payload.seriesId;
    var name_1 = payload.seriesName;
    return index2 != null && seriesModel.componentIndex !== index2 || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
  }
}
function mergeTheme(option, theme2) {
  var notMergeColorLayer = option.color && !option.colorLayer;
  each$f(theme2, function(themeItem, name2) {
    if (name2 === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!ComponentModel$1.hasClass(name2)) {
      if (typeof themeItem === "object") {
        option[name2] = !option[name2] ? clone$4(themeItem) : merge3(option[name2], themeItem, false);
      } else {
        if (option[name2] == null) {
          option[name2] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr, idOrName, cmpts) {
  if (isArray$1(idOrName)) {
    var keyMap_1 = createHashMap();
    each$f(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        var idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap_1.set(idOrNameItem, true);
      }
    });
    return filter17(cmpts, function(cmpt) {
      return cmpt && keyMap_1.get(cmpt[attr]);
    });
  } else {
    var idName_1 = convertOptionIdName(idOrName, null);
    return filter17(cmpts, function(cmpt) {
      return cmpt && idName_1 != null && cmpt[attr] === idName_1;
    });
  }
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter17(components, function(cmpt) {
    return cmpt && cmpt.subType === condition.subType;
  }) : components;
}
function normalizeSetOptionInput(opts) {
  var replaceMergeMainTypeMap = createHashMap();
  opts && each$f(normalizeToArray(opts.replaceMerge), function(mainType) {
    {
      assert(ComponentModel$1.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
    }
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin(GlobalModel, PaletteMixin);
var GlobalModel$1 = GlobalModel;
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = function() {
  function ExtensionAPI2(ecInstance) {
    each$f(availableMethods, function(methodName) {
      this[methodName] = bind$1(ecInstance[methodName], ecInstance);
    }, this);
  }
  return ExtensionAPI2;
}();
var ExtensionAPI$1 = ExtensionAPI;
var coordinateSystemCreators = {};
var CoordinateSystemManager = function() {
  function CoordinateSystemManager2() {
    this._coordinateSystems = [];
  }
  CoordinateSystemManager2.prototype.create = function(ecModel, api) {
    var coordinateSystems = [];
    each$f(coordinateSystemCreators, function(creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  };
  CoordinateSystemManager2.prototype.update = function(ecModel, api) {
    each$f(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  };
  CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
    return this._coordinateSystems.slice();
  };
  CoordinateSystemManager2.register = function(type, creator) {
    coordinateSystemCreators[type] = creator;
  };
  CoordinateSystemManager2.get = function(type) {
    return coordinateSystemCreators[type];
  };
  return CoordinateSystemManager2;
}();
var CoordinateSystem = CoordinateSystemManager;
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = function() {
  function OptionManager2(api) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api;
  }
  OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
    if (rawOption) {
      each$f(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each$f(normalizeToArray(rawOption.dataset), function(dataset) {
        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
      });
    }
    rawOption = clone$4(rawOption);
    var optionBackup = this._optionBackup;
    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  };
  OptionManager2.prototype.mountOption = function(isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone$4(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  };
  OptionManager2.prototype.getTimelineOption = function(ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone$4(
          timelineOptions[timelineModel.getCurrentIndex()]
        );
      }
    }
    return option;
  };
  OptionManager2.prototype.getMediaOption = function(ecModel) {
    var ecWidth = this._api.getWidth();
    var ecHeight = this._api.getHeight();
    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (var i = 0, len2 = mediaList.length; i < len2; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map$1(indices, function(index2) {
        return clone$4(index2 === -1 ? mediaDefault.option : mediaList[index2].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  };
  return OptionManager2;
}();
function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var declaredBaseOption = rawOption.baseOption;
  var timelineOnRoot = rawOption.timeline;
  var timelineOptionsOnRoot = rawOption.options;
  var mediaOnRoot = rawOption.media;
  var hasMedia = !!rawOption.media;
  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray$1(mediaOnRoot)) {
      each$f(mediaOnRoot, function(singleMedia) {
        {
          if (singleMedia && !singleMedia.option && isObject$3(singleMedia.query) && isObject$3(singleMedia.query.option)) {
            error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
          }
        }
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    } else {
      {
        error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
      }
    }
  }
  doPreprocess(baseOption);
  each$f(timelineOptionsOnRoot, function(option) {
    return doPreprocess(option);
  });
  each$f(mediaList, function(media) {
    return doPreprocess(media.option);
  });
  function doPreprocess(option) {
    each$f(optionPreprocessorFuncs2, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query5, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  var applicatable = true;
  each$f(query5, function(value, attr) {
    var matched = attr.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();
    if (!compare10(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}
function compare10(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager$1 = OptionManager;
var each$d = each$f;
var isObject$2 = isObject$3;
var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (var i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      {
        deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge3(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      {
        deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge3(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      {
        deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
      }
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      {
        deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
      }
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject$2(opt) && opt[propName];
  var textStyle = isObject$2(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    {
      deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
    }
    for (var i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
      var textPropName = TEXT_STYLE_OPTIONS[i];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject$2(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  var markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  var markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  var markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  var data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray(edgeData)) {
      for (var i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }
    each$f(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !isTypedArray(data)) {
    for (var i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;
    for (var i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    var mlData = markLine.data;
    for (var i = 0; i < mlData.length; i++) {
      if (isArray$1(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    each$f(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o) {
  return isArray$1(o) ? o : o ? [o] : [];
}
function toObj(o) {
  return (isArray$1(o) ? o[0] : o) || {};
}
function globalCompatStyle(option, isTheme) {
  each$d(toArr(option.series), function(seriesOpt) {
    isObject$2(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each$d(axes, function(axisName) {
    each$d(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each$d(toArr(option.parallel), function(parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each$d(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each$d(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
      {
        deprecateLog("name property in radar component has been changed to axisName");
      }
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
      {
        deprecateLog("nameGap property in radar component has been changed to axisNameGap");
      }
    }
    {
      each$d(radarOpt.indicator, function(indicatorOpt) {
        if (indicatorOpt.text) {
          deprecateReplaceLog("text", "name", "radar.indicator");
        }
      });
    }
  });
  each$d(toArr(option.geo), function(geoOpt) {
    if (isObject$2(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each$d(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each$d(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    var data = timelineOpt.data;
    isArray$1(data) && each$f(data, function(item) {
      if (isObject$3(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each$d(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each$d(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}
function get4(opt, path) {
  var pathArr = path.split(",");
  var obj = opt;
  for (var i = 0; i < pathArr.length; i++) {
    obj = obj && obj[pathArr[i]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set(opt, path, val, overwrite) {
  var pathArr = path.split(",");
  var obj = opt;
  var key;
  var i = 0;
  for (; i < pathArr.length - 1; i++) {
    key = pathArr[i];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[pathArr[i]] == null) {
    obj[pathArr[i]] = val;
  }
}
function compatLayoutProperties(option) {
  option && each$f(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(option) {
  var itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      var oldName = BAR_ITEM_STYLE_MAP[i][1];
      var newName = BAR_ITEM_STYLE_MAP[i][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
        {
          deprecateReplaceLog(oldName, newName);
        }
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    {
      deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
    }
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
    {
      deprecateReplaceLog("downplay", "blur", "sunburst");
    }
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      {
        deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
      }
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data, cb) {
  if (data) {
    for (var i = 0; i < data.length; i++) {
      cb(data[i]);
      data[i] && traverseTree(data[i].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each$f(option.series, function(seriesOpt) {
    if (!isObject$3(seriesOpt)) {
      return;
    }
    var seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
        {
          deprecateReplaceLog("clipOverflow", "clip", "line");
        }
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
        {
          deprecateReplaceLog("clockWise", "clockwise");
        }
      }
      compatPieLabel(seriesOpt.label);
      var data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          compatPieLabel(data[i]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          {
            deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
          }
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType2 === "gauge") {
      var pointerColor = get4(seriesOpt, "pointer.color");
      pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType2 === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      var data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i] === "object") {
            compatBarItemStyle(data[i]);
            compatBarItemStyle(data[i] && data[i].emphasis);
          }
        }
      }
    } else if (seriesType2 === "sunburst") {
      var highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
          {
            deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
          }
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType2 === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        {
          deprecateReplaceLog("mapType", "map", "map");
        }
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        {
          deprecateLog("`mapLocation` is not used anymore.");
        }
        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        {
          deprecateReplaceLog("hoverAnimation", "emphasis.scale");
        }
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each$f(COMPATITABLE_COMPONENTS, function(componentName) {
    var options = option[componentName];
    if (options) {
      if (!isArray$1(options)) {
        options = [options];
      }
      each$f(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}
function dataStack(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    var stack = seriesModel.get("stack");
    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data = seriesModel.getData();
      var stackInfo = {
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each$f(stackInfoList, function(targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
    targetData.modify(dims, function(v0, v12, dataIndex) {
      var sum2 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum2)) {
        return resultNaN;
      }
      var byValue;
      var stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      var stackedOver = NaN;
      for (var j = idxInStack - 1; j >= 0; j--) {
        var stackInfo = stackInfoList[j];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum2 >= 0 && val > 0 || stackStrategy === "samesign" && sum2 <= 0 && val < 0) {
            sum2 = addSafe(sum2, val);
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum2;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}
var SourceImpl = function() {
  function SourceImpl2(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (var i = 0; i < dimensionsDefine.length; i++) {
        var dim = dimensionsDefine[i];
        if (dim.type == null) {
          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
  return SourceImpl2;
}();
function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  var source2 = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone$4(thisMetaRawOption)
  });
  return source2;
}
function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source2) {
  return new SourceImpl({
    data: source2.data,
    sourceFormat: source2.sourceFormat,
    seriesLayoutBy: source2.seriesLayoutBy,
    dimensionsDefine: clone$4(source2.dimensionsDefine),
    startIndex: source2.startIndex,
    dimensionsDetectedCount: source2.dimensionsDetectedCount
  });
}
function detectSourceFormat(data) {
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray$1(data)) {
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (var i = 0, len2 = data.length; i < len2; i++) {
      var item = data[i];
      if (item == null) {
        continue;
      } else if (isArray$1(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject$3(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject$3(data)) {
    for (var key in data) {
      if (hasOwn(data, key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  var dimensionsDetectedCount;
  var startIndex;
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val) {
        if (val != null && val !== "-") {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val, index2) {
        dimensionsDefine[index2] = val != null ? val + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each$f(data, function(colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray$1(value0) && value0.length || 1;
  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    {
      assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
    }
  }
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data) {
  var firstIndex = 0;
  var obj;
  while (firstIndex < data.length && !(obj = data[firstIndex++])) {
  }
  if (obj) {
    var dimensions_1 = [];
    each$f(obj, function(value, key) {
      dimensions_1.push(key);
    });
    return dimensions_1;
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  var nameMap = createHashMap();
  return map$1(dimensionsDefine, function(rawItem, index2) {
    rawItem = isObject$3(rawItem) ? rawItem : {
      name: rawItem
    };
    var item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    var exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    var value0 = data[0] || [];
    for (var i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}
function shouldRetrieveDataByName(source2) {
  var sourceFormat = source2.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}
var _a, _b, _c;
var providerMethods;
var mountMethods;
var DefaultDataProvider = function() {
  function DefaultDataProvider2(sourceParam, dimSize) {
    var source2 = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source2;
    var data = this._data = source2.data;
    if (source2.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      {
        if (dimSize == null) {
          throw new Error("Typed array data must specify dimension size");
        }
      }
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }
    mountMethods(this, data, source2);
  }
  DefaultDataProvider2.prototype.getSource = function() {
    return this._source;
  };
  DefaultDataProvider2.prototype.count = function() {
    return 0;
  };
  DefaultDataProvider2.prototype.getItem = function(idx, out2) {
    return;
  };
  DefaultDataProvider2.prototype.appendData = function(newData) {
  };
  DefaultDataProvider2.prototype.clean = function() {
  };
  DefaultDataProvider2.protoInitialize = function() {
    var proto2 = DefaultDataProvider2.prototype;
    proto2.pure = false;
    proto2.persistent = true;
  }();
  DefaultDataProvider2.internalField = function() {
    var _a2;
    mountMethods = function(provider, data, source2) {
      var sourceFormat = source2.sourceFormat;
      var seriesLayoutBy = source2.seriesLayoutBy;
      var startIndex = source2.startIndex;
      var dimsDef = source2.dimensionsDefine;
      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
      {
        assert(methods, "Invalide sourceFormat: " + sourceFormat);
      }
      extend2(provider, methods);
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        provider.getItem = getItemForTypedArray;
        provider.count = countForTypedArray;
        provider.fillStorage = fillStorageForTypedArray;
      } else {
        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
        provider.getItem = bind$1(rawItemGetter, null, data, startIndex, dimsDef);
        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
        provider.count = bind$1(rawCounter, null, data, startIndex, dimsDef);
      }
    };
    var getItemForTypedArray = function(idx, out2) {
      idx = idx - this._offset;
      out2 = out2 || [];
      var data = this._data;
      var dimSize = this._dimSize;
      var offset = dimSize * idx;
      for (var i = 0; i < dimSize; i++) {
        out2[i] = data[offset + i];
      }
      return out2;
    };
    var fillStorageForTypedArray = function(start2, end2, storage2, extent3) {
      var data = this._data;
      var dimSize = this._dimSize;
      for (var dim = 0; dim < dimSize; dim++) {
        var dimExtent = extent3[dim];
        var min5 = dimExtent[0] == null ? Infinity : dimExtent[0];
        var max4 = dimExtent[1] == null ? -Infinity : dimExtent[1];
        var count3 = end2 - start2;
        var arr = storage2[dim];
        for (var i = 0; i < count3; i++) {
          var val = data[i * dimSize + dim];
          arr[start2 + i] = val;
          val < min5 && (min5 = val);
          val > max4 && (max4 = val);
        }
        dimExtent[0] = min5;
        dimExtent[1] = max4;
      }
    };
    var countForTypedArray = function() {
      return this._data ? this._data.length / this._dimSize : 0;
    };
    providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
      pure: true,
      appendData: function(newData) {
        var data = this._data;
        each$f(newData, function(newCol, key) {
          var oldCol = data[key] || (data[key] = []);
          for (var i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    }, _a2[SOURCE_FORMAT_ORIGINAL] = {
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        {
          assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
        }
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }, _a2);
    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }
  }();
  return DefaultDataProvider2;
}();
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx + startIndex];
}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
  idx += startIndex;
  var item = out2 || [];
  var data = rawData;
  for (var i = 0; i < data.length; i++) {
    var row = data[i];
    item[i] = row ? row[idx] : null;
  }
  return item;
}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
  var item = out2 || [];
  for (var i = 0; i < dimsDef.length; i++) {
    var dimName = dimsDef[i].name;
    {
      if (dimName == null) {
        throw new Error();
      }
    }
    var col = rawData[dimName];
    item[i] = col ? col[idx] : null;
  }
  return item;
}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  {
    assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
  return Math.max(0, rawData.length - startIndex);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
  var row = rawData[0];
  return row ? Math.max(0, row.length - startIndex) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
  var dimName = dimsDef[0].name;
  {
    if (dimName == null) {
      throw new Error();
    }
  }
  var col = rawData[dimName];
  return col ? col.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  {
    assert(method, 'Do not suppport count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
  return dataItem[property];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
  var value = getDataItemValue(dataItem);
  return !(value instanceof Array) ? value : value[dimIndex];
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(sourceFormat) {
  var method = rawSourceValueGetterMap[sourceFormat];
  {
    assert(method, 'Do not suppport get value on "' + sourceFormat + '".');
  }
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  var dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  var store = data.getStore();
  var sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    var dimIndex = data.getDimensionIndex(dim);
    var property = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
  } else {
    var result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
  function DataFormatMixin2() {
  }
  DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name2 = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var style = data.getItemVisual(dataIndex, "style");
    var color = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
    var borderColor = style && style.stroke;
    var mainType = this.mainType;
    var isSeries2 = mainType === "series";
    var userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries2 ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries2 ? this.id : null,
      seriesName: isSeries2 ? this.name : null,
      name: name2,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  };
  DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || "normal";
    var data = this.getData(dataType);
    var params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray$1(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter) {
      var itemModel = data.getItemModel(dataIndex);
      formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString(formatter)) {
      var str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        var len2 = dimStr.length;
        var dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
          {
            if (isNaN(dimLoose)) {
              error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
            }
          }
        }
        var val = retrieveRawValue(data, dataIndex, dimLoose);
        if (extendParams && isArray$1(extendParams.interpolatedValue)) {
          var dimIndex = data.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val != null ? val + "" : "";
      });
    }
  };
  DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  };
  DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return;
  };
  return DataFormatMixin2;
}();
function normalizeTooltipFormatResult(result) {
  var markupText;
  var markupFragment;
  if (isObject$3(result)) {
    if (result.type) {
      markupFragment = result;
    } else {
      {
        console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
      }
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}
function createTask(define2) {
  return new Task(define2);
}
var Task = function() {
  function Task2(define2) {
    define2 = define2 || {};
    this._reset = define2.reset;
    this._plan = define2.plan;
    this._count = define2.count;
    this._onDirty = define2.onDirty;
    this._dirty = true;
  }
  Task2.prototype.perform = function(performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    var planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val) {
      !(val >= 1) && (val = 1);
      return val;
    }
    var forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;
    if (upTask) {
      {
        assert(upTask._outputDueEnd != null);
      }
      this._dueEnd = upTask._outputDueEnd;
    } else {
      {
        assert(!this._progress || this._count);
      }
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      var start2 = this._dueIndex;
      var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        var progress = this._progress;
        if (isArray$1(progress)) {
          for (var i = 0; i < progress.length; i++) {
            this._doProgress(progress[i], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      {
        assert(outputDueEnd >= this._outputDueEnd);
      }
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  };
  Task2.prototype.dirty = function() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };
  Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
    iterator7.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator7.next
    }, this.context);
  };
  Task2.prototype._doReset = function(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray$1(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    var downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  };
  Task2.prototype.unfinished = function() {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  Task2.prototype.pipe = function(downTask) {
    {
      assert(downTask && !downTask._disposed && downTask !== this);
    }
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };
  Task2.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };
  Task2.prototype.getUpstream = function() {
    return this._upstream;
  };
  Task2.prototype.getDownstream = function() {
    return this._downstream;
  };
  Task2.prototype.setOutputEnd = function(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  };
  return Task2;
}();
var iterator7 = function() {
  var end2;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function(s, e2, sStep, sCount) {
      current = s;
      end2 = e2;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();
function parseDataValue(value, opt) {
  var dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value;
  }
  if (dimType === "time" && !isNumber(value) && value != null && value !== "-") {
    value = +parseDate(value);
  }
  return value == null || value === "" ? NaN : +value;
}
var valueParserMap = createHashMap({
  "number": function(val) {
    return parseFloat(val);
  },
  "time": function(val) {
    return +parseDate(val);
  },
  "trim": function(val) {
    return isString(val) ? trim$1(val) : val;
  }
});
function getRawValueParser(type) {
  return valueParserMap.get(type);
}
var ORDER_COMPARISON_OP_MAP = {
  lt: function(lval, rval) {
    return lval < rval;
  },
  lte: function(lval, rval) {
    return lval <= rval;
  },
  gt: function(lval, rval) {
    return lval > rval;
  },
  gte: function(lval, rval) {
    return lval >= rval;
  }
};
var FilterOrderComparator = function() {
  function FilterOrderComparator2(op, rval) {
    if (!isNumber(rval)) {
      var errMsg = "";
      {
        errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.';
      }
      throwError(errMsg);
    }
    this._opFn = ORDER_COMPARISON_OP_MAP[op];
    this._rvalFloat = numericToNumber(rval);
  }
  FilterOrderComparator2.prototype.evaluate = function(lval) {
    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
  };
  return FilterOrderComparator2;
}();
var SortOrderComparator = function() {
  function SortOrderComparator2(order, incomparable) {
    var isDesc = order === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  SortOrderComparator2.prototype.evaluate = function(lval, rval) {
    var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
    var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
    var lvalNotNumeric = isNaN(lvalFloat);
    var rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      var lvalIsStr = isString(lval);
      var rvalIsStr = isString(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  };
  return SortOrderComparator2;
}();
var FilterEqualityComparator = function() {
  function FilterEqualityComparator2(isEq, rval) {
    this._rval = rval;
    this._isEQ = isEq;
    this._rvalTypeof = typeof rval;
    this._rvalFloat = numericToNumber(rval);
  }
  FilterEqualityComparator2.prototype.evaluate = function(lval) {
    var eqResult = lval === this._rval;
    if (!eqResult) {
      var lvalTypeof = typeof lval;
      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
        eqResult = numericToNumber(lval) === this._rvalFloat;
      }
    }
    return this._isEQ ? eqResult : !eqResult;
  };
  return FilterEqualityComparator2;
}();
function createFilterComparator(op, rval) {
  return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
}
var ExternalSource = function() {
  function ExternalSource2() {
  }
  ExternalSource2.prototype.getRawData = function() {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.cloneRawData = function() {
    return;
  };
  ExternalSource2.prototype.getDimensionInfo = function(dim) {
    return;
  };
  ExternalSource2.prototype.cloneAllDimensionInfo = function() {
    return;
  };
  ExternalSource2.prototype.count = function() {
    return;
  };
  ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
    return;
  };
  ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
    return;
  };
  ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  };
  return ExternalSource2;
}();
function createExternalSource(internalSource, externalTransform) {
  var extSource = new ExternalSource();
  var data = internalSource.data;
  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  var sourceHeaderCount = internalSource.startIndex;
  var errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    {
      errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
    }
    throwError(errMsg);
  }
  var dimensions = [];
  var dimsByName = {};
  var dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each$f(dimsDef, function(dimDef, idx) {
      var name2 = dimDef.name;
      var dimDefExt = {
        index: idx,
        name: name2,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name2 != null) {
        var errMsg_1 = "";
        if (hasOwn(dimsByName, name2)) {
          {
            errMsg_1 = 'dimension name "' + name2 + '" duplicated.';
          }
          throwError(errMsg_1);
        }
        dimsByName[name2] = dimDefExt;
      }
    });
  } else {
    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
      dimensions.push({
        index: i
      });
    }
  }
  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind$1(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind$1(cloneRawData, null, internalSource);
  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind$1(rawCounter, null, data, sourceHeaderCount, dimensions);
  var rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    var dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind$1(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    {
      errMsg = "`getRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  var data = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    {
      errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var result = [];
    for (var i = 0, len2 = data.length; i < len2; i++) {
      result.push(data[i].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var result = [];
    for (var i = 0, len2 = data.length; i < len2; i++) {
      result.push(extend2({}, data[i]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone$4(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone$4(externalTransform);
  var type = externalTransform.type;
  var errMsg = "";
  if (!type) {
    {
      errMsg = "Must have a `type` when `registerTransform`.";
    }
    throwError(errMsg);
  }
  var typeParsed = type.split(":");
  if (typeParsed.length !== 2) {
    {
      errMsg = 'Name must include namespace like "ns:regression".';
    }
    throwError(errMsg);
  }
  var isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  var pipedTransOption = normalizeToArray(rawTransOption);
  var pipeLen = pipedTransOption.length;
  var errMsg = "";
  if (!pipeLen) {
    {
      errMsg = "If `transform` declared, it should at least contain one transform.";
    }
    throwError(errMsg);
  }
  for (var i = 0, len2 = pipeLen; i < len2; i++) {
    var transOption = pipedTransOption[i];
    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
    if (i !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  var errMsg = "";
  if (!upSourceList.length) {
    {
      errMsg = "Must have at least one upstream dataset.";
    }
    throwError(errMsg);
  }
  if (!isObject$3(transOption)) {
    {
      errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
    }
    throwError(errMsg);
  }
  var transType = transOption.type;
  var externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    {
      errMsg = 'Can not find transform on type "' + transType + '".';
    }
    throwError(errMsg);
  }
  var extUpSourceList = map$1(upSourceList, function(upSource) {
    return createExternalSource(upSource, externalTransform);
  });
  var resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone$4(transOption.config)
  }));
  {
    if (transOption.print) {
      var printStrArr = map$1(resultList, function(extSource) {
        var pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
        return ["=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===", "- transform result data:", makePrintable(extSource.data), "- transform result dimensions:", makePrintable(extSource.dimensions)].join("\n");
      }).join("\n");
      log(printStrArr);
    }
  }
  return map$1(resultList, function(result, resultIndex) {
    var errMsg2 = "";
    if (!isObject$3(result)) {
      {
        errMsg2 = "A transform should not return some empty results.";
      }
      throwError(errMsg2);
    }
    if (!result.data) {
      {
        errMsg2 = "Transform result data should be not be null or undefined";
      }
      throwError(errMsg2);
    }
    var sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      {
        errMsg2 = "Transform result data should be array rows or object rows.";
      }
      throwError(errMsg2);
    }
    var resultMetaRawOption;
    var firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      var startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  "float": CtorFloat64Array,
  "int": CtorInt32Array$1,
  "ordinal": Array,
  "number": Array,
  "time": CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append2) {
  var DataCtor = dataCtors[dimType || "float"];
  if (append2) {
    var oldStore = store[dimIdx];
    var oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      var newStore = new DataCtor(end2);
      for (var j = 0; j < oldLen; j++) {
        newStore[j] = oldStore[j];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore = function() {
  function DataStore2() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
    {
      assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
    }
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    var source2 = provider.getSource();
    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source2.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    var willRetrieveDataByName = shouldRetrieveDataByName(source2);
    this._dimensions = map$1(inputDimensions, function(dim) {
      {
        if (willRetrieveDataByName) {
          assert(dim.property != null);
        }
      }
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  };
  DataStore2.prototype.getProvider = function() {
    return this._provider;
  };
  DataStore2.prototype.getSource = function() {
    return this._provider.getSource();
  };
  DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
    var calcDimNameToIdx = this._calcDimNameToIdx;
    var dimensions = this._dimensions;
    var calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {
      type
    };
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  };
  DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
    var chunk = this._chunks[dimIdx];
    var dim = this._dimensions[dimIdx];
    var rawExtents = this._rawExtent;
    var offset = dim.ordinalOffset || 0;
    var len2 = chunk.length;
    if (offset === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    var dimRawExtent = rawExtents[dimIdx];
    for (var i = offset; i < len2; i++) {
      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
      if (!isNaN(val)) {
        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
      }
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  };
  DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
    var dimInfo = this._dimensions[dimIdx];
    var ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  };
  DataStore2.prototype.getDimensionProperty = function(dimIndex) {
    var item = this._dimensions[dimIndex];
    return item && item.property;
  };
  DataStore2.prototype.appendData = function(data) {
    {
      assert(!this._indices, "appendData can only be called on raw data.");
    }
    var provider = this._provider;
    var start2 = this.count();
    provider.appendData(data);
    var end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  };
  DataStore2.prototype.appendValues = function(values3, minFillLen) {
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start2 = this.count();
    var end2 = start2 + Math.max(values3.length, minFillLen || 0);
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      prepareStore(chunks, i, dim.type, end2, true);
    }
    var emptyDataItem = [];
    for (var idx = start2; idx < end2; idx++) {
      var sourceIdx = idx - start2;
      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        var dim = dimensions[dimIdx];
        var val = defaultDimValueGetters.arrayRows.call(this, values3[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        var dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }
    this._rawCount = this._count = end2;
    return {
      start: start2,
      end: end2
    };
  };
  DataStore2.prototype._initDataFromProvider = function(start2, end2, append2) {
    var provider = this._provider;
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var dimNames = map$1(dimensions, function(dim2) {
      return dim2.property;
    });
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      if (!rawExtent[i]) {
        rawExtent[i] = getInitialExtent();
      }
      prepareStore(chunks, i, dim.type, end2, append2);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      var dataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          var dimStorage = chunks[dimIdx];
          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val;
          var dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  };
  DataStore2.prototype.count = function() {
    return this._count;
  };
  DataStore2.prototype.get = function(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  };
  DataStore2.prototype.getValues = function(dimensions, idx) {
    var values3 = [];
    var dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (var i = 0; i < this._dimensions.length; i++) {
        dimArr.push(i);
      }
    } else {
      dimArr = dimensions;
    }
    for (var i = 0, len2 = dimArr.length; i < len2; i++) {
      values3.push(this.get(dimArr[i], idx));
    }
    return values3;
  };
  DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  };
  DataStore2.prototype.getSum = function(dim) {
    var dimData = this._chunks[dim];
    var sum2 = 0;
    if (dimData) {
      for (var i = 0, len2 = this.count(); i < len2; i++) {
        var value = this.get(dim, i);
        if (!isNaN(value)) {
          sum2 += value;
        }
      }
    }
    return sum2;
  };
  DataStore2.prototype.getMedian = function(dim) {
    var dimDataArray = [];
    this.each([dim], function(val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    var sortedDimDataArray = dimDataArray.sort(function(a, b) {
      return a - b;
    });
    var len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  };
  DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    var indices = this._indices;
    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    var left = 0;
    var right = this._count - 1;
    while (left <= right) {
      var mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  DataStore2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    var chunks = this._chunks;
    var dimData = chunks[dim];
    var nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0;
    for (var i = 0, len2 = this.count(); i < len2; i++) {
      var dataIndex = this.getRawIndex(i);
      var diff2 = value - dimData[dataIndex];
      var dist3 = Math.abs(diff2);
      if (dist3 <= maxDistance) {
        if (dist3 < minDist || dist3 === minDist && diff2 >= 0 && minDiff < 0) {
          minDist = dist3;
          minDiff = diff2;
          nearestIndicesLen = 0;
        }
        if (diff2 === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  DataStore2.prototype.getIndices = function() {
    var newIndices;
    var indices = this._indices;
    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (var i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }
    return newIndices;
  };
  DataStore2.prototype.filter = function(dims, cb) {
    if (!this._count) {
      return this;
    }
    var newStore = this.clone();
    var count3 = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(count3);
    var value = [];
    var dimSize = dims.length;
    var offset = 0;
    var dim0 = dims[0];
    var chunks = newStore._chunks;
    for (var i = 0; i < count3; i++) {
      var keep = void 0;
      var rawIdx = newStore.getRawIndex(i);
      if (dimSize === 0) {
        keep = cb(i);
      } else if (dimSize === 1) {
        var val = chunks[dim0][rawIdx];
        keep = cb(val, i);
      } else {
        var k = 0;
        for (; k < dimSize; k++) {
          value[k] = chunks[dims[k]][rawIdx];
        }
        value[k] = i;
        keep = cb.apply(null, value);
      }
      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    }
    if (offset < count3) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.selectRange = function(range) {
    var newStore = this.clone();
    var len2 = newStore._count;
    if (!len2) {
      return this;
    }
    var dims = keys2(range);
    var dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    var originalCount = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(originalCount);
    var offset = 0;
    var dim0 = dims[0];
    var min5 = range[dim0][0];
    var max4 = range[dim0][1];
    var storeArr = newStore._chunks;
    var quickFinished = false;
    if (!newStore._indices) {
      var idx = 0;
      if (dimSize === 1) {
        var dimStorage = storeArr[dims[0]];
        for (var i = 0; i < len2; i++) {
          var val = dimStorage[i];
          if (val >= min5 && val <= max4 || isNaN(val)) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = storeArr[dims[0]];
        var dimStorage2 = storeArr[dims[1]];
        var min23 = range[dims[1]][0];
        var max23 = range[dims[1]][1];
        for (var i = 0; i < len2; i++) {
          var val = dimStorage[i];
          var val2 = dimStorage2[i];
          if ((val >= min5 && val <= max4 || isNaN(val)) && (val2 >= min23 && val2 <= max23 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i = 0; i < originalCount; i++) {
          var rawIndex = newStore.getRawIndex(i);
          var val = storeArr[dims[0]][rawIndex];
          if (val >= min5 && val <= max4 || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (var i = 0; i < originalCount; i++) {
          var keep = true;
          var rawIndex = newStore.getRawIndex(i);
          for (var k = 0; k < dimSize; k++) {
            var dimk = dims[k];
            var val = storeArr[dimk][rawIndex];
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset++] = newStore.getRawIndex(i);
          }
        }
      }
    }
    if (offset < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.map = function(dims, cb) {
    var target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  };
  DataStore2.prototype.modify = function(dims, cb) {
    this._updateDims(this, dims, cb);
  };
  DataStore2.prototype._updateDims = function(target, dims, cb) {
    var targetChunks = target._chunks;
    var tmpRetValue = [];
    var dimSize = dims.length;
    var dataCount = target.count();
    var values3 = [];
    var rawExtent = target._rawExtent;
    for (var i = 0; i < dims.length; i++) {
      rawExtent[dims[i]] = getInitialExtent();
    }
    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      var rawIndex = target.getRawIndex(dataIndex);
      for (var k = 0; k < dimSize; k++) {
        values3[k] = targetChunks[dims[k]][rawIndex];
      }
      values3[dimSize] = dataIndex;
      var retValue = cb && cb.apply(null, values3);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (var i = 0; i < retValue.length; i++) {
          var dim = dims[i];
          var val = retValue[i];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  };
  DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var dimStore = targetStorage[valueDimension];
    var len2 = this.count();
    var sampledIndex = 0;
    var frameSize = Math.floor(1 / rate);
    var currentRawIndex = this.getRawIndex(0);
    var maxArea;
    var area5;
    var nextRawIndex;
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
    newIndices[sampledIndex++] = currentRawIndex;
    for (var i = 1; i < len2 - 1; i += frameSize) {
      var nextFrameStart = Math.min(i + frameSize, len2 - 1);
      var nextFrameEnd = Math.min(i + frameSize * 2, len2);
      var avgX = (nextFrameEnd + nextFrameStart) / 2;
      var avgY = 0;
      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y2 = dimStore[rawIndex];
        if (isNaN(y2)) {
          continue;
        }
        avgY += y2;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      var frameStart = i;
      var frameEnd = Math.min(i + frameSize, len2);
      var pointAX = i - 1;
      var pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      var firstNaNIndex = -1;
      var countNaN = 0;
      for (var idx = frameStart; idx < frameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y2 = dimStore[rawIndex];
        if (isNaN(y2)) {
          countNaN++;
          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }
          continue;
        }
        area5 = Math.abs((pointAX - avgX) * (y2 - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area5 > maxArea) {
          maxArea = area5;
          nextRawIndex = rawIndex;
        }
      }
      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  };
  DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var target = this.clone([dimension], true);
    var targetStorage = target._chunks;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len2 = this.count();
    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    var offset = 0;
    for (var i = 0; i < len2; i += frameSize) {
      if (frameSize > len2 - i) {
        frameSize = len2 - i;
        frameValues.length = frameSize;
      }
      for (var k = 0; k < frameSize; k++) {
        var dataIdx = this.getRawIndex(i + k);
        frameValues[k] = dimStore[dataIdx];
      }
      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset++] = sampleFrameIdx;
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype.each = function(dims, cb) {
    if (!this._count) {
      return;
    }
    var dimSize = dims.length;
    var chunks = this._chunks;
    for (var i = 0, len2 = this.count(); i < len2; i++) {
      var rawIdx = this.getRawIndex(i);
      switch (dimSize) {
        case 0:
          cb(i);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
          break;
        default:
          var k = 0;
          var value = [];
          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          }
          value[k] = i;
          cb.apply(null, value);
      }
    }
  };
  DataStore2.prototype.getDataExtent = function(dim) {
    var dimData = this._chunks[dim];
    var initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    var currEnd = this.count();
    var useRaw = !this._indices;
    var dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    var min5 = dimExtent[0];
    var max4 = dimExtent[1];
    for (var i = 0; i < currEnd; i++) {
      var rawIdx = this.getRawIndex(i);
      var value = dimData[rawIdx];
      value < min5 && (min5 = value);
      value > max4 && (max4 = value);
    }
    dimExtent = [min5, max4];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  DataStore2.prototype.getRawDataItem = function(idx) {
    var rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      var val = [];
      var chunks = this._chunks;
      for (var i = 0; i < chunks.length; i++) {
        val.push(chunks[i][rawIdx]);
      }
      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  };
  DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
    var target = new DataStore2();
    var chunks = this._chunks;
    var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (var i = 0; i < chunks.length; i++) {
        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype._copyCommonProps = function(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone$4(this._extent);
    target._rawExtent = clone$4(this._rawExtent);
  };
  DataStore2.prototype._cloneIndices = function() {
    if (this._indices) {
      var Ctor = this._indices.constructor;
      var indices = void 0;
      if (Ctor === Array) {
        var thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          indices[i] = this._indices[i];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  };
  DataStore2.prototype._getRawIdxIdentity = function(idx) {
    return idx;
  };
  DataStore2.prototype._getRawIdx = function(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  };
  DataStore2.prototype._updateGetRawIdx = function() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  };
  DataStore2.internalField = function() {
    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
    }
    defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, property, dataIndex, dimIndex) {
        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, property, dataIndex, dimIndex) {
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
      },
      typedArray: function(dataItem, property, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
  }();
  return DataStore2;
}();
var SourceManager = function() {
  function SourceManager2(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  SourceManager2.prototype.dirty = function() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  };
  SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  };
  SourceManager2.prototype._getVersionSign = function() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  };
  SourceManager2.prototype.prepareSource = function() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  };
  SourceManager2.prototype._createSource = function() {
    this._setLocalSource([], []);
    var sourceHost = this._sourceHost;
    var upSourceMgrList = this._getUpstreamSourceManagers();
    var hasUpstream = !!upSourceMgrList.length;
    var resultSourceList;
    var upstreamSignList;
    if (isSeries(sourceHost)) {
      var seriesModel = sourceHost;
      var data = void 0;
      var sourceFormat = void 0;
      var upSource = void 0;
      if (hasUpstream) {
        var upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data = seriesModel.get("data", true);
        sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      var newMetaRawOption = this._getSourceMetaRawOption() || {};
      var upMetaRawOption = upSource && upSource.metaRawOption || {};
      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {
        seriesLayoutBy,
        sourceHeader,
        dimensions
      }, sourceFormat)] : [];
    } else {
      var datasetModel = sourceHost;
      if (hasUpstream) {
        var result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        var sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    {
      assert(resultSourceList && upstreamSignList);
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  };
  SourceManager2.prototype._applyTransform = function(upMgrList) {
    var datasetModel = this._sourceHost;
    var transformOption = datasetModel.get("transform", true);
    var fromTransformResult = datasetModel.get("fromTransformResult", true);
    {
      assert(fromTransformResult != null || transformOption != null);
    }
    if (fromTransformResult != null) {
      var errMsg = "";
      if (upMgrList.length !== 1) {
        {
          errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
        }
        doThrow(errMsg);
      }
    }
    var sourceList;
    var upSourceList = [];
    var upstreamSignList = [];
    each$f(upMgrList, function(upMgr) {
      upMgr.prepareSource();
      var upSource = upMgr.getSource(fromTransformResult || 0);
      var errMsg2 = "";
      if (fromTransformResult != null && !upSource) {
        {
          errMsg2 = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
        }
        doThrow(errMsg2);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {
        datasetIndex: datasetModel.componentIndex
      });
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {
      sourceList,
      upstreamSignList
    };
  };
  SourceManager2.prototype._isDirty = function() {
    if (this._dirty) {
      return true;
    }
    var upSourceMgrList = this._getUpstreamSourceManagers();
    for (var i = 0; i < upSourceMgrList.length; i++) {
      var upSrcMgr = upSourceMgrList[i];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  };
  SourceManager2.prototype.getSource = function(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    var source2 = this._sourceList[sourceIndex];
    if (!source2) {
      var upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source2;
  };
  SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
    {
      assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
    }
    var schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  };
  SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
    var sourceIndex = 0;
    var storeList = this._storeList;
    var cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    var cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      var upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore();
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  };
  SourceManager2.prototype._getUpstreamSourceManagers = function() {
    var sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
        return datasetModel2.getSourceManager();
      });
    }
  };
  SourceManager2.prototype._getSourceMetaRawOption = function() {
    var sourceHost = this._sourceHost;
    var seriesLayoutBy;
    var sourceHeader;
    var dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      var model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {
      seriesLayoutBy,
      sourceHeader,
      dimensions
    };
  };
  return SourceManager2;
}();
function disableTransformOptionMerge(datasetModel) {
  var transformOption = datasetModel.option.transform;
  transformOption && setAsPrimitive(datasetModel.option.transform);
}
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipTextStyle(textStyle, renderMode) {
  var nameFontColor = textStyle.color || "#6e7079";
  var nameFontSize = textStyle.fontSize || 12;
  var nameFontWeight = textStyle.fontWeight || "400";
  var valueFontColor = textStyle.color || "#464646";
  var valueFontSize = textStyle.fontSize || 14;
  var valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
      valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    var gapLevel_1 = 0;
    var subBlockLen = frag.blocks.length;
    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each$f(frag.blocks, function(subBlock) {
      var subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel_1) {
        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel_1;
  }
  return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var noHeader = fragment.noHeader;
  var gaps = getGap(getBlockGapLevel(fragment));
  var subMarkupTextList = [];
  var subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray$1(subBlocks));
  subBlocks = subBlocks || [];
  var orderMode = ctx.orderMode;
  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    var orderMap = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn(orderMap, orderMode)) {
      var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort(function(a, b) {
        return comparator_1.evaluate(a.sortParam, b.sortParam);
      });
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each$f(subBlocks, function(subBlock, idx) {
    var valueFormatter = fragment.valueFormatter;
    var subMarkupText2 = getBuilder(subBlock)(
      valueFormatter ? extend2(extend2({}, ctx), {
        valueFormatter
      }) : ctx,
      subBlock,
      idx > 0 ? gaps.html : 0,
      toolTipTextStyle
    );
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML('<div style="' + nameStyle + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var renderMode = ctx.renderMode;
  var noName = fragment.noName;
  var noValue = fragment.noValue;
  var noMarker = !fragment.markerType;
  var name2 = fragment.name;
  var useUTC = ctx.useUTC;
  var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
    value = isArray$1(value) ? value : [value];
    return map$1(value, function(val, idx) {
      return makeValueReadable(val, isArray$1(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
    });
  };
  if (noName && noValue) {
    return;
  }
  var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
  var readableName = noName ? "" : makeValueReadable(name2, "ordinal", useUTC);
  var valueTypeOption = fragment.valueType;
  var readableValueList = noValue ? [] : valueFormatter(fragment.value);
  var valueAlignRight = !noMarker || !noName;
  var valueCloseToMarker = !noMarker && noName;
  var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }
  var builder = getBuilder(fragment);
  var ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(encodedContent, topGap) {
  var clearfix = '<div style="clear:both"></div>';
  var marginCSS = "margin: " + topGap + "px 0 0";
  return '<div style="' + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name2, leftHasMarker, style) {
  var marginCss = leftHasMarker ? "margin-left:2px" : "";
  return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name2) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  var paddingStr = valueCloseToMarker ? "10px" : "20px";
  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
  valueList = isArray$1(valueList) ? valueList : [valueList];
  return '<span style="' + alignCSS + ";" + style + '">' + map$1(valueList, function(value) {
    return encodeHTML(value);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name2, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name2, style);
}
function wrapInlineValueRichText(ctx, values3, alignRight, valueCloseToMarker, style) {
  var styles = [style];
  var paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({
    padding: [0, 0, 0, paddingLeft],
    align: "right"
  });
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray$1(values3) ? values3.join("  ") : values3, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  var style = series.getData().getItemVisual(dataIndex, "style");
  var color = style[series.visualDrawType];
  return convertToColorString(color);
}
function getPaddingFromTooltipModel(model, renderMode) {
  var padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = function() {
  function TooltipMarkupStyleCreator2() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  };
  TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
    var markerId = renderMode === "richText" ? this._generateStyleName() : null;
    var marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString(marker)) {
      return marker;
    } else {
      {
        assert(markerId);
      }
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  };
  TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text, styles) {
    var finalStl = {};
    if (isArray$1(styles)) {
      each$f(styles, function(stl) {
        return extend2(finalStl, stl);
      });
    } else {
      extend2(finalStl, styles);
    }
    var styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return "{" + styleName + "|" + text + "}";
  };
  return TooltipMarkupStyleCreator2;
}();
function defaultSeriesFormatTooltip(opt) {
  var series = opt.series;
  var dataIndex = opt.dataIndex;
  var multipleSeries = opt.multipleSeries;
  var data = series.getData();
  var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
  var tooltipDimLen = tooltipDims.length;
  var value = series.getRawValue(dataIndex);
  var isValueArr = isArray$1(value);
  var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  var inlineValue;
  var inlineValueType;
  var subBlocks;
  var sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    var dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  }
  var seriesNameSpecified = isNameSpecified(series);
  var seriesName = seriesNameSpecified && series.name || "";
  var itemName = data.getName(dataIndex);
  var inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor,
      name: inlineName,
      noName: !trim$1(inlineName),
      value: inlineValue,
      valueType: inlineValueType
    })].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  var data = series.getData();
  var isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
    var dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  var inlineValues = [];
  var inlineValueTypes = [];
  var blocks = [];
  tooltipDims.length ? each$f(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) : each$f(value, setEachItem);
  function setEachItem(val, dim) {
    var dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {
    inlineValues,
    inlineValueTypes,
    blocks
  };
}
var inner$k = makeInner();
function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
  __extends$1(SeriesModel2, _super);
  function SeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._selectedDataIndicesMap = {};
    return _this;
  }
  SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    var sourceManager = inner$k(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    {
      assert(data, "getInitialData returned invalid data.");
    }
    inner$k(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeSubType = this.subType;
    if (ComponentModel$1.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge3(option, ecModel.getTheme().get(this.subType));
    merge3(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
    newSeriesOption = merge3(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    var sourceManager = inner$k(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner$k(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.fillDataTextStyle = function(data) {
    if (data && !isTypedArray(data)) {
      var props = ["show"];
      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          defaultEmphasis(data[i], "label", props);
        }
      }
    }
  };
  SeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return;
  };
  SeriesModel2.prototype.appendData = function(params) {
    var data = this.getRawData();
    data.appendData(params.data);
  };
  SeriesModel2.prototype.getData = function(dataType) {
    var task = getCurrentTask(this);
    if (task) {
      var data = task.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      return inner$k(this).data;
    }
  };
  SeriesModel2.prototype.getAllData = function() {
    var mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
      data: mainData
    }];
  };
  SeriesModel2.prototype.setData = function(data) {
    var task = getCurrentTask(this);
    if (task) {
      var context = task.context;
      context.outputData = data;
      if (task !== this.dataTask) {
        context.data = data;
      }
    }
    inner$k(this).data = data;
  };
  SeriesModel2.prototype.getEncode = function() {
    var encode2 = this.get("encode", true);
    if (encode2) {
      return createHashMap(encode2);
    }
  };
  SeriesModel2.prototype.getSourceManager = function() {
    return inner$k(this).sourceManager;
  };
  SeriesModel2.prototype.getSource = function() {
    return this.getSourceManager().getSource();
  };
  SeriesModel2.prototype.getRawData = function() {
    return inner$k(this).dataBeforeProcessed;
  };
  SeriesModel2.prototype.getColorBy = function() {
    var colorBy = this.get("colorBy");
    return colorBy || "series";
  };
  SeriesModel2.prototype.isColorBySeries = function() {
    return this.getColorBy() === "series";
  };
  SeriesModel2.prototype.getBaseAxis = function() {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  };
  SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  };
  SeriesModel2.prototype.isAnimationEnabled = function() {
    var ecModel = this.ecModel;
    if (env$1.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    var animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  };
  SeriesModel2.prototype.restoreData = function() {
    this.dataTask.dirty();
  };
  SeriesModel2.prototype.getColorFromPalette = function(name2, scope, requestColorNum) {
    var ecModel = this.ecModel;
    var color = PaletteMixin.prototype.getColorFromPalette.call(this, name2, scope, requestColorNum);
    if (!color) {
      color = ecModel.getColorFromPalette(name2, scope, requestColorNum);
    }
    return color;
  };
  SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  };
  SeriesModel2.prototype.getProgressive = function() {
    return this.get("progressive");
  };
  SeriesModel2.prototype.getProgressiveThreshold = function() {
    return this.get("progressiveThreshold");
  };
  SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  };
  SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    var selectedMode = this.option.selectedMode;
    var data = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (var i = 0; i < innerDataIndices.length; i++) {
      var dataIndex = innerDataIndices[i];
      var nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  };
  SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
    var tmpArr2 = [];
    for (var i = 0; i < innerDataIndices.length; i++) {
      tmpArr2[0] = innerDataIndices[i];
      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
    }
  };
  SeriesModel2.prototype.getSelectedDataIndices = function() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    var selectedDataIndicesMap = this._selectedDataIndicesMap;
    var nameOrIds = keys2(selectedDataIndicesMap);
    var dataIndices = [];
    for (var i = 0; i < nameOrIds.length; i++) {
      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  };
  SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    var data = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
  };
  SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    var universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  };
  SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
    var _a2, _b2;
    var option = this.option;
    var selectedMode = option.selectedMode;
    var len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject$3(option.selectedMap)) {
        option.selectedMap = {};
      }
      var selectedMap = option.selectedMap;
      for (var i = 0; i < len2; i++) {
        var dataIndex = innerDataIndices[i];
        var nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      var lastDataIndex = innerDataIndices[len2 - 1];
      var nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
      this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
    }
  };
  SeriesModel2.prototype._initSelectedMapFromData = function(data) {
    if (this.option.selectedMap) {
      return;
    }
    var dataIndices = [];
    if (data.hasItemOption) {
      data.each(function(idx) {
        var rawItem = data.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  };
  SeriesModel2.registerClass = function(clz) {
    return ComponentModel$1.registerClass(clz);
  };
  SeriesModel2.protoInitialize = function() {
    var proto2 = SeriesModel2.prototype;
    proto2.type = "series.__base__";
    proto2.seriesIndex = 0;
    proto2.ignoreStyleOnData = false;
    proto2.hasSymbolVisual = false;
    proto2.defaultSymbol = "circle";
    proto2.visualStyleAccessPath = "itemStyle";
    proto2.visualDrawType = "fill";
  }();
  return SeriesModel2;
}(ComponentModel$1);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
function autoSeriesName(seriesModel) {
  var name2 = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name2;
  }
}
function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimensionsAll("seriesName");
  var nameArr = [];
  each$f(dataDims, function(dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  each$f(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
    data.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  var task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    var task = pipeline.currentTask;
    if (task) {
      var agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var SeriesModel$1 = SeriesModel;
var ComponentView = function() {
  function ComponentView2() {
    this.group = new Group$4();
    this.uid = getUID("viewComponent");
  }
  ComponentView2.prototype.init = function(ecModel, api) {
  };
  ComponentView2.prototype.render = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.dispose = function(ecModel, api) {
  };
  ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {
  };
  ComponentView2.prototype.eachRendered = function(cb) {
    var group = this.group;
    if (group) {
      group.traverse(cb);
    }
  };
  return ComponentView2;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var ComponentView$1 = ComponentView;
function createRenderPlanner() {
  var inner2 = makeInner();
  return function(seriesModel) {
    var fields = inner2(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = !!fields.large;
    var originalProgressive = !!fields.progressiveRender;
    var large = fields.large = !!(pipelineContext && pipelineContext.large);
    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}
var inner$j = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
  function ChartView2() {
    this.group = new Group$4();
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }
  ChartView2.prototype.init = function(ecModel, api) {
  };
  ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    {
      throw new Error("render method must been implemented");
    }
  };
  ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      {
        error("Unknown dataType " + payload.dataType);
      }
      return;
    }
    toggleHighlight(data, payload, "emphasis");
  };
  ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      {
        error("Unknown dataType " + payload.dataType);
      }
      return;
    }
    toggleHighlight(data, payload, "normal");
  };
  ChartView2.prototype.remove = function(ecModel, api) {
    this.group.removeAll();
  };
  ChartView2.prototype.dispose = function(ecModel, api) {
  };
  ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this.group, cb);
  };
  ChartView2.markUpdateMethod = function(payload, methodName) {
    inner$j(payload).updateMethod = methodName;
  };
  ChartView2.protoInitialize = function() {
    var proto2 = ChartView2.prototype;
    proto2.type = "chart";
  }();
  return ChartView2;
}();
function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}
function toggleHighlight(data, payload, state) {
  var dataIndex = queryDataIndex(data, payload);
  var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each$f(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload;
  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner$j(payload).updateMethod;
  var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var ChartView$1 = ChartView;
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff2;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }
  var cb = function() {
    var cbArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      cbArgs[_i] = arguments[_i];
    }
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff2 = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff2 >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff2);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];
  if (!fn) {
    return;
  }
  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }
  return fn;
}
function clear$1(obj, fnAttr) {
  var fn = obj[fnAttr];
  if (fn && fn[ORIGIN_METHOD]) {
    fn.clear && fn.clear();
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}
var inner$i = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var styleModel = seriesModel.getModel(stylePath);
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var globalStyle = getStyle2(styleModel);
    var decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    var colorKey = getDefaultColorKey(seriesModel, stylePath);
    var color = globalStyle[colorKey];
    var colorCallback = isFunction(color) ? color : null;
    var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      var colorPalette2 = seriesModel.getColorFromPalette(
        seriesModel.name,
        null,
        ecModel.getSeriesCount()
      );
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette2;
        data.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
    }
    data.setVisual("style", globalStyle);
    data.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual("colorFromPalette", false);
      return {
        dataEach: function(data2, idx) {
          var dataParams = seriesModel.getDataParams(idx);
          var itemStyle = extend2({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data2.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model$1();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var colorKey = data.getVisual("drawType");
    return {
      dataEach: data.hasItemOption ? function(data2, idx) {
        var rawItem = data2.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          var style = getStyle2(sharedModel);
          var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
          extend2(existsStyle, style);
          if (sharedModel.option.decal) {
            data2.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data2.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset: function(ecModel) {
    var paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      var key = seriesModel.type + "-" + colorBy;
      var colorScope = paletteScopeGroupByType.get(key);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }
      inner$i(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      var data = seriesModel.getData();
      var colorScope = inner$i(seriesModel).scope;
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function(idx) {
        var rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        var idx = idxMap[rawIdx];
        var fromPalette = data.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
          var dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
        }
      });
    });
  }
};
var PI$5 = Math.PI;
function defaultLoading(api, opts) {
  opts = opts || {};
  defaults(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new Group$4();
  var mask2 = new Rect$3({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask2);
  var textContent = new ZRText$1({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new Rect$3({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  var arc;
  if (opts.showSpinner) {
    arc = new Arc$1({
      shape: {
        startAngle: -PI$5 / 2,
        endAngle: -PI$5 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1e3, {
      endAngle: PI$5 * 3 / 2
    }).start("circularInOut");
    arc.animateShape(true).when(1e3, {
      startAngle: PI$5 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc);
  }
  group.resize = function() {
    var textWidth = textContent.getBoundingRect().width;
    var r = opts.showSpinner ? opts.spinnerRadius : 0;
    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask2.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  group.resize();
  return group;
}
var Scheduler = function() {
  function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  Scheduler2.prototype.restoreData = function(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  };
  Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    var pipeline = this._pipelineMap.get(task.__pipeline.id);
    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step,
      modBy,
      modDataCount
    };
  };
  Scheduler2.prototype.getPipeline = function(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);
    var data = seriesModel.getData();
    var dataLen = data.count();
    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  };
  Scheduler2.prototype.restorePipelines = function(ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  };
  Scheduler2.prototype.prepareStageTasks = function() {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.api.getModel();
    var api = this.api;
    each$f(this._allHandlers, function(handler) {
      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      var errMsg = "";
      {
        errMsg = '"reset" and "overallReset" must not be both specified.';
      }
      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
    }, this);
  };
  Scheduler2.prototype.prepareView = function(view, model, ecModel, api) {
    var renderTask = view.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view.incrementalPrepareRender;
    this._pipe(model, renderTask);
  };
  Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  };
  Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  };
  Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished = false;
    var scheduler = this;
    each$f(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        var overallNeedDirty_1;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty_1 = true;
          }
        });
        overallNeedDirty_1 && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs_1);
        });
        if (overallTask.perform(performArgs_1)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          var performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.performSeriesTasks = function(ecModel) {
    var unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.plan = function() {
    this._pipelineMap.each(function(pipeline) {
      var task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  };
  Scheduler2.prototype.updatePayload = function(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  };
  Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create6);
    } else if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, create6);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create6);
    }
    function create6(seriesModel) {
      var pipelineId = seriesModel.uid;
      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  };
  Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel,
      api,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    var oldAgentStubMap = overallTask.agentStubMap;
    var newAgentStubMap = overallTask.agentStubMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var shouldOverallTaskDirty = false;
    var errMsg = "";
    {
      errMsg = '"createOnAllSeries" do not supported for "overallReset", becuase it will block all streams.';
    }
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } else {
      overallProgress = false;
      each$f(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  };
  Scheduler2.prototype._pipe = function(seriesModel, task) {
    var pipelineId = seriesModel.uid;
    var pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  };
  Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
    if (isFunction(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  return Scheduler2;
}();
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map$1(resetDefines, function(v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (var i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e2) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (var name_1 in Clz.prototype) {
    target[name_1] = noop;
  }
}
var Scheduler$1 = Scheduler;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
var lightTheme = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var contrastColor = "#B9B8CE";
var backgroundColor = "#100C2A";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
};
var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var darkTheme = theme;
var ECEventProcessor = function() {
  function ECEventProcessor2() {
  }
  ECEventProcessor2.prototype.normalizeQuery = function(query5) {
    var cptQuery = {};
    var dataQuery = {};
    var otherQuery = {};
    if (isString(query5)) {
      var condCptType = parseClassType(query5);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      var suffixes_1 = ["Index", "Name", "Id"];
      var dataKeys_1 = {
        name: 1,
        dataIndex: 1,
        dataType: 1
      };
      each$f(query5, function(val, key) {
        var reserved = false;
        for (var i = 0; i < suffixes_1.length; i++) {
          var propSuffix = suffixes_1[i];
          var suffixPos = key.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
            var mainType = key.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val;
              reserved = true;
            }
          }
        }
        if (dataKeys_1.hasOwnProperty(key)) {
          dataQuery[key] = val;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key] = val;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  };
  ECEventProcessor2.prototype.filter = function(eventType, query5) {
    var eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    var targetEl = eventInfo.targetEl;
    var packedEvent = eventInfo.packedEvent;
    var model = eventInfo.model;
    var view = eventInfo.view;
    if (!model || !view) {
      return true;
    }
    var cptQuery = query5.cptQuery;
    var dataQuery = query5.dataQuery;
    return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query5.otherQuery, targetEl, packedEvent));
    function check(query6, host, prop, propOnHost) {
      return query6[prop] == null || host[propOnHost || prop] === query6[prop];
    }
  };
  ECEventProcessor2.prototype.afterTrigger = function() {
    this.eventInfo = null;
  };
  return ECEventProcessor2;
}();
var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    var symbolOptions = {};
    var symbolOptionsCb = {};
    var hasCallback = false;
    for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
      var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
      var val = seriesModel.get(symbolPropName);
      if (isFunction(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend2({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var symbolPropsCb = keys2(symbolOptionsCb);
    function dataEach(data2, idx) {
      var rawValue = seriesModel.getRawValue(idx);
      var params = seriesModel.getDataParams(idx);
      for (var i2 = 0; i2 < symbolPropsCb.length; i2++) {
        var symbolPropName2 = symbolPropsCb[i2];
        data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
      }
    }
    return {
      dataEach: hasCallback ? dataEach : null
    };
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    function dataEach(data2, idx) {
      var itemModel = data2.getItemModel(idx);
      for (var i = 0; i < SYMBOL_PROPS.length; i++) {
        var symbolPropName = SYMBOL_PROPS[i];
        var val = itemModel.getShallow(symbolPropName, true);
        if (val != null) {
          data2.setItemVisual(idx, symbolPropName, val);
        }
      }
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
function getItemVisualFromData(data, dataIndex, key) {
  switch (key) {
    case "color":
      var style = data.getItemVisual(dataIndex, "style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getItemVisual(dataIndex, key);
    default: {
      console.warn("Unknown visual type " + key);
    }
  }
}
function getVisualFromData(data, key) {
  switch (key) {
    case "color":
      var style = data.getVisual("style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getVisual(key);
    default: {
      console.warn("Unknown visual type " + key);
    }
  }
}
function setItemVisualFromData(data, dataIndex, key, value) {
  switch (key) {
    case "color":
      var style = data.ensureUniqueItemVisual(dataIndex, "style");
      style[data.getVisual("drawType")] = value;
      data.setItemVisual(dataIndex, "colorFromPalette", false);
      break;
    case "opacity":
      data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      data.setItemVisual(dataIndex, key, value);
      break;
    default: {
      console.warn("Unknown visual type " + key);
    }
  }
}
function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    var seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType2,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each$f([[seriesType2 + "ToggleSelect", "toggleSelect"], [seriesType2 + "Select", "select"], [seriesType2 + "UnSelect", "unselect"]], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
      payload = extend2({}, payload);
      {
        deprecateReplaceLog(payload.type, eventsMap[1]);
      }
      api.dispatchAction(extend2(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  var legacyEventName = type + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    {
      deprecateLog("event " + legacyEventName + " is deprecated.");
    }
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      var seriesIndex = seriesModel.seriesIndex;
      var selectedMap = seriesModel.option.selectedMap;
      var selected = payload.selected;
      for (var i = 0; i < selected.length; i++) {
        if (selected[i].seriesIndex === seriesIndex) {
          var data = seriesModel.getData();
          var dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray$1(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString(selectedMap) ? selectedMap : extend2({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
  messageCenter.on("selectchanged", function(params) {
    var ecModel = api.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}
function findEventDispatcher(target, det2, returnFirstMatch) {
  var found;
  while (target) {
    if (det2(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap$1 = function() {
  function WeakMap2() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  WeakMap2.prototype.get = function(key) {
    return this._guard(key)[this._id];
  };
  WeakMap2.prototype.set = function(key, value) {
    var target = this._guard(key);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value;
    }
    return this;
  };
  WeakMap2.prototype["delete"] = function(key) {
    if (this.has(key)) {
      delete this._guard(key)[this._id];
      return true;
    }
    return false;
  };
  WeakMap2.prototype.has = function(key) {
    return !!this._guard(key)[this._id];
  };
  WeakMap2.prototype._guard = function(key) {
    if (key !== Object(key)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key;
  };
  return WeakMap2;
}();
var WeakMap$2 = WeakMap$1;
var Triangle2 = Path$1.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
var Diamond = Path$1.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
var Pin = Path$1.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var x2 = shape.x;
    var y2 = shape.y;
    var w = shape.width / 5 * 3;
    var h = Math.max(w, shape.height);
    var r = w / 2;
    var dy = r * r / (h - r);
    var cy = y2 - h + r + dy;
    var angle4 = Math.asin(dy / r);
    var dx = Math.cos(angle4) * r;
    var tanX = Math.sin(angle4);
    var tanY = Math.cos(angle4);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x2 - dx, cy + dy);
    path.arc(x2, cy, r, Math.PI - angle4, Math.PI * 2 + angle4);
    path.bezierCurveTo(x2 + dx - tanX * cpLen, cy + dy + tanY * cpLen, x2, y2 - cpLen2, x2, y2);
    path.bezierCurveTo(x2, y2 - cpLen2, x2 - dx + tanX * cpLen, cy + dy + tanY * cpLen, x2 - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path$1.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x2 = shape.x;
    var y2 = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 + dx, y2 + height);
    ctx.lineTo(x2, y2 + height / 4 * 3);
    ctx.lineTo(x2 - dx, y2 + height);
    ctx.lineTo(x2, y2);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line$3,
  rect: Rect$3,
  roundRect: Rect$3,
  square: Rect$3,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle2
};
var symbolShapeMakers = {
  line: function(x2, y2, w, h, shape) {
    shape.x1 = x2;
    shape.y1 = y2 + h / 2;
    shape.x2 = x2 + w;
    shape.y2 = y2 + h / 2;
  },
  rect: function(x2, y2, w, h, shape) {
    shape.x = x2;
    shape.y = y2;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function(x2, y2, w, h, shape) {
    shape.x = x2;
    shape.y = y2;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function(x2, y2, w, h, shape) {
    var size11 = Math.min(w, h);
    shape.x = x2;
    shape.y = y2;
    shape.width = size11;
    shape.height = size11;
  },
  circle: function(x2, y2, w, h, shape) {
    shape.cx = x2 + w / 2;
    shape.cy = y2 + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function(x2, y2, w, h, shape) {
    shape.cx = x2 + w / 2;
    shape.cy = y2 + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function(x2, y2, w, h, shape) {
    shape.x = x2 + w / 2;
    shape.y = y2 + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function(x2, y2, w, h, shape) {
    shape.x = x2 + w / 2;
    shape.y = y2 + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function(x2, y2, w, h, shape) {
    shape.cx = x2 + w / 2;
    shape.cy = y2 + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
each$f(symbolCtors, function(Ctor, name2) {
  symbolBuildProxies[name2] = new Ctor();
});
var SymbolClz$1 = Path$1.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(out2, config, rect) {
    var res = calculateTextPosition(out2, config, rect);
    var shape = this.shape;
    if (shape && shape.symbolType === "pin" && config.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath: function(ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    if (symbolType !== "none") {
      var proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color, innerColor2) {
  if (this.type !== "image") {
    var symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor2 || "#fff";
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color;
    } else {
      symbolStyle.fill = color;
    }
    this.markRedraw();
  }
}
function createSymbol$1(symbolType, x2, y2, w, h, color, keepAspect) {
  var isEmpty6 = symbolType.indexOf("empty") === 0;
  if (isEmpty6) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  var symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect$1(x2, y2, w, h), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect$1(x2, y2, w, h), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz$1({
      shape: {
        symbolType,
        x: x2,
        y: y2,
        width: w,
        height: h
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty6;
  symbolPath.setColor = symbolPathSetColor;
  if (color) {
    symbolPath.setColor(color);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray$1(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray$1(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}
function isSafeNum(num) {
  return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
  var x2 = obj.x == null ? 0 : obj.x;
  var x22 = obj.x2 == null ? 1 : obj.x2;
  var y2 = obj.y == null ? 0 : obj.y;
  var y22 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x2 = x2 * rect.width + rect.x;
    x22 = x22 * rect.width + rect.x;
    y2 = y2 * rect.height + rect.y;
    y22 = y22 * rect.height + rect.y;
  }
  x2 = isSafeNum(x2) ? x2 : 0;
  x22 = isSafeNum(x22) ? x22 : 1;
  y2 = isSafeNum(y2) ? y2 : 0;
  y22 = isSafeNum(y22) ? y22 : 0;
  var canvasGradient = ctx.createLinearGradient(x2, y2, x22, y22);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min5 = Math.min(width, height);
  var x2 = obj.x == null ? 0.5 : obj.x;
  var y2 = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x2 = x2 * width + rect.x;
    y2 = y2 * height + rect.y;
    r = r * min5;
  }
  x2 = isSafeNum(x2) ? x2 : 0.5;
  y2 = isSafeNum(y2) ? y2 : 0.5;
  r = r >= 0 && isSafeNum(r) ? r : 0.5;
  var canvasGradient = ctx.createRadialGradient(x2, y2, 0, x2, y2, r);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  var colorStops = obj.colorStops;
  for (var i = 0; i < colorStops.length; i++) {
    canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSize$1(root, whIdx, opts) {
  var wh = ["width", "height"][whIdx];
  var cwh = ["clientWidth", "clientHeight"][whIdx];
  var plt = ["paddingLeft", "paddingTop"][whIdx];
  var prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh] != null && opts[wh] !== "auto") {
    return parseFloat(opts[wh]);
  }
  var stl = document.defaultView.getComputedStyle(root);
  return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray$1(lineType) ? lineType : null;
}
function getLineDash(el) {
  var style = el.style;
  var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  var lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
    if (lineScale_1 && lineScale_1 !== 1) {
      lineDash = map$1(lineDash, function(rawVal) {
        return rawVal / lineScale_1;
      });
      lineDashOffset /= lineScale_1;
    }
  }
  return [lineDash, lineDashOffset];
}
var pathProxyForDraw = new PathProxy(true);
function styleHasStroke(style) {
  var stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el) {
  var image = createOrUpdateImage(pattern.image, pattern.__image, el);
  if (isImageReady(image)) {
    var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      var matrix = new DOMMatrix();
      matrix.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el, style, inBatch) {
  var _a2;
  var hasStroke = styleHasStroke(style);
  var hasFill = styleHasFill(style);
  var strokePercent = style.strokePercent;
  var strokePart = strokePercent < 1;
  var firstDraw = !el.path;
  if ((!el.silent || strokePart) && firstDraw) {
    el.createPathProxy();
  }
  var path = el.path || pathProxyForDraw;
  var dirtyFlag = el.__dirty;
  if (!inBatch) {
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    var fillGradient = void 0;
    var strokeGradient = void 0;
    var fillPattern = void 0;
    var strokePattern = void 0;
    var rect = void 0;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
      el.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
      el.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
      el.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
      el.__canvasStrokePattern = fillPattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  var scale4 = el.getGlobalScale();
  path.setScale(scale4[0], scale4[1], el.segmentIgnoreThreshold);
  var lineDash;
  var lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
  }
  var needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el.buildPath(path, el.shape, inBatch);
    path.toStatic();
    el.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el, style) {
  var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  var x2 = style.x || 0;
  var y2 = style.y || 0;
  var width = el.getWidth();
  var height = el.getHeight();
  var aspect = image.width / image.height;
  if (width == null && height != null) {
    width = height * aspect;
  } else if (height == null && width != null) {
    height = width / aspect;
  } else if (width == null && height == null) {
    width = image.width;
    height = image.height;
  }
  if (style.sWidth && style.sHeight) {
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x2, y2, width, height);
  } else if (style.sx && style.sy) {
    var sx = style.sx;
    var sy = style.sy;
    var sWidth = width - sx;
    var sHeight = height - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x2, y2, width, height);
  } else {
    ctx.drawImage(image, x2, y2, width, height);
  }
}
function brushText(ctx, el, style) {
  var _a2;
  var text = style.text;
  text != null && (text += "");
  if (text) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    var lineDash = void 0;
    var lineDashOffset = void 0;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  var styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    var opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
    var propName = SHADOW_NUMBER_PROPS[i];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
  var style = getStyle(el, scope.inHover);
  var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el.hasStroke()) {
    var lineWidth = style.lineWidth;
    var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (var i = 0; i < STROKE_PROPS.length; i++) {
    var prop = STROKE_PROPS[i];
    var propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
  var m2 = el.transform;
  var dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  var allClipped = false;
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  var hasFill = styleHasFill(style);
  var hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle(el, inHover) {
  return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
  brush$1(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
}
function brush$1(ctx, el, scope, isLast) {
  var m2 = el.transform;
  if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el.__dirty &= ~REDRAW_BIT;
    el.__isRendered = false;
    return;
  }
  var clipPaths = el.__clipPaths;
  var prevElClipPaths = scope.prevElClipPaths;
  var forceSetTransform = false;
  var forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el.__isRendered = false;
    return;
  }
  el.beforeBrush && el.beforeBrush();
  el.innerBeforeBrush();
  var prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  var canBatchPath = el instanceof Path$1 && el.autoBatch && canPathBatch(el.style);
  if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  var style = getStyle(el, scope.inHover);
  if (el instanceof Path$1) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el instanceof TSpan$1) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushText(ctx, el, style);
    } else if (el instanceof ZRImage$1) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushImage(ctx, el, style);
    } else if (el.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el.innerAfterBrush();
  el.afterBrush && el.afterBrush();
  scope.prevEl = el;
  el.__dirty = 0;
  el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
  var displayables = el.getDisplayables();
  var temporalDisplayables = el.getTemporalDisplayables();
  ctx.save();
  var innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  var i;
  var len2;
  for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
    var displayable = displayables[i];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush$1(ctx, displayable, innerScope, i === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
    var displayable = temporalDisplayables[i_1];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush$1(ctx, displayable, innerScope, i_1 === len_1 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el.clearTemporalDisplayables();
  el.notClear = true;
  ctx.restore();
}
var decalMap = new WeakMap$2();
var decalCache = new LRU$1(100);
var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(decalObject, api) {
  if (decalObject === "none") {
    return null;
  }
  var dpr2 = api.getDevicePixelRatio();
  var zr = api.getZr();
  var isSVG = zr.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap["delete"](decalObject);
  }
  var oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  var decalOpt = defaults(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  var pattern = {
    repeat: "repeat"
  };
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    var keys3 = [dpr2];
    var isValidKey = true;
    for (var i = 0; i < decalKeys.length; ++i) {
      var value = decalOpt[decalKeys[i]];
      if (value != null && !isArray$1(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
        isValidKey = false;
        break;
      }
      keys3.push(value);
    }
    var cacheKey;
    if (isValidKey) {
      cacheKey = keys3.join(",") + (isSVG ? "-svg" : "");
      var cache = decalCache.get(cacheKey);
      if (cache) {
        isSVG ? pattern2.svgElement = cache : pattern2.image = cache;
      }
    }
    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    var canvas = !isSVG && platformApi.createCanvas();
    var svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    var pSize = getPatternSize();
    var ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      var width = 1;
      for (var i2 = 0, xlen = lineBlockLengthsX.length; i2 < xlen; ++i2) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i2]);
      }
      var symbolRepeats = 1;
      for (var i2 = 0, xlen = symbolArray.length; i2 < xlen; ++i2) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i2].length);
      }
      width *= symbolRepeats;
      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      {
        var warn2 = function(attrName) {
          console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
        };
        if (width > decalOpt.maxTileWidth) {
          warn2("maxTileWidth");
        }
        if (height > decalOpt.maxTileHeight) {
          warn2("maxTileHeight");
        }
      }
      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      var ySum = 0;
      for (var i2 = 0; i2 < dashArrayY.length; ++i2) {
        ySum += dashArrayY[i2];
      }
      if (ySum <= 0) {
        return;
      }
      var y2 = -lineBlockLengthY;
      var yId = 0;
      var yIdTotal = 0;
      var xId0 = 0;
      while (y2 < pSize.height) {
        if (yId % 2 === 0) {
          var symbolYId = yIdTotal / 2 % symbolArray.length;
          var x2 = 0;
          var xId1 = 0;
          var xId1Total = 0;
          while (x2 < pSize.width * 2) {
            var xSum = 0;
            for (var i2 = 0; i2 < dashArrayX[xId0].length; ++i2) {
              xSum += dashArrayX[xId0][i2];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              var size11 = (1 - decalOpt.symbolSize) * 0.5;
              var left = x2 + dashArrayX[xId0][xId1] * size11;
              var top_1 = y2 + dashArrayY[yId] * size11;
              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              var height = dashArrayY[yId] * decalOpt.symbolSize;
              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
            }
            x2 += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y2 += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x3, y3, width2, height2, symbolType) {
        var scale4 = isSVG ? 1 : dpr2;
        var symbol = createSymbol$1(symbolType, x3 * scale4, y3 * scale4, width2 * scale4, height2 * scale4, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          var symbolVNode = zr.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString(symbol)) {
    return [[symbol]];
  }
  var isAllString = true;
  for (var i = 0; i < symbol.length; ++i) {
    if (!isString(symbol[i])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  var result = [];
  for (var i = 0; i < symbol.length; ++i) {
    if (isString(symbol[i])) {
      result.push([symbol[i]]);
    } else {
      result.push(symbol[i]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber(dash)) {
    var dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  var isAllNumber = true;
  for (var i = 0; i < dash.length; ++i) {
    if (!isNumber(dash[i])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  var result = [];
  for (var i = 0; i < dash.length; ++i) {
    if (isNumber(dash[i])) {
      var dashValue = Math.ceil(dash[i]);
      result.push([dashValue, dashValue]);
    } else {
      var dashValue = map$1(dash[i], function(n) {
        return Math.ceil(n);
      });
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber(dash)) {
    var dashValue_1 = Math.ceil(dash);
    return [dashValue_1, dashValue_1];
  }
  var dashValue = map$1(dash, function(n) {
    return Math.ceil(n);
  });
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map$1(dash, function(line) {
    return getLineBlockLengthY(line);
  });
}
function getLineBlockLengthY(dash) {
  var blockLength = 0;
  for (var i = 0; i < dash.length; ++i) {
    blockLength += dash[i];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}
function decalVisual(ecModel, api) {
  ecModel.eachRawSeries(function(seriesModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    if (data.hasItemVisual()) {
      data.each(function(idx) {
        var decal2 = data.getItemVisual(idx, "decal");
        if (decal2) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
        }
      });
    }
    var decal = data.getVisual("decal");
    if (decal) {
      var style = data.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api);
    }
  });
}
var lifecycle = new Eventful$1();
var lifecycle$1 = lifecycle;
var implsStore = {};
function registerImpl(name2, impl) {
  {
    if (implsStore[name2]) {
      error("Already has an implementation of " + name2 + ".");
    }
  }
  implsStore[name2] = impl;
}
function getImpl(name2) {
  {
    if (!implsStore[name2]) {
      error("Implementation of " + name2 + " doesn't exists.");
    }
  }
  return implsStore[name2];
}
var hasWindow = typeof window !== "undefined";
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
function createRegisterEventWithLowercaseECharts(method) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful$1.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
  __extends$1(MessageCenter2, _super);
  function MessageCenter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return MessageCenter2;
}(Eventful$1);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var markStatusToUpdate;
var applyChangedStates;
var ECharts = function(_super) {
  __extends$1(ECharts2, _super);
  function ECharts2(dom, theme2, opts) {
    var _this = _super.call(this, new ECEventProcessor()) || this;
    _this._chartsViews = [];
    _this._chartsMap = {};
    _this._componentsViews = [];
    _this._componentsMap = {};
    _this._pendingActions = [];
    opts = opts || {};
    if (isString(theme2)) {
      theme2 = themeStorage[theme2];
    }
    _this._dom = dom;
    var defaultRenderer = "canvas";
    var defaultCoarsePointer = "auto";
    var defaultUseDirtyRect = false;
    {
      var root = hasWindow ? window : global;
      defaultRenderer = root.__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;
      defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
      var devUseDirtyRect = root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;
      defaultUseDirtyRect = devUseDirtyRect == null ? defaultUseDirtyRect : devUseDirtyRect;
    }
    var zr = _this._zr = init$1(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
      useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
      pointerSize: opts.pointerSize
    });
    _this._ssr = opts.ssr;
    _this._throttledZrFlush = throttle(bind$1(zr.flush, zr), 17);
    theme2 = clone$4(theme2);
    theme2 && globalBackwardCompat(theme2, true);
    _this._theme = theme2;
    _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    _this._coordSysMgr = new CoordinateSystem();
    var api = _this._api = createExtensionAPI(_this);
    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }
    sort$2(visualFuncs, prioritySortFunc);
    sort$2(dataProcessorFuncs, prioritySortFunc);
    _this._scheduler = new Scheduler$1(_this, api, dataProcessorFuncs, visualFuncs);
    _this._messageCenter = new MessageCenter();
    _this._initEvents();
    _this.resize = bind$1(_this.resize, _this);
    zr.animation.on("frame", _this._onframe, _this);
    bindRenderedEvent(zr, _this);
    bindMouseEvent(zr, _this);
    setAsPrimitive(_this);
    return _this;
  }
  ECharts2.prototype._onframe = function() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    var scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      var silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e2;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;
      do {
        var startTime = +new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, "remain", {});
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  };
  ECharts2.prototype.getDom = function() {
    return this._dom;
  };
  ECharts2.prototype.getId = function() {
    return this.id;
  };
  ECharts2.prototype.getZr = function() {
    return this._zr;
  };
  ECharts2.prototype.isSSR = function() {
    return this._ssr;
  };
  ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      {
        error("`setOption` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var silent;
    var replaceMerge;
    var transitionOpt;
    if (isObject$3(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager$1(this._api);
      var theme2 = this._theme;
      var ecModel = this._model = new GlobalModel$1();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {
      replaceMerge
    }, optionPreprocessorFuncs);
    var updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e2) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  ECharts2.prototype.setTheme = function() {
    deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
  };
  ECharts2.prototype.getModel = function() {
    return this._model;
  };
  ECharts2.prototype.getOption = function() {
    return this._model && this._model.getOption();
  };
  ECharts2.prototype.getWidth = function() {
    return this._zr.getWidth();
  };
  ECharts2.prototype.getHeight = function() {
    return this._zr.getHeight();
  };
  ECharts2.prototype.getDevicePixelRatio = function() {
    return this._zr.painter.dpr || hasWindow && window.devicePixelRatio || 1;
  };
  ECharts2.prototype.getRenderedCanvas = function(opts) {
    {
      deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
    }
    return this.renderToCanvas(opts);
  };
  ECharts2.prototype.renderToCanvas = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    {
      if (painter.type !== "canvas") {
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      }
    }
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  };
  ECharts2.prototype.renderToSVGString = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    {
      if (painter.type !== "svg") {
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      }
    }
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  };
  ECharts2.prototype.getSvgDataURL = function() {
    if (!env$1.svgSupported) {
      return;
    }
    var zr = this._zr;
    var list = zr.storage.getDisplayList();
    each$f(list, function(el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  };
  ECharts2.prototype.getDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self2 = this;
    each$f(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        var view = self2._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each$f(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  };
  ECharts2.prototype.getConnectedDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var isSvg = opts.type === "svg";
    var groupId = this.group;
    var mathMin2 = Math.min;
    var mathMax2 = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left_1 = MAX_NUMBER;
      var top_1 = MAX_NUMBER;
      var right_1 = -MAX_NUMBER;
      var bottom_1 = -MAX_NUMBER;
      var canvasList_1 = [];
      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each$f(instances, function(chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$4(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left_1 = mathMin2(boundingRect.left, left_1);
          top_1 = mathMin2(boundingRect.top, top_1);
          right_1 = mathMax2(boundingRect.right, right_1);
          bottom_1 = mathMax2(boundingRect.bottom, bottom_1);
          canvasList_1.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left_1 *= dpr_1;
      top_1 *= dpr_1;
      right_1 *= dpr_1;
      bottom_1 *= dpr_1;
      var width = right_1 - left_1;
      var height = bottom_1 - top_1;
      var targetCanvas = platformApi.createCanvas();
      var zr_1 = init$1(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr_1.resize({
        width,
        height
      });
      if (isSvg) {
        var content_1 = "";
        each$f(canvasList_1, function(item) {
          var x2 = item.left - left_1;
          var y2 = item.top - top_1;
          content_1 += '<g transform="translate(' + x2 + "," + y2 + ')">' + item.dom + "</g>";
        });
        zr_1.painter.getSvgRoot().innerHTML = content_1;
        if (opts.connectedBackgroundColor) {
          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr_1.refreshImmediately();
        return zr_1.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr_1.add(new Rect$3({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each$f(canvasList_1, function(item) {
          var img = new ZRImage$1({
            style: {
              x: item.left * dpr_1 - left_1,
              y: item.top * dpr_1 - top_1,
              image: item.dom
            }
          });
          zr_1.add(img);
        });
        zr_1.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  ECharts2.prototype.convertToPixel = function(finder, value) {
    return doConvertPixel(this, "convertToPixel", finder, value);
  };
  ECharts2.prototype.convertFromPixel = function(finder, value) {
    return doConvertPixel(this, "convertFromPixel", finder, value);
  };
  ECharts2.prototype.containPixel = function(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var result;
    var findResult = parseFinder$1(ecModel, finder);
    each$f(findResult, function(models, key) {
      key.indexOf("Models") >= 0 && each$f(models, function(model) {
        var coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key === "seriesModels") {
          var view = this._chartsMap[model.__viewId];
          if (view && view.containPoint) {
            result = result || view.containPoint(value, model);
          } else {
            {
              console.warn(key + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
            }
          }
        } else {
          {
            console.warn(key + ": containPoint is not supported");
          }
        }
      }, this);
    }, this);
    return !!result;
  };
  ECharts2.prototype.getVisual = function(finder, visualType) {
    var ecModel = this._model;
    var parsedFinder = parseFinder$1(ecModel, finder, {
      defaultMainType: "series"
    });
    var seriesModel = parsedFinder.seriesModel;
    {
      if (!seriesModel) {
        console.warn("There is no specified seires model");
      }
    }
    var data = seriesModel.getData();
    var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  };
  ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };
  ECharts2.prototype._initEvents = function() {
    var _this = this;
    each$f(MOUSE_EVENT_NAMES, function(eveName) {
      var handler = function(e2) {
        var ecModel = _this.getModel();
        var el = e2.target;
        var params;
        var isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, function(parent) {
            var ecData = getECData(parent);
            if (ecData && ecData.dataIndex != null) {
              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend2({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          {
            if (!isGlobalOut && !(model && view)) {
              console.warn("model or view can not be found by params");
            }
          }
          params.event = e2;
          params.type = eveName;
          _this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model,
            view
          };
          _this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      _this._zr.on(eveName, handler, _this);
    });
    each$f(eventActionMap, function(actionType, eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    each$f(["selectchanged"], function(eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  };
  ECharts2.prototype.isDisposed = function() {
    return this._disposed;
  };
  ECharts2.prototype.clear = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({
      series: []
    }, true);
  };
  ECharts2.prototype.dispose = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    var dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    var chart = this;
    var api = chart._api;
    var ecModel = chart._model;
    each$f(chart._componentsViews, function(component) {
      component.dispose(ecModel, api);
    });
    each$f(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances[chart.id];
  };
  ECharts2.prototype.resize = function(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      {
        error("`resize` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    var ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    var needPrepare = ecModel.resetOption("media");
    var silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend2({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e2) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e2;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.showLoading = function(name2, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject$3(name2)) {
      cfg = name2;
      name2 = "";
    }
    name2 = name2 || "default";
    this.hideLoading();
    if (!loadingEffects[name2]) {
      {
        console.warn("Loading effects " + name2 + " not exists.");
      }
      return;
    }
    var el = loadingEffects[name2](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  ECharts2.prototype.hideLoading = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  ECharts2.prototype.makeActionFromEvent = function(eventObj) {
    var payload = extend2({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  ECharts2.prototype.dispatchAction = function(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject$3(opt)) {
      opt = {
        silent: !!opt
      };
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    var silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    var flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env$1.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.updateLabelLayout = function() {
    lifecycle$1.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  };
  ECharts2.prototype.appendData = function(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    {
      assert(params.data && seriesModel);
    }
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  };
  ECharts2.internalField = function() {
    prepare = function(ecIns) {
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecIns._model);
      scheduler.prepareStageTasks();
      prepareView(ecIns, true);
      prepareView(ecIns, false);
      scheduler.plan();
    };
    prepareView = function(ecIns, isComponent) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;
      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var requireNewView = model.__requireNewView;
        model.__requireNewView = false;
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view2 = !requireNewView && viewMap[viewId];
        if (!view2) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView$1.getClass(classType.main, classType.sub) : ChartView$1.getClass(classType.sub);
          {
            assert(Clazz, classType.sub + " does not exist.");
          }
          view2 = new Clazz();
          view2.init(ecModel, api);
          viewMap[viewId] = view2;
          viewList.push(view2);
          zr.add(view2.group);
        }
        model.__viewId = view2.__id = viewId;
        view2.__alive = true;
        view2.__model = model;
        view2.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view2, model, ecModel, api);
      }
      for (var i = 0; i < viewList.length; ) {
        var view = viewList[i];
        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i, 1);
          if (viewMap[view.__id] === view) {
            delete viewMap[view.__id];
          }
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    };
    updateDirectly = function(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      ecModel.setUpdatePayload(payload);
      if (!mainType) {
        each$f([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
        return;
      }
      var query5 = {};
      query5[mainType + "Id"] = payload[mainType + "Id"];
      query5[mainType + "Index"] = payload[mainType + "Index"];
      query5[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query: query5
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      var excludeSeriesIdMap;
      if (excludeSeriesId != null) {
        excludeSeriesIdMap = createHashMap();
        each$f(normalizeToArray(excludeSeriesId), function(id) {
          var modelId = convertOptionIdName(id, null);
          if (modelId != null) {
            excludeSeriesIdMap.set(modelId, true);
          }
        });
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        if (isHighDownPayload(payload)) {
          if (model instanceof SeriesModel$1) {
            if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
              blurSeriesFromHighlightPayload(model, payload, ecIns._api);
            }
          } else {
            var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
            if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
              blurComponent(model.mainType, model.componentIndex, ecIns._api);
            }
            if (dispatchers) {
              each$f(dispatchers, function(dispatcher) {
                payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
              });
            }
          }
        } else if (isSelectChangePayload(payload)) {
          if (model instanceof SeriesModel$1) {
            toggleSelectionFromPayload(model, payload, ecIns._api);
            updateSeriesElementSelection(model);
            markStatusToUpdate(ecIns);
          }
        }
      }, ecIns);
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
      }, ecIns);
      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    };
    updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload, {
          optionChanged: payload.newOption != null
        });
      },
      update: function(payload, updateParams) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload, updateParams);
        var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
        var darkMode = ecModel.get("darkMode");
        zr.setBackgroundColor(backgroundColor2);
        if (darkMode != null && darkMode !== "auto") {
          zr.setDarkMode(darkMode);
        }
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateTransform: function(payload) {
        var _this = this;
        var ecModel = this._model;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType === "series") {
            return;
          }
          var componentView = _this.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ChartView$1.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render(this, ecModel, this._api, payload, {});
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateVisual: function(payload) {
        var _this = this;
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ecModel.eachSeries(function(seriesModel) {
          seriesModel.getData().clearAllVisual();
        });
        ChartView$1.markUpdateMethod(payload, "updateVisual");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          visualType: "visual",
          setDirty: true
        });
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType !== "series") {
            var componentView = _this.getViewOfComponentModel(componentModel);
            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
        });
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    doConvertPixel = function(ecIns, methodName, finder, value) {
      if (ecIns._disposed) {
        disposedWarning(ecIns.id);
        return;
      }
      var ecModel = ecIns._model;
      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
      var result;
      var parsedFinder = parseFinder$1(ecModel, finder);
      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
          return result;
        }
      }
      {
        console.warn("No coordinate system that supports " + methodName + " found by the given finder.");
      }
    };
    updateStreamModes = function(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    };
    doDispatchAction = function(payload, silent) {
      var _this = this;
      var ecModel = this.getModel();
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo2 = actionWrap.actionInfo;
      var cptTypeTmp = (actionInfo2.update || "update").split(":");
      var updateMethod = cptTypeTmp.pop();
      var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
      this[IN_MAIN_PROCESS_KEY] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = map$1(payload.batch, function(item) {
          item = defaults(extend2({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isSelectChange = isSelectChangePayload(payload);
      var isHighDown = isHighDownPayload(payload);
      if (isHighDown) {
        allLeaveBlur(this._api);
      }
      each$f(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, _this._model, _this._api);
        eventObj = eventObj || extend2({}, batchItem);
        eventObj.type = actionInfo2.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
          updateDirectly(_this, updateMethod, batchItem, componentMainType);
          markStatusToUpdate(_this);
        } else if (isSelectChange) {
          updateDirectly(_this, updateMethod, batchItem, "series");
          markStatusToUpdate(_this);
        } else if (cptType) {
          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      });
      if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
        try {
          if (this[PENDING_UPDATE]) {
            prepare(this);
            updateMethods.update.call(this, payload);
            this[PENDING_UPDATE] = null;
          } else {
            updateMethods[updateMethod].call(this, payload);
          }
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo2.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS_KEY] = false;
      if (!silent) {
        var messageCenter = this._messageCenter;
        messageCenter.trigger(eventObj.type, eventObj);
        if (isSelectChange) {
          var newObj = {
            type: "selectchanged",
            escapeConnect,
            selected: getAllSelectedIndices(ecModel),
            isFromClick: payload.isFromClick || false,
            fromAction: payload.type,
            fromActionPayload: payload
          };
          messageCenter.trigger(newObj.type, newObj);
        }
      }
    };
    flushPendingActions = function(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    };
    triggerUpdatedEvent = function(silent) {
      !silent && this.trigger("updated");
    };
    bindRenderedEvent = function(zr, ecIns) {
      zr.on("rendered", function(params) {
        ecIns.trigger("rendered", params);
        if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger("finished");
        }
      });
    };
    bindMouseEvent = function(zr, ecIns) {
      zr.on("mouseover", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("mouseout", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("click", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, function(target) {
          return getECData(target).dataIndex != null;
        }, true);
        if (dispatcher) {
          var actionType = dispatcher.selected ? "unselect" : "select";
          var ecData = getECData(dispatcher);
          ecIns._api.dispatchAction({
            type: actionType,
            dataType: ecData.dataType,
            dataIndexInside: ecData.dataIndex,
            seriesIndex: ecData.seriesIndex,
            isFromClick: true
          });
        }
      });
    };
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function allocateZlevels(ecModel) {
      var componentZLevels = [];
      var seriesZLevels = [];
      var hasSeperateZLevel = false;
      ecModel.eachComponent(function(componentType, componentModel) {
        var zlevel = componentModel.get("zlevel") || 0;
        var z = componentModel.get("z") || 0;
        var zlevelKey = componentModel.getZLevelKey();
        hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
        (componentType === "series" ? seriesZLevels : componentZLevels).push({
          zlevel,
          z,
          idx: componentModel.componentIndex,
          type: componentType,
          key: zlevelKey
        });
      });
      if (hasSeperateZLevel) {
        var zLevels = componentZLevels.concat(seriesZLevels);
        var lastSeriesZLevel_1;
        var lastSeriesKey_1;
        sort$2(zLevels, function(a, b) {
          if (a.zlevel === b.zlevel) {
            return a.z - b.z;
          }
          return a.zlevel - b.zlevel;
        });
        each$f(zLevels, function(item) {
          var componentModel = ecModel.getComponent(item.type, item.idx);
          var zlevel = item.zlevel;
          var key = item.key;
          if (lastSeriesZLevel_1 != null) {
            zlevel = Math.max(lastSeriesZLevel_1, zlevel);
          }
          if (key) {
            if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
              zlevel++;
            }
            lastSeriesKey_1 = key;
          } else if (lastSeriesKey_1) {
            if (zlevel === lastSeriesZLevel_1) {
              zlevel++;
            }
            lastSeriesKey_1 = "";
          }
          lastSeriesZLevel_1 = zlevel;
          componentModel.setZLevel(zlevel);
        });
      }
    }
    render = function(ecIns, ecModel, api, payload, updateParams) {
      allocateZlevels(ecModel);
      renderComponents(ecIns, ecModel, api, payload, updateParams);
      each$f(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload, updateParams);
      each$f(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    };
    renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
      each$f(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        clearStates(componentModel, componentView);
        componentView.render(componentModel, ecModel, api, payload);
        updateZ2(componentModel, componentView);
        updateStates(componentModel, componentView);
      });
    };
    renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
      var scheduler = ecIns._scheduler;
      updateParams = extend2(updateParams || {}, {
        updatedSeries: ecModel.getSeries()
      });
      lifecycle$1.trigger("series:beforeupdate", ecModel, api, updateParams);
      var unfinished = false;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        clearStates(seriesModel, chartView);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
          unfinished = true;
        }
        chartView.group.silent = !!seriesModel.get("silent");
        updateBlend(seriesModel, chartView);
        updateSeriesElementSelection(seriesModel);
      });
      scheduler.unfinished = unfinished || scheduler.unfinished;
      lifecycle$1.trigger("series:layoutlabels", ecModel, api, updateParams);
      lifecycle$1.trigger("series:transition", ecModel, api, updateParams);
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        updateZ2(seriesModel, chartView);
        updateStates(seriesModel, chartView);
      });
      updateHoverLayerStatus(ecIns, ecModel);
      lifecycle$1.trigger("series:afterupdate", ecModel, api, updateParams);
    };
    markStatusToUpdate = function(ecIns) {
      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
      ecIns.getZr().wakeUp();
    };
    applyChangedStates = function(ecIns) {
      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
        return;
      }
      ecIns.getZr().storage.traverse(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        applyElementStates(el);
      });
      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
    };
    function applyElementStates(el) {
      var newStates = [];
      var oldStates = el.currentStates;
      for (var i = 0; i < oldStates.length; i++) {
        var stateName = oldStates[i];
        if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
          newStates.push(stateName);
        }
      }
      if (el.selected && el.states.select) {
        newStates.push("select");
      }
      if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
        newStates.push("emphasis");
      } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
        newStates.push("blur");
      }
      el.useStates(newStates);
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage2 = zr.storage;
      var elCount = 0;
      storage2.traverse(function(el) {
        if (!el.isGroup) {
          elCount++;
        }
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env$1.node && !env$1.worker) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.eachRendered(function(el) {
              if (el.states.emphasis) {
                el.states.emphasis.hoverLayer = true;
              }
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.eachRendered(function(el) {
        if (!el.isGroup) {
          el.style.blend = blendMode;
        }
      });
    }
    function updateZ2(model, view) {
      if (model.preventAutoZ) {
        return;
      }
      var z = model.get("z") || 0;
      var zlevel = model.get("zlevel") || 0;
      view.eachRendered(function(el) {
        doUpdateZ(el, z, zlevel, -Infinity);
        return true;
      });
    }
    function doUpdateZ(el, z, zlevel, maxZ2) {
      var label = el.getTextContent();
      var labelLine = el.getTextGuideLine();
      var isGroup = el.isGroup;
      if (isGroup) {
        var children = el.childrenRef();
        for (var i = 0; i < children.length; i++) {
          maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
        }
      } else {
        el.z = z;
        el.zlevel = zlevel;
        maxZ2 = Math.max(el.z2, maxZ2);
      }
      if (label) {
        label.z = z;
        label.zlevel = zlevel;
        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
      }
      if (labelLine) {
        var textGuideLineConfig = el.textGuideLineConfig;
        labelLine.z = z;
        labelLine.zlevel = zlevel;
        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
      }
      return maxZ2;
    }
    function clearStates(model, view) {
      view.eachRendered(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        var textContent = el.getTextContent();
        var textGuide = el.getTextGuideLine();
        if (el.stateTransition) {
          el.stateTransition = null;
        }
        if (textContent && textContent.stateTransition) {
          textContent.stateTransition = null;
        }
        if (textGuide && textGuide.stateTransition) {
          textGuide.stateTransition = null;
        }
        if (el.hasState()) {
          el.prevStates = el.currentStates;
          el.clearStates();
        } else if (el.prevStates) {
          el.prevStates = null;
        }
      });
    }
    function updateStates(model, view) {
      var stateAnimationModel = model.getModel("stateAnimation");
      var enableAnimation = model.isAnimationEnabled();
      var duration = stateAnimationModel.get("duration");
      var stateTransition = duration > 0 ? {
        duration,
        delay: stateAnimationModel.get("delay"),
        easing: stateAnimationModel.get("easing")
      } : null;
      view.eachRendered(function(el) {
        if (el.states && el.states.emphasis) {
          if (isElementRemoved(el)) {
            return;
          }
          if (el instanceof Path$1) {
            savePathStates(el);
          }
          if (el.__dirty) {
            var prevStates = el.prevStates;
            if (prevStates) {
              el.useStates(prevStates);
            }
          }
          if (enableAnimation) {
            el.stateTransition = stateTransition;
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine();
            if (textContent) {
              textContent.stateTransition = stateTransition;
            }
            if (textGuide) {
              textGuide.stateTransition = stateTransition;
            }
          }
          if (el.__dirty) {
            applyElementStates(el);
          }
        }
      });
    }
    createExtensionAPI = function(ecIns) {
      return new (function(_super2) {
        __extends$1(class_1, _super2);
        function class_1() {
          return _super2 !== null && _super2.apply(this, arguments) || this;
        }
        class_1.prototype.getCoordinateSystems = function() {
          return ecIns._coordSysMgr.getCoordinateSystems();
        };
        class_1.prototype.getComponentByElement = function(el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;
            if (modelInfo != null) {
              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el = el.parent;
          }
        };
        class_1.prototype.enterEmphasis = function(el, highlightDigit) {
          enterEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
          leaveEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterBlur = function(el) {
          enterBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveBlur = function(el) {
          leaveBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterSelect = function(el) {
          enterSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveSelect = function(el) {
          leaveSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.getModel = function() {
          return ecIns.getModel();
        };
        class_1.prototype.getViewOfComponentModel = function(componentModel) {
          return ecIns.getViewOfComponentModel(componentModel);
        };
        class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
          return ecIns.getViewOfSeriesModel(seriesModel);
        };
        return class_1;
      }(ExtensionAPI$1))(ecIns);
    };
  }();
  return ECharts2;
}(Eventful$1);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  var self2 = this;
  deprecateLog("ECharts#one is deprecated.");
  function wrapped() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(id) {
  {
    console.warn("Instance " + id + " has been disposed");
  }
}
var actions = {};
var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function registerTheme(name2, theme2) {
  themeStorage[name2] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf2(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name2, cb) {
  lifecycle$1.on(name2, cb);
}
function registerAction(actionInfo2, eventName, action) {
  if (isFunction(eventName)) {
    action = eventName;
    eventName = "";
  }
  var actionType = isObject$3(actionInfo2) ? actionInfo2.type : [actionInfo2, actionInfo2 = {
    event: eventName
  }][0];
  actionInfo2.event = (actionInfo2.event || actionType).toLowerCase();
  eventName = actionInfo2.event;
  if (eventActionMap[eventName]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
  if (!actions[actionType]) {
    actions[actionType] = {
      action,
      actionInfo: actionInfo2
    };
  }
  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem.register(type, coordSysCreator);
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
  if (isFunction(priority) || isObject$3(priority)) {
    fn = priority;
    priority = defaultPriority;
  }
  {
    if (isNaN(priority) || priority == null) {
      throw new Error("Illegal priority");
    }
    each$f(targetList, function(wrap2) {
      assert(wrap2.__raw !== fn);
    });
  }
  if (indexOf2(registeredTasks, fn) >= 0) {
    return;
  }
  registeredTasks.push(fn);
  var stageHandler = Scheduler$1.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList.push(stageHandler);
}
function registerLoading(name2, loadingFx) {
  loadingEffects[name2] = loadingFx;
}
function registerMap$1(mapName, geoJson, specialAreas) {
  var registerMap2 = getImpl("registerMap");
  registerMap2 && registerMap2(mapName, geoJson, specialAreas);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop);
registerTheme("light", lightTheme);
registerTheme("dark", darkTheme);
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap: registerMap$1,
  registerImpl,
  PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  registerComponentModel: function(ComponentModelClass) {
    ComponentModel$1.registerClass(ComponentModelClass);
  },
  registerComponentView: function(ComponentViewClass) {
    ComponentView$1.registerClass(ComponentViewClass);
  },
  registerSeriesModel: function(SeriesModelClass) {
    SeriesModel$1.registerClass(SeriesModelClass);
  },
  registerChartView: function(ChartViewClass) {
    ChartView$1.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter: function(componentType, defaulter) {
    ComponentModel$1.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter: function(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use2(ext) {
  if (isArray$1(ext)) {
    each$f(ext, function(singleExt) {
      use2(singleExt);
    });
    return;
  }
  if (indexOf2(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = function() {
  function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  DataDiffer2.prototype.add = function(func) {
    this._add = func;
    return this;
  };
  DataDiffer2.prototype.update = function(func) {
    this._update = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToOne = function(func) {
    this._updateManyToOne = func;
    return this;
  };
  DataDiffer2.prototype.updateOneToMany = function(func) {
    this._updateOneToMany = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToMany = function(func) {
    this._updateManyToMany = func;
    return this;
  };
  DataDiffer2.prototype.remove = function(func) {
    this._remove = func;
    return this;
  };
  DataDiffer2.prototype.execute = function() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  };
  DataDiffer2.prototype._executeOneToOne = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var newDataIndexMap = {};
    var oldDataKeyArr = new Array(oldArr.length);
    var newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i = 0; i < oldArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        var newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i);
      } else {
        this._remove && this._remove(i);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._executeMultiple = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i = 0; i < oldDataKeyArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var oldIdxMapVal = oldDataIndexMap[oldKey];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
          this._remove && this._remove(oldIdxMapVal[i_1]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
    for (var i = 0; i < newDataKeyArr.length; i++) {
      var newKey = newDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[newKey];
      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (var j = 0; j < idxMapValLen; j++) {
          this._add && this._add(newIdxMapVal[j]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  };
  DataDiffer2.prototype._initIndexMap = function(arr, map5, keyArr, keyGetterName) {
    var cbModeMultiple = this._diffModeMultiple;
    for (var i = 0; i < arr.length; i++) {
      var key = "_ec_" + this[keyGetterName](arr[i], i);
      if (!cbModeMultiple) {
        keyArr[i] = key;
      }
      if (!map5) {
        continue;
      }
      var idxMapVal = map5[key];
      var idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map5[key] = i;
        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map5[key] = [idxMapVal, i];
      } else {
        idxMapVal.push(i);
      }
    }
  };
  return DataDiffer2;
}();
var DataDiffer$1 = DataDiffer;
var DimensionUserOuput = function() {
  function DimensionUserOuput2(encode2, dimRequest) {
    this._encode = encode2;
    this._schema = dimRequest;
  }
  DimensionUserOuput2.prototype.get = function() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  };
  DimensionUserOuput2.prototype._getFullDimensionNames = function() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  };
  return DimensionUserOuput2;
}();
function summarizeDimensions(data, schema) {
  var summary = {};
  var encode2 = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  var userOutputEncode = {};
  each$f(data.dimensions, function(dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;
    if (coordDim) {
      {
        assert(VISUAL_DIMENSIONS.get(coordDim) == null);
      }
      var coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode2, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v, otherDim) {
      var encodeArr = getOrCreateEncodeArr(encode2, otherDim);
      var dimIndex = dimItem.otherDims[otherDim];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v, coordDim) {
    var dimArr = encode2[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function(dimName) {
    return data.getDimensionInfo(dimName).storeDimIndex;
  });
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode2.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  var encodeTooltip = encode2.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode2.defaultedLabel = defaultedLabel;
  encode2.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode2, dim) {
  if (!encode2.hasOwnProperty(dim)) {
    encode2[dim] = [];
  }
  return encode2[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}
var SeriesDimensionDefine = function() {
  function SeriesDimensionDefine2(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend2(this, opt);
    }
  }
  return SeriesDimensionDefine2;
}();
var SeriesDimensionDefine$1 = SeriesDimensionDefine;
var inner$h = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = function() {
  function SeriesDataSchema2(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  SeriesDataSchema2.prototype.isDimensionOmitted = function() {
    return this._dimOmitted;
  };
  SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  };
  SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  };
  SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
    var dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  };
  SeriesDataSchema2.prototype.makeStoreSchema = function() {
    var dimCount = this._fullDimCount;
    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    var dimHash = "";
    var dims = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      var property = void 0;
      var type = void 0;
      var ordinalMeta = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }
      dims.push({
        property,
        type,
        ordinalMeta
      });
      if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    var source2 = this.source;
    var hash = [source2.seriesLayoutBy, source2.startIndex, dimHash].join("$$");
    return {
      dimensions: dims,
      hash
    };
  };
  SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
    var result = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      var name_1 = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name_1 = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name_1 = sourceDimDef.name;
        }
      }
      result.push(name_1);
    }
    return result;
  };
  SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  };
  return SeriesDataSchema2;
}();
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  var dataDimNameMap = createHashMap();
  for (var i = 0; i < (dimsDef || []).length; i++) {
    var dimDefItemRaw = dimsDef[i];
    var userDimName = isObject$3(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source2) {
  var innerSource = inner$h(source2);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source2.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}
var isObject$1 = isObject$3;
var map4 = map$1;
var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId2;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
  function SeriesData2(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
    var dimensions;
    var assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    var needsHasOwn = false;
    var emptyObj = {};
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfoInput = dimensions[i];
      var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine$1({
        name: dimInfoInput
      }) : !(dimInfoInput instanceof SeriesDimensionDefine$1) ? new SeriesDimensionDefine$1(dimInfoInput) : dimInfoInput;
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = i;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = i;
      }
      {
        assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      var dimIdxToName_1 = this._dimIdxToName = createHashMap();
      each$f(dimensionNames, function(dimName) {
        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  SeriesData2.prototype.getDimension = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    var dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    var sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  };
  SeriesData2.prototype.getDimensionIndex = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    var dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  };
  SeriesData2.prototype._recognizeDimIndex = function(dim) {
    if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  };
  SeriesData2.prototype._getStoreDimIndex = function(dim) {
    var dimIdx = this.getDimensionIndex(dim);
    {
      if (dimIdx == null) {
        throw new Error("Unkown dimension " + dim);
      }
    }
    return dimIdx;
  };
  SeriesData2.prototype.getDimensionInfo = function(dim) {
    return this._getDimInfo(this.getDimension(dim));
  };
  SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
    var dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? function(dimName) {
      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
    } : function(dimName) {
      return dimensionInfos[dimName];
    };
  };
  SeriesData2.prototype.getDimensionsOnCoord = function() {
    return this._dimSummary.dataDimsOnCoord.slice();
  };
  SeriesData2.prototype.mapDimension = function(coordDim, idx) {
    var dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    var dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  };
  SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
    var dimensionsSummary = this._dimSummary;
    var dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  };
  SeriesData2.prototype.getStore = function() {
    return this._store;
  };
  SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
    var _this = this;
    var store;
    if (data instanceof DataStore) {
      store = data;
    }
    if (!store) {
      var dimensions = this.dimensions;
      var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore();
      var dimensionInfos = map4(dimensions, function(dimName) {
        return {
          type: _this._dimInfos[dimName].type,
          property: dimName
        };
      });
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  };
  SeriesData2.prototype.appendData = function(data) {
    var range = this._store.appendData(data);
    this._doInit(range[0], range[1]);
  };
  SeriesData2.prototype.appendValues = function(values3, names) {
    var _a2 = this._store.appendValues(values3, names.length), start2 = _a2.start, end2 = _a2.end;
    var shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names) {
      for (var idx = start2; idx < end2; idx++) {
        var sourceIdx = idx - start2;
        this._nameList[idx] = names[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  };
  SeriesData2.prototype._updateOrdinalMeta = function() {
    var store = this._store;
    var dimensions = this.dimensions;
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfo = this._dimInfos[dimensions[i]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  };
  SeriesData2.prototype._shouldMakeIdFromName = function() {
    var provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  };
  SeriesData2.prototype._doInit = function(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    var store = this._store;
    var provider = store.getProvider();
    this._updateOrdinalMeta();
    var nameList = this._nameList;
    var idList = this._idList;
    var sourceFormat = provider.getSource().sourceFormat;
    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      var sharedDataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        var dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          var itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          var itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (var idx = start2; idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  };
  SeriesData2.prototype.getApproximateExtent = function(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent3.slice();
  };
  SeriesData2.prototype.getCalculationInfo = function(key) {
    return this._calculationInfo[key];
  };
  SeriesData2.prototype.setCalculationInfo = function(key, value) {
    isObject$1(key) ? extend2(this._calculationInfo, key) : this._calculationInfo[key] = value;
  };
  SeriesData2.prototype.getName = function(idx) {
    var rawIndex = this.getRawIndex(idx);
    var name2 = this._nameList[rawIndex];
    if (name2 == null && this._nameDimIdx != null) {
      name2 = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name2 == null) {
      name2 = "";
    }
    return name2;
  };
  SeriesData2.prototype._getCategory = function(dimIdx, idx) {
    var ordinal = this._store.get(dimIdx, idx);
    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  };
  SeriesData2.prototype.getId = function(idx) {
    return getId2(this, this.getRawIndex(idx));
  };
  SeriesData2.prototype.count = function() {
    return this._store.count();
  };
  SeriesData2.prototype.get = function(dim, idx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  };
  SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  };
  SeriesData2.prototype.getIndices = function() {
    return this._store.getIndices();
  };
  SeriesData2.prototype.getDataExtent = function(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getSum = function(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getMedian = function(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getValues = function(dimensions, idx) {
    var _this = this;
    var store = this._store;
    return isArray$1(dimensions) ? store.getValues(map4(dimensions, function(dim) {
      return _this._getStoreDimIndex(dim);
    }), idx) : store.getValues(dimensions);
  };
  SeriesData2.prototype.hasValue = function(idx) {
    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (var i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
        return false;
      }
    }
    return true;
  };
  SeriesData2.prototype.indexOfName = function(name2) {
    for (var i = 0, len2 = this._store.count(); i < len2; i++) {
      if (this.getName(i) === name2) {
        return i;
      }
    }
    return -1;
  };
  SeriesData2.prototype.getRawIndex = function(idx) {
    return this._store.getRawIndex(idx);
  };
  SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  };
  SeriesData2.prototype.rawIndexOf = function(dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    {
      if (!invertedIndices) {
        throw new Error("Do not supported yet");
      }
    }
    var rawIndex = invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  };
  SeriesData2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
  };
  SeriesData2.prototype.each = function(dims, cb, ctx) {
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map4(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map4(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return this;
  };
  SeriesData2.prototype.selectRange = function(range) {
    var _this = this;
    var innerRange = {};
    var dims = keys2(range);
    each$f(dims, function(dim) {
      var dimIdx = _this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range[dim];
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  };
  SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    var result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  };
  SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map4(normalizeDimensions(dims), this._getStoreDimIndex, this);
    var list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return list;
  };
  SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
    var _this = this;
    var fCtx = ctx || ctxCompat || this;
    {
      each$f(normalizeDimensions(dims), function(dim) {
        var dimInfo = _this.getDimensionInfo(dim);
        if (!dimInfo.isCalculationCoord) {
          console.error("Danger: only stack dimension can be modified");
        }
      });
    }
    var dimIndices = map4(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  };
  SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  };
  SeriesData2.prototype.getRawDataItem = function(idx) {
    return this._store.getRawDataItem(idx);
  };
  SeriesData2.prototype.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    var dataItem = this.getRawDataItem(idx);
    return new Model$1(dataItem, hostModel, hostModel && hostModel.ecModel);
  };
  SeriesData2.prototype.diff = function(otherList) {
    var thisList = this;
    return new DataDiffer$1(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId2(otherList, idx);
    }, function(idx) {
      return getId2(thisList, idx);
    });
  };
  SeriesData2.prototype.getVisual = function(key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  SeriesData2.prototype.setVisual = function(kvObj, val) {
    this._visual = this._visual || {};
    if (isObject$1(kvObj)) {
      extend2(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  };
  SeriesData2.prototype.getItemVisual = function(idx, key) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];
    if (val == null) {
      return this.getVisual(key);
    }
    return val;
  };
  SeriesData2.prototype.hasItemVisual = function() {
    return this._itemVisuals.length > 0;
  };
  SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key) {
    var itemVisuals = this._itemVisuals;
    var itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    var val = itemVisual[key];
    if (val == null) {
      val = this.getVisual(key);
      if (isArray$1(val)) {
        val = val.slice();
      } else if (isObject$1(val)) {
        val = extend2({}, val);
      }
      itemVisual[key] = val;
    }
    return val;
  };
  SeriesData2.prototype.setItemVisual = function(idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject$1(key)) {
      extend2(itemVisual, key);
    } else {
      itemVisual[key] = value;
    }
  };
  SeriesData2.prototype.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
  };
  SeriesData2.prototype.setLayout = function(key, val) {
    isObject$1(key) ? extend2(this._layout, key) : this._layout[key] = val;
  };
  SeriesData2.prototype.getLayout = function(key) {
    return this._layout[key];
  };
  SeriesData2.prototype.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  SeriesData2.prototype.setItemLayout = function(idx, layout2, merge4) {
    this._itemLayouts[idx] = merge4 ? extend2(this._itemLayouts[idx] || {}, layout2) : layout2;
  };
  SeriesData2.prototype.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  };
  SeriesData2.prototype.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
    each$f(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  SeriesData2.prototype.cloneShallow = function(list) {
    if (!list) {
      list = new SeriesData2(this._schema ? this._schema : map4(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list, this);
    list._store = this._store;
    return list;
  };
  SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (!isFunction(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  };
  SeriesData2.internalField = function() {
    prepareInvertedIndex = function(data) {
      var invertedIndicesMap = data._invertedIndicesMap;
      each$f(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = data._dimInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        var store = data._store;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }
          for (var i = 0; i < store.count(); i++) {
            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
          }
        }
      });
    };
    getIdNameFromStore = function(data, dimIdx, idx) {
      return convertOptionIdName(data._getCategory(dimIdx, idx), null);
    };
    getId2 = function(data, rawIndex) {
      var id = data._idList[rawIndex];
      if (id == null && data._idDimIdx != null) {
        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
      }
      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }
      return id;
    };
    normalizeDimensions = function(dimensions) {
      if (!isArray$1(dimensions)) {
        dimensions = dimensions != null ? [dimensions] : [];
      }
      return dimensions;
    };
    cloneListForMapAndSample = function(original) {
      var list = new SeriesData2(original._schema ? original._schema : map4(original.dimensions, original._getDimInfo, original), original.hostModel);
      transferProperties(list, original);
      return list;
    };
    transferProperties = function(target, source2) {
      each$f(TRANSFERABLE_PROPERTIES.concat(source2.__wrappedMethods || []), function(propName) {
        if (source2.hasOwnProperty(propName)) {
          target[propName] = source2[propName];
        }
      });
      target.__wrappedMethods = source2.__wrappedMethods;
      each$f(CLONE_PROPERTIES, function(propName) {
        target[propName] = clone$4(source2[propName]);
      });
      target._calculationInfo = extend2({}, source2._calculationInfo);
    };
    makeIdFromName = function(data, idx) {
      var nameList = data._nameList;
      var idList = data._idList;
      var nameDimIdx = data._nameDimIdx;
      var idDimIdx = data._idDimIdx;
      var name2 = nameList[idx];
      var id = idList[idx];
      if (name2 == null && nameDimIdx != null) {
        nameList[idx] = name2 = getIdNameFromStore(data, nameDimIdx, idx);
      }
      if (id == null && idDimIdx != null) {
        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
      }
      if (id == null && name2 != null) {
        var nameRepeatCount = data._nameRepeatCount;
        var nmCnt = nameRepeatCount[name2] = (nameRepeatCount[name2] || 0) + 1;
        id = name2;
        if (nmCnt > 1) {
          id += "__ec__" + nmCnt;
        }
        idList[idx] = id;
      }
    };
  }();
  return SeriesData2;
}();
var SeriesData$1 = SeriesData;
function prepareSeriesDataSchema(source2, opt) {
  if (!isSourceInstance(source2)) {
    source2 = createSourceFromSeriesDataOption(source2);
  }
  opt = opt || {};
  var sysDims = opt.coordDimensions || [];
  var dimsDef = opt.dimensionsDefine || source2.dimensionsDefine || [];
  var coordDimNameMap = createHashMap();
  var resultList = [];
  var dimCount = getDimCount(source2, sysDims, dimsDef, opt.dimensionsCount);
  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  var isUsingSourceDimensionsDef = dimsDef === source2.dimensionsDefine;
  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source2) : createDimNameMap(dimsDef);
  var encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source2, dimCount);
  }
  var encodeDefMap = createHashMap(encodeDef);
  var indicesMap = new CtorInt32Array$1(dimCount);
  for (var i = 0; i < indicesMap.length; i++) {
    indicesMap[i] = -1;
  }
  function getResultItem(dimIdx) {
    var idx = indicesMap[dimIdx];
    if (idx < 0) {
      var dimDefItemRaw = dimsDef[dimIdx];
      var dimDefItem = isObject$3(dimDefItemRaw) ? dimDefItemRaw : {
        name: dimDefItemRaw
      };
      var resultItem2 = new SeriesDimensionDefine$1();
      var userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem2.name = resultItem2.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
      var newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem2.storeDimIndex = dimIdx;
      resultList.push(resultItem2);
      return resultItem2;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (var i = 0; i < dimCount; i++) {
      getResultItem(i);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim2) {
    var dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim2, false);
      return;
    }
    var validDataDims = encodeDefMap.set(coordDim2, []);
    each$f(dataDims, function(resultDimIdxOrName, idx) {
      var resultDimIdx2 = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
        validDataDims[idx] = resultDimIdx2;
        applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
      }
    });
  });
  var availDimIdx = 0;
  each$f(sysDims, function(sysDimItemRaw) {
    var coordDim2;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;
    var sysDimItem;
    if (isString(sysDimItemRaw)) {
      coordDim2 = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim2 = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend2({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    var dataDims = encodeDefMap.get(coordDim2);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each$f(dataDims, function(resultDimIdx2, coordDimIndex) {
      var resultItem2 = getResultItem(resultDimIdx2);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem2.type = sysDimItem.type;
      }
      applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
      if (resultItem2.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject$3(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
        resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem2, coordDim2, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
      resultItem2.otherDims[coordDim2] = coordDimIndex;
    } else {
      resultItem2.coordDim = coordDim2;
      resultItem2.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim2, true);
    }
  }
  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem2) {
    if (resultItem2.name == null) {
      resultItem2.name = resultItem2.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = getResultItem(resultDimIdx);
      var coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source2, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each$f(resultList, function(resultItem2) {
      ifNoNameFillWithCoordName(resultItem2);
    });
    resultList.sort(function(item0, item1) {
      return item0.storeDimIndex - item1.storeDimIndex;
    });
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source: source2,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  var duplicationMap = createHashMap();
  for (var i = 0; i < result.length; i++) {
    var dim = result[i];
    var dimOriginalName = dim.name;
    var count3 = duplicationMap.get(dimOriginalName) || 0;
    if (count3 > 0) {
      dim.name = dimOriginalName + (count3 - 1);
    }
    count3++;
    duplicationMap.set(dimOriginalName, count3);
  }
}
function getDimCount(source2, sysDims, dimsDef, optDimCount) {
  var dimCount = Math.max(source2.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each$f(sysDims, function(sysDimItem) {
    var sysDimItemDimsDef;
    if (isObject$3(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name2, map5, fromZero) {
  var mapData = map5.data;
  if (fromZero || mapData.hasOwnProperty(name2)) {
    var i = 0;
    while (mapData.hasOwnProperty(name2 + i)) {
      i++;
    }
    name2 += i;
  }
  map5.set(name2, true);
  return name2;
}
var CoordSysInfo = function() {
  function CoordSysInfo2(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
  return CoordSysInfo2;
}();
function getCoordSysInfoBySeries(seriesModel) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var result = new CoordSysInfo(coordSysName);
  var fetch = fetchers[coordSysName];
  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    {
      if (!xAxisModel) {
        throw new Error('xAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + '" not found');
      }
      if (!yAxisModel) {
        throw new Error('yAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + '" not found');
      }
    }
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    {
      if (!singleAxisModel) {
        throw new Error("singleAxis should be specified.");
      }
    }
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    var angleAxisModel = polarModel.findAxisModel("angleAxis");
    {
      if (!angleAxisModel) {
        throw new Error("angleAxis option not found");
      }
      if (!radiusAxisModel) {
        throw new Error("radiusAxis option not found");
      }
    }
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each$f(parallelModel.parallelAxisIndex, function(axisIndex, index2) {
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axisDim = coordSysDims[index2];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index2;
        }
      }
    });
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension;
  var dimensionDefineList;
  var schema;
  var store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  var mayStack = !!(seriesModel && seriesModel.get("stack"));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each$f(dimensionDefineList, function(dimensionInfo, index2) {
    if (isString(dimensionInfo)) {
      dimensionDefineList[index2] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex_1 = 0;
    each$f(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
        stackedDimCoordIndex_1++;
      }
    });
    var stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim_1,
      coordDimIndex: stackedDimCoordIndex_1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    var stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex_1 + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
  return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map$1(coordSysInfo.coordSysDims, function(dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        var axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysInfo && each$f(dimInfoList, function(dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  var sourceManager = seriesModel.getSourceManager();
  var source2;
  var isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source2 = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source2 = sourceManager.getSource();
    isOriginalSource = source2.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  var useEncodeDefaulter = opt.useEncodeDefaulter;
  var encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  var createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  var schema = prepareSeriesDataSchema(source2, createDimensionOptions);
  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  var stackCalculationInfo = enableDataStack(seriesModel, {
    schema,
    store
  });
  var data = new SeriesData$1(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source2) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData(
    isOriginalSource ? source2 : store,
    null,
    dimValueGetter
  );
  return data;
}
function isNeedCompleteOrdinalData(source2) {
  if (source2.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source2.data || []);
    return !isArray$1(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  var i = 0;
  while (i < arr.length && arr[i] == null) {
    i++;
  }
  return arr[i];
}
var Scale = function() {
  function Scale2(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
  }
  Scale2.prototype.getSetting = function(name2) {
    return this._setting[name2];
  };
  Scale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
  };
  Scale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  Scale2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Scale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
  };
  Scale2.prototype.isInExtentRange = function(value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  Scale2.prototype.isBlank = function() {
    return this._isBlank;
  };
  Scale2.prototype.setBlank = function(isBlank) {
    this._isBlank = isBlank;
  };
  return Scale2;
}();
enableClassManagement(Scale);
var Scale$1 = Scale;
var uidBase = 0;
var OrdinalMeta = function() {
  function OrdinalMeta2(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }
  OrdinalMeta2.createByAxisModel = function(axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map$1(data, getName);
    return new OrdinalMeta2({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  };
  OrdinalMeta2.prototype.getOrdinal = function(category) {
    return this._getOrCreateMap().get(category);
  };
  OrdinalMeta2.prototype.parseAndCollect = function(category) {
    var index2;
    var needCollect = this._needCollect;
    if (!isString(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index2 = this.categories.length;
      this.categories[index2] = category;
      return index2;
    }
    var map5 = this._getOrCreateMap();
    index2 = map5.get(category);
    if (index2 == null) {
      if (needCollect) {
        index2 = this.categories.length;
        this.categories[index2] = category;
        map5.set(category, index2);
      } else {
        index2 = NaN;
      }
    }
    return index2;
  };
  OrdinalMeta2.prototype._getOrCreateMap = function() {
    return this._map || (this._map = createHashMap(this.categories));
  };
  return OrdinalMeta2;
}();
function getName(obj) {
  if (isObject$3(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta$1 = OrdinalMeta;
function isValueNice(val) {
  var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
  var f = Math.abs(val / exp10);
  return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
}
function isIntervalOrLogScale(scale4) {
  return scale4.type === "interval" || scale4.type === "log";
}
function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent3[1] - extent3[0];
  var interval = result.interval = nice(span / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  var precision = result.intervalPrecision = getIntervalPrecision(interval);
  var niceTickExtent = result.niceTickExtent = [round$3(Math.ceil(extent3[0] / interval) * interval, precision), round$3(Math.floor(extent3[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent3);
  return result;
}
function increaseInterval(interval) {
  var exp10 = Math.pow(10, quantityExponent(interval));
  var f = interval / exp10;
  if (!f) {
    f = 1;
  } else if (f === 2) {
    f = 3;
  } else if (f === 3) {
    f = 5;
  } else {
    f *= 2;
  }
  return round$3(f * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp2(niceTickExtent, idx, extent3) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
}
function fixExtent(niceTickExtent, extent3) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
  clamp2(niceTickExtent, 0, extent3);
  clamp2(niceTickExtent, 1, extent3);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain$1(val, extent3) {
  return val >= extent3[0] && val <= extent3[1];
}
function normalize$2(val, extent3) {
  if (extent3[1] === extent3[0]) {
    return 0.5;
  }
  return (val - extent3[0]) / (extent3[1] - extent3[0]);
}
function scale3(val, extent3) {
  return val * (extent3[1] - extent3[0]) + extent3[0];
}
var OrdinalScale = function(_super) {
  __extends$1(OrdinalScale2, _super);
  function OrdinalScale2(setting) {
    var _this = _super.call(this, setting) || this;
    _this.type = "ordinal";
    var ordinalMeta = _this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta$1({});
    }
    if (isArray$1(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta$1({
        categories: map$1(ordinalMeta, function(item) {
          return isObject$3(item) ? item.value : item;
        })
      });
    }
    _this._ordinalMeta = ordinalMeta;
    _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
    return _this;
  }
  OrdinalScale2.prototype.parse = function(val) {
    if (val == null) {
      return NaN;
    }
    return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
  };
  OrdinalScale2.prototype.contain = function(rank) {
    rank = this.parse(rank);
    return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
  };
  OrdinalScale2.prototype.normalize = function(val) {
    val = this._getTickNumber(this.parse(val));
    return normalize$2(val, this._extent);
  };
  OrdinalScale2.prototype.scale = function(val) {
    val = Math.round(scale3(val, this._extent));
    return this.getRawOrdinalNumber(val);
  };
  OrdinalScale2.prototype.getTicks = function() {
    var ticks = [];
    var extent3 = this._extent;
    var rank = extent3[0];
    while (rank <= extent3[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }
    return ticks;
  };
  OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
    return;
  };
  OrdinalScale2.prototype.setSortInfo = function(info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    var infoOrdinalNumbers = info.ordinalNumbers;
    var ordinalsByTick = this._ordinalNumbersByTick = [];
    var ticksByOrdinal = this._ticksByOrdinalNumber = [];
    var tickNum = 0;
    var allCategoryLen = this._ordinalMeta.categories.length;
    for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
      var ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    var unusedOrdinal = 0;
    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  };
  OrdinalScale2.prototype._getTickNumber = function(ordinal) {
    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  };
  OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
    var ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  };
  OrdinalScale2.prototype.getLabel = function(tick) {
    if (!this.isBlank()) {
      var ordinalNumber = this.getRawOrdinalNumber(tick.value);
      var cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  };
  OrdinalScale2.prototype.count = function() {
    return this._extent[1] - this._extent[0] + 1;
  };
  OrdinalScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  OrdinalScale2.prototype.isInExtentRange = function(value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  OrdinalScale2.prototype.getOrdinalMeta = function() {
    return this._ordinalMeta;
  };
  OrdinalScale2.prototype.calcNiceTicks = function() {
  };
  OrdinalScale2.prototype.calcNiceExtent = function() {
  };
  OrdinalScale2.type = "ordinal";
  return OrdinalScale2;
}(Scale$1);
Scale$1.registerClass(OrdinalScale);
var OrdinalScale$1 = OrdinalScale;
var roundNumber = round$3;
var IntervalScale = function(_super) {
  __extends$1(IntervalScale2, _super);
  function IntervalScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "interval";
    _this._interval = 0;
    _this._intervalPrecision = 2;
    return _this;
  }
  IntervalScale2.prototype.parse = function(val) {
    return val;
  };
  IntervalScale2.prototype.contain = function(val) {
    return contain$1(val, this._extent);
  };
  IntervalScale2.prototype.normalize = function(val) {
    return normalize$2(val, this._extent);
  };
  IntervalScale2.prototype.scale = function(val) {
    return scale3(val, this._extent);
  };
  IntervalScale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = parseFloat(start2);
    }
    if (!isNaN(end2)) {
      thisExtent[1] = parseFloat(end2);
    }
  };
  IntervalScale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
    this.setExtent(extent3[0], extent3[1]);
  };
  IntervalScale2.prototype.getInterval = function() {
    return this._interval;
  };
  IntervalScale2.prototype.setInterval = function(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  };
  IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
    var interval = this._interval;
    var extent3 = this._extent;
    var niceTickExtent = this._niceExtent;
    var intervalPrecision = this._intervalPrecision;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    var safeLimit = 1e4;
    if (extent3[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[0]
        });
      }
    }
    var tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent3[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[1]
        });
      }
    }
    return ticks;
  };
  IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
    var ticks = this.getTicks(true);
    var minorTicks = [];
    var extent3 = this.getExtent();
    for (var i = 1; i < ticks.length; i++) {
      var nextTick = ticks[i];
      var prevTick = ticks[i - 1];
      var count3 = 0;
      var minorTicksGroup = [];
      var interval = nextTick.value - prevTick.value;
      var minorInterval = interval / splitNumber;
      while (count3 < splitNumber - 1) {
        var minorTick = roundNumber(prevTick.value + (count3 + 1) * minorInterval);
        if (minorTick > extent3[0] && minorTick < extent3[1]) {
          minorTicksGroup.push(minorTick);
        }
        count3++;
      }
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  };
  IntervalScale2.prototype.getLabel = function(data, opt) {
    if (data == null) {
      return "";
    }
    var precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    var dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  };
  IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent3.reverse();
    }
    var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  };
  IntervalScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      if (extent3[0] !== 0) {
        var expandSize = Math.abs(extent3[0]);
        if (!opt.fixMax) {
          extent3[1] += expandSize / 2;
          extent3[0] -= expandSize / 2;
        } else {
          extent3[0] -= expandSize / 2;
        }
      } else {
        extent3[1] = 1;
      }
    }
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      extent3[0] = 0;
      extent3[1] = 1;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    var interval = this._interval;
    if (!opt.fixMin) {
      extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
    }
  };
  IntervalScale2.prototype.setNiceExtent = function(min5, max4) {
    this._niceExtent = [min5, max4];
  };
  IntervalScale2.type = "interval";
  return IntervalScale2;
}(Scale$1);
Scale$1.registerClass(IntervalScale);
var IntervalScale$1 = IntervalScale;
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray$1(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey$1(axis) {
  return axis.dim + axis.index;
}
function getLayoutOnAxis(opt) {
  var params = [];
  var baseAxis = opt.axis;
  var axisKey = "axis0";
  if (baseAxis.type !== "category") {
    return;
  }
  var bandWidth = baseAxis.getBandWidth();
  for (var i = 0; i < opt.count || 0; i++) {
    params.push(defaults({
      bandWidth,
      axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }
  var widthAndOffsets = doCalBarWidthAndOffset(params);
  var result = [];
  for (var i = 0; i < opt.count; i++) {
    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }
  return result;
}
function prepareLayoutBarSeries(seriesType2, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  var axisValues = {};
  each$f(barSeries, function(seriesModel) {
    var cartesian2 = seriesModel.coordinateSystem;
    var baseAxis = cartesian2.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    var data = seriesModel.getData();
    var key2 = baseAxis.dim + "_" + baseAxis.index;
    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    var store = data.getStore();
    for (var i = 0, cnt = store.count(); i < cnt; ++i) {
      var value = store.get(dimIdx, i);
      if (!axisValues[key2]) {
        axisValues[key2] = [value];
      } else {
        axisValues[key2].push(value);
      }
    }
  });
  var axisMinGaps = {};
  for (var key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      var valuesInAxis = axisValues[key];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a, b) {
          return a - b;
        });
        var min5 = null;
        for (var j = 1; j < valuesInAxis.length; ++j) {
          var delta2 = valuesInAxis[j] - valuesInAxis[j - 1];
          if (delta2 > 0) {
            min5 = min5 === null ? delta2 : Math.min(min5, delta2);
          }
        }
        axisMinGaps[key] = min5;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  var axisMinGaps = getValueAxesMinGaps(barSeries);
  var seriesInfoList = [];
  each$f(barSeries, function(seriesModel) {
    var cartesian2 = seriesModel.coordinateSystem;
    var baseAxis = cartesian2.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      var key = baseAxis.dim + "_" + baseAxis.index;
      var minGap = axisMinGaps[key];
      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      var scale4 = baseAxis.scale.getExtent();
      var scaleSpan = Math.abs(scale4[1] - scale4[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      var data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }
    var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
    var barMinWidth = parsePercent(
      seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1),
      bandWidth
    );
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      axisKey: getAxisKey$1(baseAxis),
      stackId: getSeriesStackId$1(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  var columnsMap = {};
  each$f(seriesInfoList, function(seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$f(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      var columnCount = keys2(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    var categoryGap = parsePercent(categoryGapPercent, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$f(stacks, function(column) {
      var maxWidth = column.maxWidth;
      var minWidth = column.minWidth;
      if (!column.width) {
        var finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        var finalWidth = column.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$f(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset = -widthSum / 2;
    each$f(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey$1(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId$1(seriesModel)];
    }
    return result;
  }
}
function layout$3(seriesType2, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  each$f(seriesModels, function(seriesModel) {
    var data = seriesModel.getData();
    var cartesian2 = seriesModel.coordinateSystem;
    var baseAxis = cartesian2.getBaseAxis();
    var stackId = getSeriesStackId$1(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey$1(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType2) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var cartesian2 = seriesModel.coordinateSystem;
      var baseAxis = cartesian2.getBaseAxis();
      var valueAxis2 = cartesian2.getOtherAxis(baseAxis);
      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var drawBackground = seriesModel.get("showBackground", true);
      var valueDim = data.mapDimension(valueAxis2.dim);
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
      var isValueAxisH = valueAxis2.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
      var isLarge = isInLargeMode(seriesModel);
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
      var columnWidth = data.getLayout("size");
      var columnOffset = data.getLayout("offset");
      return {
        progress: function(params, data2) {
          var count3 = params.count;
          var largePoints = isLarge && createFloat32Array(count3 * 3);
          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count3 * 3);
          var largeDataIndices = isLarge && createFloat32Array(count3);
          var coordLayout = cartesian2.master.getRect();
          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          var dataIndex;
          var store = data2.getStore();
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            var baseValue = store.get(baseDimIdx, dataIndex);
            var baseCoord = valueAxisStart;
            var startValue = void 0;
            if (stacked) {
              startValue = +value - store.get(valueDimIdx, dataIndex);
            }
            var x2 = void 0;
            var y2 = void 0;
            var width = void 0;
            var height = void 0;
            if (isValueAxisH) {
              var coord = cartesian2.dataToPoint([value, baseValue]);
              if (stacked) {
                var startCoord = cartesian2.dataToPoint([startValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x2 = baseCoord;
              y2 = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;
              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              var coord = cartesian2.dataToPoint([baseValue, value]);
              if (stacked) {
                var startCoord = cartesian2.dataToPoint([baseValue, startValue]);
                baseCoord = startCoord[1];
              }
              x2 = coord[0] + columnOffset;
              y2 = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;
              if (Math.abs(height) < barMinHeight) {
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data2.setItemLayout(dataIndex, {
                x: x2,
                y: y2,
                width,
                height
              });
            } else {
              largePoints[idxOffset] = x2;
              largePoints[idxOffset + 1] = y2;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x2;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y2 : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data2.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis2) {
  return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? 1 : 0));
}
var bisect = function(a, x2, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid][1] < x2) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
};
var TimeScale = function(_super) {
  __extends$1(TimeScale2, _super);
  function TimeScale2(settings2) {
    var _this = _super.call(this, settings2) || this;
    _this.type = "time";
    return _this;
  }
  TimeScale2.prototype.getLabel = function(tick) {
    var useUTC = this.getSetting("useUTC");
    return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  };
  TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
    var isUTC = this.getSetting("useUTC");
    var lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  };
  TimeScale2.prototype.getTicks = function() {
    var interval = this._interval;
    var extent3 = this._extent;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    ticks.push({
      value: extent3[0],
      level: 0
    });
    var useUTC = this.getSetting("useUTC");
    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent3[1],
      level: 0
    });
    return ticks;
  };
  TimeScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      extent3[0] -= ONE_DAY;
      extent3[1] += ONE_DAY;
    }
    if (extent3[1] === -Infinity && extent3[0] === Infinity) {
      var d = new Date();
      extent3[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent3[0] = extent3[1] - ONE_DAY;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  };
  TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    var scaleIntervalsLen = scaleIntervals.length;
    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  };
  TimeScale2.prototype.parse = function(val) {
    return isNumber(val) ? val : +parseDate(val);
  };
  TimeScale2.prototype.contain = function(val) {
    return contain$1(this.parse(val), this._extent);
  };
  TimeScale2.prototype.normalize = function(val) {
    return normalize$2(this.parse(val), this._extent);
  };
  TimeScale2.prototype.scale = function(val) {
    return scale3(val, this._extent);
  };
  TimeScale2.type = "time";
  return TimeScale2;
}(IntervalScale$1);
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isUnitValueSame(unit, valueA, valueB, isUTC) {
  var dateA = parseDate(valueA);
  var dateB = parseDate(valueB);
  var isSame = function(unit2) {
    return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
  };
  var isSameYear = function() {
    return isSame("year");
  };
  var isSameMonth = function() {
    return isSameYear() && isSame("month");
  };
  var isSameDay = function() {
    return isSameMonth() && isSame("day");
  };
  var isSameHour = function() {
    return isSameDay() && isSame("hour");
  };
  var isSameMinute = function() {
    return isSameHour() && isSame("minute");
  };
  var isSameSecond = function() {
    return isSameMinute() && isSame("second");
  };
  var isSameMilliSecond = function() {
    return isSameSecond() && isSame("millisecond");
  };
  switch (unit) {
    case "year":
      return isSameYear();
    case "month":
      return isSameMonth();
    case "day":
      return isSameDay();
    case "hour":
      return isSameHour();
    case "minute":
      return isSameMinute();
    case "second":
      return isSameSecond();
    case "millisecond":
      return isSameMilliSecond();
  }
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  var APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(date, unitName, isUTC) {
  var outDate = new Date(date);
  switch (getPrimaryTimeUnit(unitName)) {
    case "year":
    case "month":
      outDate[monthSetterName(isUTC)](0);
    case "day":
      outDate[dateSetterName(isUTC)](1);
    case "hour":
      outDate[hoursSetterName(isUTC)](0);
    case "minute":
      outDate[minutesSetterName(isUTC)](0);
    case "second":
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }
  return outDate.getTime();
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
  var safeLimit = 1e4;
  var unitNames = timeUnits;
  var iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate2, out2) {
    var date = new Date(minTimestamp);
    var dateTime = minTimestamp;
    var d = date[getMethodName]();
    while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
      out2.push({
        value: dateTime
      });
      d += interval;
      date[setMethodName](d);
      dateTime = date.getTime();
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
    var newAddedTicks = [];
    var isFirstLevel = !lastLevelTicks.length;
    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
      }, {
        value: extent3[1]
      }];
    }
    for (var i2 = 0; i2 < lastLevelTicks.length - 1; i2++) {
      var startTick = lastLevelTicks[i2].value;
      var endTick = lastLevelTicks[i2 + 1].value;
      if (startTick === endTick) {
        continue;
      }
      var interval = void 0;
      var getterName = void 0;
      var setterName = void 0;
      var isDate2 = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate2 = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate2, newAddedTicks);
      if (unitName === "year" && levelTicks2.length > 1 && i2 === 0) {
        levelTicks2.unshift({
          value: levelTicks2[0].value - interval
        });
      }
    }
    for (var i2 = 0; i2 < newAddedTicks.length; i2++) {
      levelTicks2.push(newAddedTicks[i2]);
    }
    return newAddedTicks;
  }
  var levelsTicks = [];
  var currentLevelTicks = [];
  var tickCount = 0;
  var lastLevelTickCount = 0;
  for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
    if (!isPrimaryTimeUnit(unitNames[i])) {
      continue;
    }
    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort(function(a, b) {
          return a.value - b.value;
        });
        var levelTicksRemoveDuplicated = [];
        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
          var tickValue = currentLevelTicks[i_1].value;
          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
            if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
              tickCount++;
            }
          }
        }
        var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  {
    if (iter >= safeLimit) {
      warn("Exceed safe limit.");
    }
  }
  var levelsTicksInExtent = filter17(map$1(levelsTicks, function(levelTicks2) {
    return filter17(levelTicks2, function(tick) {
      return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
    });
  }), function(levelTicks2) {
    return levelTicks2.length > 0;
  });
  var ticks = [];
  var maxLevel = levelsTicksInExtent.length - 1;
  for (var i = 0; i < levelsTicksInExtent.length; ++i) {
    var levelTicks = levelsTicksInExtent[i];
    for (var k = 0; k < levelTicks.length; ++k) {
      ticks.push({
        value: levelTicks[k].value,
        level: maxLevel - i
      });
    }
  }
  ticks.sort(function(a, b) {
    return a.value - b.value;
  });
  var result = [];
  for (var i = 0; i < ticks.length; ++i) {
    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
      result.push(ticks[i]);
    }
  }
  return result;
}
Scale$1.registerClass(TimeScale);
var TimeScale$1 = TimeScale;
var scaleProto = Scale$1.prototype;
var intervalScaleProto = IntervalScale$1.prototype;
var roundingErrorFix = round$3;
var mathFloor$1 = Math.floor;
var mathCeil$1 = Math.ceil;
var mathPow$1 = Math.pow;
var mathLog$1 = Math.log;
var LogScale = function(_super) {
  __extends$1(LogScale2, _super);
  function LogScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    _this.base = 10;
    _this._originalScale = new IntervalScale$1();
    _this._interval = 0;
    return _this;
  }
  LogScale2.prototype.getTicks = function(expandToNicedExtent) {
    var originalScale = this._originalScale;
    var extent3 = this._extent;
    var originalExtent = originalScale.getExtent();
    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map$1(ticks, function(tick) {
      var val = tick.value;
      var powVal = round$3(mathPow$1(this.base, val));
      powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  };
  LogScale2.prototype.setExtent = function(start2, end2) {
    var base2 = mathLog$1(this.base);
    start2 = mathLog$1(Math.max(0, start2)) / base2;
    end2 = mathLog$1(Math.max(0, end2)) / base2;
    intervalScaleProto.setExtent.call(this, start2, end2);
  };
  LogScale2.prototype.getExtent = function() {
    var base2 = this.base;
    var extent3 = scaleProto.getExtent.call(this);
    extent3[0] = mathPow$1(base2, extent3[0]);
    extent3[1] = mathPow$1(base2, extent3[1]);
    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
    this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
    return extent3;
  };
  LogScale2.prototype.unionExtent = function(extent3) {
    this._originalScale.unionExtent(extent3);
    var base2 = this.base;
    extent3[0] = mathLog$1(extent3[0]) / mathLog$1(base2);
    extent3[1] = mathLog$1(extent3[1]) / mathLog$1(base2);
    scaleProto.unionExtent.call(this, extent3);
  };
  LogScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (span === Infinity || span <= 0) {
      return;
    }
    var interval = quantity(span);
    var err = approxTickNum / span * interval;
    if (err <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    var niceExtent = [round$3(mathCeil$1(extent3[0] / interval) * interval), round$3(mathFloor$1(extent3[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  };
  LogScale2.prototype.calcNiceExtent = function(opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  };
  LogScale2.prototype.parse = function(val) {
    return val;
  };
  LogScale2.prototype.contain = function(val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return contain$1(val, this._extent);
  };
  LogScale2.prototype.normalize = function(val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return normalize$2(val, this._extent);
  };
  LogScale2.prototype.scale = function(val) {
    val = scale3(val, this._extent);
    return mathPow$1(this.base, val);
  };
  LogScale2.type = "log";
  return LogScale2;
}(Scale$1);
var proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecision(originalVal));
}
Scale$1.registerClass(LogScale);
var LogScale$1 = LogScale;
var ScaleRawExtentInfo = function() {
  function ScaleRawExtentInfo2(scale4, model, originalExtent) {
    this._prepareParams(scale4, model, originalExtent);
  }
  ScaleRawExtentInfo2.prototype._prepareParams = function(scale4, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    var isOrdinal = this._isOrdinal = scale4.type === "ordinal";
    this._needCrossZero = scale4.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    var modelMinRaw = this._modelMinRaw = model.get("min", true);
    if (isFunction(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw);
    }
    var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      var boundaryGap = model.get("boundaryGap");
      var boundaryGapArr = isArray$1(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        {
          console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.');
        }
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
      }
    }
  };
  ScaleRawExtentInfo2.prototype.calculate = function() {
    var isOrdinal = this._isOrdinal;
    var dataMin = this._dataMin;
    var dataMax = this._dataMax;
    var axisDataLen = this._axisDataLen;
    var boundaryGapInner = this._boundaryGapInner;
    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    var min5 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    var max4 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    var minFixed = min5 != null;
    var maxFixed = max4 != null;
    if (min5 == null) {
      min5 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max4 == null) {
      max4 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min5 == null || !isFinite(min5)) && (min5 = NaN);
    (max4 == null || !isFinite(max4)) && (max4 = NaN);
    var isBlank = eqNaN(min5) || eqNaN(max4) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min5 > 0 && max4 > 0 && !minFixed) {
        min5 = 0;
      }
      if (min5 < 0 && max4 < 0 && !maxFixed) {
        max4 = 0;
      }
    }
    var determinedMin = this._determinedMin;
    var determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min5 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max4 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min5,
      max: max4,
      minFixed,
      maxFixed,
      isBlank
    };
  };
  ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
    {
      assert(!this.frozen);
    }
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  };
  ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
    {
      assert(!this.frozen && this[attr] == null);
    }
    this[attr] = val;
  };
  ScaleRawExtentInfo2.prototype.freeze = function() {
    this.frozen = true;
  };
  return ScaleRawExtentInfo2;
}();
var DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(scale4, model, originalExtent) {
  var rawExtentInfo = scale4.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale4, model, originalExtent);
  scale4.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale4, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale4.parse(minMax);
}
function getScaleExtent(scale4, model) {
  var scaleType = scale4.type;
  var rawExtentResult = ensureScaleRawExtentInfo(scale4, model, scale4.getExtent()).calculate();
  scale4.setBlank(rawExtentResult.isBlank);
  var min5 = rawExtentResult.min;
  var max4 = rawExtentResult.max;
  var ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    var isBaseAxisAndHasBarSeries_1 = false;
    each$f(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries_1) {
      var barWidthAndOffset = makeColumnLayout(barSeriesModels);
      var adjustedScale = adjustScaleForOverflow(min5, max4, model, barWidthAndOffset);
      min5 = adjustedScale.min;
      max4 = adjustedScale.max;
    }
  }
  return {
    extent: [min5, max4],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min5, max4, model, barWidthAndOffset) {
  var axisExtent = model.axis.getExtent();
  var axisLength = axisExtent[1] - axisExtent[0];
  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === void 0) {
    return {
      min: min5,
      max: max4
    };
  }
  var minOverflow = Infinity;
  each$f(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  each$f(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow;
  var oldRange = max4 - min5;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max4 += overflowBuffer * (maxOverflow / totalOverFlow);
  min5 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min5,
    max: max4
  };
}
function niceScaleExtent(scale4, inModel) {
  var model = inModel;
  var extentInfo = getScaleExtent(scale4, model);
  var extent3 = extentInfo.extent;
  var splitNumber = model.get("splitNumber");
  if (scale4 instanceof LogScale$1) {
    scale4.base = model.get("logBase");
  }
  var scaleType = scale4.type;
  var interval = model.get("interval");
  var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale4.setExtent(extent3[0], extent3[1]);
  scale4.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale4.setInterval && scale4.setInterval(interval);
  }
}
function createScaleByModel$1(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale$1.getClass(axisType) || IntervalScale$1)();
    }
  }
}
function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min5 = dataExtent[0];
  var max4 = dataExtent[1];
  return !(min5 > 0 && max4 > 0 || min5 < 0 && max4 < 0);
}
function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get("formatter");
  var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
  if (axis.scale.type === "time") {
    return function(tpl) {
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString(labelFormatter)) {
    return function(tpl) {
      return function(tick) {
        var label = axis.scale.getLabel(tick);
        var text = tpl.replace("{value}", label != null ? label : "");
        return text;
      };
    }(labelFormatter);
  } else if (isFunction(labelFormatter)) {
    return function(cb) {
      return function(tick, idx) {
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }
        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale4 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale4.isBlank()) {
    return;
  }
  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale4.getExtent();
  if (scale4 instanceof OrdinalScale$1) {
    tickCount = scale4.count();
  } else {
    realNumberScaleTicks = scale4.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (var i = 0; i < tickCount; i += step) {
    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
      value: categoryScaleExtent[0] + i
    };
    var label = labelFormatter(tick, i);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
}
function rotateTextRect(textRect, rotate2) {
  var rotateRadians2 = rotate2 * Math.PI / 180;
  var beforeWidth = textRect.width;
  var beforeHeight = textRect.height;
  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians2)) + Math.abs(beforeHeight * Math.sin(rotateRadians2));
  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians2)) + Math.abs(beforeHeight * Math.cos(rotateRadians2));
  var rotatedRect = new BoundingRect$1(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
function getOptionCategoryInterval(model) {
  var interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  var dataDimMap = {};
  each$f(data.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys2(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
  if (data) {
    each$f(getDataDimensionsOnAxis(data, axisDim), function(dim) {
      var seriesExtent = data.getApproximateExtent(dim);
      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
    });
  }
}
var AxisModelCommonMixin = function() {
  function AxisModelCommonMixin2() {
  }
  AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
    var option = this.option;
    return !option.scale;
  };
  AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
    return;
  };
  return AxisModelCommonMixin2;
}();
var EPSILON = 1e-8;
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
function contain(points2, x2, y2) {
  var w = 0;
  var p = points2[0];
  if (!p) {
    return false;
  }
  for (var i = 1; i < points2.length; i++) {
    var p2 = points2[i];
    w += windingLine(p[0], p[1], p2[0], p2[1], x2, y2);
    p = p2;
  }
  var p0 = points2[0];
  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
    w += windingLine(p[0], p[1], p0[0], p0[1], x2, y2);
  }
  return w !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(points2, transform4) {
  for (var p = 0; p < points2.length; p++) {
    applyTransform$1(points2[p], points2[p], transform4);
  }
}
function updateBBoxFromPoints(points2, min5, max4, projection2) {
  for (var i = 0; i < points2.length; i++) {
    var p = points2[i];
    if (projection2) {
      p = projection2.project(p);
    }
    if (p && isFinite(p[0]) && isFinite(p[1])) {
      min$1(min5, min5, p);
      max$1(max4, max4, p);
    }
  }
}
function centroid$1(points2) {
  var signedArea5 = 0;
  var cx = 0;
  var cy = 0;
  var len2 = points2.length;
  var x02 = points2[len2 - 1][0];
  var y02 = points2[len2 - 1][1];
  for (var i = 0; i < len2; i++) {
    var x12 = points2[i][0];
    var y12 = points2[i][1];
    var a = x02 * y12 - x12 * y02;
    signedArea5 += a;
    cx += (x02 + x12) * a;
    cy += (y02 + y12) * a;
    x02 = x12;
    y02 = y12;
  }
  return signedArea5 ? [cx / signedArea5 / 3, cy / signedArea5 / 3, signedArea5] : [points2[0][0] || 0, points2[0][1] || 0];
}
var Region = function() {
  function Region2(name2) {
    this.name = name2;
  }
  Region2.prototype.setCenter = function(center2) {
    this._center = center2;
  };
  Region2.prototype.getCenter = function() {
    var center2 = this._center;
    if (!center2) {
      center2 = this._center = this.calcCenter();
    }
    return center2;
  };
  return Region2;
}();
var GeoJSONPolygonGeometry = function() {
  function GeoJSONPolygonGeometry2(exterior, interiors) {
    this.type = "polygon";
    this.exterior = exterior;
    this.interiors = interiors;
  }
  return GeoJSONPolygonGeometry2;
}();
var GeoJSONLineStringGeometry = function() {
  function GeoJSONLineStringGeometry2(points2) {
    this.type = "linestring";
    this.points = points2;
  }
  return GeoJSONLineStringGeometry2;
}();
var GeoJSONRegion = function(_super) {
  __extends$1(GeoJSONRegion2, _super);
  function GeoJSONRegion2(name2, geometries, cp) {
    var _this = _super.call(this, name2) || this;
    _this.type = "geoJSON";
    _this.geometries = geometries;
    _this._center = cp && [cp[0], cp[1]];
    return _this;
  }
  GeoJSONRegion2.prototype.calcCenter = function() {
    var geometries = this.geometries;
    var largestGeo;
    var largestGeoSize = 0;
    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      var exterior = geo.exterior;
      var size11 = exterior && exterior.length;
      if (size11 > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size11;
      }
    }
    if (largestGeo) {
      return centroid$1(largestGeo.exterior);
    }
    var rect = this.getBoundingRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.getBoundingRect = function(projection2) {
    var rect = this._rect;
    if (rect && !projection2) {
      return rect;
    }
    var min5 = [Infinity, Infinity];
    var max4 = [-Infinity, -Infinity];
    var geometries = this.geometries;
    each$f(geometries, function(geo) {
      if (geo.type === "polygon") {
        updateBBoxFromPoints(geo.exterior, min5, max4, projection2);
      } else {
        each$f(geo.points, function(points2) {
          updateBBoxFromPoints(points2, min5, max4, projection2);
        });
      }
    });
    if (!(isFinite(min5[0]) && isFinite(min5[1]) && isFinite(max4[0]) && isFinite(max4[1]))) {
      min5[0] = min5[1] = max4[0] = max4[1] = 0;
    }
    rect = new BoundingRect$1(min5[0], min5[1], max4[0] - min5[0], max4[1] - min5[1]);
    if (!projection2) {
      this._rect = rect;
    }
    return rect;
  };
  GeoJSONRegion2.prototype.contain = function(coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;
    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }
    loopGeo:
      for (var i = 0, len2 = geometries.length; i < len2; i++) {
        var geo = geometries[i];
        if (geo.type !== "polygon") {
          continue;
        }
        var exterior = geo.exterior;
        var interiors = geo.interiors;
        if (contain(exterior, coord[0], coord[1])) {
          for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
            if (contain(interiors[k], coord[0], coord[1])) {
              continue loopGeo;
            }
          }
          return true;
        }
      }
    return false;
  };
  GeoJSONRegion2.prototype.transformTo = function(x2, y2, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;
    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }
    var target = new BoundingRect$1(x2, y2, width, height);
    var transform4 = rect.calculateTransform(target);
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      if (geo.type === "polygon") {
        transformPoints(geo.exterior, transform4);
        each$f(geo.interiors, function(interior) {
          transformPoints(interior, transform4);
        });
      } else {
        each$f(geo.points, function(points2) {
          transformPoints(points2, transform4);
        });
      }
    }
    rect = this._rect;
    rect.copy(target);
    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.cloneShallow = function(name2) {
    name2 == null && (name2 = this.name);
    var newRegion = new GeoJSONRegion2(name2, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null;
    return newRegion;
  };
  return GeoJSONRegion2;
}(Region);
var GeoSVGRegion = function(_super) {
  __extends$1(GeoSVGRegion2, _super);
  function GeoSVGRegion2(name2, elOnlyForCalculate) {
    var _this = _super.call(this, name2) || this;
    _this.type = "geoSVG";
    _this._elOnlyForCalculate = elOnlyForCalculate;
    return _this;
  }
  GeoSVGRegion2.prototype.calcCenter = function() {
    var el = this._elOnlyForCalculate;
    var rect = el.getBoundingRect();
    var center2 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    var mat = identity(TMP_TRANSFORM);
    var target = el;
    while (target && !target.isGeoSVGGraphicRoot) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    invert(mat, mat);
    applyTransform$1(center2, center2, mat);
    return center2;
  };
  return GeoSVGRegion2;
}(Region);
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }
  var jsonCompressed = json;
  var encodeScale = jsonCompressed.UTF8Scale;
  if (encodeScale == null) {
    encodeScale = 1024;
  }
  var features2 = jsonCompressed.features;
  each$f(features2, function(feature2) {
    var geometry2 = feature2.geometry;
    var encodeOffsets = geometry2.encodeOffsets;
    var coordinates = geometry2.coordinates;
    if (!encodeOffsets) {
      return;
    }
    switch (geometry2.type) {
      case "LineString":
        geometry2.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;
      case "Polygon":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiLineString":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiPolygon":
        each$f(coordinates, function(rings, idx) {
          return decodeRings(rings, encodeOffsets[idx], encodeScale);
        });
    }
  });
  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
  for (var c = 0; c < rings.length; c++) {
    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
  }
}
function decodeRing(coordinate2, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];
  for (var i = 0; i < coordinate2.length; i += 2) {
    var x2 = coordinate2.charCodeAt(i) - 64;
    var y2 = coordinate2.charCodeAt(i + 1) - 64;
    x2 = x2 >> 1 ^ -(x2 & 1);
    y2 = y2 >> 1 ^ -(y2 & 1);
    x2 += prevX;
    y2 += prevY;
    prevX = x2;
    prevY = y2;
    result.push([x2 / encodeScale, y2 / encodeScale]);
  }
  return result;
}
function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode(geoJson);
  return map$1(filter17(geoJson.features, function(featureObj) {
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function(featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var geometries = [];
    switch (geo.type) {
      case "Polygon":
        var coordinates = geo.coordinates;
        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;
      case "MultiPolygon":
        each$f(geo.coordinates, function(item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;
      case "LineString":
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;
      case "MultiLineString":
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }
    var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}
var inner$g = makeInner();
function createAxisLabels(axis) {
  return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel) {
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
    ticks: map$1(axis.scale.getTicks(), function(tick) {
      return tick.value;
    })
  };
}
function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get("show") || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}
function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, "labels");
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet(labelsCache, optionLabelInterval);
  if (result) {
    return result;
  }
  var labels;
  var numericLabelInterval;
  if (isFunction(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  return listCacheSet(labelsCache, optionLabelInterval, {
    labels,
    labelCategoryInterval: numericLabelInterval
  });
}
function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, "ticks");
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  var ticks;
  var tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map$1(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return listCacheSet(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map$1(ticks, function(tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}
function getListCache(axis, prop) {
  return inner$g(axis)[prop] || (inner$g(axis)[prop] = []);
}
function listCacheGet(cache, key) {
  for (var i = 0; i < cache.length; i++) {
    if (cache[i].key === key) {
      return cache[i].value;
    }
  }
}
function listCacheSet(cache, key, value) {
  cache.push({
    key,
    value
  });
  return value;
}
function makeAutoCategoryInterval(axis) {
  var result = inner$g(axis).autoInterval;
  return result != null ? result : inner$g(axis).autoInterval = axis.calculateCategoryInterval();
}
function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  var step = 1;
  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }
  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    var width = 0;
    var height = 0;
    var rect = getBoundingRect(labelFormatter({
      value: tickValue
    }), params.font, "center", "top");
    width = rect.width * 1.3;
    height = rect.height * 1.3;
    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }
  var dw = maxW / unitW;
  var dh = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  var cache = inner$g(axis.model);
  var axisExtent = axis.getExtent();
  var lastAutoInterval = cache.lastAutoInterval;
  var lastTickCount = cache.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } else {
    cache.lastTickCount = tickCount;
    cache.lastAutoInterval = interval;
    cache.axisExtent0 = axisExtent[0];
    cache.axisExtent1 = axisExtent[1];
  }
  return interval;
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = [];
  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  var showAllLabel = shouldShowAllLabels(axis);
  var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  var tickValue = startTick;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    var tickObj = {
      value: tickValue2
    };
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  each$f(ordinalScale.getTicks(), function(tick) {
    var rawLabel = ordinalScale.getLabel(tick);
    var tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue
      });
    }
  });
  return result;
}
var NORMALIZED_EXTENT = [0, 1];
var Axis = function() {
  function Axis2(dim, scale4, extent3) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale4;
    this._extent = extent3 || [0, 0];
  }
  Axis2.prototype.contain = function(coord) {
    var extent3 = this._extent;
    var min5 = Math.min(extent3[0], extent3[1]);
    var max4 = Math.max(extent3[0], extent3[1]);
    return coord >= min5 && coord <= max4;
  };
  Axis2.prototype.containData = function(data) {
    return this.scale.contain(data);
  };
  Axis2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Axis2.prototype.getPixelPrecision = function(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  };
  Axis2.prototype.setExtent = function(start2, end2) {
    var extent3 = this._extent;
    extent3[0] = start2;
    extent3[1] = end2;
  };
  Axis2.prototype.dataToCoord = function(data, clamp3) {
    var extent3 = this._extent;
    var scale4 = this.scale;
    data = scale4.normalize(data);
    if (this.onBand && scale4.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale4.count());
    }
    return linearMap$2(data, NORMALIZED_EXTENT, extent3, clamp3);
  };
  Axis2.prototype.coordToData = function(coord, clamp3) {
    var extent3 = this._extent;
    var scale4 = this.scale;
    if (this.onBand && scale4.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale4.count());
    }
    var t = linearMap$2(coord, extent3, NORMALIZED_EXTENT, clamp3);
    return this.scale.scale(t);
  };
  Axis2.prototype.pointToData = function(point4, clamp3) {
    return;
  };
  Axis2.prototype.getTicksCoords = function(opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map$1(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    var alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  };
  Axis2.prototype.getMinorTicksCoords = function() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    var minorTickModel = this.model.getModel("minorTick");
    var splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    var minorTicks = this.scale.getMinorTicks(splitNumber);
    var minorTicksCoords = map$1(minorTicks, function(minorTicksGroup) {
      return map$1(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  };
  Axis2.prototype.getViewLabels = function() {
    return createAxisLabels(this).labels;
  };
  Axis2.prototype.getLabelModel = function() {
    return this.model.getModel("axisLabel");
  };
  Axis2.prototype.getTickModel = function() {
    return this.model.getModel("axisTick");
  };
  Axis2.prototype.getBandWidth = function() {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    var size11 = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size11) / len2;
  };
  Axis2.prototype.calculateCategoryInterval = function() {
    return calculateCategoryInterval(this);
  };
  return Axis2;
}();
function fixExtentWithBands(extent3, nTick) {
  var size11 = extent3[1] - extent3[0];
  var len2 = nTick;
  var margin = size11 / len2 / 2;
  extent3[0] += margin;
  extent3[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp3) {
  var ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  var axisExtent = axis.getExtent();
  var last;
  var diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {
      coord: axisExtent[0]
    };
  } else {
    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each$f(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift_1 / 2;
    });
    var dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {
      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
    };
    ticksCoords.push(last);
  }
  var inverse = axisExtent[0] > axisExtent[1];
  if (littleThan2(ticksCoords[0].coord, axisExtent[0])) {
    clamp3 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp3 && littleThan2(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }
  if (littleThan2(axisExtent[1], last.coord)) {
    clamp3 ? last.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp3 && littleThan2(last.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }
  function littleThan2(a, b) {
    a = round$3(a);
    b = round$3(b);
    return inverse ? a > b : a < b;
  }
}
var Axis$1 = Axis;
var PI2$2 = Math.PI * 2;
var CMD$1 = PathProxy.CMD;
var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(pos, distance11, rect, outPt, outDir) {
  var width = rect.width;
  var height = rect.height;
  switch (pos) {
    case "top":
      outPt.set(rect.x + width / 2, rect.y - distance11);
      outDir.set(0, -1);
      break;
    case "bottom":
      outPt.set(rect.x + width / 2, rect.y + height + distance11);
      outDir.set(0, 1);
      break;
    case "left":
      outPt.set(rect.x - distance11, rect.y + height / 2);
      outDir.set(-1, 0);
      break;
    case "right":
      outPt.set(rect.x + width + distance11, rect.y + height / 2);
      outDir.set(1, 0);
      break;
  }
}
function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x2, y2, out2) {
  x2 -= cx;
  y2 -= cy;
  var d = Math.sqrt(x2 * x2 + y2 * y2);
  x2 /= d;
  y2 /= d;
  var ox = x2 * r + cx;
  var oy = y2 * r + cy;
  if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$2;
  }
  var angle4 = Math.atan2(y2, x2);
  if (angle4 < 0) {
    angle4 += PI2$2;
  }
  if (angle4 >= startAngle && angle4 <= endAngle || angle4 + PI2$2 >= startAngle && angle4 + PI2$2 <= endAngle) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  var x12 = r * Math.cos(startAngle) + cx;
  var y12 = r * Math.sin(startAngle) + cy;
  var x22 = r * Math.cos(endAngle) + cx;
  var y22 = r * Math.sin(endAngle) + cy;
  var d1 = (x12 - x2) * (x12 - x2) + (y12 - y2) * (y12 - y2);
  var d2 = (x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2);
  if (d1 < d2) {
    out2[0] = x12;
    out2[1] = y12;
    return Math.sqrt(d1);
  } else {
    out2[0] = x22;
    out2[1] = y22;
    return Math.sqrt(d2);
  }
}
function projectPointToLine(x12, y12, x2, y2, x3, y3, out2, limitToEnds) {
  var dx = x3 - x12;
  var dy = y3 - y12;
  var dx1 = x2 - x12;
  var dy1 = y2 - y12;
  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  var projectedLen = dx * dx1 + dy * dy1;
  var t = projectedLen / lineLen;
  if (limitToEnds) {
    t = Math.min(Math.max(t, 0), 1);
  }
  t *= lineLen;
  var ox = out2[0] = x12 + t * dx1;
  var oy = out2[1] = y12 + t * dy1;
  return Math.sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3));
}
function projectPointToRect(x12, y12, width, height, x2, y2, out2) {
  if (width < 0) {
    x12 = x12 + width;
    width = -width;
  }
  if (height < 0) {
    y12 = y12 + height;
    height = -height;
  }
  var x22 = x12 + width;
  var y22 = y12 + height;
  var ox = out2[0] = Math.min(Math.max(x2, x12), x22);
  var oy = out2[1] = Math.min(Math.max(y2, y12), y22);
  return Math.sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2));
}
var tmpPt = [];
function nearestPointOnRect(pt, rect, out2) {
  var dist3 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
  out2.set(tmpPt[0], tmpPt[1]);
  return dist3;
}
function nearestPointOnPath(pt, path, out2) {
  var xi = 0;
  var yi = 0;
  var x02 = 0;
  var y02 = 0;
  var x12;
  var y12;
  var minDist = Infinity;
  var data = path.data;
  var x2 = pt.x;
  var y2 = pt.y;
  for (var i = 0; i < data.length; ) {
    var cmd = data[i++];
    if (i === 1) {
      xi = data[i];
      yi = data[i + 1];
      x02 = xi;
      y02 = yi;
    }
    var d = minDist;
    switch (cmd) {
      case CMD$1.M:
        x02 = data[i++];
        y02 = data[i++];
        xi = x02;
        yi = y02;
        break;
      case CMD$1.L:
        d = projectPointToLine(xi, yi, data[i], data[i + 1], x2, y2, tmpPt, true);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.C:
        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x2, y2, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.Q:
        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x2, y2, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        i += 1;
        var anticlockwise = !!(1 - data[i++]);
        x12 = Math.cos(theta) * rx + cx;
        y12 = Math.sin(theta) * ry + cy;
        if (i <= 1) {
          x02 = x12;
          y02 = y12;
        }
        var _x = (x2 - cx) * ry / rx + cx;
        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y2, tmpPt);
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$1.R:
        x02 = xi = data[i++];
        y02 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        d = projectPointToRect(x02, y02, width, height, x2, y2, tmpPt);
        break;
      case CMD$1.Z:
        d = projectPointToLine(xi, yi, x02, y02, x2, y2, tmpPt, true);
        xi = x02;
        yi = y02;
        break;
    }
    if (d < minDist) {
      minDist = d;
      out2.set(tmpPt[0], tmpPt[1]);
    }
  }
  return minDist;
}
var pt0 = new Point$1();
var pt1 = new Point$1();
var pt2 = new Point$1();
var dir = new Point$1();
var dir2 = new Point$1();
function updateLabelLinePoints(target, labelLineModel) {
  if (!target) {
    return;
  }
  var labelLine = target.getTextGuideLine();
  var label = target.getTextContent();
  if (!(label && labelLine)) {
    return;
  }
  var labelGuideConfig = target.textGuideLineConfig || {};
  var points2 = [[0, 0], [0, 0], [0, 0]];
  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
  var labelRect = label.getBoundingRect().clone();
  labelRect.applyTransform(label.getComputedTransform());
  var minDist = Infinity;
  var anchorPoint = labelGuideConfig.anchor;
  var targetTransform = target.getComputedTransform();
  var targetInversedTransform = targetTransform && invert([], targetTransform);
  var len2 = labelLineModel.get("length2") || 0;
  if (anchorPoint) {
    pt2.copy(anchorPoint);
  }
  for (var i = 0; i < searchSpace.length; i++) {
    var candidate = searchSpace[i];
    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
    Point$1.scaleAndAdd(pt1, pt0, dir, len2);
    pt1.transform(targetInversedTransform);
    var boundingRect = target.getBoundingRect();
    var dist3 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path$1 ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
    if (dist3 < minDist) {
      minDist = dist3;
      pt1.transform(targetTransform);
      pt2.transform(targetTransform);
      pt2.toArray(points2[0]);
      pt1.toArray(points2[1]);
      pt0.toArray(points2[2]);
    }
  }
  limitTurnAngle(points2, labelLineModel.get("minTurnAngle"));
  labelLine.setShape({
    points: points2
  });
}
var tmpArr = [];
var tmpProjPoint = new Point$1();
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt0, pt1);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(dir2);
  var minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t)) {
      return;
    }
    if (t < 0) {
      Point$1.copy(tmpProjPoint, pt1);
    } else if (t > 1) {
      Point$1.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt1, pt0);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(surfaceNormal);
  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    var HALF_PI = Math.PI / 2;
    var angle22 = Math.acos(dir2.dot(surfaceNormal));
    var newAngle = HALF_PI + angle22 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point$1.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t)) {
        return;
      }
      if (t < 0) {
        Point$1.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point$1.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  var isNormal = stateName === "normal";
  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  var smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  var styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (!points2) {
    return;
  }
  path.moveTo(points2[0][0], points2[0][1]);
  if (smooth > 0 && points2.length >= 3) {
    var len1 = dist$1(points2[0], points2[1]);
    var len2 = dist$1(points2[1], points2[2]);
    if (!len1 || !len2) {
      path.lineTo(points2[1][0], points2[1][1]);
      path.lineTo(points2[2][0], points2[2][1]);
      return;
    }
    var moveLen = Math.min(len1, len2) * smooth;
    var midPoint0 = lerp$1([], points2[1], points2[0], moveLen / len1);
    var midPoint22 = lerp$1([], points2[1], points2[2], moveLen / len2);
    var midPoint1 = lerp$1([], midPoint0, midPoint22, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint22[0], midPoint22[1], midPoint22[0], midPoint22[1], points2[2][0], points2[2][1]);
  } else {
    for (var i = 1; i < points2.length; i++) {
      path.lineTo(points2[i][0], points2[i][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  var labelLine = targetEl.getTextGuideLine();
  var label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  var normalModel = statesModels.normal;
  var showNormal = normalModel.get("show");
  var labelIgnoreNormal = label.ignore;
  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateName = DISPLAY_STATES[i];
    var stateModel = statesModels[stateName];
    var isNormal = stateName === "normal";
    if (stateModel) {
      var stateShow = stateModel.get("show");
      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
        if (stateObj) {
          stateObj.ignore = true;
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline$3();
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    var showAbove = normalModel.get("showAbove");
    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  var statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}
function prepareLayoutList(input) {
  var list = [];
  for (var i = 0; i < input.length; i++) {
    var rawItem = input[i];
    if (rawItem.defaultAttr.ignore) {
      continue;
    }
    var label = rawItem.label;
    var transform4 = label.getComputedTransform();
    var localRect = label.getBoundingRect();
    var isAxisAligned = !transform4 || transform4[1] < 1e-5 && transform4[2] < 1e-5;
    var minMargin = label.style.margin || 0;
    var globalRect = localRect.clone();
    globalRect.applyTransform(transform4);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    var obb = isAxisAligned ? new OrientedBoundingRect$1(localRect, transform4) : null;
    list.push({
      label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect,
      obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform: transform4
    });
  }
  return list;
}
function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  var len2 = list.length;
  if (len2 < 2) {
    return;
  }
  list.sort(function(a, b) {
    return a.rect[xyDim] - b.rect[xyDim];
  });
  var lastPos = 0;
  var delta2;
  var adjusted = false;
  var totalShifts = 0;
  for (var i = 0; i < len2; i++) {
    var item = list[i];
    var rect = item.rect;
    delta2 = rect[xyDim] - lastPos;
    if (delta2 < 0) {
      rect[xyDim] -= delta2;
      item.label[xyDim] -= delta2;
      adjusted = true;
    }
    var shift = Math.max(-delta2, 0);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  var first = list[0];
  var last = list[len2 - 1];
  var minGap;
  var maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        var remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta3, start2, end2) {
    if (delta3 !== 0) {
      adjusted = true;
    }
    for (var i2 = start2; i2 < end2; i2++) {
      var item2 = list[i2];
      var rect2 = item2.rect;
      rect2[xyDim] += delta3;
      item2.label[xyDim] += delta3;
    }
  }
  function squeezeGaps(delta3, maxSqeezePercent) {
    var gaps = [];
    var totalGaps = 0;
    for (var i2 = 1; i2 < len2; i2++) {
      var prevItemRect = list[i2 - 1].rect;
      var gap = Math.max(list[i2].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    var squeezePercent = Math.min(Math.abs(delta3) / totalGaps, maxSqeezePercent);
    if (delta3 > 0) {
      for (var i2 = 0; i2 < len2 - 1; i2++) {
        var movement = gaps[i2] * squeezePercent;
        shiftList(movement, 0, i2 + 1);
      }
    } else {
      for (var i2 = len2 - 1; i2 > 0; i2--) {
        var movement = gaps[i2 - 1] * squeezePercent;
        shiftList(-movement, i2, len2);
      }
    }
  }
  function squeezeWhenBailout(delta3) {
    var dir3 = delta3 < 0 ? -1 : 1;
    delta3 = Math.abs(delta3);
    var moveForEachLabel = Math.ceil(delta3 / (len2 - 1));
    for (var i2 = 0; i2 < len2 - 1; i2++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i2 + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i2 - 1, len2);
      }
      delta3 -= moveForEachLabel;
      if (delta3 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
  return shiftLayout(list, "x", "width", leftBound, rightBound, balanceShift);
}
function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
  return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  var displayedLabels = [];
  labelList.sort(function(a, b) {
    return b.priority - a.priority;
  });
  var globalRect = new BoundingRect$1(0, 0, 0, 0);
  function hideEl(el) {
    if (!el.ignore) {
      var emphasisState = el.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el.ignore = true;
  }
  for (var i = 0; i < labelList.length; i++) {
    var labelItem = labelList[i];
    var isAxisAligned = labelItem.axisAligned;
    var localRect = labelItem.localRect;
    var transform4 = labelItem.transform;
    var label = labelItem.label;
    var labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect);
    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    var obb = labelItem.obb;
    var overlapped = false;
    for (var j = 0; j < displayedLabels.length; j++) {
      var existsTextCfg = displayedLabels[j];
      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }
      if (isAxisAligned && existsTextCfg.axisAligned) {
        overlapped = true;
        break;
      }
      if (!existsTextCfg.obb) {
        existsTextCfg.obb = new OrientedBoundingRect$1(existsTextCfg.localRect, existsTextCfg.transform);
      }
      if (!obb) {
        obb = new OrientedBoundingRect$1(localRect, transform4);
      }
      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}
function cloneArr(points2) {
  if (points2) {
    var newPoints = [];
    for (var i = 0; i < points2.length; i++) {
      newPoints.push(points2[i].slice());
    }
    return newPoints;
  }
}
function prepareLayoutCallbackParams(labelItem, hostEl) {
  var label = labelItem.label;
  var labelLine = hostEl && hostEl.getTextGuideLine();
  return {
    dataIndex: labelItem.dataIndex,
    dataType: labelItem.dataType,
    seriesIndex: labelItem.seriesModel.seriesIndex,
    text: labelItem.label.style.text,
    rect: labelItem.hostRect,
    labelRect: labelItem.rect,
    align: label.style.align,
    verticalAlign: label.style.verticalAlign,
    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
var dummyTransformable = new Transformable$1();
var labelLayoutInnerStore = makeInner();
var labelLineAnimationStore = makeInner();
function extendWithKeys(target, source2, keys3) {
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (source2[key] != null) {
      target[key] = source2[key];
    }
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
var LabelManager = function() {
  function LabelManager2() {
    this._labelList = [];
    this._chartViewList = [];
  }
  LabelManager2.prototype.clearLabels = function() {
    this._labelList = [];
    this._chartViewList = [];
  };
  LabelManager2.prototype._addLabel = function(dataIndex, dataType, seriesModel, label, layoutOption) {
    var labelStyle = label.style;
    var hostEl = label.__hostTarget;
    var textConfig = hostEl.textConfig || {};
    var labelTransform = label.getComputedTransform();
    var labelRect = label.getBoundingRect().plain();
    BoundingRect$1.applyTransform(labelRect, labelRect, labelTransform);
    if (labelTransform) {
      dummyTransformable.setLocalTransform(labelTransform);
    } else {
      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
    }
    var host = label.__hostTarget;
    var hostRect;
    if (host) {
      hostRect = host.getBoundingRect().plain();
      var transform4 = host.getComputedTransform();
      BoundingRect$1.applyTransform(hostRect, hostRect, transform4);
    }
    var labelGuide = hostRect && host.getTextGuideLine();
    this._labelList.push({
      label,
      labelLine: labelGuide,
      seriesModel,
      dataIndex,
      dataType,
      layoutOption,
      computedLayoutOption: null,
      rect: labelRect,
      hostRect,
      priority: hostRect ? hostRect.width * hostRect.height : 0,
      defaultAttr: {
        ignore: label.ignore,
        labelGuideIgnore: labelGuide && labelGuide.ignore,
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY,
        rotation: dummyTransformable.rotation,
        style: {
          x: labelStyle.x,
          y: labelStyle.y,
          align: labelStyle.align,
          verticalAlign: labelStyle.verticalAlign,
          width: labelStyle.width,
          height: labelStyle.height,
          fontSize: labelStyle.fontSize
        },
        cursor: label.cursor,
        attachedPos: textConfig.position,
        attachedRot: textConfig.rotation
      }
    });
  };
  LabelManager2.prototype.addLabelsOfSeries = function(chartView) {
    var _this = this;
    this._chartViewList.push(chartView);
    var seriesModel = chartView.__model;
    var layoutOption = seriesModel.get("labelLayout");
    if (!(isFunction(layoutOption) || keys2(layoutOption).length)) {
      return;
    }
    chartView.group.traverse(function(child) {
      if (child.ignore) {
        return true;
      }
      var textEl = child.getTextContent();
      var ecData = getECData(child);
      if (textEl && !textEl.disableLabelLayout) {
        _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
      }
    });
  };
  LabelManager2.prototype.updateLayoutConfig = function(api) {
    var width = api.getWidth();
    var height = api.getHeight();
    function createDragHandler(el, labelLineModel) {
      return function() {
        updateLabelLinePoints(el, labelLineModel);
      };
    }
    for (var i = 0; i < this._labelList.length; i++) {
      var labelItem = this._labelList[i];
      var label = labelItem.label;
      var hostEl = label.__hostTarget;
      var defaultLabelAttr = labelItem.defaultAttr;
      var layoutOption = void 0;
      if (isFunction(labelItem.layoutOption)) {
        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
      } else {
        layoutOption = labelItem.layoutOption;
      }
      layoutOption = layoutOption || {};
      labelItem.computedLayoutOption = layoutOption;
      var degreeToRadian = Math.PI / 180;
      if (hostEl) {
        hostEl.setTextConfig({
          local: false,
          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
          offset: [layoutOption.dx || 0, layoutOption.dy || 0]
        });
      }
      var needsUpdateLabelLine = false;
      if (layoutOption.x != null) {
        label.x = parsePercent(layoutOption.x, width);
        label.setStyle("x", 0);
        needsUpdateLabelLine = true;
      } else {
        label.x = defaultLabelAttr.x;
        label.setStyle("x", defaultLabelAttr.style.x);
      }
      if (layoutOption.y != null) {
        label.y = parsePercent(layoutOption.y, height);
        label.setStyle("y", 0);
        needsUpdateLabelLine = true;
      } else {
        label.y = defaultLabelAttr.y;
        label.setStyle("y", defaultLabelAttr.style.y);
      }
      if (layoutOption.labelLinePoints) {
        var guideLine = hostEl.getTextGuideLine();
        if (guideLine) {
          guideLine.setShape({
            points: layoutOption.labelLinePoints
          });
          needsUpdateLabelLine = false;
        }
      }
      var labelLayoutStore = labelLayoutInnerStore(label);
      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
      label.scaleX = defaultLabelAttr.scaleX;
      label.scaleY = defaultLabelAttr.scaleY;
      for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
        var key = LABEL_OPTION_TO_STYLE_KEYS[k];
        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
      }
      if (layoutOption.draggable) {
        label.draggable = true;
        label.cursor = "move";
        if (hostEl) {
          var hostModel = labelItem.seriesModel;
          if (labelItem.dataIndex != null) {
            var data = labelItem.seriesModel.getData(labelItem.dataType);
            hostModel = data.getItemModel(labelItem.dataIndex);
          }
          label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
        }
      } else {
        label.off("drag");
        label.cursor = defaultLabelAttr.cursor;
      }
    }
  };
  LabelManager2.prototype.layout = function(api) {
    var width = api.getWidth();
    var height = api.getHeight();
    var labelList = prepareLayoutList(this._labelList);
    var labelsNeedsAdjustOnX = filter17(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftX";
    });
    var labelsNeedsAdjustOnY = filter17(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftY";
    });
    shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
    shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
    var labelsNeedsHideOverlap = filter17(labelList, function(item) {
      return item.layoutOption.hideOverlap;
    });
    hideOverlap(labelsNeedsHideOverlap);
  };
  LabelManager2.prototype.processLabelsOverall = function() {
    var _this = this;
    each$f(this._chartViewList, function(chartView) {
      var seriesModel = chartView.__model;
      var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
      var animationEnabled = seriesModel.isAnimationEnabled();
      chartView.group.traverse(function(child) {
        if (child.ignore && !child.forceLabelAnimation) {
          return true;
        }
        var needsUpdateLabelLine = !ignoreLabelLineUpdate;
        var label = child.getTextContent();
        if (!needsUpdateLabelLine && label) {
          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
        }
        if (needsUpdateLabelLine) {
          _this._updateLabelLine(child, seriesModel);
        }
        if (animationEnabled) {
          _this._animateLabels(child, seriesModel);
        }
      });
    });
  };
  LabelManager2.prototype._updateLabelLine = function(el, seriesModel) {
    var textEl = el.getTextContent();
    var ecData = getECData(el);
    var dataIndex = ecData.dataIndex;
    if (textEl && dataIndex != null) {
      var data = seriesModel.getData(ecData.dataType);
      var itemModel = data.getItemModel(dataIndex);
      var defaultStyle = {};
      var visualStyle = data.getItemVisual(dataIndex, "style");
      var visualType = data.getVisual("drawType");
      defaultStyle.stroke = visualStyle[visualType];
      var labelLineModel = itemModel.getModel("labelLine");
      setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
      updateLabelLinePoints(el, labelLineModel);
    }
  };
  LabelManager2.prototype._animateLabels = function(el, seriesModel) {
    var textEl = el.getTextContent();
    var guideLine = el.getTextGuideLine();
    if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
      var layoutStore = labelLayoutInnerStore(textEl);
      var oldLayout = layoutStore.oldLayout;
      var ecData = getECData(el);
      var dataIndex = ecData.dataIndex;
      var newProps = {
        x: textEl.x,
        y: textEl.y,
        rotation: textEl.rotation
      };
      var data = seriesModel.getData(ecData.dataType);
      if (!oldLayout) {
        textEl.attr(newProps);
        if (!labelInner(textEl).valueAnimation) {
          var oldOpacity = retrieve2(textEl.style.opacity, 1);
          textEl.style.opacity = 0;
          initProps(textEl, {
            style: {
              opacity: oldOpacity
            }
          }, seriesModel, dataIndex);
        }
      } else {
        textEl.attr(oldLayout);
        var prevStates = el.prevStates;
        if (prevStates) {
          if (indexOf2(prevStates, "select") >= 0) {
            textEl.attr(layoutStore.oldLayoutSelect);
          }
          if (indexOf2(prevStates, "emphasis") >= 0) {
            textEl.attr(layoutStore.oldLayoutEmphasis);
          }
        }
        updateProps$1(textEl, newProps, seriesModel, dataIndex);
      }
      layoutStore.oldLayout = newProps;
      if (textEl.states.select) {
        var layoutSelect = layoutStore.oldLayoutSelect = {};
        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
      }
      if (textEl.states.emphasis) {
        var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
      }
      animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
    }
    if (guideLine && !guideLine.ignore && !guideLine.invisible) {
      var layoutStore = labelLineAnimationStore(guideLine);
      var oldLayout = layoutStore.oldLayout;
      var newLayout = {
        points: guideLine.shape.points
      };
      if (!oldLayout) {
        guideLine.setShape(newLayout);
        guideLine.style.strokePercent = 0;
        initProps(guideLine, {
          style: {
            strokePercent: 1
          }
        }, seriesModel);
      } else {
        guideLine.attr({
          shape: oldLayout
        });
        updateProps$1(guideLine, {
          shape: newLayout
        }, seriesModel);
      }
      layoutStore.oldLayout = newLayout;
    }
  };
  return LabelManager2;
}();
var LabelManager$1 = LabelManager;
var getLabelManager = makeInner();
function installLabelLayout(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", function(ecModel, api, params) {
    var labelManager = getLabelManager(api).labelManager;
    if (!labelManager) {
      labelManager = getLabelManager(api).labelManager = new LabelManager$1();
    }
    labelManager.clearLabels();
  });
  registers.registerUpdateLifecycle("series:layoutlabels", function(ecModel, api, params) {
    var labelManager = getLabelManager(api).labelManager;
    params.updatedSeries.forEach(function(series) {
      labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));
    });
    labelManager.updateLayoutConfig(api);
    labelManager.layout(api);
    labelManager.processLabelsOverall();
  });
}
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI$4 = Math.PI;
var PI2$1 = Math.PI * 2;
var degree = 180 / PI$4;
var SVGPathRebuilder = function() {
  function SVGPathRebuilder2() {
  }
  SVGPathRebuilder2.prototype.reset = function(precision) {
    this._start = true;
    this._d = [];
    this._str = "";
    this._p = Math.pow(10, precision || 4);
  };
  SVGPathRebuilder2.prototype.moveTo = function(x2, y2) {
    this._add("M", x2, y2);
  };
  SVGPathRebuilder2.prototype.lineTo = function(x2, y2) {
    this._add("L", x2, y2);
  };
  SVGPathRebuilder2.prototype.bezierCurveTo = function(x2, y2, x22, y22, x3, y3) {
    this._add("C", x2, y2, x22, y22, x3, y3);
  };
  SVGPathRebuilder2.prototype.quadraticCurveTo = function(x2, y2, x22, y22) {
    this._add("Q", x2, y2, x22, y22);
  };
  SVGPathRebuilder2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
  };
  SVGPathRebuilder2.prototype.ellipse = function(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
    var dTheta = endAngle - startAngle;
    var clockwise = !anticlockwise;
    var dThetaPositive = Math.abs(dTheta);
    var isCircle = isAroundZero(dThetaPositive - PI2$1) || (clockwise ? dTheta >= PI2$1 : -dTheta >= PI2$1);
    var unifiedTheta = dTheta > 0 ? dTheta % PI2$1 : dTheta % PI2$1 + PI2$1;
    var large = false;
    if (isCircle) {
      large = true;
    } else if (isAroundZero(dThetaPositive)) {
      large = false;
    } else {
      large = unifiedTheta >= PI$4 === !!clockwise;
    }
    var x02 = cx + rx * mathCos(startAngle);
    var y02 = cy + ry * mathSin(startAngle);
    if (this._start) {
      this._add("M", x02, y02);
    }
    var xRot = Math.round(psi * degree);
    if (isCircle) {
      var p = 1 / this._p;
      var dTheta_1 = (clockwise ? 1 : -1) * (PI2$1 - p);
      this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos(startAngle + dTheta_1), cy + ry * mathSin(startAngle + dTheta_1));
      if (p > 0.01) {
        this._add("A", rx, ry, xRot, 0, +clockwise, x02, y02);
      }
    } else {
      var x2 = cx + rx * mathCos(endAngle);
      var y2 = cy + ry * mathSin(endAngle);
      this._add("A", rx, ry, xRot, +large, +clockwise, x2, y2);
    }
  };
  SVGPathRebuilder2.prototype.rect = function(x2, y2, w, h) {
    this._add("M", x2, y2);
    this._add("l", w, 0);
    this._add("l", 0, h);
    this._add("l", -w, 0);
    this._add("Z");
  };
  SVGPathRebuilder2.prototype.closePath = function() {
    if (this._d.length > 0) {
      this._add("Z");
    }
  };
  SVGPathRebuilder2.prototype._add = function(cmd, a, b, c, d, e2, f, g, h) {
    var vals = [];
    var p = this._p;
    for (var i = 1; i < arguments.length; i++) {
      var val = arguments[i];
      if (isNaN(val)) {
        this._invalid = true;
        return;
      }
      vals.push(Math.round(val * p) / p);
    }
    this._d.push(cmd + vals.join(" "));
    this._start = cmd === "Z";
  };
  SVGPathRebuilder2.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join("");
    this._d = [];
  };
  SVGPathRebuilder2.prototype.getStr = function() {
    return this._str;
  };
  return SVGPathRebuilder2;
}();
var SVGPathRebuilder$1 = SVGPathRebuilder;
var NONE = "none";
var mathRound = Math.round;
function pathHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
  var stroke = style.stroke;
  return stroke != null && stroke !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"];
var svgStrokeProps = map$1(strokeProps, function(prop) {
  return "stroke-" + prop.toLowerCase();
});
function mapStyleToAttrs(updateAttr2, style, el, forceUpdate) {
  var opacity = style.opacity == null ? 1 : style.opacity;
  if (el instanceof ZRImage$1) {
    updateAttr2("opacity", opacity);
    return;
  }
  if (pathHasFill(style)) {
    var fill = normalizeColor(style.fill);
    updateAttr2("fill", fill.color);
    var fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
    if (forceUpdate || fillOpacity < 1) {
      updateAttr2("fill-opacity", fillOpacity);
    }
  } else {
    updateAttr2("fill", NONE);
  }
  if (pathHasStroke(style)) {
    var stroke = normalizeColor(style.stroke);
    updateAttr2("stroke", stroke.color);
    var strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
    var strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
    var strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
    var strokeFirst = style.strokeFirst;
    if (forceUpdate || strokeWidth !== 1) {
      updateAttr2("stroke-width", strokeWidth);
    }
    if (forceUpdate || strokeFirst) {
      updateAttr2("paint-order", strokeFirst ? "stroke" : "fill");
    }
    if (forceUpdate || strokeOpacity < 1) {
      updateAttr2("stroke-opacity", strokeOpacity);
    }
    if (style.lineDash) {
      var _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
      if (lineDash) {
        lineDashOffset = mathRound(lineDashOffset || 0);
        updateAttr2("stroke-dasharray", lineDash.join(","));
        if (lineDashOffset || forceUpdate) {
          updateAttr2("stroke-dashoffset", lineDashOffset);
        }
      }
    } else if (forceUpdate) {
      updateAttr2("stroke-dasharray", NONE);
    }
    for (var i = 0; i < strokeProps.length; i++) {
      var propName = strokeProps[i];
      if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
        var val = style[propName] || DEFAULT_PATH_STYLE[propName];
        val && updateAttr2(svgStrokeProps[i], val);
      }
    }
  } else if (forceUpdate) {
    updateAttr2("stroke", NONE);
  }
}
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
function createElement(name2) {
  return document.createElementNS(SVGNS, name2);
}
function createVNode(tag2, key, attrs, children, text) {
  return {
    tag: tag2,
    attrs: attrs || {},
    children,
    text,
    key
  };
}
function createElementOpen(name2, attrs) {
  var attrsStr = [];
  if (attrs) {
    for (var key in attrs) {
      var val = attrs[key];
      var part = key;
      if (val === false) {
        continue;
      } else if (val !== true && val != null) {
        part += '="' + val + '"';
      }
      attrsStr.push(part);
    }
  }
  return "<" + name2 + " " + attrsStr.join(" ") + ">";
}
function createElementClose(name2) {
  return "</" + name2 + ">";
}
function vNodeToString(el, opts) {
  opts = opts || {};
  var S = opts.newline ? "\n" : "";
  function convertElToString(el2) {
    var children = el2.children, tag2 = el2.tag, attrs = el2.attrs;
    return createElementOpen(tag2, attrs) + encodeHTML(el2.text) + (children ? "" + S + map$1(children, function(child) {
      return convertElToString(child);
    }).join(S) + S : "") + createElementClose(tag2);
  }
  return convertElToString(el);
}
function getCssString(selectorNodes, animationNodes, opts) {
  opts = opts || {};
  var S = opts.newline ? "\n" : "";
  var bracketBegin = " {" + S;
  var bracketEnd = S + "}";
  var selectors = map$1(keys2(selectorNodes), function(className) {
    return className + bracketBegin + map$1(keys2(selectorNodes[className]), function(attrName) {
      return attrName + ":" + selectorNodes[className][attrName] + ";";
    }).join(S) + bracketEnd;
  }).join(S);
  var animations = map$1(keys2(animationNodes), function(animationName) {
    return "@keyframes " + animationName + bracketBegin + map$1(keys2(animationNodes[animationName]), function(percent) {
      return percent + bracketBegin + map$1(keys2(animationNodes[animationName][percent]), function(attrName) {
        var val = animationNodes[animationName][percent][attrName];
        if (attrName === "d") {
          val = 'path("' + val + '")';
        }
        return attrName + ":" + val + ";";
      }).join(S) + bracketEnd;
    }).join(S) + bracketEnd;
  }).join(S);
  if (!selectors && !animations) {
    return "";
  }
  return ["<![CDATA[", selectors, animations, "]]>"].join(S);
}
function createBrushScope(zrId) {
  return {
    zrId,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssClassIdx: 0,
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(width, height, children, useViewBox) {
  return createVNode("svg", "root", {
    "width": width,
    "height": height,
    "xmlns": SVGNS,
    "xmlns:xlink": XLINKNS,
    "version": "1.1",
    "baseProfile": "full",
    "viewBox": useViewBox ? "0 0 " + width + " " + height : false
  }, children);
}
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
};
var transformOriginKey = "transform-origin";
function buildPathString(el, kfShape, path) {
  var shape = extend2({}, el.shape);
  extend2(shape, kfShape);
  el.buildPath(path, shape);
  var svgPathBuilder = new SVGPathRebuilder$1();
  svgPathBuilder.reset(getPathPrecision(el));
  path.rebuildPath(svgPathBuilder, 1);
  svgPathBuilder.generateStr();
  return svgPathBuilder.getStr();
}
function setTransformOrigin(target, transform4) {
  var originX = transform4.originX, originY = transform4.originY;
  if (originX || originY) {
    target[transformOriginKey] = originX + "px " + originY + "px";
  }
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(cssAnim, scope) {
  var animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
  scope.cssAnims[animationName] = cssAnim;
  return animationName;
}
function createCompoundPathCSSAnimation(el, attrs, scope) {
  var paths = el.shape.paths;
  var composedAnim = {};
  var cssAnimationCfg;
  var cssAnimationName;
  each$f(paths, function(path) {
    var subScope = createBrushScope(scope.zrId);
    subScope.animation = true;
    createCSSAnimation(path, {}, subScope, true);
    var cssAnims = subScope.cssAnims;
    var cssNodes = subScope.cssNodes;
    var animNames = keys2(cssAnims);
    var len2 = animNames.length;
    if (!len2) {
      return;
    }
    cssAnimationName = animNames[len2 - 1];
    var lastAnim = cssAnims[cssAnimationName];
    for (var percent in lastAnim) {
      var kf = lastAnim[percent];
      composedAnim[percent] = composedAnim[percent] || { d: "" };
      composedAnim[percent].d += kf.d || "";
    }
    for (var className in cssNodes) {
      var val = cssNodes[className].animation;
      if (val.indexOf(cssAnimationName) >= 0) {
        cssAnimationCfg = val;
      }
    }
  });
  if (!cssAnimationCfg) {
    return;
  }
  attrs.d = false;
  var animationName = addAnimation(composedAnim, scope);
  return cssAnimationCfg.replace(cssAnimationName, animationName);
}
function getEasingFunc(easing) {
  return isString(easing) ? EASING_MAP[easing] ? "cubic-bezier(" + EASING_MAP[easing] + ")" : createCubicEasingFunc(easing) ? easing : "" : "";
}
function createCSSAnimation(el, attrs, scope, onlyShape) {
  var animators = el.animators;
  var len2 = animators.length;
  var cssAnimations = [];
  if (el instanceof CompoundPath$1) {
    var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    } else if (!len2) {
      return;
    }
  } else if (!len2) {
    return;
  }
  var groupAnimators = {};
  for (var i = 0; i < len2; i++) {
    var animator = animators[i];
    var cfgArr = [animator.getMaxTime() / 1e3 + "s"];
    var easing = getEasingFunc(animator.getClip().easing);
    var delay = animator.getDelay();
    if (easing) {
      cfgArr.push(easing);
    } else {
      cfgArr.push("linear");
    }
    if (delay) {
      cfgArr.push(delay / 1e3 + "s");
    }
    if (animator.getLoop()) {
      cfgArr.push("infinite");
    }
    var cfg = cfgArr.join(" ");
    groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
    groupAnimators[cfg][1].push(animator);
  }
  function createSingleCSSAnimation(groupAnimator) {
    var animators2 = groupAnimator[1];
    var len3 = animators2.length;
    var transformKfs = {};
    var shapeKfs = {};
    var finalKfs = {};
    var animationTimingFunctionAttrName = "animation-timing-function";
    function saveAnimatorTrackToCssKfs(animator3, cssKfs, toCssAttrName) {
      var tracks = animator3.getTracks();
      var maxTime = animator3.getMaxTime();
      for (var k = 0; k < tracks.length; k++) {
        var track = tracks[k];
        if (track.needsAnimate()) {
          var kfs = track.keyframes;
          var attrName = track.propName;
          toCssAttrName && (attrName = toCssAttrName(attrName));
          if (attrName) {
            for (var i3 = 0; i3 < kfs.length; i3++) {
              var kf = kfs[i3];
              var percent2 = Math.round(kf.time / maxTime * 100) + "%";
              var kfEasing = getEasingFunc(kf.easing);
              var rawValue = kf.rawValue;
              if (isString(rawValue) || isNumber(rawValue)) {
                cssKfs[percent2] = cssKfs[percent2] || {};
                cssKfs[percent2][attrName] = kf.rawValue;
                if (kfEasing) {
                  cssKfs[percent2][animationTimingFunctionAttrName] = kfEasing;
                }
              }
            }
          }
        }
      }
    }
    for (var i2 = 0; i2 < len3; i2++) {
      var animator2 = animators2[i2];
      var targetProp = animator2.targetName;
      if (!targetProp) {
        !onlyShape && saveAnimatorTrackToCssKfs(animator2, transformKfs);
      } else if (targetProp === "shape") {
        saveAnimatorTrackToCssKfs(animator2, shapeKfs);
      }
    }
    for (var percent in transformKfs) {
      var transform4 = {};
      copyTransform(transform4, el);
      extend2(transform4, transformKfs[percent]);
      var str = getSRTTransformString(transform4);
      var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
      finalKfs[percent] = str ? {
        transform: str
      } : {};
      setTransformOrigin(finalKfs[percent], transform4);
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    var path;
    var canAnimateShape = true;
    for (var percent in shapeKfs) {
      finalKfs[percent] = finalKfs[percent] || {};
      var isFirst = !path;
      var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
      if (isFirst) {
        path = new PathProxy();
      }
      var len_1 = path.len();
      path.reset();
      finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
      var newLen = path.len();
      if (!isFirst && len_1 !== newLen) {
        canAnimateShape = false;
        break;
      }
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    if (!canAnimateShape) {
      for (var percent in finalKfs) {
        delete finalKfs[percent].d;
      }
    }
    if (!onlyShape) {
      for (var i2 = 0; i2 < len3; i2++) {
        var animator2 = animators2[i2];
        var targetProp = animator2.targetName;
        if (targetProp === "style") {
          saveAnimatorTrackToCssKfs(animator2, finalKfs, function(propName) {
            return ANIMATE_STYLE_MAP[propName];
          });
        }
      }
    }
    var percents = keys2(finalKfs);
    var allTransformOriginSame = true;
    var transformOrigin;
    for (var i2 = 1; i2 < percents.length; i2++) {
      var p0 = percents[i2 - 1];
      var p1 = percents[i2];
      if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
        allTransformOriginSame = false;
        break;
      }
      transformOrigin = finalKfs[p0][transformOriginKey];
    }
    if (allTransformOriginSame && transformOrigin) {
      for (var percent in finalKfs) {
        if (finalKfs[percent][transformOriginKey]) {
          delete finalKfs[percent][transformOriginKey];
        }
      }
      attrs[transformOriginKey] = transformOrigin;
    }
    if (filter17(percents, function(percent2) {
      return keys2(finalKfs[percent2]).length > 0;
    }).length) {
      var animationName = addAnimation(finalKfs, scope);
      return animationName + " " + groupAnimator[0] + " both";
    }
  }
  for (var key in groupAnimators) {
    var animationCfg = createSingleCSSAnimation(groupAnimators[key]);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    }
  }
  if (cssAnimations.length) {
    var className = scope.zrId + "-cls-" + scope.cssClassIdx++;
    scope.cssNodes["." + className] = {
      animation: cssAnimations.join(",")
    };
    attrs["class"] = className;
  }
}
var round$1 = Math.round;
function isImageLike(val) {
  return val && isString(val.src);
}
function isCanvasLike(val) {
  return val && isFunction(val.toDataURL);
}
function setStyleAttrs(attrs, style, el, scope) {
  mapStyleToAttrs(function(key, val) {
    var isFillStroke = key === "fill" || key === "stroke";
    if (isFillStroke && isGradient(val)) {
      setGradient(style, attrs, key, scope);
    } else if (isFillStroke && isPattern(val)) {
      setPattern(el, attrs, key, scope);
    } else {
      attrs[key] = val;
    }
  }, style, el, false);
  setShadow(el, attrs, scope);
}
function noRotateScale(m2) {
  return isAroundZero(m2[0] - 1) && isAroundZero(m2[1]) && isAroundZero(m2[2]) && isAroundZero(m2[3] - 1);
}
function noTranslate(m2) {
  return isAroundZero(m2[4]) && isAroundZero(m2[5]);
}
function setTransform(attrs, m2, compress) {
  if (m2 && !(noTranslate(m2) && noRotateScale(m2))) {
    var mul2 = compress ? 10 : 1e4;
    attrs.transform = noRotateScale(m2) ? "translate(" + round$1(m2[4] * mul2) / mul2 + " " + round$1(m2[5] * mul2) / mul2 + ")" : getMatrixStr(m2);
  }
}
function convertPolyShape(shape, attrs, mul2) {
  var points2 = shape.points;
  var strArr = [];
  for (var i = 0; i < points2.length; i++) {
    strArr.push(round$1(points2[i][0] * mul2) / mul2);
    strArr.push(round$1(points2[i][1] * mul2) / mul2);
  }
  attrs.points = strArr.join(" ");
}
function validatePolyShape(shape) {
  return !shape.smooth;
}
function createAttrsConvert(desc) {
  var normalizedDesc = map$1(desc, function(item) {
    return typeof item === "string" ? [item, item] : item;
  });
  return function(shape, attrs, mul2) {
    for (var i = 0; i < normalizedDesc.length; i++) {
      var item = normalizedDesc[i];
      var val = shape[item[0]];
      if (val != null) {
        attrs[item[1]] = round$1(val * mul2) / mul2;
      }
    }
  };
}
var buitinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(el) {
  var animators = el.animators;
  for (var i = 0; i < animators.length; i++) {
    if (animators[i].targetName === "shape") {
      return true;
    }
  }
  return false;
}
function brushSVGPath(el, scope) {
  var style = el.style;
  var shape = el.shape;
  var builtinShpDef = buitinShapesDef[el.type];
  var attrs = {};
  var needsAnimate = scope.animation;
  var svgElType = "path";
  var strokePercent = el.style.strokePercent;
  var precision = scope.compress && getPathPrecision(el) || 4;
  if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
    svgElType = el.type;
    var mul2 = Math.pow(10, precision);
    builtinShpDef[0](shape, attrs, mul2);
  } else {
    if (!el.path) {
      el.createPathProxy();
    }
    var path = el.path;
    if (el.shapeChanged()) {
      path.beginPath();
      el.buildPath(path, el.shape);
      el.pathUpdated();
    }
    var pathVersion = path.getVersion();
    var elExt = el;
    var svgPathBuilder = elExt.__svgPathBuilder;
    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
      if (!svgPathBuilder) {
        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder$1();
      }
      svgPathBuilder.reset(precision);
      path.rebuildPath(svgPathBuilder, strokePercent);
      svgPathBuilder.generateStr();
      elExt.__svgPathVersion = pathVersion;
      elExt.__svgPathStrokePercent = strokePercent;
    }
    attrs.d = svgPathBuilder.getStr();
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode(svgElType, el.id + "", attrs);
}
function brushSVGImage(el, scope) {
  var style = el.style;
  var image = style.image;
  if (image && !isString(image)) {
    if (isImageLike(image)) {
      image = image.src;
    } else if (isCanvasLike(image)) {
      image = image.toDataURL();
    }
  }
  if (!image) {
    return;
  }
  var x2 = style.x || 0;
  var y2 = style.y || 0;
  var dw = style.width;
  var dh = style.height;
  var attrs = {
    href: image,
    width: dw,
    height: dh
  };
  if (x2) {
    attrs.x = x2;
  }
  if (y2) {
    attrs.y = y2;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("image", el.id + "", attrs);
}
function brushSVGTSpan(el, scope) {
  var style = el.style;
  var text = style.text;
  text != null && (text += "");
  if (!text || isNaN(style.x) || isNaN(style.y)) {
    return;
  }
  var font = style.font || DEFAULT_FONT;
  var x2 = style.x || 0;
  var y2 = adjustTextY$1(style.y || 0, getLineHeight(font), style.textBaseline);
  var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
  var attrs = {
    "dominant-baseline": "central",
    "text-anchor": textAlign
  };
  if (hasSeparateFont(style)) {
    var separatedFontStr = "";
    var fontStyle = style.fontStyle;
    var fontSize = parseFontSize(style.fontSize);
    if (!parseFloat(fontSize)) {
      return;
    }
    var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
    var fontWeight = style.fontWeight;
    separatedFontStr += "font-size:" + fontSize + ";font-family:" + fontFamily + ";";
    if (fontStyle && fontStyle !== "normal") {
      separatedFontStr += "font-style:" + fontStyle + ";";
    }
    if (fontWeight && fontWeight !== "normal") {
      separatedFontStr += "font-weight:" + fontWeight + ";";
    }
    attrs.style = separatedFontStr;
  } else {
    attrs.style = "font: " + font;
  }
  if (text.match(/\s/)) {
    attrs["xml:space"] = "preserve";
  }
  if (x2) {
    attrs.x = x2;
  }
  if (y2) {
    attrs.y = y2;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("text", el.id + "", attrs, void 0, text);
}
function brush(el, scope) {
  if (el instanceof Path$1) {
    return brushSVGPath(el, scope);
  } else if (el instanceof ZRImage$1) {
    return brushSVGImage(el, scope);
  } else if (el instanceof TSpan$1) {
    return brushSVGTSpan(el, scope);
  }
}
function setShadow(el, attrs, scope) {
  var style = el.style;
  if (hasShadow(style)) {
    var shadowKey = getShadowKey(el);
    var shadowCache = scope.shadowCache;
    var shadowId = shadowCache[shadowKey];
    if (!shadowId) {
      var globalScale = el.getGlobalScale();
      var scaleX = globalScale[0];
      var scaleY = globalScale[1];
      if (!scaleX || !scaleY) {
        return;
      }
      var offsetX = style.shadowOffsetX || 0;
      var offsetY = style.shadowOffsetY || 0;
      var blur_1 = style.shadowBlur;
      var _a2 = normalizeColor(style.shadowColor), opacity = _a2.opacity, color = _a2.color;
      var stdDx = blur_1 / 2 / scaleX;
      var stdDy = blur_1 / 2 / scaleY;
      var stdDeviation = stdDx + " " + stdDy;
      shadowId = scope.zrId + "-s" + scope.shadowIdx++;
      scope.defs[shadowId] = createVNode("filter", shadowId, {
        "id": shadowId,
        "x": "-100%",
        "y": "-100%",
        "width": "300%",
        "height": "300%"
      }, [
        createVNode("feDropShadow", "", {
          "dx": offsetX / scaleX,
          "dy": offsetY / scaleY,
          "stdDeviation": stdDeviation,
          "flood-color": color,
          "flood-opacity": opacity
        })
      ]);
      shadowCache[shadowKey] = shadowId;
    }
    attrs.filter = getIdURL(shadowId);
  }
}
function setGradient(style, attrs, target, scope) {
  var val = style[target];
  var gradientTag;
  var gradientAttrs = {
    "gradientUnits": val.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient(val)) {
    gradientTag = "linearGradient";
    gradientAttrs.x1 = val.x;
    gradientAttrs.y1 = val.y;
    gradientAttrs.x2 = val.x2;
    gradientAttrs.y2 = val.y2;
  } else if (isRadialGradient(val)) {
    gradientTag = "radialGradient";
    gradientAttrs.cx = retrieve2(val.x, 0.5);
    gradientAttrs.cy = retrieve2(val.y, 0.5);
    gradientAttrs.r = retrieve2(val.r, 0.5);
  } else {
    {
      logError("Illegal gradient type.");
    }
    return;
  }
  var colors2 = val.colorStops;
  var colorStops = [];
  for (var i = 0, len2 = colors2.length; i < len2; ++i) {
    var offset = round4(colors2[i].offset) * 100 + "%";
    var stopColor = colors2[i].color;
    var _a2 = normalizeColor(stopColor), color = _a2.color, opacity = _a2.opacity;
    var stopsAttrs = {
      "offset": offset
    };
    stopsAttrs["stop-color"] = color;
    if (opacity < 1) {
      stopsAttrs["stop-opacity"] = opacity;
    }
    colorStops.push(createVNode("stop", i + "", stopsAttrs));
  }
  var gradientVNode = createVNode(gradientTag, "", gradientAttrs, colorStops);
  var gradientKey = vNodeToString(gradientVNode);
  var gradientCache = scope.gradientCache;
  var gradientId = gradientCache[gradientKey];
  if (!gradientId) {
    gradientId = scope.zrId + "-g" + scope.gradientIdx++;
    gradientCache[gradientKey] = gradientId;
    gradientAttrs.id = gradientId;
    scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
  }
  attrs[target] = getIdURL(gradientId);
}
function setPattern(el, attrs, target, scope) {
  var val = el.style[target];
  var patternAttrs = {
    "patternUnits": "userSpaceOnUse"
  };
  var child;
  if (isImagePattern(val)) {
    var imageWidth_1 = val.imageWidth;
    var imageHeight_1 = val.imageHeight;
    var imageSrc = void 0;
    var patternImage = val.image;
    if (isString(patternImage)) {
      imageSrc = patternImage;
    } else if (isImageLike(patternImage)) {
      imageSrc = patternImage.src;
    } else if (isCanvasLike(patternImage)) {
      imageSrc = patternImage.toDataURL();
    }
    if (typeof Image === "undefined") {
      var errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(imageWidth_1, errMsg);
      assert(imageHeight_1, errMsg);
    } else if (imageWidth_1 == null || imageHeight_1 == null) {
      var setSizeToVNode_1 = function(vNode, img) {
        if (vNode) {
          var svgEl = vNode.elm;
          var width = vNode.attrs.width = imageWidth_1 || img.width;
          var height = vNode.attrs.height = imageHeight_1 || img.height;
          if (svgEl) {
            svgEl.setAttribute("width", width);
            svgEl.setAttribute("height", height);
          }
        }
      };
      var createdImage = createOrUpdateImage(imageSrc, null, el, function(img) {
        setSizeToVNode_1(patternVNode, img);
        setSizeToVNode_1(child, img);
      });
      if (createdImage && createdImage.width && createdImage.height) {
        imageWidth_1 = imageWidth_1 || createdImage.width;
        imageHeight_1 = imageHeight_1 || createdImage.height;
      }
    }
    child = createVNode("image", "img", {
      href: imageSrc,
      width: imageWidth_1,
      height: imageHeight_1
    });
    patternAttrs.width = imageWidth_1;
    patternAttrs.height = imageHeight_1;
  } else if (val.svgElement) {
    child = clone$4(val.svgElement);
    patternAttrs.width = val.svgWidth;
    patternAttrs.height = val.svgHeight;
  }
  if (!child) {
    return;
  }
  patternAttrs.patternTransform = getSRTTransformString(val);
  var patternVNode = createVNode("pattern", "", patternAttrs, [child]);
  var patternKey = vNodeToString(patternVNode);
  var patternCache = scope.patternCache;
  var patternId = patternCache[patternKey];
  if (!patternId) {
    patternId = scope.zrId + "-p" + scope.patternIdx++;
    patternCache[patternKey] = patternId;
    patternAttrs.id = patternId;
    patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
  }
  attrs[target] = getIdURL(patternId);
}
function setClipPath(clipPath, attrs, scope) {
  var clipPathCache = scope.clipPathCache, defs = scope.defs;
  var clipPathId = clipPathCache[clipPath.id];
  if (!clipPathId) {
    clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
    var clipPathAttrs = {
      id: clipPathId
    };
    clipPathCache[clipPath.id] = clipPathId;
    defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
  }
  attrs["clip-path"] = getIdURL(clipPathId);
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function setTextContent(node, text) {
  node.textContent = text;
}
var colonChar = 58;
var xChar = 120;
var emptyNode = createVNode("", "");
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var map5 = {};
  for (var i = beginIdx; i <= endIdx; ++i) {
    var key = children[i].key;
    if (key !== void 0) {
      {
        if (map5[key] != null) {
          console.error("Duplicate key " + key);
        }
      }
      map5[key] = i;
    }
  }
  return map5;
}
function sameVnode(vnode1, vnode2) {
  var isSameKey = vnode1.key === vnode2.key;
  var isSameTag = vnode1.tag === vnode2.tag;
  return isSameTag && isSameKey;
}
function createElm(vnode) {
  var i;
  var children = vnode.children;
  var tag2 = vnode.tag;
  if (isDef(tag2)) {
    var elm = vnode.elm = createElement(tag2);
    updateAttrs(emptyNode, vnode);
    if (isArray$1(children)) {
      for (i = 0; i < children.length; ++i) {
        var ch = children[i];
        if (ch != null) {
          appendChild(elm, createElm(ch));
        }
      }
    } else if (isDef(vnode.text) && !isObject$3(vnode.text)) {
      appendChild(elm, createTextNode(vnode.text));
    }
  } else {
    vnode.elm = createTextNode(vnode.text);
  }
  return vnode.elm;
}
function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    var ch = vnodes[startIdx];
    if (ch != null) {
      insertBefore(parentElm, createElm(ch), before);
    }
  }
}
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    var ch = vnodes[startIdx];
    if (ch != null) {
      if (isDef(ch.tag)) {
        var parent_1 = parentNode(ch.elm);
        removeChild(parent_1, ch.elm);
      } else {
        removeChild(parentElm, ch.elm);
      }
    }
  }
}
function updateAttrs(oldVnode, vnode) {
  var key;
  var elm = vnode.elm;
  var oldAttrs = oldVnode && oldVnode.attrs || {};
  var attrs = vnode.attrs || {};
  if (oldAttrs === attrs) {
    return;
  }
  for (key in attrs) {
    var cur = attrs[key];
    var old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key === "xmlns:xlink" || key === "xmlns") {
          elm.setAttributeNS(XMLNS, key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(XML_NAMESPACE, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(XLINKNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
function updateChildren(parentElm, oldCh, newCh) {
  var oldStartIdx = 0;
  var newStartIdx = 0;
  var oldEndIdx = oldCh.length - 1;
  var oldStartVnode = oldCh[0];
  var oldEndVnode = oldCh[oldEndIdx];
  var newEndIdx = newCh.length - 1;
  var newStartVnode = newCh[0];
  var newEndVnode = newCh[newEndIdx];
  var oldKeyToIdx;
  var idxInOld;
  var elmToMove;
  var before;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = oldKeyToIdx[newStartVnode.key];
      if (isUndef(idxInOld)) {
        insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
      } else {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.tag !== newStartVnode.tag) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
        } else {
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
    if (oldStartIdx > oldEndIdx) {
      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
    } else {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }
}
function patchVnode(oldVnode, vnode) {
  var elm = vnode.elm = oldVnode.elm;
  var oldCh = oldVnode.children;
  var ch = vnode.children;
  if (oldVnode === vnode) {
    return;
  }
  updateAttrs(oldVnode, vnode);
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        updateChildren(elm, oldCh, ch);
      }
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) {
        setTextContent(elm, "");
      }
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      setTextContent(elm, "");
    }
  } else if (oldVnode.text !== vnode.text) {
    if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    }
    setTextContent(elm, vnode.text);
  }
}
function patch(oldVnode, vnode) {
  if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode);
  } else {
    var elm = oldVnode.elm;
    var parent_2 = parentNode(elm);
    createElm(vnode);
    if (parent_2 !== null) {
      insertBefore(parent_2, vnode.elm, nextSibling(elm));
      removeVnodes(parent_2, [oldVnode], 0, 0);
    }
  }
  return vnode;
}
var svgId = 0;
var SVGPainter = function() {
  function SVGPainter2(root, storage2, opts) {
    this.type = "svg";
    this.refreshHover = createMethodNotSupport("refreshHover");
    this.configLayer = createMethodNotSupport("configLayer");
    this.storage = storage2;
    this._opts = opts = extend2({}, opts);
    this.root = root;
    this._id = "zr" + svgId++;
    this._oldVNode = createSVGVNode(opts.width, opts.height);
    if (root && !opts.ssr) {
      var viewport = this._viewport = document.createElement("div");
      viewport.style.cssText = "position:relative;overflow:hidden";
      var svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode);
      viewport.appendChild(svgDom);
      root.appendChild(viewport);
    }
    this.resize(opts.width, opts.height);
  }
  SVGPainter2.prototype.getType = function() {
    return this.type;
  };
  SVGPainter2.prototype.getViewportRoot = function() {
    return this._viewport;
  };
  SVGPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  SVGPainter2.prototype.getSvgDom = function() {
    return this._svgDom;
  };
  SVGPainter2.prototype.refresh = function() {
    if (this.root) {
      var vnode = this.renderToVNode({
        willUpdate: true
      });
      vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
      patch(this._oldVNode, vnode);
      this._oldVNode = vnode;
    }
  };
  SVGPainter2.prototype.renderOneToVNode = function(el) {
    return brush(el, createBrushScope(this._id));
  };
  SVGPainter2.prototype.renderToVNode = function(opts) {
    opts = opts || {};
    var list = this.storage.getDisplayList(true);
    var bgColor = this._backgroundColor;
    var width = this._width;
    var height = this._height;
    var scope = createBrushScope(this._id);
    scope.animation = opts.animation;
    scope.willUpdate = opts.willUpdate;
    scope.compress = opts.compress;
    var children = [];
    if (bgColor && bgColor !== "none") {
      var _a2 = normalizeColor(bgColor), color = _a2.color, opacity = _a2.opacity;
      this._bgVNode = createVNode("rect", "bg", {
        width,
        height,
        x: "0",
        y: "0",
        id: "0",
        fill: color,
        "fill-opacity": opacity
      });
      children.push(this._bgVNode);
    } else {
      this._bgVNode = null;
    }
    var mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
    this._paintList(list, scope, mainVNode ? mainVNode.children : children);
    mainVNode && children.push(mainVNode);
    var defs = map$1(keys2(scope.defs), function(id) {
      return scope.defs[id];
    });
    if (defs.length) {
      children.push(createVNode("defs", "defs", {}, defs));
    }
    if (opts.animation) {
      var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true });
      if (animationCssStr) {
        var styleNode = createVNode("style", "stl", {}, [], animationCssStr);
        children.push(styleNode);
      }
    }
    return createSVGVNode(width, height, children, opts.useViewBox);
  };
  SVGPainter2.prototype.renderToString = function(opts) {
    opts = opts || {};
    return vNodeToString(this.renderToVNode({
      animation: retrieve2(opts.cssAnimation, true),
      willUpdate: false,
      compress: true,
      useViewBox: retrieve2(opts.useViewBox, true)
    }), { newline: true });
  };
  SVGPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    var bgVNode = this._bgVNode;
    if (bgVNode && bgVNode.elm) {
      var _a2 = normalizeColor(backgroundColor2), color = _a2.color, opacity = _a2.opacity;
      bgVNode.elm.setAttribute("fill", color);
      if (opacity < 1) {
        bgVNode.elm.setAttribute("fill-opacity", opacity);
      }
    }
  };
  SVGPainter2.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  };
  SVGPainter2.prototype._paintList = function(list, scope, out2) {
    var listLen = list.length;
    var clipPathsGroupsStack = [];
    var clipPathsGroupsStackDepth = 0;
    var currentClipPathGroup;
    var prevClipPaths;
    var clipGroupNodeIdx = 0;
    for (var i = 0; i < listLen; i++) {
      var displayable = list[i];
      if (!displayable.invisible) {
        var clipPaths = displayable.__clipPaths;
        var len2 = clipPaths && clipPaths.length || 0;
        var prevLen = prevClipPaths && prevClipPaths.length || 0;
        var lca = void 0;
        for (lca = Math.max(len2 - 1, prevLen - 1); lca >= 0; lca--) {
          if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {
            break;
          }
        }
        for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {
          clipPathsGroupsStackDepth--;
          currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
        }
        for (var i_2 = lca + 1; i_2 < len2; i_2++) {
          var groupAttrs = {};
          setClipPath(clipPaths[i_2], groupAttrs, scope);
          var g = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(g);
          clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;
          currentClipPathGroup = g;
        }
        prevClipPaths = clipPaths;
        var ret = brush(displayable, scope);
        if (ret) {
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(ret);
        }
      }
    }
  };
  SVGPainter2.prototype.resize = function(width, height) {
    var opts = this._opts;
    var root = this.root;
    var viewport = this._viewport;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    if (root && viewport) {
      viewport.style.display = "none";
      width = getSize$1(root, 0, opts);
      height = getSize$1(root, 1, opts);
      viewport.style.display = "";
    }
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      if (viewport) {
        var viewportStyle = viewport.style;
        viewportStyle.width = width + "px";
        viewportStyle.height = height + "px";
      }
      var svgDom = this._svgDom;
      if (svgDom) {
        svgDom.setAttribute("width", width);
        svgDom.setAttribute("height", height);
      }
    }
  };
  SVGPainter2.prototype.getWidth = function() {
    return this._width;
  };
  SVGPainter2.prototype.getHeight = function() {
    return this._height;
  };
  SVGPainter2.prototype.dispose = function() {
    if (this.root) {
      this.root.innerHTML = "";
    }
    this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  };
  SVGPainter2.prototype.clear = function() {
    if (this._svgDom) {
      this._svgDom.innerHTML = null;
    }
    this._oldVNode = null;
  };
  SVGPainter2.prototype.toDataURL = function(base64) {
    var str = encodeURIComponent(this.renderToString());
    var prefix = "data:image/svg+xml;";
    if (base64) {
      str = encodeBase64(str);
      return str && prefix + "base64," + str;
    }
    return prefix + "charset=UTF-8," + str;
  };
  return SVGPainter2;
}();
function createMethodNotSupport(method) {
  return function() {
    {
      logError('In SVG mode painter not support method "' + method + '"');
    }
  };
}
var SVGPainter$1 = SVGPainter;
function install$S(registers) {
  registers.registerPainter("svg", SVGPainter$1);
}
function createDom(id, painter, dpr2) {
  var newDom = platformApi.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr2;
  newDom.height = height * dpr2;
  return newDom;
}
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id, painter, dpr2) {
    var _this = _super.call(this) || this;
    _this.motionBlur = false;
    _this.lastFrameAlpha = 0.7;
    _this.dpr = 1;
    _this.virtual = false;
    _this.config = {};
    _this.incremental = false;
    _this.zlevel = 0;
    _this.maxRepaintRectCount = 5;
    _this.__dirty = true;
    _this.__firstTimePaint = true;
    _this.__used = false;
    _this.__drawIndex = 0;
    _this.__startIndex = 0;
    _this.__endIndex = 0;
    _this.__prevStartIndex = null;
    _this.__prevEndIndex = null;
    var dom;
    dpr2 = dpr2 || devicePixelRatio;
    if (typeof id === "string") {
      dom = createDom(id, painter, dpr2);
    } else if (isObject$3(id)) {
      dom = id;
      id = dom.id;
    }
    _this.id = id;
    _this.dom = dom;
    var domStyle = dom.style;
    if (domStyle) {
      disableUserSelect(dom);
      dom.onselectstart = function() {
        return false;
      };
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    _this.painter = painter;
    _this.dpr = dpr2;
    return _this;
  }
  Layer2.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  };
  Layer2.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  };
  Layer2.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  };
  Layer2.prototype.setUnpainted = function() {
    this.__firstTimePaint = true;
  };
  Layer2.prototype.createBackBuffer = function() {
    var dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  };
  Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    var mergedRepaintRects = [];
    var maxRepaintRectCount = this.maxRepaintRectCount;
    var full = false;
    var pendingRect = new BoundingRect$1(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        var boundingRect = new BoundingRect$1(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        var isMerged = false;
        var minDeltaArea = Infinity;
        var bestRectToMergeIdx = 0;
        for (var i2 = 0; i2 < mergedRepaintRects.length; ++i2) {
          var mergedRect = mergedRepaintRects[i2];
          if (mergedRect.intersect(rect)) {
            var pendingRect_1 = new BoundingRect$1(0, 0, 0, 0);
            pendingRect_1.copy(mergedRect);
            pendingRect_1.union(rect);
            mergedRepaintRects[i2] = pendingRect_1;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            var aArea = rect.width * rect.height;
            var bArea = mergedRect.width * mergedRect.height;
            var pendingArea = pendingRect.width * pendingRect.height;
            var deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i2;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          var boundingRect = new BoundingRect$1(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (var i = this.__startIndex; i < this.__endIndex; ++i) {
      var el = displayList[i];
      if (el) {
        var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
      var el = prevList[i];
      var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
        var prevRect = el.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    var hasIntersections;
    do {
      hasIntersections = false;
      for (var i = 0; i < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i].isZero()) {
          mergedRepaintRects.splice(i, 1);
          continue;
        }
        for (var j = i + 1; j < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
            hasIntersections = true;
            mergedRepaintRects[i].union(mergedRepaintRects[j]);
            mergedRepaintRects.splice(j, 1);
          } else {
            j++;
          }
        }
        i++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  };
  Layer2.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  };
  Layer2.prototype.resize = function(width, height) {
    var dpr2 = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom.width = width * dpr2;
    dom.height = height * dpr2;
    if (domBack) {
      domBack.width = width * dpr2;
      domBack.height = height * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  };
  Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr2 = this.dpr;
    var self2 = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
    }
    var domBack = this.domBack;
    function doClear(x2, y2, width2, height2) {
      ctx.clearRect(x2, y2, width2, height2);
      if (clearColor && clearColor !== "transparent") {
        var clearColorGradientOrPattern = void 0;
        if (isGradientObject(clearColor)) {
          clearColorGradientOrPattern = clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width2,
            height: height2
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
        } else if (isImagePatternObject(clearColor)) {
          clearColor.scaleX = clearColor.scaleX || dpr2;
          clearColor.scaleY = clearColor.scaleY || dpr2;
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty: function() {
              self2.setUnpainted();
              self2.__painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x2, y2, width2, height2);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x2, y2, width2, height2);
        ctx.restore();
      }
    }
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width, height);
    } else if (repaintRects.length) {
      each$f(repaintRects, function(rect) {
        doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
      });
    }
  };
  return Layer2;
}(Eventful$1);
var Layer$1 = Layer;
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function isLayerValid(layer2) {
  if (!layer2) {
    return false;
  }
  if (layer2.__builtin__) {
    return true;
  }
  if (typeof layer2.resize !== "function" || typeof layer2.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width, height) {
  var domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = function() {
  function CanvasPainter2(root, storage2, opts, id) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend2({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root;
    var rootStyle = root.style;
    if (rootStyle) {
      disableUserSelect(root);
      root.innerHTML = "";
    }
    this.storage = storage2;
    var zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    var layers = this._layers;
    if (!singleCanvas) {
      this._width = getSize$1(root, 0, opts);
      this._height = getSize$1(root, 1, opts);
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      var rootCanvas = root;
      var width = rootCanvas.width;
      var height = rootCanvas.height;
      if (opts.width != null) {
        width = opts.width;
      }
      if (opts.height != null) {
        height = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width * this.dpr;
      rootCanvas.height = height * this.dpr;
      this._width = width;
      this._height = height;
      var mainLayer = new Layer$1(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root;
    }
  }
  CanvasPainter2.prototype.getType = function() {
    return "canvas";
  };
  CanvasPainter2.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  };
  CanvasPainter2.prototype.getViewportRoot = function() {
    return this._domRoot;
  };
  CanvasPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  CanvasPainter2.prototype.refresh = function(paintAll) {
    var list = this.storage.getDisplayList(true);
    var prevList = this._prevDisplayList;
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer2 = this._layers[z];
      if (!layer2.__builtin__ && layer2.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer2.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  };
  CanvasPainter2.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(false));
  };
  CanvasPainter2.prototype._paintHoverList = function(list) {
    var len2 = list.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len2) {
      return;
    }
    var scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    var ctx;
    for (var i = 0; i < len2; i++) {
      var el = list[i];
      if (el.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush$1(ctx, el, scope, i === len2 - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  };
  CanvasPainter2.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  };
  CanvasPainter2.prototype.paintOne = function(ctx, el) {
    brushSingle(ctx, el);
  };
  CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    var _a2 = this._doPaintList(list, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      var self_1 = this;
      requestAnimationFrame$1(function() {
        self_1._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer(function(layer2) {
        layer2.afterBrush && layer2.afterBrush();
      });
    }
  };
  CanvasPainter2.prototype._compositeManually = function() {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer2) {
      if (layer2.virtual) {
        ctx.drawImage(layer2.dom, 0, 0, width, height);
      }
    });
  };
  CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
    var _this = this;
    var layerList = [];
    var useDirtyRect = this._opts.useDirtyRect;
    for (var zi = 0; zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer2 = this._layers[zlevel];
      if (layer2.__builtin__ && layer2 !== this._hoverlayer && (layer2.__dirty || paintAll)) {
        layerList.push(layer2);
      }
    }
    var finished = true;
    var needsRefreshHover = false;
    var _loop_1 = function(k2) {
      var layer3 = layerList[k2];
      var ctx = layer3.ctx;
      var repaintRects = useDirtyRect && layer3.createRepaintRects(list, prevList, this_1._width, this_1._height);
      var start2 = paintAll ? layer3.__startIndex : layer3.__drawIndex;
      var useTimer = !paintAll && layer3.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer3.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
      if (layer3.__startIndex === layer3.__endIndex) {
        layer3.clear(false, clearColor, repaintRects);
      } else if (start2 === layer3.__startIndex) {
        var firstEl = list[start2];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer3.clear(false, clearColor, repaintRects);
        }
      }
      if (start2 === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start2 = layer3.__startIndex;
      }
      var i;
      var repaint = function(repaintRect) {
        var scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: _this._width,
          viewHeight: _this._height
        };
        for (i = start2; i < layer3.__endIndex; i++) {
          var el = list[i];
          if (el.__inHover) {
            needsRefreshHover = true;
          }
          _this._doPaintEl(el, layer3, useDirtyRect, repaintRect, scope, i === layer3.__endIndex - 1);
          if (useTimer) {
            var dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i = layer3.__endIndex;
        } else {
          var dpr2 = this_1.dpr;
          for (var r = 0; r < repaintRects.length; ++r) {
            var rect = repaintRects[r];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer3.__drawIndex = i;
      if (layer3.__drawIndex < layer3.__endIndex) {
        finished = false;
      }
    };
    var this_1 = this;
    for (var k = 0; k < layerList.length; k++) {
      _loop_1(k);
    }
    if (env$1.wxa) {
      each$f(this._layers, function(layer3) {
        if (layer3 && layer3.ctx && layer3.ctx.draw) {
          layer3.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  };
  CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    var ctx = currentLayer.ctx;
    if (useDirtyRect) {
      var paintRect = el.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush$1(ctx, el, scope, isLast);
        el.setPrevPaintRect(paintRect);
      }
    } else {
      brush$1(ctx, el, scope, isLast);
    }
  };
  CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    var layer2 = this._layers[zlevel];
    if (!layer2) {
      layer2 = new Layer$1("zr_" + zlevel, this, this.dpr);
      layer2.zlevel = zlevel;
      layer2.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge3(layer2, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge3(layer2, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer2.virtual = virtual;
      }
      this.insertLayer(zlevel, layer2);
      layer2.initContext();
    }
    return layer2;
  };
  CanvasPainter2.prototype.insertLayer = function(zlevel, layer2) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len2 = zlevelList.length;
    var domRoot = this._domRoot;
    var prevLayer = null;
    var i = -1;
    if (layersMap[zlevel]) {
      {
        logError("ZLevel " + zlevel + " has been used already");
      }
      return;
    }
    if (!isLayerValid(layer2)) {
      {
        logError("Layer of zlevel " + zlevel + " is not valid");
      }
      return;
    }
    if (len2 > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len2 - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i]];
    }
    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer2;
    if (!layer2.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer2.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer2.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer2.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer2.dom);
        }
      }
    }
    layer2.__painter = this;
  };
  CanvasPainter2.prototype.eachLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  };
  CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer2 = this._layers[z];
      if (layer2.__builtin__) {
        cb.call(context, layer2, z);
      }
    }
  };
  CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer2 = this._layers[z];
      if (!layer2.__builtin__) {
        cb.call(context, layer2, z);
      }
    }
  };
  CanvasPainter2.prototype.getLayers = function() {
    return this._layers;
  };
  CanvasPainter2.prototype._updateLayerStatus = function(list) {
    this.eachBuiltinLayer(function(layer3, z) {
      layer3.__dirty = layer3.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (var i_1 = 1; i_1 < list.length; i_1++) {
        var el = list[i_1];
        if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;
    var i;
    for (i = 0; i < list.length; i++) {
      var el = list[i];
      var zlevel = el.zlevel;
      var layer2 = void 0;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer2 = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer2.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer2 = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer2.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer2.id);
      }
      if (layer2 !== prevLayer) {
        layer2.__used = true;
        if (layer2.__startIndex !== i) {
          layer2.__dirty = true;
        }
        layer2.__startIndex = i;
        if (!layer2.incremental) {
          layer2.__drawIndex = i;
        } else {
          layer2.__drawIndex = -1;
        }
        updatePrevLayer(i);
        prevLayer = layer2;
      }
      if (el.__dirty & REDRAW_BIT && !el.__inHover) {
        layer2.__dirty = true;
        if (layer2.incremental && layer2.__drawIndex < 0) {
          layer2.__drawIndex = i;
        }
      }
    }
    updatePrevLayer(i);
    this.eachBuiltinLayer(function(layer3, z) {
      if (!layer3.__used && layer3.getElementCount() > 0) {
        layer3.__dirty = true;
        layer3.__startIndex = layer3.__endIndex = layer3.__drawIndex = 0;
      }
      if (layer3.__dirty && layer3.__drawIndex < 0) {
        layer3.__drawIndex = layer3.__startIndex;
      }
    });
  };
  CanvasPainter2.prototype.clear = function() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  };
  CanvasPainter2.prototype._clearLayer = function(layer2) {
    layer2.clear();
  };
  CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    each$f(this._layers, function(layer2) {
      layer2.setUnpainted();
    });
  };
  CanvasPainter2.prototype.configLayer = function(zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        merge3(layerConfig[zlevel], config, true);
      }
      for (var i = 0; i < this._zlevelList.length; i++) {
        var _zlevel = this._zlevelList[i];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer2 = this._layers[_zlevel];
          merge3(layer2, layerConfig[zlevel], true);
        }
      }
    }
  };
  CanvasPainter2.prototype.delLayer = function(zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer2 = layers[zlevel];
    if (!layer2) {
      return;
    }
    layer2.dom.parentNode.removeChild(layer2.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf2(zlevelList, zlevel), 1);
  };
  CanvasPainter2.prototype.resize = function(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot;
      domRoot.style.display = "none";
      var opts = this._opts;
      var root = this.root;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = getSize$1(root, 0, opts);
      height = getSize$1(root, 1, opts);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  };
  CanvasPainter2.prototype.clearLayer = function(zlevel) {
    var layer2 = this._layers[zlevel];
    if (layer2) {
      layer2.clear();
    }
  };
  CanvasPainter2.prototype.dispose = function() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  };
  CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    var imageLayer = new Layer$1("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    var ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width_1 = imageLayer.dom.width;
      var height_1 = imageLayer.dom.height;
      this.eachLayer(function(layer2) {
        if (layer2.__builtin__) {
          ctx.drawImage(layer2.dom, 0, 0, width_1, height_1);
        } else if (layer2.renderToCanvas) {
          ctx.save();
          layer2.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      var scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var displayList = this.storage.getDisplayList(true);
      for (var i = 0, len2 = displayList.length; i < len2; i++) {
        var el = displayList[i];
        brush$1(ctx, el, scope, i === len2 - 1);
      }
    }
    return imageLayer.dom;
  };
  CanvasPainter2.prototype.getWidth = function() {
    return this._width;
  };
  CanvasPainter2.prototype.getHeight = function() {
    return this._height;
  };
  return CanvasPainter2;
}();
var CanvasPainter$1 = CanvasPainter;
function install$R(registers) {
  registers.registerPainter("canvas", CanvasPainter$1);
}
var LineSeriesModel = function(_super) {
  __extends$1(LineSeriesModel2, _super);
  function LineSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LineSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  LineSeriesModel2.prototype.getInitialData = function(option) {
    {
      var coordSys = option.coordinateSystem;
      if (coordSys !== "polar" && coordSys !== "cartesian2d") {
        throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
    }
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  LineSeriesModel2.prototype.getLegendIcon = function(opt) {
    var group = new Group$4();
    var line = createSymbol$1("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line);
    line.setStyle(opt.lineStyle);
    var visualType = this.getData().getVisual("symbol");
    var visualRotate = this.getData().getVisual("symbolRotate");
    var symbolType = visualType === "none" ? "circle" : visualType;
    var size11 = opt.itemHeight * 0.8;
    var symbol = createSymbol$1(symbolType, (opt.itemWidth - size11) / 2, (opt.itemHeight - size11) / 2, size11, size11, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = "#fff";
      symbol.style.lineWidth = 2;
    }
    return group;
  };
  LineSeriesModel2.type = "series.line";
  LineSeriesModel2.dependencies = ["grid", "polar"];
  LineSeriesModel2.defaultOption = {
    z: 3,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    clip: true,
    label: {
      position: "top"
    },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: "solid"
    },
    emphasis: {
      scale: true
    },
    step: false,
    smooth: false,
    smoothMonotone: null,
    symbol: "emptyCircle",
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    showAllSymbol: "auto",
    connectNulls: false,
    sampling: "none",
    animationEasing: "linear",
    progressive: 0,
    hoverLayerThreshold: Infinity,
    universalTransition: {
      divideShape: "clone"
    },
    triggerLineEvent: false
  };
  return LineSeriesModel2;
}(SeriesModel$1);
var LineSeries = LineSeriesModel;
function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  var len2 = labelDims.length;
  if (len2 === 1) {
    var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    var vals = [];
    for (var i = 0; i < labelDims.length; i++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  if (!isArray$1(interpolatedValue)) {
    return interpolatedValue + "";
  }
  var vals = [];
  for (var i = 0; i < labelDims.length; i++) {
    var dimIndex = data.getDimensionIndex(labelDims[i]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}
var Symbol$1 = function(_super) {
  __extends$1(Symbol2, _super);
  function Symbol2(data, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;
    _this.updateData(data, idx, seriesScope, opts);
    return _this;
  }
  Symbol2.prototype._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
    this.removeAll();
    var symbolPath = createSymbol$1(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  Symbol2.prototype.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };
  Symbol2.prototype.getSymbolType = function() {
    return this._symbolType;
  };
  Symbol2.prototype.getSymbolPath = function() {
    return this.childAt(0);
  };
  Symbol2.prototype.highlight = function() {
    enterEmphasis(this.childAt(0));
  };
  Symbol2.prototype.downplay = function() {
    leaveEmphasis(this.childAt(0));
  };
  Symbol2.prototype.setZ = function(zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };
  Symbol2.prototype.setDraggable = function(draggable, hasCursorOption) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
  };
  Symbol2.prototype.updateData = function(data, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, "symbol") || "circle";
    var seriesModel = data.hostModel;
    var symbolSize = Symbol2.getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps$1(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      var symbolPath = this.childAt(0);
      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
  };
  Symbol2.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus;
    var blurScope;
    var emphasisDisabled;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    var symbolStyle = data.getItemVisual(idx, "style");
    var visualColor = symbolStyle.fill;
    if (symbolPath instanceof ZRImage$1) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle(extend2({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend2({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    var liftZ = data.getItemVisual(idx, "liftZ");
    var z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    var useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
    emphasisState.scaleX = this._sizeX * scaleRatio;
    emphasisState.scaleY = this._sizeY * scaleRatio;
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Symbol2.prototype.setSymbolScale = function(scale4) {
    this.scaleX = this.scaleY = scale4;
  };
  Symbol2.prototype.fadeOut = function(cb, seriesModel, opt) {
    var symbolPath = this.childAt(0);
    var dataIndex = getECData(this).dataIndex;
    var animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb: function() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex,
      cb,
      removeOpt: animationOpt
    });
  };
  Symbol2.getSymbolSize = function(data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
  };
  return Symbol2;
}(Group$4);
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var SymbolClz = Symbol$1;
function symbolNeedsDraw$1(data, point4, idx, opt) {
  return point4 && !isNaN(point4[0]) && !isNaN(point4[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point4[0], point4[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject$3(opt)) {
    opt = {
      isIgnore: opt
    };
  }
  return opt || {};
}
function makeSeriesScope$2(data) {
  var seriesModel = data.hostModel;
  var emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = function() {
  function SymbolDraw2(SymbolCtor) {
    this.group = new Group$4();
    this._SymbolCtor = SymbolCtor || SymbolClz;
  }
  SymbolDraw2.prototype.updateData = function(data, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope$2(data);
    var symbolUpdateOpt = {
      disableAnimation
    };
    var getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      var point4 = getSymbolPoint(newIdx);
      if (symbolNeedsDraw$1(data, point4, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point4);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point4 = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw$1(data, point4, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point4);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point4[0],
          y: point4[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps$1(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  };
  SymbolDraw2.prototype.updateLayout = function() {
    var _this = this;
    var data = this._data;
    if (data) {
      data.eachItemGraphicEl(function(el, idx) {
        var point4 = _this._getSymbolPoint(idx);
        el.setPosition(point4);
        el.markRedraw();
      });
    }
  };
  SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this._seriesScope = makeSeriesScope$2(data);
    this._data = null;
    this.group.removeAll();
  };
  SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point4 = data.getItemLayout(idx);
      if (symbolNeedsDraw$1(data, point4, idx, opt)) {
        var el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point4);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  };
  SymbolDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  SymbolDraw2.prototype.remove = function(enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        }, data.hostModel);
      });
    } else {
      group.removeAll();
    }
  };
  return SymbolDraw2;
}();
var SymbolDraw$1 = SymbolDraw;
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis2 = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis2, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis2.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  var dims = map$1(coordSys.dimensions, function(coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked(
    data,
    dims[0]
  )) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked(
    data,
    dims[1]
  )) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis2, valueOrigin) {
  var valueStart = 0;
  var extent3 = valueAxis2.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent3[0];
  } else if (valueOrigin === "end") {
    valueStart = extent3[1];
  } else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
    valueStart = valueOrigin;
  } else {
    if (extent3[0] > 0) {
      valueStart = extent3[0];
    } else if (extent3[1] < 0) {
      valueStart = extent3[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value = NaN;
  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }
  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}
function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({
      cmd: "+",
      idx
    });
  }).update(function(newIdx, oldIdx) {
    diffResult.push({
      cmd: "=",
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function(idx) {
    diffResult.push({
      cmd: "-",
      idx
    });
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff2 = diffData(oldData, newData);
  var currPoints = [];
  var nextPoints = [];
  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  var oldPoints = oldData.getLayout("points") || [];
  var newPoints = newData.getLayout("points") || [];
  for (var i = 0; i < diff2.length; i++) {
    var diffItem = diff2[i];
    var pointAdded = true;
    var oldIdx2 = void 0;
    var newIdx2 = void 0;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var len2 = currPoints.length;
  var sortedCurrPoints = createFloat32Array(len2);
  var sortedNextPoints = createFloat32Array(len2);
  var sortedCurrStackedPoints = createFloat32Array(len2);
  var sortedNextStackedPoints = createFloat32Array(len2);
  var sortedStatus = [];
  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    var i2 = i * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}
var mathMin$5 = Math.min;
var mathMax$5 = Math.max;
function isPointNull$1(x2, y2) {
  return isNaN(x2) || isNaN(y2);
}
function drawSegment(ctx, points2, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start2;
  var k = 0;
  for (; k < segLen; k++) {
    var x2 = points2[idx * 2];
    var y2 = points2[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull$1(x2, y2)) {
      if (connectNulls) {
        idx += dir3;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir3 > 0 ? "moveTo" : "lineTo"](x2, y2);
      cpx0 = x2;
      cpy0 = y2;
    } else {
      var dx = x2 - prevX;
      var dy = y2 - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir3;
        continue;
      }
      if (smooth > 0) {
        var nextIdx = idx + dir3;
        var nextX = points2[nextIdx * 2];
        var nextY = points2[nextIdx * 2 + 1];
        while (nextX === x2 && nextY === y2 && k < segLen) {
          k++;
          nextIdx += dir3;
          idx += dir3;
          nextX = points2[nextIdx * 2];
          nextY = points2[nextIdx * 2 + 1];
          x2 = points2[idx * 2];
          y2 = points2[idx * 2 + 1];
          dx = x2 - prevX;
          dy = y2 - prevY;
        }
        var tmpK = k + 1;
        if (connectNulls) {
          while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir3;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
          }
        }
        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = void 0;
        var nextCpy0 = void 0;
        if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
          cpx1 = x2;
          cpy1 = y2;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x2 - prevX;
          var dx1 = nextX - x2;
          var dy0 = y2 - prevY;
          var dy1 = nextY - y2;
          var lenPrevSeg = void 0;
          var lenNextSeg = void 0;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            var dir_1 = vx > 0 ? 1 : -1;
            cpx1 = x2 - dir_1 * lenPrevSeg * smooth;
            cpy1 = y2;
            nextCpx0 = x2 + dir_1 * lenNextSeg * smooth;
            nextCpy0 = y2;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            var dir_2 = vy > 0 ? 1 : -1;
            cpx1 = x2;
            cpy1 = y2 - dir_2 * lenPrevSeg * smooth;
            nextCpx0 = x2;
            nextCpy0 = y2 + dir_2 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x2 - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y2 - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x2 + vx * smooth * ratioNextSeg;
            nextCpy0 = y2 + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin$5(nextCpx0, mathMax$5(nextX, x2));
            nextCpy0 = mathMin$5(nextCpy0, mathMax$5(nextY, y2));
            nextCpx0 = mathMax$5(nextCpx0, mathMin$5(nextX, x2));
            nextCpy0 = mathMax$5(nextCpy0, mathMin$5(nextY, y2));
            vx = nextCpx0 - x2;
            vy = nextCpy0 - y2;
            cpx1 = x2 - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y2 - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin$5(cpx1, mathMax$5(prevX, x2));
            cpy1 = mathMin$5(cpy1, mathMax$5(prevY, y2));
            cpx1 = mathMax$5(cpx1, mathMin$5(prevX, x2));
            cpy1 = mathMax$5(cpy1, mathMin$5(prevY, y2));
            vx = x2 - cpx1;
            vy = y2 - cpy1;
            nextCpx0 = x2 + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y2 + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x2, y2);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x2, y2);
      }
    }
    prevX = x2;
    prevY = y2;
    idx += dir3;
  }
  return k;
}
var ECPolylineShape = function() {
  function ECPolylineShape2() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
  return ECPolylineShape2;
}();
var ECPolyline = function(_super) {
  __extends$1(ECPolyline2, _super);
  function ECPolyline2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polyline";
    return _this;
  }
  ECPolyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECPolyline2.prototype.getDefaultShape = function() {
    return new ECPolylineShape();
  };
  ECPolyline2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var i = 0;
    var len2 = points2.length / 2;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      i += drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };
  ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    var path = this.path;
    var data = path.data;
    var CMD2 = PathProxy.CMD;
    var x02;
    var y02;
    var isDimX = dim === "x";
    var roots2 = [];
    for (var i = 0; i < data.length; ) {
      var cmd = data[i++];
      var x2 = void 0;
      var y2 = void 0;
      var x22 = void 0;
      var y22 = void 0;
      var x3 = void 0;
      var y3 = void 0;
      var t = void 0;
      switch (cmd) {
        case CMD2.M:
          x02 = data[i++];
          y02 = data[i++];
          break;
        case CMD2.L:
          x2 = data[i++];
          y2 = data[i++];
          t = isDimX ? (xOrY - x02) / (x2 - x02) : (xOrY - y02) / (y2 - y02);
          if (t <= 1 && t >= 0) {
            var val = isDimX ? (y2 - y02) * t + y02 : (x2 - x02) * t + x02;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }
          x02 = x2;
          y02 = y2;
          break;
        case CMD2.C:
          x2 = data[i++];
          y2 = data[i++];
          x22 = data[i++];
          y22 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          var nRoot = isDimX ? cubicRootAt(x02, x2, x22, x3, xOrY, roots2) : cubicRootAt(y02, y2, y22, y3, xOrY, roots2);
          if (nRoot > 0) {
            for (var i_1 = 0; i_1 < nRoot; i_1++) {
              var t_1 = roots2[i_1];
              if (t_1 <= 1 && t_1 >= 0) {
                var val = isDimX ? cubicAt(y02, y2, y22, y3, t_1) : cubicAt(x02, x2, x22, x3, t_1);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }
          x02 = x3;
          y02 = y3;
          break;
      }
    }
  };
  return ECPolyline2;
}(Path$1);
var ECPolygonShape = function(_super) {
  __extends$1(ECPolygonShape2, _super);
  function ECPolygonShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return ECPolygonShape2;
}(ECPolylineShape);
var ECPolygon = function(_super) {
  __extends$1(ECPolygon2, _super);
  function ECPolygon2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polygon";
    return _this;
  }
  ECPolygon2.prototype.getDefaultShape = function() {
    return new ECPolygonShape();
  };
  ECPolygon2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len2 = points2.length / 2;
    var smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      var k = drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  };
  return ECPolygon2;
}(Path$1);
function createGridClipPath(cartesian2, hasAnimation, seriesModel, done, during) {
  var rect = cartesian2.getArea();
  var x2 = rect.x;
  var y2 = rect.y;
  var width = rect.width;
  var height = rect.height;
  var lineWidth = seriesModel.get(["lineStyle", "width"]) || 2;
  x2 -= lineWidth / 2;
  y2 -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth;
  x2 = Math.floor(x2);
  width = Math.round(width);
  var clipPath = new Rect$3({
    shape: {
      x: x2,
      y: y2,
      width,
      height
    }
  });
  if (hasAnimation) {
    var baseAxis = cartesian2.getBaseAxis();
    var isHorizontal2 = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;
    if (isHorizontal2) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }
      clipPath.shape.height = 0;
    }
    var duringCb = isFunction(during) ? function(percent) {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width,
        height,
        x: x2,
        y: y2
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea();
  var r0 = round$3(sectorArea.r0, 1);
  var r = round$3(sectorArea.r, 1);
  var clipPath = new Sector$1({
    shape: {
      cx: round$3(polar.cx, 1),
      cy: round$3(polar.cy, 1),
      r0,
      r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }
  for (var i = 0; i < points1.length; i++) {
    if (points1[i] !== points2[i]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points2) {
  var minX2 = Infinity;
  var minY2 = Infinity;
  var maxX2 = -Infinity;
  var maxY2 = -Infinity;
  for (var i = 0; i < points2.length; ) {
    var x2 = points2[i++];
    var y2 = points2[i++];
    if (!isNaN(x2)) {
      minX2 = Math.min(x2, minX2);
      maxX2 = Math.max(x2, maxX2);
    }
    if (!isNaN(y2)) {
      minY2 = Math.min(y2, minY2);
      maxY2 = Math.max(y2, maxY2);
    }
  }
  return [[minX2, minY2], [maxX2, maxY2]];
}
function getBoundingDiff(points1, points2) {
  var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
  var _b2 = bboxFromPoints(points2), min23 = _b2[0], max23 = _b2[1];
  return Math.max(Math.abs(min1[0] - min23[0]), Math.abs(min1[1] - min23[1]), Math.abs(max1[0] - max23[0]), Math.abs(max1[1] - max23[1]));
}
function getSmooth(smooth) {
  return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  var len2 = data.count();
  var points2 = createFloat32Array(len2 * 2);
  for (var idx = 0; idx < len2; idx++) {
    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points2[idx * 2] = pt[0];
    points2[idx * 2 + 1] = pt[1];
  }
  return points2;
}
function turnPointsIntoStep(points2, coordSys, stepTurnAt, connectNulls) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  var stepPoints = [];
  var i = 0;
  var stepPt = [];
  var pt = [];
  var nextPt = [];
  var filteredPoints = [];
  if (connectNulls) {
    for (i = 0; i < points2.length; i += 2) {
      if (!isNaN(points2[i]) && !isNaN(points2[i + 1])) {
        filteredPoints.push(points2[i], points2[i + 1]);
      }
    }
    points2 = filteredPoints;
  }
  for (i = 0; i < points2.length - 2; i += 2) {
    nextPt[0] = points2[i + 2];
    nextPt[1] = points2[i + 3];
    pt[0] = points2[i];
    pt[1] = points2[i + 1];
    stepPoints.push(pt[0], pt[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points2[i++], points2[i++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  var newColorStops = [];
  var len2 = colorStops.length;
  var prevOutOfRangeColorStop;
  var prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    var coord0 = stop0.coord;
    var p = (clippedCoord - coord0) / (stop1.coord - coord0);
    var color = lerp(p, [stop0.color, stop1.color]);
    return {
      coord: clippedCoord,
      color
    };
  }
  for (var i = 0; i < len2; i++) {
    var stop_1 = colorStops[i];
    var coord = stop_1.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop_1;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop_1);
      prevInRangeColorStop = stop_1;
    }
  }
  return newColorStops;
}
function getVisualGradient(data, coordSys, api) {
  var visualMetaList = data.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    {
      console.warn("Visual map on line style is only supported on cartesian2d.");
    }
    return;
  }
  var coordDim;
  var visualMeta;
  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i];
      break;
    }
  }
  if (!visualMeta) {
    {
      console.warn("Visual map on line style only support x or y dimension.");
    }
    return;
  }
  var axis = coordSys.getAxis(coordDim);
  var colorStops = map$1(visualMeta.stops, function(stop2) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
      color: stop2.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
  var inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  var tinyExtent = 10;
  var minCoord = colorStopsInRange[0].coord - tinyExtent;
  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;
  if (coordSpan < 1e-3) {
    return "transparent";
  }
  each$f(colorStopsInRange, function(stop2) {
    stop2.offset = (stop2.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  var gradient = new LinearGradient$1(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get("showAllSymbol");
  var isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis2) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
    return;
  }
  var categoryDataDim = data.mapDimension(categoryAxis2.dim);
  var labelMap = {};
  each$f(categoryAxis2.getViewLabels(), function(labelItem) {
    var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis2, data) {
  var axisExtent = categoryAxis2.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
  isNaN(availSize) && (availSize = 0);
  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));
  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (SymbolClz.getSymbolSize(
      data,
      dataIndex
    )[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull(x2, y2) {
  return isNaN(x2) || isNaN(y2);
}
function getLastIndexNotNull(points2) {
  var len2 = points2.length / 2;
  for (; len2 > 0; len2--) {
    if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points2, idx) {
  return [points2[idx * 2], points2[idx * 2 + 1]];
}
function getIndexRange(points2, xOrY, dim) {
  var len2 = points2.length / 2;
  var dimIdx = dim === "x" ? 0 : 1;
  var a;
  var b;
  var prevIndex = 0;
  var nextIndex = -1;
  for (var i = 0; i < len2; i++) {
    b = points2[i * 2 + dimIdx];
    if (isNaN(b) || isNaN(points2[i * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i === 0) {
      a = b;
      continue;
    }
    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
      nextIndex = i;
      break;
    }
    prevIndex = i;
    a = b;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a) / (b - a)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    var endLabelModel_1 = seriesModel.getModel("endLabel");
    var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal2 = coordSys.getBaseAxis().isHorizontal();
    var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
      var endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal2) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    {
      if (seriesModel.get(["endLabel", "show"])) {
        console.warn("endLabel is not supported for lines in polar systems.");
      }
    }
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal2 = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal2 ? isBaseInversed ? "right" : "left" : "center";
  var verticalAlign = isHorizontal2 ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = function(_super) {
  __extends$1(LineView2, _super);
  function LineView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineView2.prototype.init = function() {
    var lineGroup = new Group$4();
    var symbolDraw = new SymbolDraw$1();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  };
  LineView2.prototype.render = function(seriesModel, ecModel, api) {
    var _this = this;
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel("lineStyle");
    var areaStyleModel = seriesModel.getModel("areaStyle");
    var points2 = data.getLayout("points") || [];
    var isCoordSysPolar = coordSys.type === "polar";
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon4 = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get("animation");
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get("origin");
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get("showSymbol");
    var connectNulls = seriesModel.get("connectNulls");
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    var step = !isCoordSysPolar ? seriesModel.get("step") : false;
    var clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
      if (step) {
        points2 = turnPointsIntoStep(points2, coordSys, step, connectNulls);
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
        }
      }
      polyline = this._newPolyline(points2);
      if (isAreaChart) {
        polygon4 = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon4) {
        lineGroup.remove(polygon4);
        polygon4 = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon4) {
        polygon4 = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon4 && !isAreaChart) {
        lineGroup.remove(polygon4);
        polygon4 = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      var oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
        } else {
          if (step) {
            points2 = turnPointsIntoStep(points2, coordSys, step, connectNulls);
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
            }
          }
          polyline.setShape({
            points: points2
          });
          polygon4 && polygon4.setShape({
            points: points2,
            stackedOnPoints
          });
        }
      }
    }
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults(
      lineStyleModel.getLineStyle(),
      {
        fill: "none",
        stroke: visualColor,
        lineJoin: "bevel"
      }
    ));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      var emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    var smooth = getSmooth(seriesModel.get("smooth"));
    var smoothMonotone = seriesModel.get("smoothMonotone");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon4) {
      var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
      var stackedOnSmooth = 0;
      polygon4.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon4.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon4, seriesModel, "areaStyle");
      getECData(polygon4).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon4, focus, blurScope, emphasisDisabled);
    }
    var changePolyState = function(toState) {
      _this._changePolyState(toState);
    };
    data.eachItemGraphicEl(function(el) {
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points2;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon4 && this.packEventData(seriesModel, polygon4);
    }
  };
  LineView2.prototype.packEventData = function(seriesModel, el) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  };
  LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points2 = data.getLayout("points");
      var symbol = data.getItemGraphicEl(dataIndex);
      if (!symbol) {
        var x2 = points2[dataIndex * 2];
        var y2 = points2[dataIndex * 2 + 1];
        if (isNaN(x2) || isNaN(y2)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x2, y2)) {
          return;
        }
        var zlevel = seriesModel.get("zlevel") || 0;
        var z = seriesModel.get("z") || 0;
        symbol = new SymbolClz(data, dataIndex);
        symbol.x = x2;
        symbol.y = y2;
        symbol.setZ(zlevel, z);
        var symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      ChartView$1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      ChartView$1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype._changePolyState = function(toState) {
    var polygon4 = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon4 && setStatesFlag(polygon4, toState);
  };
  LineView2.prototype._newPolyline = function(points2) {
    var polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points2
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  };
  LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
    var polygon4 = this._polygon;
    if (polygon4) {
      this._lineGroup.remove(polygon4);
    }
    polygon4 = new ECPolygon({
      shape: {
        points: points2,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon4);
    this._polygon = polygon4;
    return polygon4;
  };
  LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    var seriesModel = data.hostModel;
    var seriesDuration = seriesModel.get("animationDuration");
    if (isFunction(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    var seriesDalay = seriesModel.get("animationDelay") || 0;
    var seriesDalayValue = isFunction(seriesDalay) ? seriesDalay(null) : seriesDalay;
    data.eachItemGraphicEl(function(symbol, idx) {
      var el = symbol;
      if (el) {
        var point4 = [symbol.x, symbol.y];
        var start2 = void 0;
        var end2 = void 0;
        var current = void 0;
        if (clipShape) {
          if (isCoordSysPolar) {
            var polarClip = clipShape;
            var coord = coordSys.pointToCoord(point4);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            var gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        var delay = isFunction(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
        var symbolPath = el.getSymbolPath();
        var text = symbolPath.getTextContent();
        el.attr({
          scaleX: 0,
          scaleY: 0
        });
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay
        });
        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  };
  LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline;
      var points2 = data_2.getLayout("points");
      if (!points2) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      var endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new ZRText$1({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      var dataIndex = getLastIndexNotNull(points2);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  };
  LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      var points2 = data.getLayout("points");
      var seriesModel = data.hostModel;
      var connectNulls = seriesModel.get("connectNulls");
      var precision = endLabelModel.get("precision");
      var distance11 = endLabelModel.get("distance") || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal2 = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal2 ? clipShape.x : clipShape.y + clipShape.height : isHorizontal2 ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal2 ? distance11 : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal2 ? 0 : -distance11) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal2 ? "x" : "y";
      var dataIndexRange = getIndexRange(points2, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff2 = indices[1] - indices[0];
      var value = void 0;
      if (diff2 >= 1) {
        if (diff2 > 1 && !connectNulls) {
          var pt = getPointAtIndex(points2, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          var pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt = getPointAtIndex(points2, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }
      if (valueAnimation) {
        labelInner(endLabel).setLabelText(value);
      }
    }
  };
  LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
    var polyline = this._polyline;
    var polygon4 = this._polygon;
    var seriesModel = data.hostModel;
    var diff2 = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
    var current = diff2.current;
    var stackedOnCurrent = diff2.stackedOnCurrent;
    var next3 = diff2.next;
    var stackedOnNext = diff2.stackedOnNext;
    if (step) {
      current = turnPointsIntoStep(diff2.current, coordSys, step, connectNulls);
      stackedOnCurrent = turnPointsIntoStep(diff2.stackedOnCurrent, coordSys, step, connectNulls);
      next3 = turnPointsIntoStep(diff2.next, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff2.stackedOnNext, coordSys, step, connectNulls);
    }
    if (getBoundingDiff(current, next3) > 3e3 || polygon4 && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next3
      });
      if (polygon4) {
        polygon4.stopAnimation();
        polygon4.setShape({
          points: next3,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff2.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next3
      }
    };
    if (diff2.current !== current) {
      target.shape.__points = diff2.next;
    }
    polyline.stopAnimation();
    updateProps$1(polyline, target, seriesModel);
    if (polygon4) {
      polygon4.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon4.stopAnimation();
      updateProps$1(polygon4, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon4.shape.points) {
        polygon4.shape.points = polyline.shape.points;
      }
    }
    var updatedDataInfo = [];
    var diffStatus = diff2.status;
    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;
      if (cmd === "=") {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);
        if (el) {
          updatedDataInfo.push({
            el,
            ptIdx: i
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon4 && polygon4.dirtyShape();
        var points2 = polyline.shape.__points;
        for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
          var el2 = updatedDataInfo[i2].el;
          var offset = updatedDataInfo[i2].ptIdx * 2;
          el2.x = points2[offset];
          el2.y = points2[offset + 1];
          el2.markRedraw();
        }
      });
    }
  };
  LineView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };
  LineView2.type = "line";
  return LineView2;
}(ChartView$1);
var LineView$1 = LineView;
function pointsLayout(seriesType2, forceStoreInTypedArray) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      var dims = map$1(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      var store = data.getStore();
      var dimIdx0 = data.getDimensionIndex(dims[0]);
      var dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function(params, data2) {
          var segCount = params.end - params.start;
          var points2 = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];
          for (var i = params.start, offset = 0; i < params.end; i++) {
            var point4 = void 0;
            if (dimLen === 1) {
              var x2 = store.get(dimIdx0, i);
              point4 = coordSys.dataToPoint(x2, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i);
              point4 = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points2[offset++] = point4[0];
              points2[offset++] = point4[1];
            } else {
              data2.setItemLayout(i, point4.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points2);
        }
      };
    }
  };
}
var samplers = {
  average: function(frame) {
    var sum2 = 0;
    var count3 = 0;
    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum2 += frame[i];
        count3++;
      }
    }
    return count3 === 0 ? NaN : sum2 / count3;
  },
  sum: function(frame) {
    var sum2 = 0;
    for (var i = 0; i < frame.length; i++) {
      sum2 += frame[i] || 0;
    }
    return sum2;
  },
  max: function(frame) {
    var max4 = -Infinity;
    for (var i = 0; i < frame.length; i++) {
      frame[i] > max4 && (max4 = frame[i]);
    }
    return isFinite(max4) ? max4 : NaN;
  },
  min: function(frame) {
    var min5 = Infinity;
    for (var i = 0; i < frame.length; i++) {
      frame[i] < min5 && (min5 = frame[i]);
    }
    return isFinite(min5) ? min5 : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get("sampling");
      var coordSys = seriesModel.coordinateSystem;
      var count3 = data.count();
      if (count3 > 10 && coordSys.type === "cartesian2d" && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var extent3 = baseAxis.getExtent();
        var dpr2 = api.getDevicePixelRatio();
        var size11 = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
        var rate = Math.round(count3 / size11);
        if (isFinite(rate) && rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
          }
          var sampler = void 0;
          if (isString(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}
function install$Q(registers) {
  registers.registerChartView(LineView$1);
  registers.registerSeriesModel(LineSeries);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data.getVisual("style").fill;
      }
      data.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = function(_super) {
  __extends$1(BaseBarSeriesModel2, _super);
  function BaseBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BaseBarSeriesModel2.type;
    return _this;
  }
  BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  BaseBarSeriesModel2.prototype.getMarkerPosition = function(value) {
    var coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      var pt = coordSys.dataToPoint(coordSys.clampData(value));
      var data = this.getData();
      var offset = data.getLayout("offset");
      var size11 = data.getLayout("size");
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size11 / 2;
      return pt;
    }
    return [NaN, NaN];
  };
  BaseBarSeriesModel2.type = "series.__base_bar__";
  BaseBarSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    barMinHeight: 0,
    barMinAngle: 0,
    large: false,
    largeThreshold: 400,
    progressive: 3e3,
    progressiveChunkMode: "mod"
  };
  return BaseBarSeriesModel2;
}(SeriesModel$1);
SeriesModel$1.registerClass(BaseBarSeriesModel);
var BaseBarSeriesModel$1 = BaseBarSeriesModel;
var BarSeriesModel = function(_super) {
  __extends$1(BarSeriesModel2, _super);
  function BarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BarSeriesModel2.type;
    return _this;
  }
  BarSeriesModel2.prototype.getInitialData = function() {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  };
  BarSeriesModel2.prototype.getProgressive = function() {
    return this.get("large") ? this.get("progressive") : false;
  };
  BarSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.get("progressiveThreshold");
    var largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  };
  BarSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  };
  BarSeriesModel2.type = "series.bar";
  BarSeriesModel2.dependencies = ["grid", "polar"];
  BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: "rgba(180, 180, 180, 0.2)",
      borderColor: null,
      borderWidth: 0,
      borderType: "solid",
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel2;
}(BaseBarSeriesModel$1);
var BarSeries = BarSeriesModel;
var SausageShape = function() {
  function SausageShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return SausageShape2;
}();
var SausagePath = function(_super) {
  __extends$1(SausagePath2, _super);
  function SausagePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "sausage";
    return _this;
  }
  SausagePath2.prototype.getDefaultShape = function() {
    return new SausageShape();
  };
  SausagePath2.prototype.buildPath = function(ctx, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var dr = (r - r0) * 0.5;
    var rCenter = r0 + dr;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var PI22 = Math.PI * 2;
    var lessThanCircle = clockwise ? endAngle - startAngle < PI22 : startAngle - endAngle < PI22;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI22 : -PI22);
    }
    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
    }
    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  };
  return SausagePath2;
}(Path$1);
var Sausage = SausagePath;
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  var isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    var textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    var mappedSectorPosition = positionMapping(textPosition);
    var distance11 = opts2.distance != null ? opts2.distance : 5;
    var sector2 = this.shape;
    var cx = sector2.cx;
    var cy = sector2.cy;
    var r = sector2.r;
    var r0 = sector2.r0;
    var middleR = (r + r0) / 2;
    var startAngle = sector2.startAngle;
    var endAngle = sector2.endAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
    var mathCos2 = Math.cos;
    var mathSin2 = Math.sin;
    var x2 = cx + r * mathCos2(startAngle);
    var y2 = cy + r * mathSin2(startAngle);
    var textAlign = "left";
    var textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x2 = cx + (r0 - distance11) * mathCos2(middleAngle);
        y2 = cy + (r0 - distance11) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x2 = cx + (r0 + distance11) * mathCos2(middleAngle);
        y2 = cy + (r0 + distance11) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, distance11 + extraDist, false);
        y2 = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, distance11 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, -distance11 + extraDist, false);
        y2 = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, -distance11 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x2 = cx + middleR * mathCos2(middleAngle);
        y2 = cy + middleR * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x2 = cx + (r + distance11) * mathCos2(middleAngle);
        y2 = cy + (r + distance11) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x2 = cx + (r - distance11) * mathCos2(middleAngle);
        y2 = cy + (r - distance11) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, distance11 + extraDist, true);
        y2 = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, distance11 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, -distance11 + extraDist, true);
        y2 = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, -distance11 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x2;
    out2.y = y2;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector2, textPosition, positionMapping, rotateType) {
  if (isNumber(rotateType)) {
    sector2.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray$1(textPosition)) {
    sector2.setTextConfig({
      rotation: 0
    });
    return;
  }
  var shape = sector2.shape;
  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  var middleAngle = (startAngle + endAngle) / 2;
  var anchorAngle;
  var mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector2.setTextConfig({
        rotation: 0
      });
      return;
  }
  var rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector2.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle4, distance11, isEnd) {
  return distance11 * Math.sin(angle4) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle4, distance11, isEnd) {
  return distance11 * Math.cos(angle4) * (isEnd ? 1 : -1);
}
var mathMax$4 = Math.max;
var mathMin$4 = Math.min;
function getClipArea(coord, data) {
  var coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      var expandWidth = data.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView = function(_super) {
  __extends$1(BarView2, _super);
  function BarView2() {
    var _this = _super.call(this) || this;
    _this.type = BarView2.type;
    _this._isFirstFrame = true;
    return _this;
  }
  BarView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api);
    this._updateDrawMode(seriesModel);
    var coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    } else {
      warn("Only cartesian2d and polar supported for bar.");
    }
  };
  BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype.incrementalRender = function(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  };
  BarView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  BarView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  BarView2.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api);
    }
    var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data);
    group.removeClipPath();
    var roundCap = seriesModel.get("roundCap", true);
    var drawBackground = seriesModel.get("showBackground", true);
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var barBorderRadius = backgroundModel.get("borderRadius") || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    data.diff(oldData).add(function(dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      var layout2 = getLayout[coord.type](data, dataIndex, itemModel);
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout2)) {
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
      }
      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {
          shape: layout2
        }, seriesModel, dataIndex);
      }
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      var itemModel = data.getItemModel(newIndex);
      var layout2 = getLayout[coord.type](data, newIndex, itemModel);
      if (drawBackground) {
        var bgEl = void 0;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        var bgLayout = getLayout[coord.type](data, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps$1(bgEl, {
          shape
        }, animationModel, newIndex);
      }
      var el = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout2)) {
        group.remove(el);
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
        if (isClipped) {
          group.remove(el);
        }
      }
      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } else {
        saveOldStyle(el);
      }
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        var textEl = el.getTextContent();
        if (textEl) {
          var labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle(el, data, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps$1(el, {
          shape: layout2
        }, seriesModel, newIndex, null);
      }
      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function(dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group$4());
    bgGroup.removeAll();
    for (var i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  };
  BarView2.prototype._renderLarge = function(seriesModel, ecModel, api) {
    this._clear();
    createLarge$1(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    this._removeBackground();
    createLarge$1(seriesModel, this.group, this._progressiveEls, true);
  };
  BarView2.prototype._updateLargeClip = function(seriesModel) {
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    var group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  };
  BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api) {
    var _this = this;
    if (!data.count()) {
      return;
    }
    var baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api);
      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function(idx) {
        var el = data.getItemGraphicEl(idx);
        var shape = el && el.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = function() {
        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
      };
      api.getZr().on("rendered", this._onRendered);
    }
  };
  BarView2.prototype._dataSort = function(data, baseAxis, orderMapping) {
    var info = [];
    data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info.sort(function(a, b) {
      return b.mappedValue - a.mappedValue;
    });
    return {
      ordinalNumbers: map$1(info, function(item) {
        return item.ordinalNumber;
      })
    };
  };
  BarView2.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
    var scale4 = baseAxis.scale;
    var ordinalDataDim = data.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;
    for (var tickNum = 0, len2 = scale4.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
      var rawIdx = data.rawIndexOf(ordinalDataDim, scale4.getRawOrdinalNumber(tickNum));
      var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
      if (value > lastValue) {
        return true;
      }
      lastValue = value;
    }
    return false;
  };
  BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
    var scale4 = baseAxis.scale;
    var extent3 = scale4.getExtent();
    var tickNum = Math.max(0, extent3[0]);
    var tickMax = Math.min(extent3[1], scale4.getOrdinalMeta().categories.length - 1);
    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale4.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };
  BarView2.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }
    var sortInfo = this._dataSort(data, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);
      api.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  };
  BarView2.prototype._dispatchInitSort = function(data, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;
    var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });
    api.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  };
  BarView2.prototype.remove = function(ecModel, api) {
    this._clear(this._model);
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype.dispose = function(ecModel, api) {
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype._removeOnRenderedListener = function(api) {
    if (this._onRendered) {
      api.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  };
  BarView2.prototype._clear = function(model) {
    var group = this.group;
    var data = this._data;
    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data.eachItemGraphicEl(function(el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  };
  BarView2.prototype._removeBackground = function() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };
  BarView2.type = "bar";
  return BarView2;
}(ChartView$1);
var clip = {
  cartesian2d: function(coordSysBoundingRect, layout2) {
    var signWidth = layout2.width < 0 ? -1 : 1;
    var signHeight = layout2.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x2 = mathMax$4(layout2.x, coordSysBoundingRect.x);
    var x22 = mathMin$4(layout2.x + layout2.width, coordSysX2);
    var y2 = mathMax$4(layout2.y, coordSysBoundingRect.y);
    var y22 = mathMin$4(layout2.y + layout2.height, coordSysY2);
    var xClipped = x22 < x2;
    var yClipped = y22 < y2;
    layout2.x = xClipped && x2 > coordSysX2 ? x22 : x2;
    layout2.y = yClipped && y2 > coordSysY2 ? y22 : y2;
    layout2.width = xClipped ? 0 : x22 - x2;
    layout2.height = yClipped ? 0 : y22 - y2;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    return xClipped || yClipped;
  },
  polar: function(coordSysClipArea, layout2) {
    var signR = layout2.r0 <= layout2.r ? 1 : -1;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    var r = mathMin$4(layout2.r, coordSysClipArea.r);
    var r0 = mathMax$4(layout2.r0, coordSysClipArea.r0);
    layout2.r = r;
    layout2.r0 = r0;
    var clipped = r - r0 < 0;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function(seriesModel, data, newIndex, layout2, isHorizontal2, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new Rect$3({
      shape: extend2({}, layout2),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal2 ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar: function(seriesModel, data, newIndex, layout2, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    var ShapeClass = !isRadial && roundCap ? Sausage : Sector$1;
    var sector2 = new ShapeClass({
      shape: layout2,
      z2: 1
    });
    sector2.name = "item";
    var positionMap = createPolarPositionMapping(isRadial);
    sector2.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === Sausage
    });
    if (animationModel) {
      var sectorShape = sector2.shape;
      var animateProperty = isRadial ? "r" : "endAngle";
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout2.startAngle;
      animateTarget[animateProperty] = layout2[animateProperty];
      (isUpdate ? updateProps$1 : initProps)(sector2, {
        shape: animateTarget
      }, animationModel);
    }
    return sector2;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get("realtimeSort", true);
  var baseAxis = coordSys.getBaseAxis();
  {
    if (realtimeSortOption) {
      if (baseAxis.type !== "category") {
        warn("`realtimeSort` will not work because this bar series is not based on a category axis.");
      }
      if (coordSys.type !== "cartesian2d") {
        warn("`realtimeSort` will not work because this bar series is not on cartesian2d.");
      }
    }
  }
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout2, newIndex, isHorizontal2, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;
  if (isHorizontal2) {
    axisTarget = {
      x: layout2.x,
      width: layout2.width
    };
    seriesTarget = {
      y: layout2.y,
      height: layout2.height
    };
  } else {
    axisTarget = {
      y: layout2.y,
      height: layout2.height
    };
    seriesTarget = {
      x: layout2.x,
      width: layout2.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps$1 : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps$1 : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
  for (var i = 0; i < props.length; i++) {
    if (!isFinite(obj[props[i]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d: function(layout2) {
    return !checkPropertiesNotValid(layout2, rectPropties);
  },
  polar: function(layout2) {
    return !checkPropertiesNotValid(layout2, polarPropties);
  }
};
var getLayout = {
  cartesian2d: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
    var signX = layout2.width > 0 ? 1 : -1;
    var signY = layout2.height > 0 ? 1 : -1;
    return {
      x: layout2.x + signX * fixedLineWidth / 2,
      y: layout2.y + signY * fixedLineWidth / 2,
      width: layout2.width - signX * fixedLineWidth,
      height: layout2.height - signY * fixedLineWidth
    };
  },
  polar: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    return {
      cx: layout2.cx,
      cy: layout2.cy,
      r0: layout2.r0,
      r: layout2.r,
      startAngle: layout2.startAngle,
      endAngle: layout2.endAngle,
      clockwise: layout2.clockwise
    };
  }
};
function isZeroOnPolar(layout2) {
  return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return function(isRadial2) {
    var arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return function(position2) {
      switch (position2) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position2 + arcOrAngle;
        default:
          return position2;
      }
    };
  }(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, isPolar) {
  var style = data.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    el.setShape("r", itemModel.get(["itemStyle", "borderRadius"]) || 0);
  }
  el.useStyle(style);
  var cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el.attr("cursor", cursorStyle);
  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout2.r >= layout2.r0 ? "endArc" : "startArc" : layout2.endAngle >= layout2.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout2.height >= 0 ? "bottom" : "top" : layout2.width >= 0 ? "right" : "left";
  var labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  var label = el.getTextContent();
  if (isPolar && label) {
    var position2 = itemModel.get(["label", "position"]);
    el.textConfig.inside = position2 === "middle" ? true : null;
    setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
    return getDefaultInterpolatedLabel(data, value);
  });
  var emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el, itemModel);
  if (isZeroOnPolar(layout2)) {
    el.style.fill = "none";
    el.style.stroke = "none";
    each$f(el.states, function(state) {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  var borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}
var LagePathShape = function() {
  function LagePathShape2() {
  }
  return LagePathShape2;
}();
var LargePath = function(_super) {
  __extends$1(LargePath2, _super);
  function LargePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeBar";
    return _this;
  }
  LargePath2.prototype.getDefaultShape = function() {
    return new LagePathShape();
  };
  LargePath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var baseDimIdx = this.baseDimIdx;
    var valueDimIdx = 1 - this.baseDimIdx;
    var startPoint = [];
    var size11 = [];
    var barWidth = this.barWidth;
    for (var i = 0; i < points2.length; i += 3) {
      size11[baseDimIdx] = barWidth;
      size11[valueDimIdx] = points2[i + 2];
      startPoint[baseDimIdx] = points2[i + baseDimIdx];
      startPoint[valueDimIdx] = points2[i + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size11[0], size11[1]);
    }
  };
  return LargePath2;
}(Path$1);
function createLarge$1(seriesModel, group, progressiveEls, incremental) {
  var data = seriesModel.getData();
  var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
  var largeDataIndices = data.getLayout("largeDataIndices");
  var barWidth = data.getLayout("size");
  var backgroundModel = seriesModel.getModel("backgroundStyle");
  var bgPoints = data.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    var bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  var el = new LargePath({
    shape: {
      points: data.getLayout("largePoints")
    },
    incremental: !!incremental,
    ignoreCoarsePointer: true,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual("style"));
  getECData(el).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el.on("mousedown", largePathUpdateDataIndex);
    el.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x2, y2) {
  var baseDimIdx = largePath.baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points2 = largePath.shape.points;
  var largeDataIndices = largePath.largeDataIndices;
  var startPoint = [];
  var size11 = [];
  var barWidth = largePath.barWidth;
  for (var i = 0, len2 = points2.length / 3; i < len2; i++) {
    var ii = i * 3;
    size11[baseDimIdx] = barWidth;
    size11[valueDimIdx] = points2[ii + 2];
    startPoint[baseDimIdx] = points2[ii + baseDimIdx];
    startPoint[valueDimIdx] = points2[ii + valueDimIdx];
    if (size11[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size11[valueDimIdx];
      size11[valueDimIdx] = -size11[valueDimIdx];
    }
    if (x2 >= startPoint[0] && x2 <= startPoint[0] + size11[0] && y2 >= startPoint[1] && y2 <= startPoint[1] + size11[1]) {
      return largeDataIndices[i];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var rectShape = layout2;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout2;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
  var ElementClz = coord.type === "polar" ? Sector$1 : Rect$3;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
    silent: true,
    z2: 0
  });
}
var BarView$1 = BarView;
function install$P(registers) {
  registers.registerChartView(BarView$1);
  registers.registerSeriesModel(BarSeries);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}
var PI2 = Math.PI * 2;
var RADIAN$2 = Math.PI / 180;
function getViewRect$5(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getBasicPieLayout(seriesModel, api) {
  var viewRect2 = getViewRect$5(seriesModel, api);
  var center2 = seriesModel.get("center");
  var radius = seriesModel.get("radius");
  if (!isArray$1(radius)) {
    radius = [0, radius];
  }
  if (!isArray$1(center2)) {
    center2 = [center2, center2];
  }
  var width = parsePercent(viewRect2.width, api.getWidth());
  var height = parsePercent(viewRect2.height, api.getHeight());
  var size11 = Math.min(width, height);
  var r0 = parsePercent(radius[0], size11 / 2);
  var r = parsePercent(radius[1], size11 / 2);
  var cx;
  var cy;
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys) {
    var point4 = coordSys.dataToPoint(center2);
    cx = point4[0] || 0;
    cy = point4[1] || 0;
  } else {
    cx = parsePercent(center2[0], width) + viewRect2.x;
    cy = parsePercent(center2[1], height) + viewRect2.y;
  }
  return {
    cx,
    cy,
    r0,
    r
  };
}
function pieLayout(seriesType2, ecModel, api) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var viewRect2 = getViewRect$5(seriesModel, api);
    var _a2 = getBasicPieLayout(seriesModel, api), cx = _a2.cx, cy = _a2.cy, r = _a2.r, r0 = _a2.r0;
    var startAngle = -seriesModel.get("startAngle") * RADIAN$2;
    var minAngle = seriesModel.get("minAngle") * RADIAN$2;
    var validDataCount = 0;
    data.each(valueDim, function(value) {
      !isNaN(value) && validDataCount++;
    });
    var sum2 = data.getSum(valueDim);
    var unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    var clockwise = seriesModel.get("clockwise");
    var roseType = seriesModel.get("roseType");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var extent3 = data.getDataExtent(valueDim);
    extent3[0] = 0;
    var restAngle = PI2;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    var dir3 = clockwise ? 1 : -1;
    data.setLayout({
      viewRect: viewRect2,
      r
    });
    data.each(valueDim, function(value, idx) {
      var angle4;
      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r
        });
        return;
      }
      if (roseType !== "area") {
        angle4 = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle4 = PI2 / validDataCount;
      }
      if (angle4 < minAngle) {
        angle4 = minAngle;
        restAngle -= minAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }
      var endAngle = currentAngle + dir3 * angle4;
      data.setItemLayout(idx, {
        angle: angle4,
        startAngle: currentAngle,
        endAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap$2(value, extent3, [r0, r]) : r
      });
      currentAngle = endAngle;
    });
    if (restAngle < PI2 && validDataCount) {
      if (restAngle <= 1e-3) {
        var angle_1 = PI2 / validDataCount;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_1 = data.getItemLayout(idx);
            layout_1.angle = angle_1;
            layout_1.startAngle = startAngle + dir3 * idx * angle_1;
            layout_1.endAngle = startAngle + dir3 * (idx + 1) * angle_1;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_2 = data.getItemLayout(idx);
            var angle4 = layout_2.angle === minAngle ? minAngle : value * unitRadian;
            layout_2.startAngle = currentAngle;
            layout_2.endAngle = currentAngle + dir3 * angle4;
            currentAngle += dir3 * angle4;
          }
        });
      }
    }
  });
}
function dataFilter$1(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var name2 = data.getName(idx);
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(name2)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}
var RADIAN$1 = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;
    for (var i2 = 0; i2 < semi.list.length; i2++) {
      var item = semi.list[i2];
      var dy = Math.abs(item.label.y - cy);
      var rA = r + item.len;
      var rA2 = rA * rA;
      var dx2 = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      var newX = cx + (dx2 + item.len2) * dir3;
      var deltaX = newX - item.label.x;
      var newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };
    for (var i2 = 0; i2 < items.length; i2++) {
      if (items[i2].labelAlignTo !== "none") {
        continue;
      }
      var item = items[i2];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        var dx2 = item.label.x - cx - item.len2 * dir3;
        var rA = r + item.len;
        var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  var len2 = list.length;
  for (var i = 0; i < len2; i++) {
    if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
      var dx = list[i].label.x - farthestX;
      list[i].linePoints[1][0] += dx;
      list[i].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;
  for (var i = 0; i < labelLayoutList.length; i++) {
    var label = labelLayoutList[i].label;
    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      if (layout2.labelStyleWidth != null) {
        continue;
      }
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var targetTextWidth = void 0;
      if (layout2.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout2.edgeDistance - linePoints[2][0] - layout2.labelDistance;
        }
      } else if (layout2.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout2.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout2.bleedMargin;
        }
      }
      layout2.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout2, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var isAlignToEdge = layout2.labelAlignTo === "edge";
      var padding = label.style.padding;
      var paddingH = padding ? padding[1] + padding[3] : 0;
      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      var realTextWidth = layout2.rect.width + extraPaddingH;
      var dist3 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout2.edgeDistance + realTextWidth + layout2.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout2.edgeDistance - realTextWidth - layout2.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout2.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout2.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist3;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout2, availableWidth, forceRecalculate) {
  if (forceRecalculate === void 0) {
    forceRecalculate = false;
  }
  if (layout2.labelStyleWidth != null) {
    return;
  }
  var label = layout2.label;
  var style = label.style;
  var textRect = layout2.rect;
  var bgColor = style.backgroundColor;
  var padding = style.padding;
  var paddingH = padding ? padding[1] + padding[3] : 0;
  var overflow = style.overflow;
  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    var oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      var innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      var availableInnerWidth = availableWidth - paddingH;
      var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout2.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    var newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    var margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  var data = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN$1;
  var viewRect2 = data.getLayout("viewRect");
  var r = data.getLayout("r");
  var viewWidth = viewRect2.width;
  var viewLeft = viewRect2.x;
  var viewTop = viewRect2.y;
  var viewHeight = viewRect2.height;
  function setNotShow(el) {
    el.ignore = true;
  }
  function isLabelShown(label2) {
    if (!label2.ignore) {
      return true;
    }
    for (var key in label2.states) {
      if (label2.states[key].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data.each(function(idx) {
    var sector2 = data.getItemGraphicEl(idx);
    var sectorShape = sector2.shape;
    var label2 = sector2.getTextContent();
    var labelLine2 = sector2.getTextGuideLine();
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    var labelDistance = labelModel.get("distanceToLabelLine");
    var labelAlignTo = labelModel.get("alignTo");
    var edgeDistance = parsePercent(labelModel.get("edgeDistance"), viewWidth);
    var bleedMargin = labelModel.get("bleedMargin");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each$f(label2.states, setNotShow);
      each$f(labelLine2.states, setNotShow);
      label2.ignore = labelLine2.ignore = true;
      return;
    }
    if (!isLabelShown(label2)) {
      return;
    }
    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints2;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      var x12 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y12 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x12 + nx * 3;
      textY = y12 + ny * 3;
      if (!isLabelInside) {
        var x2 = x12 + nx * (labelLineLen + r - sectorShape.r);
        var y2 = y12 + ny * (labelLineLen + r - sectorShape.r);
        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y2;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints2 = [[x12, y12], [x2, y2], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    var PI3 = Math.PI;
    var labelRotate = 0;
    var rotate2 = labelModel.get("rotate");
    if (isNumber(rotate2)) {
      labelRotate = rotate2 * (PI3 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      var radialAngle = nx < 0 ? -midAngle + PI3 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      var rad2 = Math.atan2(nx, ny);
      if (rad2 < 0) {
        rad2 = PI3 * 2 + rad2;
      }
      var isDown = ny > 0;
      if (isDown) {
        rad2 = PI3 + rad2;
      }
      labelRotate = rad2 - PI3;
    }
    hasLabelRotate = !!labelRotate;
    label2.x = textX;
    label2.y = textY;
    label2.rotation = labelRotate;
    label2.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      var textRect = label2.getBoundingRect().clone();
      textRect.applyTransform(label2.getComputedTransform());
      var margin = (label2.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label2,
        labelLine: labelLine2,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point$1(nx, ny),
        linePoints: linePoints2,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label2.style.width
      });
    } else {
      label2.setStyle({
        align: textAlign
      });
      var selectState2 = label2.states.select;
      if (selectState2) {
        selectState2.x += label2.x;
        selectState2.y += label2.y;
      }
    }
    sector2.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    var label = layout2.label;
    var labelLine = layout2.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout2.textAlign
      });
      if (notShowLabel) {
        each$f(label.states, setNotShow);
        label.ignore = true;
      }
      var selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      var linePoints = layout2.linePoints;
      if (notShowLabel || !linePoints) {
        each$f(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout2.minTurnAngle);
        limitSurfaceAngle(linePoints, layout2.surfaceNormal, layout2.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        });
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point$1(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}
function getSectorCornerRadius(model, shape, zeroIfNull) {
  var cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {
      cornerRadius: 0
    } : null;
  }
  if (!isArray$1(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map$1(cornerRadius, function(cr) {
      return parsePercent$1(cr, dr);
    })
  };
}
var PiePiece = function(_super) {
  __extends$1(PiePiece2, _super);
  function PiePiece2(data, idx, startAngle) {
    var _this = _super.call(this) || this;
    _this.z2 = 2;
    var text = new ZRText$1();
    _this.setTextContent(text);
    _this.updateData(data, idx, startAngle, true);
    return _this;
  }
  PiePiece2.prototype.updateData = function(data, idx, startAngle, firstCreate) {
    var sector2 = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = data.getItemLayout(idx);
    var sectorShape = extend2(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout2, true), layout2);
    if (isNaN(sectorShape.startAngle)) {
      sector2.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector2.setShape(sectorShape);
      var animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector2, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: idx,
          isFrom: true
        });
        sector2.originX = sectorShape.cx;
        sector2.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector2.shape.r = layout2.r0;
        initProps(sector2, {
          shape: {
            r: layout2.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector2.setShape({
            startAngle,
            endAngle: startAngle
          });
          initProps(sector2, {
            shape: {
              startAngle: layout2.startAngle,
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector2.shape.endAngle = layout2.startAngle;
          updateProps$1(sector2, {
            shape: {
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector2);
      updateProps$1(sector2, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector2.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector2, itemModel);
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var offset = seriesModel.get("selectedOffset");
    var dx = Math.cos(midAngle) * offset;
    var dy = Math.sin(midAngle) * offset;
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector2.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data, idx);
    sector2.ensureState("emphasis").shape = extend2({
      r: layout2.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout2));
    extend2(sector2.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout2)
    });
    extend2(sector2.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout2)
    });
    var labelLine = sector2.getTextGuideLine();
    var labelText = sector2.getTextContent();
    labelLine && extend2(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend2(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  PiePiece2.prototype._updateLabel = function(seriesModel, data, idx) {
    var sector2 = this;
    var itemModel = data.getItemModel(idx);
    var labelLineModel = itemModel.getModel("labelLine");
    var style = data.getItemVisual(idx, "style");
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    setLabelStyle(sector2, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
    });
    var labelText = sector2.getTextContent();
    sector2.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector2.removeTextGuideLine();
    } else {
      var polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline$3();
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  };
  return PiePiece2;
}(Sector$1);
var PieView = function(_super) {
  __extends$1(PieView2, _super);
  function PieView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  PieView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle;
    if (!oldData && data.count() > 0) {
      var shape = data.getItemLayout(0);
      for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
        shape = data.getItemLayout(s);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
      var sector2 = new Sector$1({
        shape: getBasicPieLayout(seriesModel, api)
      });
      sector2.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector2;
      group.add(sector2);
    }
    data.diff(oldData).add(function(idx) {
      var piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data;
    }
  };
  PieView2.prototype.dispose = function() {
  };
  PieView2.prototype.containPoint = function(point4, seriesModel) {
    var data = seriesModel.getData();
    var itemLayout = data.getItemLayout(0);
    if (itemLayout) {
      var dx = point4[0] - itemLayout.cx;
      var dy = point4[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  PieView2.type = "pie";
  return PieView2;
}(ChartView$1);
var PieView$1 = PieView;
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray$1(opt) && {
    coordDimensions: opt
  } || extend2({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  var source2 = seriesModel.getSource();
  var dimensions = prepareSeriesDataSchema(source2, opt).dimensions;
  var list = new SeriesData$1(dimensions, seriesModel);
  list.initData(source2, nameList);
  return list;
}
var LegendVisualProvider = function() {
  function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  LegendVisualProvider2.prototype.getAllNames = function() {
    var rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  };
  LegendVisualProvider2.prototype.containName = function(name2) {
    var rawData = this._getRawData();
    return rawData.indexOfName(name2) >= 0;
  };
  LegendVisualProvider2.prototype.indexOfName = function(name2) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name2);
  };
  LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  };
  return LegendVisualProvider2;
}();
var LegendVisualProvider$1 = LegendVisualProvider;
var PieSeriesModel = function(_super) {
  __extends$1(PieSeriesModel2, _super);
  function PieSeriesModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  PieSeriesModel2.prototype.mergeOption = function() {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  PieSeriesModel2.prototype.getInitialData = function() {
    var data = createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
    var valueList = [];
    data.each(data.mapDimension("value"), function(value) {
      valueList.push(value);
    });
    this.seats = getPercentSeats(valueList, data.hostModel.get("percentPrecision"));
    return data;
  };
  PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    params.percent = this.seats[dataIndex];
    params.$vars.push("percent");
    return params;
  };
  PieSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  PieSeriesModel2.type = "series.pie";
  PieSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    minAngle: 0,
    minShowLabelAngle: 0,
    selectedOffset: 10,
    percentPrecision: 2,
    stillShowZeroSum: true,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      rotate: 0,
      show: true,
      overflow: "truncate",
      position: "outer",
      alignTo: "none",
      edgeDistance: "25%",
      bleedMargin: 10,
      distanceToLabelLine: 5
    },
    labelLine: {
      show: true,
      length: 15,
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      borderWidth: 1,
      borderJoin: "round"
    },
    showEmptyCircle: true,
    emptyCircleStyle: {
      color: "lightgray",
      opacity: 1
    },
    labelLayout: {
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    avoidLabelOverlap: true,
    animationType: "expansion",
    animationDuration: 1e3,
    animationTypeUpdate: "transition",
    animationEasingUpdate: "cubicInOut",
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut"
  };
  return PieSeriesModel2;
}(SeriesModel$1);
var PieSeriesModel$1 = PieSeriesModel;
function negativeDataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var valueDim = data.mapDimension("value");
        var curValue = data.get(valueDim, idx);
        if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}
function install$O(registers) {
  registers.registerChartView(PieView$1);
  registers.registerSeriesModel(PieSeriesModel$1);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry$1(pieLayout, "pie"));
  registers.registerProcessor(dataFilter$1("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}
var ScatterSeriesModel = function(_super) {
  __extends$1(ScatterSeriesModel2, _super);
  function ScatterSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScatterSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  ScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  ScatterSeriesModel2.prototype.getProgressive = function() {
    var progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 5e3 : this.get("progressive");
    }
    return progressive;
  };
  ScatterSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 1e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  };
  ScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  };
  ScatterSeriesModel2.prototype.getZLevelKey = function() {
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
  };
  ScatterSeriesModel2.type = "series.scatter";
  ScatterSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
  ScatterSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    legendHoverLink: true,
    symbolSize: 10,
    large: false,
    largeThreshold: 2e3,
    itemStyle: {
      opacity: 0.8
    },
    emphasis: {
      scale: true
    },
    clip: true,
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    universalTransition: {
      divideShape: "clone"
    }
  };
  return ScatterSeriesModel2;
}(SeriesModel$1);
var ScatterSeriesModel$1 = ScatterSeriesModel;
var BOOST_SIZE_THRESHOLD = 4;
var LargeSymbolPathShape = function() {
  function LargeSymbolPathShape2() {
  }
  return LargeSymbolPathShape2;
}();
var LargeSymbolPath = function(_super) {
  __extends$1(LargeSymbolPath2, _super);
  function LargeSymbolPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this._off = 0;
    _this.hoverDataIdx = -1;
    return _this;
  }
  LargeSymbolPath2.prototype.getDefaultShape = function() {
    return new LargeSymbolPathShape();
  };
  LargeSymbolPath2.prototype.reset = function() {
    this.notClear = false;
    this._off = 0;
  };
  LargeSymbolPath2.prototype.buildPath = function(path, shape) {
    var points2 = shape.points;
    var size11 = shape.size;
    var symbolProxy = this.symbolProxy;
    var symbolProxyShape = symbolProxy.shape;
    var ctx = path.getContext ? path.getContext() : path;
    var canBoost = ctx && size11[0] < BOOST_SIZE_THRESHOLD;
    var softClipShape = this.softClipShape;
    var i;
    if (canBoost) {
      this._ctx = ctx;
      return;
    }
    this._ctx = null;
    for (i = this._off; i < points2.length; ) {
      var x2 = points2[i++];
      var y2 = points2[i++];
      if (isNaN(x2) || isNaN(y2)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x2, y2)) {
        continue;
      }
      symbolProxyShape.x = x2 - size11[0] / 2;
      symbolProxyShape.y = y2 - size11[1] / 2;
      symbolProxyShape.width = size11[0];
      symbolProxyShape.height = size11[1];
      symbolProxy.buildPath(path, symbolProxyShape, true);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  };
  LargeSymbolPath2.prototype.afterBrush = function() {
    var shape = this.shape;
    var points2 = shape.points;
    var size11 = shape.size;
    var ctx = this._ctx;
    var softClipShape = this.softClipShape;
    var i;
    if (!ctx) {
      return;
    }
    for (i = this._off; i < points2.length; ) {
      var x2 = points2[i++];
      var y2 = points2[i++];
      if (isNaN(x2) || isNaN(y2)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x2, y2)) {
        continue;
      }
      ctx.fillRect(x2 - size11[0] / 2, y2 - size11[1] / 2, size11[0], size11[1]);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  };
  LargeSymbolPath2.prototype.findDataIndex = function(x2, y2) {
    var shape = this.shape;
    var points2 = shape.points;
    var size11 = shape.size;
    var w = Math.max(size11[0], 4);
    var h = Math.max(size11[1], 4);
    for (var idx = points2.length / 2 - 1; idx >= 0; idx--) {
      var i = idx * 2;
      var x02 = points2[i] - w / 2;
      var y02 = points2[i + 1] - h / 2;
      if (x2 >= x02 && y2 >= y02 && x2 <= x02 + w && y2 <= y02 + h) {
        return idx;
      }
    }
    return -1;
  };
  LargeSymbolPath2.prototype.contain = function(x2, y2) {
    var localPos = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    x2 = localPos[0];
    y2 = localPos[1];
    if (rect.contain(x2, y2)) {
      var dataIdx = this.hoverDataIdx = this.findDataIndex(x2, y2);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  };
  LargeSymbolPath2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    if (!rect) {
      var shape = this.shape;
      var points2 = shape.points;
      var size11 = shape.size;
      var w = size11[0];
      var h = size11[1];
      var minX2 = Infinity;
      var minY2 = Infinity;
      var maxX2 = -Infinity;
      var maxY2 = -Infinity;
      for (var i = 0; i < points2.length; ) {
        var x2 = points2[i++];
        var y2 = points2[i++];
        minX2 = Math.min(x2, minX2);
        maxX2 = Math.max(x2, maxX2);
        minY2 = Math.min(y2, minY2);
        maxY2 = Math.max(y2, maxY2);
      }
      rect = this._rect = new BoundingRect$1(minX2 - w / 2, minY2 - h / 2, maxX2 - minX2 + w, maxY2 - minY2 + h);
    }
    return rect;
  };
  return LargeSymbolPath2;
}(Path$1);
var LargeSymbolDraw = function() {
  function LargeSymbolDraw2() {
    this.group = new Group$4();
  }
  LargeSymbolDraw2.prototype.updateData = function(data, opt) {
    this._clear();
    var symbolEl = this._create();
    symbolEl.setShape({
      points: data.getLayout("points")
    });
    this._setCommon(symbolEl, data, opt);
  };
  LargeSymbolDraw2.prototype.updateLayout = function(data) {
    var points2 = data.getLayout("points");
    this.group.eachChild(function(child) {
      if (child.startIndex != null) {
        var len2 = (child.endIndex - child.startIndex) * 2;
        var byteOffset = child.startIndex * 4 * 2;
        points2 = new Float32Array(points2.buffer, byteOffset, len2);
      }
      child.setShape("points", points2);
      child.reset();
    });
  };
  LargeSymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this._clear();
  };
  LargeSymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
    var lastAdded = this._newAdded[0];
    var points2 = data.getLayout("points");
    var oldPoints = lastAdded && lastAdded.shape.points;
    if (oldPoints && oldPoints.length < 2e4) {
      var oldLen = oldPoints.length;
      var newPoints = new Float32Array(oldLen + points2.length);
      newPoints.set(oldPoints);
      newPoints.set(points2, oldLen);
      lastAdded.endIndex = taskParams.end;
      lastAdded.setShape({
        points: newPoints
      });
    } else {
      this._newAdded = [];
      var symbolEl = this._create();
      symbolEl.startIndex = taskParams.start;
      symbolEl.endIndex = taskParams.end;
      symbolEl.incremental = true;
      symbolEl.setShape({
        points: points2
      });
      this._setCommon(symbolEl, data, opt);
    }
  };
  LargeSymbolDraw2.prototype.eachRendered = function(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  };
  LargeSymbolDraw2.prototype._create = function() {
    var symbolEl = new LargeSymbolPath({
      cursor: "default"
    });
    symbolEl.ignoreCoarsePointer = true;
    this.group.add(symbolEl);
    this._newAdded.push(symbolEl);
    return symbolEl;
  };
  LargeSymbolDraw2.prototype._setCommon = function(symbolEl, data, opt) {
    var hostModel = data.hostModel;
    opt = opt || {};
    var size11 = data.getVisual("symbolSize");
    symbolEl.setShape("size", size11 instanceof Array ? size11 : [size11, size11]);
    symbolEl.softClipShape = opt.clipShape || null;
    symbolEl.symbolProxy = createSymbol$1(data.getVisual("symbol"), 0, 0, 0, 0);
    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
    symbolEl.useStyle(
      hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"])
    );
    var globalStyle = data.getVisual("style");
    var visualColor = globalStyle && globalStyle.fill;
    if (visualColor) {
      symbolEl.setColor(visualColor);
    }
    var ecData = getECData(symbolEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    symbolEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      var dataIndex = symbolEl.hoverDataIdx;
      if (dataIndex >= 0) {
        ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
      }
    });
  };
  LargeSymbolDraw2.prototype.remove = function() {
    this._clear();
  };
  LargeSymbolDraw2.prototype._clear = function() {
    this._newAdded = [];
    this.group.removeAll();
  };
  return LargeSymbolDraw2;
}();
var LargeSymbolDraw$1 = LargeSymbolDraw;
var ScatterView = function(_super) {
  __extends$1(ScatterView2, _super);
  function ScatterView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScatterView2.type;
    return _this;
  }
  ScatterView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.updateData(data, {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = true;
  };
  ScatterView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.incrementalPrepareUpdate(data);
    this._finished = false;
  };
  ScatterView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
    this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = taskParams.end === seriesModel.getData().count();
  };
  ScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    this.group.dirty();
    if (!this._finished || data.count() > 1e4) {
      return {
        update: true
      };
    } else {
      var res = pointsLayout("").reset(seriesModel, ecModel, api);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._symbolDraw.updateLayout(data);
    }
  };
  ScatterView2.prototype.eachRendered = function(cb) {
    this._symbolDraw && this._symbolDraw.eachRendered(cb);
  };
  ScatterView2.prototype._getClipShape = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get("clip", true) ? clipArea : null;
  };
  ScatterView2.prototype._updateSymbolDraw = function(data, seriesModel) {
    var symbolDraw = this._symbolDraw;
    var pipelineContext = seriesModel.pipelineContext;
    var isLargeDraw = pipelineContext.large;
    if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
      symbolDraw && symbolDraw.remove();
      symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw$1() : new SymbolDraw$1();
      this._isLargeDraw = isLargeDraw;
      this.group.removeAll();
    }
    this.group.add(symbolDraw.group);
    return symbolDraw;
  };
  ScatterView2.prototype.remove = function(ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove(true);
    this._symbolDraw = null;
  };
  ScatterView2.prototype.dispose = function() {
  };
  ScatterView2.type = "scatter";
  return ScatterView2;
}(ChartView$1);
var ScatterView$1 = ScatterView;
var GridModel = function(_super) {
  __extends$1(GridModel2, _super);
  function GridModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridModel2.type = "grid";
  GridModel2.dependencies = ["xAxis", "yAxis"];
  GridModel2.layoutMode = "box";
  GridModel2.defaultOption = {
    show: false,
    z: 0,
    left: "10%",
    top: 60,
    right: "10%",
    bottom: 70,
    containLabel: false,
    backgroundColor: "rgba(0,0,0,0)",
    borderWidth: 1,
    borderColor: "#ccc"
  };
  return GridModel2;
}(ComponentModel$1);
var GridModel$1 = GridModel;
var CartesianAxisModel = function(_super) {
  __extends$1(CartesianAxisModel2, _super);
  function CartesianAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  };
  CartesianAxisModel2.type = "cartesian2dAxis";
  return CartesianAxisModel2;
}(ComponentModel$1);
mixin(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption$1 = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
};
var categoryAxis = merge3({
  boundaryGap: true,
  deduplication: null,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption$1);
var valueAxis = merge3({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption$1);
var timeAxis = merge3({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
var axisDefault = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each$f(AXIS_TYPES, function(v, axisType) {
    var defaultOption2 = merge3(merge3({}, axisDefault[axisType], true), extraDefaultOption, true);
    var AxisModel = function(_super) {
      __extends$1(AxisModel2, _super);
      function AxisModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = axisName + "Axis." + axisType;
        return _this;
      }
      AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge3(option, themeModel.get(axisType + "Axis"));
        merge3(option, this.getDefaultOption());
        option.type = getAxisType(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      AxisModel2.prototype.optionUpdated = function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this);
        }
      };
      AxisModel2.prototype.getCategories = function(rawData) {
        var option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      };
      AxisModel2.prototype.getOrdinalMeta = function() {
        return this.__ordinalMeta;
      };
      AxisModel2.type = axisName + "Axis." + axisType;
      AxisModel2.defaultOption = defaultOption2;
      return AxisModel2;
    }(BaseAxisModelClass);
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
  return option.type || (option.data ? "category" : "value");
}
var Cartesian = function() {
  function Cartesian2(name2) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name2 || "";
  }
  Cartesian2.prototype.getAxis = function(dim) {
    return this._axes[dim];
  };
  Cartesian2.prototype.getAxes = function() {
    return map$1(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  };
  Cartesian2.prototype.getAxesByScale = function(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter17(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  };
  Cartesian2.prototype.addAxis = function(axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  };
  return Cartesian2;
}();
var Cartesian$1 = Cartesian;
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale4) {
  return scale4.type === "interval" || scale4.type === "time";
}
var Cartesian2D = function(_super) {
  __extends$1(Cartesian2D2, _super);
  function Cartesian2D2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cartesian2d";
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  Cartesian2D2.prototype.calcAffineTransform = function() {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis("x").scale;
    var yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    var scaleX = (end2[0] - start2[0]) / xScaleSpan;
    var scaleY = (end2[1] - start2[1]) / yScaleSpan;
    var translateX = start2[0] - xScaleExtent[0] * scaleX;
    var translateY = start2[1] - yScaleExtent[0] * scaleY;
    var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m2);
  };
  Cartesian2D2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  };
  Cartesian2D2.prototype.containPoint = function(point4) {
    var axisX = this.getAxis("x");
    var axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point4[0])) && axisY.contain(axisY.toLocalCoord(point4[1]));
  };
  Cartesian2D2.prototype.containData = function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  };
  Cartesian2D2.prototype.containZone = function(data1, data2) {
    var zoneDiag1 = this.dataToPoint(data1);
    var zoneDiag2 = this.dataToPoint(data2);
    var area5 = this.getArea();
    var zone = new BoundingRect$1(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area5.intersect(zone);
  };
  Cartesian2D2.prototype.dataToPoint = function(data, clamp3, out2) {
    out2 = out2 || [];
    var xVal = data[0];
    var yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform$1(out2, data, this._transform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp3));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp3));
    return out2;
  };
  Cartesian2D2.prototype.clampData = function(data, out2) {
    var xScale = this.getAxis("x").scale;
    var yScale = this.getAxis("y").scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x2 = xScale.parse(data[0]);
    var y2 = yScale.parse(data[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x2), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y2), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  };
  Cartesian2D2.prototype.pointToData = function(point4, clamp3) {
    var out2 = [];
    if (this._invTransform) {
      return applyTransform$1(out2, point4, this._invTransform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point4[0]), clamp3);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point4[1]), clamp3);
    return out2;
  };
  Cartesian2D2.prototype.getOtherAxis = function(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  };
  Cartesian2D2.prototype.getArea = function() {
    var xExtent = this.getAxis("x").getGlobalExtent();
    var yExtent = this.getAxis("y").getGlobalExtent();
    var x2 = Math.min(xExtent[0], xExtent[1]);
    var y2 = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x2;
    var height = Math.max(yExtent[0], yExtent[1]) - y2;
    return new BoundingRect$1(x2, y2, width, height);
  };
  return Cartesian2D2;
}(Cartesian$1);
var Axis2D = function(_super) {
  __extends$1(Axis2D2, _super);
  function Axis2D2(dim, scale4, coordExtent, axisType, position2) {
    var _this = _super.call(this, dim, scale4, coordExtent) || this;
    _this.index = 0;
    _this.type = axisType || "value";
    _this.position = position2 || "bottom";
    return _this;
  }
  Axis2D2.prototype.isHorizontal = function() {
    var position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  };
  Axis2D2.prototype.getGlobalExtent = function(asc2) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc2 && ret[0] > ret[1] && ret.reverse();
    return ret;
  };
  Axis2D2.prototype.pointToData = function(point4, clamp3) {
    return this.coordToData(this.toLocalCoord(point4[this.dim === "x" ? 0 : 1]), clamp3);
  };
  Axis2D2.prototype.setCategorySortInfo = function(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };
  return Axis2D2;
}(Axis$1);
var Axis2D$1 = Axis2D;
function layout$2(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout2 = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get("offset") || 0;
  var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
  layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
  layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout2.tickDirection = -layout2.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout2.labelDirection = -layout2.labelDirection;
  }
  var labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout2.z2 = 1;
  return layout2;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each$f(axisModelMap, function(v, key) {
    var axisType = key.replace(/Model$/, "");
    var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    {
      if (!axisModel) {
        throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
      }
    }
    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}
var mathLog = Math.log;
function alignScaleTicks(scale4, axisModel, alignToScale) {
  var intervalScaleProto2 = IntervalScale$1.prototype;
  var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale4, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;
  if (scale4.type === "log") {
    var logBase = mathLog(scale4.base);
    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
  }
  scale4.setExtent(rawExtent[0], rawExtent[1]);
  scale4.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent3 = intervalScaleProto2.getExtent.call(scale4);
  if (isMinFixed) {
    rawExtent[0] = extent3[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent3[1];
  }
  var interval = intervalScaleProto2.getInterval.call(scale4);
  var min5 = rawExtent[0];
  var max4 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max4 - min5) / alignToSplitNumber;
  } else if (isMinFixed) {
    max4 = rawExtent[0] + interval * alignToSplitNumber;
    while (max4 < rawExtent[1] && isFinite(max4) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max4 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min5 = rawExtent[1] - interval * alignToSplitNumber;
    while (min5 > rawExtent[0] && isFinite(min5) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min5 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale4.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    var range = interval * alignToSplitNumber;
    max4 = Math.ceil(rawExtent[1] / interval) * interval;
    min5 = round$3(max4 - range);
    if (min5 < 0 && rawExtent[0] >= 0) {
      min5 = 0;
      max4 = round$3(range);
    } else if (max4 > 0 && rawExtent[1] <= 0) {
      max4 = 0;
      min5 = -round$3(range);
    }
  }
  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto2.setExtent.call(scale4, min5 + interval * t0, max4 + interval * t1);
  intervalScaleProto2.setInterval.call(scale4, interval);
  if (t0 || t1) {
    intervalScaleProto2.setNiceExtent.call(scale4, min5 + interval, max4 - interval);
  }
  {
    var ticks = intervalScaleProto2.getTicks.call(scale4);
    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
      warn(
        "The ticks may be not readable when set min: " + axisModel.get("min") + ", max: " + axisModel.get("max") + " and alignTicks: true"
      );
    }
  }
}
var Grid = function() {
  function Grid2(gridModel, ecModel, api) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  Grid2.prototype.getRect = function() {
    return this._rect;
  };
  Grid2.prototype.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      var alignTo;
      var axesIndices = keys2(axes);
      var len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      var axisNeedsAlign = [];
      for (var i = len2 - 1; i >= 0; i--) {
        var idx = +axesIndices[i];
        var axis = axes[idx];
        var model = axis.model;
        var scale4 = axis.scale;
        if (isIntervalOrLogScale(scale4) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale4, model);
          if (isIntervalOrLogScale(scale4)) {
            alignTo = axis;
          }
        }
      }
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each$f(axisNeedsAlign, function(axis2) {
          alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    var onZeroRecords = {};
    each$f(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each$f(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    var gridRect = getLayoutRect(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each$f(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          var labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? "height" : "width";
            var margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each$f(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each$f(axesList, function(axis) {
        var isHorizontal2 = axis.isHorizontal();
        var extent3 = isHorizontal2 ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent3[idx], extent3[1 - idx]);
        updateAxisTransform(axis, isHorizontal2 ? gridRect.x : gridRect.y);
      });
    }
  };
  Grid2.prototype.getAxis = function(dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };
  Grid2.prototype.getAxes = function() {
    return this._axesList.slice();
  };
  Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject$3(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  };
  Grid2.prototype.getCartesians = function() {
    return this._coordsList.slice();
  };
  Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  Grid2.prototype._findConvertTarget = function(finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian2;
    var axis;
    if (seriesModel) {
      cartesian2 = seriesModel.coordinateSystem;
      indexOf2(coordsList, cartesian2) < 0 && (cartesian2 = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian2 = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian2 = this._coordsList[0];
      }
    }
    return {
      cartesian: cartesian2,
      axis
    };
  };
  Grid2.prototype.containPoint = function(point4) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point4);
    }
  };
  Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
    var _this = this;
    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each$f(axesMap.x, function(xAxis, xAxisIndex) {
      each$f(axesMap.y, function(yAxis, yAxisIndex) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian2 = new Cartesian2D(key);
        cartesian2.master = _this;
        cartesian2.model = gridModel;
        _this._coordsMap[key] = cartesian2;
        _this._coordsList.push(cartesian2);
        cartesian2.addAxis(xAxis);
        cartesian2.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D$1(dimName, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  Grid2.prototype._updateScale = function(ecModel, gridModel) {
    each$f(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        var categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian2 = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian2.getAxis("x");
        var yAxis = cartesian2.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each$f(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  Grid2.prototype.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each$f(this.getCartesians(), function(cartesian2) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian2.getAxis(dim) : cartesian2.getBaseAxis();
      var otherAxis = cartesian2.getOtherAxis(baseAxis);
      indexOf2(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf2(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  Grid2.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid = new Grid2(gridModel, ecModel, api);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();
      {
        if (!gridModel) {
          throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
        }
        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
          throw new Error("xAxis and yAxis must use the same grid");
        }
      }
      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid2.dimensions = cartesian2DDimensions;
  return Grid2;
}();
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(["axisLine", "onZero"]);
  var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid$1 = Grid;
var PI$3 = Math.PI;
var AxisBuilder = function() {
  function AxisBuilder2(axisModel, opt) {
    this.group = new Group$4();
    this.opt = opt;
    this.axisModel = axisModel;
    defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function() {
        return true;
      }
    });
    var transformGroup = new Group$4({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }
  AxisBuilder2.prototype.hasBuilder = function(name2) {
    return !!builders[name2];
  };
  AxisBuilder2.prototype.add = function(name2) {
    builders[name2](this.opt, this.axisModel, this.group, this._transformGroup);
  };
  AxisBuilder2.prototype.getGroup = function() {
    return this.group;
  };
  AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI$3)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI$3) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  };
  AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  };
  AxisBuilder2.isLabelSilent = function(axisModel) {
    var tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  };
  return AxisBuilder2;
}();
var builders = {
  axisLine: function(opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisLine");
    }
    if (!shown) {
      return;
    }
    var extent3 = axisModel.axis.getExtent();
    var matrix = transformGroup.transform;
    var pt12 = [extent3[0], 0];
    var pt22 = [extent3[1], 0];
    var inverse = pt12[0] > pt22[0];
    if (matrix) {
      applyTransform$1(pt12, pt12, matrix);
      applyTransform$1(pt22, pt22, matrix);
    }
    var lineStyle = extend2({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    var line = new Line$3({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    subPixelOptimizeLine(line.shape, line.style.lineWidth);
    line.anid = "line";
    group.add(line);
    var arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString(arrowSize) || isNumber(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      each$f([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point4, index2) {
        if (arrows[index2] !== "none" && arrows[index2] != null) {
          var symbol = createSymbol$1(arrows[index2], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
          var r = point4.r + point4.offset;
          var pt = inverse ? pt22 : pt12;
          symbol.attr({
            rotation: point4.rotate,
            x: pt[0] + r * Math.cos(opt.rotation),
            y: pt[1] - r * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function(opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
    if (axisModel.get(["axisLabel", "hideOverlap"])) {
      var labelList = prepareLayoutList(map$1(labelEls, function(label) {
        return {
          label,
          priority: label.z2,
          defaultAttr: {
            ignore: label.ignore
          }
        };
      }));
      hideOverlap(labelList);
    }
  },
  axisName: function(opt, axisModel, group, transformGroup) {
    var name2 = retrieve(opt.axisName, axisModel.get("name"));
    if (!name2) {
      return;
    }
    var nameLocation = axisModel.get("nameLocation");
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel("nameTextStyle");
    var gap = axisModel.get("nameGap") || 0;
    var extent3 = axisModel.axis.getExtent();
    var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
    var pos = [
      nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
    ];
    var labelLayout2;
    var nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI$3 / 180;
    }
    var axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout2 = AxisBuilder.innerTextLayout(
        opt.rotation,
        nameRotation != null ? nameRotation : opt.rotation,
        nameDirection
      );
    } else {
      labelLayout2 = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout2.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get("nameTruncate", true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var textEl = new ZRText$1({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout2.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle(textStyleModel, {
        text: name2,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout2.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout2.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name2
    });
    textEl.__fullText = name2;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name2;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};
function endTextLayout(rotation, textPosition, textRotate, extent3) {
  var rotationDiff = remRadian(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent3[0] > extent3[1];
  var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI$3 / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI$3 * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI$3 * 1.5 && rotationDiff > PI$3 / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];
  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }
  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}
function ignoreEl(el) {
  el && (el.ignore = true);
}
function isTwoLabelOverlapped(current, next3) {
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next3 && next3.getBoundingRect().clone();
  if (!firstRect || !nextRect) {
    return;
  }
  var mRotationBack = identity([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul([], mRotationBack, next3.getLocalTransform()));
  return firstRect.intersect(nextRect);
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt12 = [];
  var pt22 = [];
  for (var i = 0; i < ticksCoords.length; i++) {
    var tickCoord = ticksCoords[i].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform$1(pt12, pt12, tickTransform);
      applyTransform$1(pt22, pt22, tickTransform);
    }
    var tickEl = new Line$3({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);
    tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
  }
  return tickEls;
}
function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel("axisTick");
  var shown = tickModel.get("show");
  if (shown === "auto" && opt.handleAutoShown) {
    shown = opt.handleAutoShown("axisTick");
  }
  if (!shown || axis.scale.isBlank()) {
    return;
  }
  var lineStyleModel = tickModel.getModel("lineStyle");
  var tickEndCoord = opt.tickDirection * tickModel.get("length");
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (var i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel("minorTick");
  if (!minorTickModel.get("show") || axis.scale.isBlank()) {
    return;
  }
  var minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  var lineStyleModel = minorTickModel.getModel("lineStyle");
  var tickEndCoord = tickDirection * minorTickModel.get("length");
  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (var i = 0; i < minorTicksCoords.length; i++) {
    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
    for (var k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}
function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  if (!show || axis.scale.isBlank()) {
    return;
  }
  var labelModel = axisModel.getModel("axisLabel");
  var labelMargin = labelModel.get("margin");
  var labels = axis.getViewLabels();
  var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI$3 / 180;
  var labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent = axisModel.get("triggerEvent");
  each$f(labels, function(labelItem, index2) {
    var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];
      if (isObject$3(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model$1(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    var tickCoord = axis.dataToCoord(tickValue);
    var textEl = new ZRText$1({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout2.rotation,
      silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle(itemLabelModel, {
        text: formattedLabel,
        align: itemLabelModel.getShallow("align", true) || labelLayout2.textAlign,
        verticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout2.textVerticalAlign,
        fill: isFunction(textColor) ? textColor(
          axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
          index2
        ) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    if (triggerEvent) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      eventData.tickIndex = index2;
      if (axis.type === "category") {
        eventData.dataIndex = tickValue;
      }
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}
var AxisBuilder$1 = AxisBuilder;
function collect(ecModel, api) {
  var result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent("tooltip");
  var globalAxisPointerModel = ecModel.getComponent("axisPointer");
  var linksOption = globalAxisPointerModel.get("link", true) || [];
  var linkGroups = [];
  each$f(api.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each$f(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      var triggerAxis = baseTooltipModel.get("trigger") === "axis";
      var cross2 = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross2) {
        each$f(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross2 ? "cross" : true, triggerAxis));
      }
      if (cross2) {
        each$f(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap4 = axisPointerModel.get("snap");
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap4 || axis.type === "category";
      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        involveSeries,
        snap: snap4,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
  var volatileOption = {};
  each$f(fields, function(field) {
    volatileOption[field] = clone$4(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  var labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model$1(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each$f(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      var axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;
  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray$1(linkPropValue) && indexOf2(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  var axisInfo = getAxisInfo$1(axisModel);
  if (!axisInfo) {
    return;
  }
  var axisPointerModel = axisInfo.axisPointerModel;
  var scale4 = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get("status");
  var value = axisPointerModel.get("value");
  if (value != null) {
    value = scale4.parse(value);
  }
  var useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  var extent3 = scale4.getExtent().slice();
  extent3[0] > extent3[1] && extent3.reverse();
  if (value == null || value > extent3[1]) {
    value = extent3[1];
  }
  if (value < extent3[0]) {
    value = extent3[0];
  }
  option.value = value;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo$1(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo$1(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}
var axisPointerClazz = {};
var AxisView = function(_super) {
  __extends$1(AxisView2, _super);
  function AxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisView2.type;
    return _this;
  }
  AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.axisPointerClass && fixValue(axisModel);
    _super.prototype.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  AxisView2.prototype.remove = function(ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  AxisView2.prototype.dispose = function(ecModel, api) {
    this._disposeAxisPointer(api);
    _super.prototype.dispose.apply(this, arguments);
  };
  AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
    var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };
  AxisView2.prototype._disposeAxisPointer = function(api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };
  AxisView2.registerAxisPointerClass = function(type, clazz) {
    {
      if (axisPointerClazz[type]) {
        throw new Error("axisPointer " + type + " exists");
      }
    }
    axisPointerClazz[type] = clazz;
  };
  AxisView2.getAxisPointerClass = function(type) {
    return type && axisPointerClazz[type];
  };
  AxisView2.type = "axis";
  return AxisView2;
}(ComponentView$1);
var AxisView$1 = AxisView;
var inner$f = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  var splitAreaModel = axisModel.getModel("splitArea");
  var areaStyleModel = splitAreaModel.getModel("areaStyle");
  var areaColors = areaStyleModel.get("color");
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });
  if (!ticksCoords.length) {
    return;
  }
  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner$f(axisView).splitAreaColors;
  var newSplitAreaColors = createHashMap();
  var colorIndex = 0;
  if (lastSplitAreaColors) {
    for (var i = 0; i < ticksCoords.length; i++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }
  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray$1(areaColors) ? areaColors : [areaColors];
  for (var i = 1; i < ticksCoords.length; i++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    var x2 = void 0;
    var y2 = void 0;
    var width = void 0;
    var height = void 0;
    if (axis.isHorizontal()) {
      x2 = prev;
      y2 = gridRect.y;
      width = tickCoord - x2;
      height = gridRect.height;
      prev = x2 + width;
    } else {
      x2 = gridRect.x;
      y2 = prev;
      width = gridRect.width;
      height = tickCoord - y2;
      prev = y2 + height;
    }
    var tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect$3({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x: x2,
        y: y2,
        width,
        height
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner$f(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner$f(axisView).splitAreaColors = null;
}
var axisBuilderAttrs$3 = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs$2 = ["splitArea", "splitLine", "minorSplitLine"];
var CartesianAxisView = function(_super) {
  __extends$1(CartesianAxisView2, _super);
  function CartesianAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianAxisView2.type;
    _this.axisPointerClass = "CartesianAxisPointer";
    return _this;
  }
  CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$4();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var gridModel = axisModel.getCoordSysModel();
    var layout2 = layout$2(gridModel, axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, extend2({
      handleAutoShown: function(elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();
        for (var i = 0; i < cartesians.length; i++) {
          if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
            return true;
          }
        }
        return false;
      }
    }, layout2));
    each$f(axisBuilderAttrs$3, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    each$f(selfBuilderAttrs$2, function(name2) {
      if (axisModel.get([name2, "show"])) {
        axisElementBuilders$2[name2](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  CartesianAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  CartesianAxisView2.type = "cartesianAxis";
  return CartesianAxisView2;
}(AxisView$1);
var axisElementBuilders$2 = {
  splitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    lineColors = isArray$1(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal2 = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal2) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i].tickValue;
      var line = new Line$3({
        anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      });
      subPixelOptimizeLine(line.shape, lineStyle.lineWidth);
      axisGroup.add(line);
    }
  },
  minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal2 = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
        if (isHorizontal2) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var line = new Line$3({
          anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        });
        subPixelOptimizeLine(line.shape, lineStyle.lineWidth);
        axisGroup.add(line);
      }
    }
  },
  splitArea: function(axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};
var CartesianXAxisView = function(_super) {
  __extends$1(CartesianXAxisView2, _super);
  function CartesianXAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView2.type;
    return _this;
  }
  CartesianXAxisView2.type = "xAxis";
  return CartesianXAxisView2;
}(CartesianAxisView);
var CartesianYAxisView = function(_super) {
  __extends$1(CartesianYAxisView2, _super);
  function CartesianYAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView.type;
    return _this;
  }
  CartesianYAxisView2.type = "yAxis";
  return CartesianYAxisView2;
}(CartesianAxisView);
var GridView = function(_super) {
  __extends$1(GridView2, _super);
  function GridView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid";
    return _this;
  }
  GridView2.prototype.render = function(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect$3({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };
  GridView2.type = "grid";
  return GridView2;
}(ComponentView$1);
var extraOption = {
  offset: 0
};
function install$N(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel$1);
  registers.registerCoordinateSystem("cartesian2d", Grid$1);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}
function install$M(registers) {
  use2(install$N);
  registers.registerSeriesModel(ScatterSeriesModel$1);
  registers.registerChartView(ScatterView$1);
  registers.registerLayout(pointsLayout("scatter"));
}
function radarLayout(ecModel) {
  ecModel.eachSeriesByType("radar", function(seriesModel) {
    var data = seriesModel.getData();
    var points2 = [];
    var coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    var axes = coordSys.getIndicatorAxes();
    each$f(axes, function(axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
        points2[dataIndex] = points2[dataIndex] || [];
        var point4 = coordSys.dataToPoint(val, axisIndex);
        points2[dataIndex][axisIndex] = isValidPoint(point4) ? point4 : getValueMissingPoint(coordSys);
      });
    });
    data.each(function(idx) {
      var firstPoint = find3(points2[idx], function(point4) {
        return isValidPoint(point4);
      }) || getValueMissingPoint(coordSys);
      points2[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points2[idx]);
    });
  });
}
function isValidPoint(point4) {
  return !isNaN(point4[0]) && !isNaN(point4[1]);
}
function getValueMissingPoint(coordSys) {
  return [coordSys.cx, coordSys.cy];
}
function radarBackwardCompat(option) {
  var polarOptArr = option.polar;
  if (polarOptArr) {
    if (!isArray$1(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }
    var polarNotRadar_1 = [];
    each$f(polarOptArr, function(polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }
        option.radar = option.radar || [];
        if (!isArray$1(option.radar)) {
          option.radar = [option.radar];
        }
        option.radar.push(polarOpt);
      } else {
        polarNotRadar_1.push(polarOpt);
      }
    });
    option.polar = polarNotRadar_1;
  }
  each$f(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}
var RadarView$2 = function(_super) {
  __extends$1(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(seriesModel, ecModel, api) {
    var polar = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    function createSymbol2(data2, idx) {
      var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
      if (symbolType === "none") {
        return;
      }
      var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
      var symbolPath = createSymbol$1(symbolType, -1, -1, 2, 2);
      var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }
    function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
      symbolGroup.removeAll();
      for (var i = 0; i < newPoints.length - 1; i++) {
        var symbolPath = createSymbol2(data2, idx);
        if (symbolPath) {
          symbolPath.__dimIdx = i;
          if (oldPoints[i]) {
            symbolPath.setPosition(oldPoints[i]);
            graphic[isInit ? "initProps" : "updateProps"](symbolPath, {
              x: newPoints[i][0],
              y: newPoints[i][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i]);
          }
          symbolGroup.add(symbolPath);
        }
      }
    }
    function getInitialPoints(points2) {
      return map$1(points2, function(pt) {
        return [polar.cx, polar.cy];
      });
    }
    data.diff(oldData).add(function(idx) {
      var points2 = data.getItemLayout(idx);
      if (!points2) {
        return;
      }
      var polygon4 = new Polygon$1();
      var polyline = new Polyline$3();
      var target = {
        shape: {
          points: points2
        }
      };
      polygon4.shape.points = getInitialPoints(points2);
      polyline.shape.points = getInitialPoints(points2);
      initProps(polygon4, target, seriesModel, idx);
      initProps(polyline, target, seriesModel, idx);
      var itemGroup = new Group$4();
      var symbolGroup = new Group$4();
      itemGroup.add(polyline);
      itemGroup.add(polygon4);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points2, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function(newIdx, oldIdx) {
      var itemGroup = oldData.getItemGraphicEl(oldIdx);
      var polyline = itemGroup.childAt(0);
      var polygon4 = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };
      if (!target.shape.points) {
        return;
      }
      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      saveOldStyle(polygon4);
      saveOldStyle(polyline);
      updateProps$1(polyline, target, seriesModel);
      updateProps$1(polygon4, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function(idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function(itemGroup, idx) {
      var itemModel = data.getItemModel(idx);
      var polyline = itemGroup.childAt(0);
      var polygon4 = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var itemStyle = data.getItemVisual(idx, "style");
      var color = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
        fill: "none",
        stroke: color
      }));
      setStatesStylesFromModel(polyline, itemModel, "lineStyle");
      setStatesStylesFromModel(polygon4, itemModel, "areaStyle");
      var areaStyleModel = itemModel.getModel("areaStyle");
      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon4.ignore = polygonIgnore;
      each$f(["emphasis", "select", "blur"], function(stateName) {
        var stateModel = itemModel.getModel([stateName, "areaStyle"]);
        var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
        polygon4.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon4.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: color,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      var emphasisModel = itemModel.getModel("emphasis");
      var itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      symbolGroup.eachChild(function(symbolPath) {
        if (symbolPath instanceof ZRImage$1) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(extend2({
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color);
          symbolPath.style.strokeNoScale = true;
        }
        var pathEmphasisState = symbolPath.ensureState("emphasis");
        pathEmphasisState.style = clone$4(itemHoverStyle);
        var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = "");
        setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText,
          inheritColor: color,
          defaultOpacity: itemStyle.opacity
        });
      });
      toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    this._data = data;
  };
  RadarView2.prototype.remove = function() {
    this.group.removeAll();
    this._data = null;
  };
  RadarView2.type = "radar";
  return RadarView2;
}(ChartView$1);
var RadarView$3 = RadarView$2;
var RadarSeriesModel = function(_super) {
  __extends$1(RadarSeriesModel2, _super);
  function RadarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  RadarSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
  };
  RadarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, {
      generateCoord: "indicator_",
      generateCoordCount: Infinity
    });
  };
  RadarSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var coordSys = this.coordinateSystem;
    var indicatorAxes = coordSys.getIndicatorAxes();
    var name2 = this.getData().getName(dataIndex);
    var nameToDisplay = name2 === "" ? this.name : name2;
    var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
    return createTooltipMarkup("section", {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: map$1(indicatorAxes, function(axis) {
        var val = data.get(data.mapDimension(axis.dim), dataIndex);
        return createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  };
  RadarSeriesModel2.prototype.getTooltipPosition = function(dataIndex) {
    if (dataIndex != null) {
      var data_1 = this.getData();
      var coordSys = this.coordinateSystem;
      var values3 = data_1.getValues(map$1(coordSys.dimensions, function(dim) {
        return data_1.mapDimension(dim);
      }), dataIndex);
      for (var i = 0, len2 = values3.length; i < len2; i++) {
        if (!isNaN(values3[i])) {
          var indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values3[i]), i);
        }
      }
    }
  };
  RadarSeriesModel2.type = "series.radar";
  RadarSeriesModel2.dependencies = ["radar"];
  RadarSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    coordinateSystem: "radar",
    legendHoverLink: true,
    radarIndex: 0,
    lineStyle: {
      width: 2,
      type: "solid",
      join: "round"
    },
    label: {
      position: "top"
    },
    symbolSize: 8
  };
  return RadarSeriesModel2;
}(SeriesModel$1);
var RadarSeriesModel$1 = RadarSeriesModel;
var valueAxisDefault = axisDefault.value;
function defaultsShow(opt, show) {
  return defaults({
    show
  }, opt);
}
var RadarModel = function(_super) {
  __extends$1(RadarModel2, _super);
  function RadarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarModel2.type;
    return _this;
  }
  RadarModel2.prototype.optionUpdated = function() {
    var boundaryGap = this.get("boundaryGap");
    var splitNumber = this.get("splitNumber");
    var scale4 = this.get("scale");
    var axisLine = this.get("axisLine");
    var axisTick = this.get("axisTick");
    var axisLabel = this.get("axisLabel");
    var nameTextStyle = this.get("axisName");
    var showName = this.get(["axisName", "show"]);
    var nameFormatter = this.get(["axisName", "formatter"]);
    var nameGap = this.get("axisNameGap");
    var triggerEvent = this.get("triggerEvent");
    var indicatorModels = map$1(this.get("indicator") || [], function(indicatorOpt) {
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }
      var iNameTextStyle = nameTextStyle;
      if (indicatorOpt.color != null) {
        iNameTextStyle = defaults({
          color: indicatorOpt.color
        }, nameTextStyle);
      }
      var innerIndicatorOpt = merge3(clone$4(indicatorOpt), {
        boundaryGap,
        splitNumber,
        scale: scale4,
        axisLine,
        axisTick,
        axisLabel,
        name: indicatorOpt.text,
        showName,
        nameLocation: "end",
        nameGap,
        nameTextStyle: iNameTextStyle,
        triggerEvent
      }, false);
      if (isString(nameFormatter)) {
        var indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
      } else if (isFunction(nameFormatter)) {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }
      var model = new Model$1(innerIndicatorOpt, null, this.ecModel);
      mixin(model, AxisModelCommonMixin.prototype);
      model.mainType = "radar";
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  };
  RadarModel2.prototype.getIndicatorModels = function() {
    return this._indicatorModels;
  };
  RadarModel2.type = "radar";
  RadarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "75%",
    startAngle: 90,
    axisName: {
      show: true
    },
    boundaryGap: [0, 0],
    splitNumber: 5,
    axisNameGap: 15,
    scale: false,
    shape: "polygon",
    axisLine: merge3({
      lineStyle: {
        color: "#bbb"
      }
    }, valueAxisDefault.axisLine),
    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
    axisTick: defaultsShow(valueAxisDefault.axisTick, false),
    splitLine: defaultsShow(valueAxisDefault.splitLine, true),
    splitArea: defaultsShow(valueAxisDefault.splitArea, true),
    indicator: []
  };
  return RadarModel2;
}(ComponentModel$1);
var RadarModel$1 = RadarModel;
var axisBuilderAttrs$2 = ["axisLine", "axisTickLabel", "axisName"];
var RadarView = function(_super) {
  __extends$1(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(radarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    this._buildAxes(radarModel);
    this._buildSplitLineAndArea(radarModel);
  };
  RadarView2.prototype._buildAxes = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    var axisBuilders = map$1(indicatorAxes, function(indicatorAxis) {
      var axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
      var axisBuilder = new AxisBuilder$1(indicatorAxis.model, {
        axisName,
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    each$f(axisBuilders, function(axisBuilder) {
      each$f(axisBuilderAttrs$2, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
    }, this);
  };
  RadarView2.prototype._buildSplitLineAndArea = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    if (!indicatorAxes.length) {
      return;
    }
    var shape = radarModel.get("shape");
    var splitLineModel = radarModel.getModel("splitLine");
    var splitAreaModel = radarModel.getModel("splitArea");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var showSplitLine = splitLineModel.get("show");
    var showSplitArea = splitAreaModel.get("show");
    var splitLineColors = lineStyleModel.get("color");
    var splitAreaColors = areaStyleModel.get("color");
    var splitLineColorsArr = isArray$1(splitLineColors) ? splitLineColors : [splitLineColors];
    var splitAreaColorsArr = isArray$1(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    var splitLines = [];
    var splitAreas = [];
    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      var colorIndex2 = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
      return colorIndex2;
    }
    if (shape === "circle") {
      var ticksRadius = indicatorAxes[0].getTicksCoords();
      var cx = radar.cx;
      var cy = radar.cy;
      for (var i = 0; i < ticksRadius.length; i++) {
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Circle$1({
            shape: {
              cx,
              cy,
              r: ticksRadius[i].coord
            }
          }));
        }
        if (showSplitArea && i < ticksRadius.length - 1) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
          splitAreas[colorIndex].push(new Ring$1({
            shape: {
              cx,
              cy,
              r0: ticksRadius[i].coord,
              r: ticksRadius[i + 1].coord
            }
          }));
        }
      }
    } else {
      var realSplitNumber_1;
      var axesTicksPoints = map$1(indicatorAxes, function(indicatorAxis, idx) {
        var ticksCoords = indicatorAxis.getTicksCoords();
        realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
        return map$1(ticksCoords, function(tickCoord) {
          return radar.coordToPoint(tickCoord.coord, idx);
        });
      });
      var prevPoints = [];
      for (var i = 0; i <= realSplitNumber_1; i++) {
        var points2 = [];
        for (var j = 0; j < indicatorAxes.length; j++) {
          points2.push(axesTicksPoints[j][i]);
        }
        if (points2[0]) {
          points2.push(points2[0].slice());
        } else {
          {
            console.error("Can't draw value axis " + i);
          }
        }
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Polyline$3({
            shape: {
              points: points2
            }
          }));
        }
        if (showSplitArea && prevPoints) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
          splitAreas[colorIndex].push(new Polygon$1({
            shape: {
              points: points2.concat(prevPoints)
            }
          }));
        }
        prevPoints = points2.slice().reverse();
      }
    }
    var lineStyle = lineStyleModel.getLineStyle();
    var areaStyle = areaStyleModel.getAreaStyle();
    each$f(splitAreas, function(splitAreas2, idx) {
      this.group.add(mergePath(splitAreas2, {
        style: defaults({
          stroke: "none",
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    each$f(splitLines, function(splitLines2, idx) {
      this.group.add(mergePath(splitLines2, {
        style: defaults({
          fill: "none",
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  };
  RadarView2.type = "radar";
  return RadarView2;
}(ComponentView$1);
var RadarView$1 = RadarView;
var IndicatorAxis = function(_super) {
  __extends$1(IndicatorAxis2, _super);
  function IndicatorAxis2(dim, scale4, radiusExtent) {
    var _this = _super.call(this, dim, scale4, radiusExtent) || this;
    _this.type = "value";
    _this.angle = 0;
    _this.name = "";
    return _this;
  }
  return IndicatorAxis2;
}(Axis$1);
var IndicatorAxis$1 = IndicatorAxis;
var Radar = function() {
  function Radar2(radarModel, ecModel, api) {
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = map$1(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      var dim = "indicator_" + idx;
      var indicatorAxis = new IndicatorAxis$1(
        dim,
        new IntervalScale$1()
      );
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
  }
  Radar2.prototype.getIndicatorAxes = function() {
    return this._indicatorAxes;
  };
  Radar2.prototype.dataToPoint = function(value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  };
  Radar2.prototype.coordToPoint = function(coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle4 = indicatorAxis.angle;
    var x2 = this.cx + coord * Math.cos(angle4);
    var y2 = this.cy - coord * Math.sin(angle4);
    return [x2, y2];
  };
  Radar2.prototype.pointToData = function(pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx);
    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;
    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff2 = Math.abs(radian - indicatorAxis.angle);
      if (diff2 < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff2;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };
  Radar2.prototype.resize = function(radarModel, api) {
    var center2 = radarModel.get("center");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = parsePercent(center2[0], viewWidth);
    this.cy = parsePercent(center2[1], viewHeight);
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    var radius = radarModel.get("radius");
    if (isString(radius) || isNumber(radius)) {
      radius = [0, radius];
    }
    this.r0 = parsePercent(radius[0], viewSize);
    this.r = parsePercent(radius[1], viewSize);
    each$f(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle4 = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle4 = Math.atan2(Math.sin(angle4), Math.cos(angle4));
      indicatorAxis.angle = angle4;
    }, this);
  };
  Radar2.prototype.update = function(ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    each$f(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      var data = radarSeries.getData();
      each$f(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get("splitNumber");
    var dummyScale = new IntervalScale$1();
    dummyScale.setExtent(0, splitNumber);
    dummyScale.setInterval(1);
    each$f(indicatorAxes, function(indicatorAxis, idx) {
      alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
    });
  };
  Radar2.prototype.convertToPixel = function(ecModel, finder, value) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.containPoint = function(point4) {
    console.warn("Not implemented.");
    return false;
  };
  Radar2.create = function(ecModel, api) {
    var radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      var radar = new Radar2(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  };
  Radar2.dimensions = [];
  return Radar2;
}();
var Radar$1 = Radar;
function install$L(registers) {
  registers.registerCoordinateSystem("radar", Radar$1);
  registers.registerComponentModel(RadarModel$1);
  registers.registerComponentView(RadarView$1);
  registers.registerVisual({
    seriesType: "radar",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      data.each(function(idx) {
        data.setItemVisual(idx, "legendIcon", "roundRect");
      });
      data.setVisual("legendIcon", "roundRect");
    }
  });
}
function install$K(registers) {
  use2(install$L);
  registers.registerChartView(RadarView$3);
  registers.registerSeriesModel(RadarSeriesModel$1);
  registers.registerLayout(radarLayout);
  registers.registerProcessor(dataFilter$1("radar"));
  registers.registerPreprocessor(radarBackwardCompat);
}
var ATTR = "\0_ec_interaction_mutex";
function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];
  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}
function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}
function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
registerAction({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, noop);
var RoamController = function(_super) {
  __extends$1(RoamController2, _super);
  function RoamController2(zr) {
    var _this = _super.call(this) || this;
    _this._zr = zr;
    var mousedownHandler = bind$1(_this._mousedownHandler, _this);
    var mousemoveHandler = bind$1(_this._mousemoveHandler, _this);
    var mouseupHandler = bind$1(_this._mouseupHandler, _this);
    var mousewheelHandler = bind$1(_this._mousewheelHandler, _this);
    var pinchHandler = bind$1(_this._pinchHandler, _this);
    _this.enable = function(controlType, opt) {
      this.disable();
      this._opt = defaults(clone$4(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || controlType === "move" || controlType === "pan") {
        zr.on("mousedown", mousedownHandler);
        zr.on("mousemove", mousemoveHandler);
        zr.on("mouseup", mouseupHandler);
      }
      if (controlType === true || controlType === "scale" || controlType === "zoom") {
        zr.on("mousewheel", mousewheelHandler);
        zr.on("pinch", pinchHandler);
      }
    };
    _this.disable = function() {
      zr.off("mousedown", mousedownHandler);
      zr.off("mousemove", mousemoveHandler);
      zr.off("mouseup", mouseupHandler);
      zr.off("mousewheel", mousewheelHandler);
      zr.off("pinch", pinchHandler);
    };
    return _this;
  }
  RoamController2.prototype.isDragging = function() {
    return this._dragging;
  };
  RoamController2.prototype.isPinching = function() {
    return this._pinching;
  };
  RoamController2.prototype.setPointerChecker = function(pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  RoamController2.prototype.dispose = function() {
    this.disable();
  };
  RoamController2.prototype._mousedownHandler = function(e2) {
    if (isMiddleOrRightButtonOnMouseUpDown(e2)) {
      return;
    }
    var el = e2.target;
    while (el) {
      if (el.draggable) {
        return;
      }
      el = el.__hostTarget || el.parent;
    }
    var x2 = e2.offsetX;
    var y2 = e2.offsetY;
    if (this.pointerChecker && this.pointerChecker(e2, x2, y2)) {
      this._x = x2;
      this._y = y2;
      this._dragging = true;
    }
  };
  RoamController2.prototype._mousemoveHandler = function(e2) {
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt) || e2.gestureEvent === "pinch" || isTaken(this._zr, "globalPan")) {
      return;
    }
    var x2 = e2.offsetX;
    var y2 = e2.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x2 - oldX;
    var dy = y2 - oldY;
    this._x = x2;
    this._y = y2;
    this._opt.preventDefaultMouseMove && stop(e2.event);
    trigger$1(this, "pan", "moveOnMouseMove", e2, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x2,
      newY: y2,
      isAvailableBehavior: null
    });
  };
  RoamController2.prototype._mouseupHandler = function(e2) {
    if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
      this._dragging = false;
    }
  };
  RoamController2.prototype._mousewheelHandler = function(e2) {
    var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
    var shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
    var wheelDelta = e2.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e2.offsetX;
    var originY = e2.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale4 = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e2, {
        scale: scale4,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
    if (shouldMove) {
      var absDelta = Math.abs(wheelDelta);
      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e2, {
        scrollDelta,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
  };
  RoamController2.prototype._pinchHandler = function(e2) {
    if (isTaken(this._zr, "globalPan")) {
      return;
    }
    var scale4 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, "zoom", null, e2, {
      scale: scale4,
      originX: e2.pinchX,
      originY: e2.pinchY,
      isAvailableBehavior: null
    });
  };
  return RoamController2;
}(Eventful$1);
function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e2, contollerEvent.originX, contollerEvent.originY)) {
    stop(e2.event);
    trigger$1(controller, eventName, behaviorToCheck, e2, contollerEvent);
  }
}
function trigger$1(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  contollerEvent.isAvailableBehavior = bind$1(isAvailableBehavior, null, behaviorToCheck, e2);
  controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e2, settings2) {
  var setting = settings2[behaviorToCheck];
  return !behaviorToCheck || setting && (!isString(setting) || e2.event[setting + "Key"]);
}
var RoamController$1 = RoamController;
function updateViewOnPan(controllerHost, dx, dy) {
  var target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  var target = controllerHost.target;
  var zoomLimit = controllerHost.zoomLimit;
  var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;
  if (zoomLimit) {
    var zoomMin = zoomLimit.min || 0;
    var zoomMax = zoomLimit.max || Infinity;
    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
  }
  var zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom;
  target.x -= (zoomX - target.x) * (zoomScale - 1);
  target.y -= (zoomY - target.y) * (zoomScale - 1);
  target.scaleX *= zoomScale;
  target.scaleY *= zoomScale;
  target.dirty();
}
var IRRELEVANT_EXCLUDES = {
  "axisPointer": 1,
  "tooltip": 1,
  "brush": 1
};
function onIrrelevantElement(e2, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e2.topTarget);
  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;
}
function parseXML(svg) {
  if (isString(svg)) {
    var parser = new DOMParser();
    svg = parser.parseFromString(svg, "text/xml");
  }
  var svgNode = svg;
  if (svgNode.nodeType === 9) {
    svgNode = svgNode.firstChild;
  }
  while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) {
    svgNode = svgNode.nextSibling;
  }
  return svgNode;
}
var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  "fill": "fill",
  "stroke": "stroke",
  "stroke-width": "lineWidth",
  "opacity": "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  "visibility": "visibility",
  "display": "display"
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys2(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys2(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = function() {
  function SVGParser2() {
    this._defs = {};
    this._root = null;
  }
  SVGParser2.prototype.parse = function(xml, opt) {
    opt = opt || {};
    var svg = parseXML(xml);
    {
      if (!svg) {
        throw new Error("Illegal svg");
      }
    }
    this._defsUsePending = [];
    var root = new Group$4();
    this._root = root;
    var named = [];
    var viewBox = svg.getAttribute("viewBox") || "";
    var width = parseFloat(svg.getAttribute("width") || opt.width);
    var height = parseFloat(svg.getAttribute("height") || opt.height);
    isNaN(width) && (width = null);
    isNaN(height) && (height = null);
    parseAttributes(svg, root, null, true, false);
    var child = svg.firstChild;
    while (child) {
      this._parseNode(child, root, named, null, false, false);
      child = child.nextSibling;
    }
    applyDefs(this._defs, this._defsUsePending);
    this._defsUsePending = [];
    var viewBoxRect;
    var viewBoxTransform;
    if (viewBox) {
      var viewBoxArr = splitNumberSequence(viewBox);
      if (viewBoxArr.length >= 4) {
        viewBoxRect = {
          x: parseFloat(viewBoxArr[0] || 0),
          y: parseFloat(viewBoxArr[1] || 0),
          width: parseFloat(viewBoxArr[2]),
          height: parseFloat(viewBoxArr[3])
        };
      }
    }
    if (viewBoxRect && width != null && height != null) {
      viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width, height });
      if (!opt.ignoreViewBox) {
        var elRoot = root;
        root = new Group$4();
        root.add(elRoot);
        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
        elRoot.x = viewBoxTransform.x;
        elRoot.y = viewBoxTransform.y;
      }
    }
    if (!opt.ignoreRootClip && width != null && height != null) {
      root.setClipPath(new Rect$3({
        shape: { x: 0, y: 0, width, height }
      }));
    }
    return {
      root,
      width,
      height,
      viewBoxRect,
      viewBoxTransform,
      named
    };
  };
  SVGParser2.prototype._parseNode = function(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
    var nodeName = xmlNode.nodeName.toLowerCase();
    var el;
    var namedFromForSub = namedFrom;
    if (nodeName === "defs") {
      isInDefs = true;
    }
    if (nodeName === "text") {
      isInText = true;
    }
    if (nodeName === "defs" || nodeName === "switch") {
      el = parentGroup;
    } else {
      if (!isInDefs) {
        var parser_1 = nodeParsers[nodeName];
        if (parser_1 && hasOwn(nodeParsers, nodeName)) {
          el = parser_1.call(this, xmlNode, parentGroup);
          var nameAttr = xmlNode.getAttribute("name");
          if (nameAttr) {
            var newNamed = {
              name: nameAttr,
              namedFrom: null,
              svgNodeTagLower: nodeName,
              el
            };
            named.push(newNamed);
            if (nodeName === "g") {
              namedFromForSub = newNamed;
            }
          } else if (namedFrom) {
            named.push({
              name: namedFrom.name,
              namedFrom,
              svgNodeTagLower: nodeName,
              el
            });
          }
          parentGroup.add(el);
        }
      }
      var parser = paintServerParsers[nodeName];
      if (parser && hasOwn(paintServerParsers, nodeName)) {
        var def = parser.call(this, xmlNode);
        var id = xmlNode.getAttribute("id");
        if (id) {
          this._defs[id] = def;
        }
      }
    }
    if (el && el.isGroup) {
      var child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
        } else if (child.nodeType === 3 && isInText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
    }
  };
  SVGParser2.prototype._parseText = function(xmlNode, parentGroup) {
    var text = new TSpan$1({
      style: {
        text: xmlNode.textContent
      },
      silent: true,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(parentGroup, text);
    parseAttributes(xmlNode, text, this._defsUsePending, false, false);
    applyTextAlignment(text, parentGroup);
    var textStyle = text.style;
    var fontSize = textStyle.fontSize;
    if (fontSize && fontSize < 9) {
      textStyle.fontSize = 9;
      text.scaleX *= fontSize / 9;
      text.scaleY *= fontSize / 9;
    }
    var font = (textStyle.fontSize || textStyle.fontFamily) && [
      textStyle.fontStyle,
      textStyle.fontWeight,
      (textStyle.fontSize || 12) + "px",
      textStyle.fontFamily || "sans-serif"
    ].join(" ");
    textStyle.font = font;
    var rect = text.getBoundingRect();
    this._textX += rect.width;
    parentGroup.add(text);
    return text;
  };
  SVGParser2.internalField = function() {
    nodeParsers = {
      "g": function(xmlNode, parentGroup) {
        var g = new Group$4();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defsUsePending, false, false);
        return g;
      },
      "rect": function(xmlNode, parentGroup) {
        var rect = new Rect$3();
        inheritStyle(parentGroup, rect);
        parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
        rect.setShape({
          x: parseFloat(xmlNode.getAttribute("x") || "0"),
          y: parseFloat(xmlNode.getAttribute("y") || "0"),
          width: parseFloat(xmlNode.getAttribute("width") || "0"),
          height: parseFloat(xmlNode.getAttribute("height") || "0")
        });
        rect.silent = true;
        return rect;
      },
      "circle": function(xmlNode, parentGroup) {
        var circle2 = new Circle$1();
        inheritStyle(parentGroup, circle2);
        parseAttributes(xmlNode, circle2, this._defsUsePending, false, false);
        circle2.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
          cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
          r: parseFloat(xmlNode.getAttribute("r") || "0")
        });
        circle2.silent = true;
        return circle2;
      },
      "line": function(xmlNode, parentGroup) {
        var line = new Line$3();
        inheritStyle(parentGroup, line);
        parseAttributes(xmlNode, line, this._defsUsePending, false, false);
        line.setShape({
          x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
          y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
          x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
          y2: parseFloat(xmlNode.getAttribute("y2") || "0")
        });
        line.silent = true;
        return line;
      },
      "ellipse": function(xmlNode, parentGroup) {
        var ellipse2 = new Ellipse$1();
        inheritStyle(parentGroup, ellipse2);
        parseAttributes(xmlNode, ellipse2, this._defsUsePending, false, false);
        ellipse2.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
          cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
          rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
          ry: parseFloat(xmlNode.getAttribute("ry") || "0")
        });
        ellipse2.silent = true;
        return ellipse2;
      },
      "polygon": function(xmlNode, parentGroup) {
        var pointsStr = xmlNode.getAttribute("points");
        var pointsArr;
        if (pointsStr) {
          pointsArr = parsePoints(pointsStr);
        }
        var polygon4 = new Polygon$1({
          shape: {
            points: pointsArr || []
          },
          silent: true
        });
        inheritStyle(parentGroup, polygon4);
        parseAttributes(xmlNode, polygon4, this._defsUsePending, false, false);
        return polygon4;
      },
      "polyline": function(xmlNode, parentGroup) {
        var pointsStr = xmlNode.getAttribute("points");
        var pointsArr;
        if (pointsStr) {
          pointsArr = parsePoints(pointsStr);
        }
        var polyline = new Polyline$3({
          shape: {
            points: pointsArr || []
          },
          silent: true
        });
        inheritStyle(parentGroup, polyline);
        parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
        return polyline;
      },
      "image": function(xmlNode, parentGroup) {
        var img = new ZRImage$1();
        inheritStyle(parentGroup, img);
        parseAttributes(xmlNode, img, this._defsUsePending, false, false);
        img.setStyle({
          image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
          x: +xmlNode.getAttribute("x"),
          y: +xmlNode.getAttribute("y"),
          width: +xmlNode.getAttribute("width"),
          height: +xmlNode.getAttribute("height")
        });
        img.silent = true;
        return img;
      },
      "text": function(xmlNode, parentGroup) {
        var x2 = xmlNode.getAttribute("x") || "0";
        var y2 = xmlNode.getAttribute("y") || "0";
        var dx = xmlNode.getAttribute("dx") || "0";
        var dy = xmlNode.getAttribute("dy") || "0";
        this._textX = parseFloat(x2) + parseFloat(dx);
        this._textY = parseFloat(y2) + parseFloat(dy);
        var g = new Group$4();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defsUsePending, false, true);
        return g;
      },
      "tspan": function(xmlNode, parentGroup) {
        var x2 = xmlNode.getAttribute("x");
        var y2 = xmlNode.getAttribute("y");
        if (x2 != null) {
          this._textX = parseFloat(x2);
        }
        if (y2 != null) {
          this._textY = parseFloat(y2);
        }
        var dx = xmlNode.getAttribute("dx") || "0";
        var dy = xmlNode.getAttribute("dy") || "0";
        var g = new Group$4();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defsUsePending, false, true);
        this._textX += parseFloat(dx);
        this._textY += parseFloat(dy);
        return g;
      },
      "path": function(xmlNode, parentGroup) {
        var d = xmlNode.getAttribute("d") || "";
        var path = createFromString(d);
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defsUsePending, false, false);
        path.silent = true;
        return path;
      }
    };
  }();
  return SVGParser2;
}();
var paintServerParsers = {
  "lineargradient": function(xmlNode) {
    var x12 = parseInt(xmlNode.getAttribute("x1") || "0", 10);
    var y12 = parseInt(xmlNode.getAttribute("y1") || "0", 10);
    var x2 = parseInt(xmlNode.getAttribute("x2") || "10", 10);
    var y2 = parseInt(xmlNode.getAttribute("y2") || "0", 10);
    var gradient = new LinearGradient$1(x12, y12, x2, y2);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  },
  "radialgradient": function(xmlNode) {
    var cx = parseInt(xmlNode.getAttribute("cx") || "0", 10);
    var cy = parseInt(xmlNode.getAttribute("cy") || "0", 10);
    var r = parseInt(xmlNode.getAttribute("r") || "0", 10);
    var gradient = new RadialGradient$1(cx, cy, r);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  }
};
function parsePaintServerUnit(xmlNode, gradient) {
  var gradientUnits = xmlNode.getAttribute("gradientUnits");
  if (gradientUnits === "userSpaceOnUse") {
    gradient.global = true;
  }
}
function parseGradientColorStops(xmlNode, gradient) {
  var stop2 = xmlNode.firstChild;
  while (stop2) {
    if (stop2.nodeType === 1 && stop2.nodeName.toLocaleLowerCase() === "stop") {
      var offsetStr = stop2.getAttribute("offset");
      var offset = void 0;
      if (offsetStr && offsetStr.indexOf("%") > 0) {
        offset = parseInt(offsetStr, 10) / 100;
      } else if (offsetStr) {
        offset = parseFloat(offsetStr);
      } else {
        offset = 0;
      }
      var styleVals = {};
      parseInlineStyle(stop2, styleVals, styleVals);
      var stopColor = styleVals.stopColor || stop2.getAttribute("stop-color") || "#000000";
      gradient.colorStops.push({
        offset,
        color: stopColor
      });
    }
    stop2 = stop2.nextSibling;
  }
}
function inheritStyle(parent, child) {
  if (parent && parent.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }
    defaults(child.__inheritedStyle, parent.__inheritedStyle);
  }
}
function parsePoints(pointsString) {
  var list = splitNumberSequence(pointsString);
  var points2 = [];
  for (var i = 0; i < list.length; i += 2) {
    var x2 = parseFloat(list[i]);
    var y2 = parseFloat(list[i + 1]);
    points2.push([x2, y2]);
  }
  return points2;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
  var disp = el;
  var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
  var selfStyle = {};
  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
    if (!onlyInlineStyle) {
      parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
    }
  }
  disp.style = disp.style || {};
  if (inheritedStyle.fill != null) {
    disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
  }
  if (inheritedStyle.stroke != null) {
    disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
  }
  each$f([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = parseFloat(inheritedStyle[propName]);
    }
  });
  each$f([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = inheritedStyle[propName];
    }
  });
  if (isTextGroup) {
    disp.__selfStyle = selfStyle;
  }
  if (inheritedStyle.lineDash) {
    disp.style.lineDash = map$1(splitNumberSequence(inheritedStyle.lineDash), function(str) {
      return parseFloat(str);
    });
  }
  if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") {
    disp.invisible = true;
  }
  if (inheritedStyle.display === "none") {
    disp.ignore = true;
  }
}
function applyTextAlignment(text, parentGroup) {
  var parentSelfStyle = parentGroup.__selfStyle;
  if (parentSelfStyle) {
    var textBaseline = parentSelfStyle.textBaseline;
    var zrTextBaseline = textBaseline;
    if (!textBaseline || textBaseline === "auto") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "baseline") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") {
      zrTextBaseline = "top";
    } else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") {
      zrTextBaseline = "bottom";
    } else if (textBaseline === "central" || textBaseline === "mathematical") {
      zrTextBaseline = "middle";
    }
    text.style.textBaseline = zrTextBaseline;
  }
  var parentInheritedStyle = parentGroup.__inheritedStyle;
  if (parentInheritedStyle) {
    var textAlign = parentInheritedStyle.textAlign;
    var zrTextAlign = textAlign;
    if (textAlign) {
      if (textAlign === "middle") {
        zrTextAlign = "center";
      }
      text.style.textAlign = zrTextAlign;
    }
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
  var urlMatch = str && str.match(urlRegex);
  if (urlMatch) {
    var url = trim$1(urlMatch[1]);
    defsUsePending.push([el, method, url]);
    return;
  }
  if (str === "none") {
    str = null;
  }
  return str;
}
function applyDefs(defs, defsUsePending) {
  for (var i = 0; i < defsUsePending.length; i++) {
    var item = defsUsePending[i];
    item[0].style[item[1]] = defs[item[2]];
  }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
  return rawStr.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
  var transform4 = xmlNode.getAttribute("transform");
  if (transform4) {
    transform4 = transform4.replace(/,/g, " ");
    var transformOps_1 = [];
    var mt = null;
    transform4.replace(transformRegex, function(str, type2, value2) {
      transformOps_1.push(type2, value2);
      return "";
    });
    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
      var value = transformOps_1[i];
      var type = transformOps_1[i - 1];
      var valueArr = splitNumberSequence(value);
      mt = mt || create$1();
      switch (type) {
        case "translate":
          translate2(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
          break;
        case "scale":
          scale$1(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
          break;
        case "rotate":
          rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          break;
        case "skewX":
          var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul(mt, [1, 0, sx, 1, 0, 0], mt);
          break;
        case "skewY":
          var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul(mt, [1, sy, 0, 1, 0, 0], mt);
          break;
        case "matrix":
          mt[0] = parseFloat(valueArr[0]);
          mt[1] = parseFloat(valueArr[1]);
          mt[2] = parseFloat(valueArr[2]);
          mt[3] = parseFloat(valueArr[3]);
          mt[4] = parseFloat(valueArr[4]);
          mt[5] = parseFloat(valueArr[5]);
          break;
      }
    }
    node.setLocalTransform(mt);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  var style = xmlNode.getAttribute("style");
  if (!style) {
    return;
  }
  styleRegex.lastIndex = 0;
  var styleRegResult;
  while ((styleRegResult = styleRegex.exec(style)) != null) {
    var svgStlAttr = styleRegResult[1];
    var zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrInheritableStlAttr) {
      inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
    }
    var zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrSelfStlAttr) {
      selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
    }
  }
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
    var attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
  for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
    var attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
  var scaleX = boundingRect.width / viewBoxRect.width;
  var scaleY = boundingRect.height / viewBoxRect.height;
  var scale4 = Math.min(scaleX, scaleY);
  return {
    scale: scale4,
    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale4 + (boundingRect.x + boundingRect.width / 2),
    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale4 + (boundingRect.y + boundingRect.height / 2)
  };
}
function parseSVG(xml, opt) {
  var parser = new SVGParser();
  return parser.parse(xml, opt);
}
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  "text",
  "tspan",
  "g"
]);
var GeoSVGResource = function() {
  function GeoSVGResource2(mapName, svg) {
    this.type = "geoSVG";
    this._usedGraphicMap = createHashMap();
    this._freedGraphics = [];
    this._mapName = mapName;
    this._parsedXML = parseXML(svg);
  }
  GeoSVGResource2.prototype.load = function() {
    var firstGraphic = this._firstGraphic;
    if (!firstGraphic) {
      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
      this._freedGraphics.push(firstGraphic);
      this._boundingRect = this._firstGraphic.boundingRect.clone();
      var _a2 = createRegions(firstGraphic.named), regions = _a2.regions, regionsMap = _a2.regionsMap;
      this._regions = regions;
      this._regionsMap = regionsMap;
    }
    return {
      boundingRect: this._boundingRect,
      regions: this._regions,
      regionsMap: this._regionsMap
    };
  };
  GeoSVGResource2.prototype._buildGraphic = function(svgXML) {
    var result;
    var rootFromParse;
    try {
      result = svgXML && parseSVG(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      rootFromParse = result.root;
      assert(rootFromParse != null);
    } catch (e2) {
      throw new Error("Invalid svg format\n" + e2.message);
    }
    var root = new Group$4();
    root.add(rootFromParse);
    root.isGeoSVGGraphicRoot = true;
    var svgWidth = result.width;
    var svgHeight = result.height;
    var viewBoxRect = result.viewBoxRect;
    var boundingRect = this._boundingRect;
    if (!boundingRect) {
      var bRectX = void 0;
      var bRectY = void 0;
      var bRectWidth = void 0;
      var bRectHeight = void 0;
      if (svgWidth != null) {
        bRectX = 0;
        bRectWidth = svgWidth;
      } else if (viewBoxRect) {
        bRectX = viewBoxRect.x;
        bRectWidth = viewBoxRect.width;
      }
      if (svgHeight != null) {
        bRectY = 0;
        bRectHeight = svgHeight;
      } else if (viewBoxRect) {
        bRectY = viewBoxRect.y;
        bRectHeight = viewBoxRect.height;
      }
      if (bRectX == null || bRectY == null) {
        var calculatedBoundingRect = rootFromParse.getBoundingRect();
        if (bRectX == null) {
          bRectX = calculatedBoundingRect.x;
          bRectWidth = calculatedBoundingRect.width;
        }
        if (bRectY == null) {
          bRectY = calculatedBoundingRect.y;
          bRectHeight = calculatedBoundingRect.height;
        }
      }
      boundingRect = this._boundingRect = new BoundingRect$1(bRectX, bRectY, bRectWidth, bRectHeight);
    }
    if (viewBoxRect) {
      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
      rootFromParse.x = viewBoxTransform.x;
      rootFromParse.y = viewBoxTransform.y;
    }
    root.setClipPath(new Rect$3({
      shape: boundingRect.plain()
    }));
    var named = [];
    each$f(result.named, function(namedItem) {
      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
        named.push(namedItem);
        setSilent(namedItem.el);
      }
    });
    return {
      root,
      boundingRect,
      named
    };
  };
  GeoSVGResource2.prototype.useGraphic = function(hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      return svgGraphic;
    }
    svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
    usedRootMap.set(hostKey, svgGraphic);
    return svgGraphic;
  };
  GeoSVGResource2.prototype.freeGraphic = function(hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      usedRootMap.removeKey(hostKey);
      this._freedGraphics.push(svgGraphic);
    }
  };
  return GeoSVGResource2;
}();
function setSilent(el) {
  el.silent = false;
  if (el.isGroup) {
    el.traverse(function(child) {
      child.silent = false;
    });
  }
}
function createRegions(named) {
  var regions = [];
  var regionsMap = createHashMap();
  each$f(named, function(namedItem) {
    if (namedItem.namedFrom != null) {
      return;
    }
    var region = new GeoSVGRegion(namedItem.name, namedItem.el);
    regions.push(region);
    regionsMap.set(namedItem.name, region);
  });
  return {
    regions,
    regionsMap
  };
}
var geoCoord = [126, 25];
var nanhaiName = "\u5357\u6D77\u8BF8\u5C9B";
var points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var i = 0; i < points$1.length; i++) {
  for (var k = 0; k < points$1[i].length; k++) {
    points$1[i][k][0] /= 10.5;
    points$1[i][k][1] /= -10.5 / 0.75;
    points$1[i][k][0] += geoCoord[0];
    points$1[i][k][1] += geoCoord[1];
  }
}
function fixNanhai(mapType, regions) {
  if (mapType === "china") {
    for (var i = 0; i < regions.length; i++) {
      if (regions[i].name === nanhaiName) {
        return;
      }
    }
    regions.push(new GeoJSONRegion(nanhaiName, map$1(points$1, function(exterior) {
      return {
        type: "polygon",
        exterior
      };
    }), geoCoord));
  }
}
var coordsOffsetMap = {
  "\u5357\u6D77\u8BF8\u5C9B": [32, 80],
  "\u5E7F\u4E1C": [0, -10],
  "\u9999\u6E2F": [10, 5],
  "\u6FB3\u95E8": [-10, 10],
  "\u5929\u6D25": [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === "china") {
    var coordFix = coordsOffsetMap[region.name];
    if (coordFix) {
      var cp = region.getCenter();
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
      region.setCenter(cp);
    }
  }
}
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === "china" && region.name === "\u53F0\u6E7E") {
    region.geometries.push({
      type: "polygon",
      exterior: points[0]
    });
  }
}
var DEFAULT_NAME_PROPERTY = "name";
var GeoJSONResource = function() {
  function GeoJSONResource2(mapName, geoJSON, specialAreas) {
    this.type = "geoJSON";
    this._parsedMap = createHashMap();
    this._mapName = mapName;
    this._specialAreas = specialAreas;
    this._geoJSON = parseInput(geoJSON);
  }
  GeoJSONResource2.prototype.load = function(nameMap, nameProperty) {
    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
    var parsed = this._parsedMap.get(nameProperty);
    if (!parsed) {
      var rawRegions = this._parseToRegions(nameProperty);
      parsed = this._parsedMap.set(nameProperty, {
        regions: rawRegions,
        boundingRect: calculateBoundingRect(rawRegions)
      });
    }
    var regionsMap = createHashMap();
    var finalRegions = [];
    each$f(parsed.regions, function(region) {
      var regionName = region.name;
      if (nameMap && hasOwn(nameMap, regionName)) {
        region = region.cloneShallow(regionName = nameMap[regionName]);
      }
      finalRegions.push(region);
      regionsMap.set(regionName, region);
    });
    return {
      regions: finalRegions,
      boundingRect: parsed.boundingRect || new BoundingRect$1(0, 0, 0, 0),
      regionsMap
    };
  };
  GeoJSONResource2.prototype._parseToRegions = function(nameProperty) {
    var mapName = this._mapName;
    var geoJSON = this._geoJSON;
    var rawRegions;
    try {
      rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
    } catch (e2) {
      throw new Error("Invalid geoJson format\n" + e2.message);
    }
    fixNanhai(mapName, rawRegions);
    each$f(rawRegions, function(region) {
      var regionName = region.name;
      fixTextCoords(mapName, region);
      fixDiaoyuIsland(mapName, region);
      var specialArea = this._specialAreas && this._specialAreas[regionName];
      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }, this);
    return rawRegions;
  };
  GeoJSONResource2.prototype.getMapForUser = function() {
    return {
      geoJson: this._geoJSON,
      geoJSON: this._geoJSON,
      specialAreas: this._specialAreas
    };
  };
  return GeoJSONResource2;
}();
function calculateBoundingRect(regions) {
  var rect;
  for (var i = 0; i < regions.length; i++) {
    var regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }
  return rect;
}
function parseInput(source2) {
  return !isString(source2) ? source2 : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source2) : new Function("return (" + source2 + ");")();
}
var storage = createHashMap();
var geoSourceManager = {
  registerMap: function(mapName, rawDef, rawSpecialAreas) {
    if (rawDef.svg) {
      var resource = new GeoSVGResource(mapName, rawDef.svg);
      storage.set(mapName, resource);
    } else {
      var geoJSON = rawDef.geoJson || rawDef.geoJSON;
      if (geoJSON && !rawDef.features) {
        rawSpecialAreas = rawDef.specialAreas;
      } else {
        geoJSON = rawDef;
      }
      var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
      storage.set(mapName, resource);
    }
  },
  getGeoResource: function(mapName) {
    return storage.get(mapName);
  },
  getMapForUser: function(mapName) {
    var resource = storage.get(mapName);
    return resource && resource.type === "geoJSON" && resource.getMapForUser();
  },
  load: function(mapName, nameMap, nameProperty) {
    var resource = storage.get(mapName);
    if (!resource) {
      {
        console.error("Map " + mapName + " not exists. The GeoJSON of the map must be provided.");
      }
      return;
    }
    return resource.load(nameMap, nameProperty);
  }
};
var OPTION_STYLE_ENABLED_TAGS = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var mapLabelRaw = makeInner();
function getFixedItemStyle(model) {
  var itemStyle = model.getItemStyle();
  var areaColor = model.get("areaColor");
  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }
  return itemStyle;
}
function fixLineStyle(styleHost) {
  var style = styleHost.style;
  if (style) {
    style.stroke = style.stroke || style.fill;
    style.fill = null;
  }
}
var MapDraw = function() {
  function MapDraw2(api) {
    var group = new Group$4();
    this.uid = getUID("ec_map_draw");
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: group
    };
    this.group = group;
    group.add(this._regionsGroup = new Group$4());
    group.add(this._svgGroup = new Group$4());
  }
  MapDraw2.prototype.draw = function(mapOrGeoModel, ecModel, api, fromView, payload) {
    var isGeo = mapOrGeoModel.mainType === "geo";
    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({
      mainType: "series",
      subType: "map"
    }, function(mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    var geo = mapOrGeoModel.coordinateSystem;
    var regionsGroup = this._regionsGroup;
    var group = this.group;
    var transformInfo = geo.getTransformInfo();
    var transformInfoRaw = transformInfo.raw;
    var transformInfoRoam = transformInfo.roam;
    var isFirstDraw = !regionsGroup.childAt(0) || payload;
    if (isFirstDraw) {
      group.x = transformInfoRoam.x;
      group.y = transformInfoRoam.y;
      group.scaleX = transformInfoRoam.scaleX;
      group.scaleY = transformInfoRoam.scaleY;
      group.dirty();
    } else {
      updateProps$1(group, transformInfoRoam, mapOrGeoModel);
    }
    var isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
    var viewBuildCtx = {
      api,
      geo,
      mapOrGeoModel,
      data,
      isVisualEncodedByVisualMap,
      isGeo,
      transformInfoRaw
    };
    if (geo.resourceType === "geoJSON") {
      this._buildGeoJSON(viewBuildCtx);
    } else if (geo.resourceType === "geoSVG") {
      this._buildSVG(viewBuildCtx);
    }
    this._updateController(mapOrGeoModel, ecModel, api);
    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
  };
  MapDraw2.prototype._buildGeoJSON = function(viewBuildCtx) {
    var regionsGroupByName = this._regionsGroupByName = createHashMap();
    var regionsInfoByName = createHashMap();
    var regionsGroup = this._regionsGroup;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
    var data = viewBuildCtx.data;
    var projection2 = viewBuildCtx.geo.projection;
    var projectionStream = projection2 && projection2.stream;
    function transformPoint2(point4, project2) {
      if (project2) {
        point4 = project2(point4);
      }
      return point4 && [point4[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point4[1] * transformInfoRaw.scaleY + transformInfoRaw.y];
    }
    function transformPolygonPoints(inPoints) {
      var outPoints = [];
      var project2 = !projectionStream && projection2 && projection2.project;
      for (var i = 0; i < inPoints.length; ++i) {
        var newPt = transformPoint2(inPoints[i], project2);
        newPt && outPoints.push(newPt);
      }
      return outPoints;
    }
    function getPolyShape(points2) {
      return {
        shape: {
          points: transformPolygonPoints(points2)
        }
      };
    }
    regionsGroup.removeAll();
    each$f(viewBuildCtx.geo.regions, function(region) {
      var regionName = region.name;
      var regionGroup = regionsGroupByName.get(regionName);
      var _a2 = regionsInfoByName.get(regionName) || {}, dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
      if (!regionGroup) {
        regionGroup = regionsGroupByName.set(regionName, new Group$4());
        regionsGroup.add(regionGroup);
        dataIdx = data ? data.indexOfName(regionName) : null;
        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
        regionsInfoByName.set(regionName, {
          dataIdx,
          regionModel
        });
      }
      var polygonSubpaths = [];
      var polylineSubpaths = [];
      each$f(region.geometries, function(geometry2) {
        if (geometry2.type === "polygon") {
          var polys = [geometry2.exterior].concat(geometry2.interiors || []);
          if (projectionStream) {
            polys = projectPolys(polys, projectionStream);
          }
          each$f(polys, function(poly) {
            polygonSubpaths.push(new Polygon$1(getPolyShape(poly)));
          });
        } else {
          var points2 = geometry2.points;
          if (projectionStream) {
            points2 = projectPolys(points2, projectionStream, true);
          }
          each$f(points2, function(points3) {
            polylineSubpaths.push(new Polyline$3(getPolyShape(points3)));
          });
        }
      });
      var centerPt = transformPoint2(region.getCenter(), projection2 && projection2.project);
      function createCompoundPath(subpaths, isLine3) {
        if (!subpaths.length) {
          return;
        }
        var compoundPath = new CompoundPath$1({
          culling: true,
          segmentIgnoreThreshold: 1,
          shape: {
            paths: subpaths
          }
        });
        regionGroup.add(compoundPath);
        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
        if (isLine3) {
          fixLineStyle(compoundPath);
          each$f(compoundPath.states, fixLineStyle);
        }
      }
      createCompoundPath(polygonSubpaths);
      createCompoundPath(polylineSubpaths, true);
    });
    regionsGroupByName.each(function(regionGroup, regionName) {
      var _a2 = regionsInfoByName.get(regionName), dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
    }, this);
  };
  MapDraw2.prototype._buildSVG = function(viewBuildCtx) {
    var mapName = viewBuildCtx.geo.map;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    this._svgGroup.x = transformInfoRaw.x;
    this._svgGroup.y = transformInfoRaw.y;
    this._svgGroup.scaleX = transformInfoRaw.scaleX;
    this._svgGroup.scaleY = transformInfoRaw.scaleY;
    if (this._svgResourceChanged(mapName)) {
      this._freeSVG();
      this._useSVG(mapName);
    }
    var svgDispatcherMap = this._svgDispatcherMap = createHashMap();
    var focusSelf = false;
    each$f(this._svgGraphicRecord.named, function(namedItem) {
      var regionName = namedItem.name;
      var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      var data = viewBuildCtx.data;
      var svgNodeTagLower = namedItem.svgNodeTagLower;
      var el = namedItem.el;
      var dataIdx = data ? data.indexOfName(regionName) : null;
      var regionModel = mapOrGeoModel.getRegionModel(regionName);
      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable$1) {
        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
      }
      if (el instanceof Displayable$1) {
        el.culling = true;
      }
      el.z2EmphasisLift = 0;
      if (!namedItem.namedFrom) {
        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
        }
        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
          var focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
          if (focus_1 === "self") {
            focusSelf = true;
          }
          var els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
          els.push(el);
        }
      }
    }, this);
    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
  };
  MapDraw2.prototype._enableBlurEntireSVG = function(focusSelf, viewBuildCtx) {
    if (focusSelf && viewBuildCtx.isGeo) {
      var blurStyle = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle();
      var opacity_1 = blurStyle.opacity;
      this._svgGraphicRecord.root.traverse(function(el) {
        if (!el.isGroup) {
          setDefaultStateProxy(el);
          var style = el.ensureState("blur").style || {};
          if (style.opacity == null && opacity_1 != null) {
            style.opacity = opacity_1;
          }
          el.ensureState("emphasis");
        }
      });
    }
  };
  MapDraw2.prototype.remove = function() {
    this._regionsGroup.removeAll();
    this._regionsGroupByName = null;
    this._svgGroup.removeAll();
    this._freeSVG();
    this._controller.dispose();
    this._controllerHost = null;
  };
  MapDraw2.prototype.findHighDownDispatchers = function(name2, geoModel) {
    if (name2 == null) {
      return [];
    }
    var geo = geoModel.coordinateSystem;
    if (geo.resourceType === "geoJSON") {
      var regionsGroupByName = this._regionsGroupByName;
      if (regionsGroupByName) {
        var regionGroup = regionsGroupByName.get(name2);
        return regionGroup ? [regionGroup] : [];
      }
    } else if (geo.resourceType === "geoSVG") {
      return this._svgDispatcherMap && this._svgDispatcherMap.get(name2) || [];
    }
  };
  MapDraw2.prototype._svgResourceChanged = function(mapName) {
    return this._svgMapName !== mapName;
  };
  MapDraw2.prototype._useSVG = function(mapName) {
    var resource = geoSourceManager.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      var svgGraphic = resource.useGraphic(this.uid);
      this._svgGroup.add(svgGraphic.root);
      this._svgGraphicRecord = svgGraphic;
      this._svgMapName = mapName;
    }
  };
  MapDraw2.prototype._freeSVG = function() {
    var mapName = this._svgMapName;
    if (mapName == null) {
      return;
    }
    var resource = geoSourceManager.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      resource.freeGraphic(this.uid);
    }
    this._svgGraphicRecord = null;
    this._svgDispatcherMap = null;
    this._svgGroup.removeAll();
    this._svgMapName = null;
  };
  MapDraw2.prototype._updateController = function(mapOrGeoModel, ecModel, api) {
    var geo = mapOrGeoModel.coordinateSystem;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
    controllerHost.zoom = geo.getZoom();
    controller.enable(mapOrGeoModel.get("roam") || false);
    var mainType = mapOrGeoModel.mainType;
    function makeActionBase() {
      var action = {
        type: "geoRoam",
        componentType: mainType
      };
      action[mainType + "Id"] = mapOrGeoModel.id;
      return action;
    }
    controller.off("pan").on("pan", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction(extend2(makeActionBase(), {
        dx: e2.dx,
        dy: e2.dy,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.off("zoom").on("zoom", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction(extend2(makeActionBase(), {
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.setPointerChecker(function(e2, x2, y2) {
      return geo.containPoint([x2, y2]) && !onIrrelevantElement(e2, api, mapOrGeoModel);
    });
  };
  MapDraw2.prototype.resetForLabelLayout = function() {
    this.group.traverse(function(el) {
      var label = el.getTextContent();
      if (label) {
        label.ignore = mapLabelRaw(label).ignore;
      }
    });
  };
  MapDraw2.prototype._updateMapSelectHandler = function(mapOrGeoModel, regionsGroup, api, fromView) {
    var mapDraw2 = this;
    regionsGroup.off("mousedown");
    regionsGroup.off("click");
    if (mapOrGeoModel.get("selectedMode")) {
      regionsGroup.on("mousedown", function() {
        mapDraw2._mouseDownFlag = true;
      });
      regionsGroup.on("click", function(e2) {
        if (!mapDraw2._mouseDownFlag) {
          return;
        }
        mapDraw2._mouseDownFlag = false;
      });
    }
  };
  return MapDraw2;
}();
function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
  var normalStyleModel = regionModel.getModel("itemStyle");
  var emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
  var blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
  var selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
  var normalStyle = getFixedItemStyle(normalStyleModel);
  var emphasisStyle = getFixedItemStyle(emphasisStyleModel);
  var selectStyle = getFixedItemStyle(selectStyleModel);
  var blurStyle = getFixedItemStyle(blurStyleModel);
  var data = viewBuildCtx.data;
  if (data) {
    var style = data.getItemVisual(dataIndex, "style");
    var decal = data.getItemVisual(dataIndex, "decal");
    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
      normalStyle.fill = style.fill;
    }
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
    }
  }
  el.setStyle(normalStyle);
  el.style.strokeNoScale = true;
  el.ensureState("emphasis").style = emphasisStyle;
  el.ensureState("select").style = selectStyle;
  el.ensureState("blur").style = blurStyle;
  setDefaultStateProxy(el);
}
function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
  var data = viewBuildCtx.data;
  var isGeo = viewBuildCtx.isGeo;
  var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
  var itemLayout = data && data.getItemLayout(dataIdx);
  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
    var query5 = !isGeo ? dataIdx : regionName;
    var labelFetcher = void 0;
    if (!data || dataIdx >= 0) {
      labelFetcher = mapOrGeoModel;
    }
    var specifiedTextOpt = labelXY ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(el, getLabelStatesModels(regionModel), {
      labelFetcher,
      labelDataIndex: query5,
      defaultText: regionName
    }, specifiedTextOpt);
    var textEl = el.getTextContent();
    if (textEl) {
      mapLabelRaw(textEl).ignore = textEl.ignore;
      if (el.textConfig && labelXY) {
        var rect = el.getBoundingRect().clone();
        el.textConfig.layoutRect = rect;
        el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + "%", (labelXY[1] - rect.y) / rect.height * 100 + "%"];
      }
    }
    el.disableLabelAnimation = true;
  } else {
    el.removeTextContent();
    el.removeTextConfig();
    el.disableLabelAnimation = null;
  }
}
function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
  if (viewBuildCtx.data) {
    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
  } else {
    getECData(eventTrigger).eventData = {
      componentType: "geo",
      componentIndex: mapOrGeoModel.componentIndex,
      geoIndex: mapOrGeoModel.componentIndex,
      name: regionName,
      region: regionModel && regionModel.option || {}
    };
  }
}
function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  if (!viewBuildCtx.data) {
    setTooltipConfig({
      el,
      componentModel: mapOrGeoModel,
      itemName: regionName,
      itemTooltipOption: regionModel.get("tooltip")
    });
  }
}
function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
  var emphasisModel = regionModel.getModel("emphasis");
  var focus = emphasisModel.get("focus");
  toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  if (viewBuildCtx.isGeo) {
    enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
  }
  return focus;
}
function projectPolys(rings, createStream, isLine3) {
  var polygons2 = [];
  var curPoly;
  function startPolygon() {
    curPoly = [];
  }
  function endPolygon() {
    if (curPoly.length) {
      polygons2.push(curPoly);
      curPoly = [];
    }
  }
  var stream = createStream({
    polygonStart: startPolygon,
    polygonEnd: endPolygon,
    lineStart: startPolygon,
    lineEnd: endPolygon,
    point: function(x2, y2) {
      if (isFinite(x2) && isFinite(y2)) {
        curPoly.push([x2, y2]);
      }
    },
    sphere: function() {
    }
  });
  !isLine3 && stream.polygonStart();
  each$f(rings, function(ring) {
    stream.lineStart();
    for (var i = 0; i < ring.length; i++) {
      stream.point(ring[i][0], ring[i][1]);
    }
    stream.lineEnd();
  });
  !isLine3 && stream.polygonEnd();
  return polygons2;
}
var MapDraw$1 = MapDraw;
var MapView = function(_super) {
  __extends$1(MapView2, _super);
  function MapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MapView2.type;
    return _this;
  }
  MapView2.prototype.render = function(mapModel, ecModel, api, payload) {
    if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
      return;
    }
    var group = this.group;
    group.removeAll();
    if (mapModel.getHostGeoModel()) {
      return;
    }
    if (this._mapDraw && payload && payload.type === "geoRoam") {
      this._mapDraw.resetForLabelLayout();
    }
    if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        var mapDraw2 = this._mapDraw || new MapDraw$1(api);
        group.add(mapDraw2.group);
        mapDraw2.draw(mapModel, ecModel, api, this, payload);
        this._mapDraw = mapDraw2;
      } else {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      var mapDraw2 = this._mapDraw;
      mapDraw2 && group.add(mapDraw2.group);
    }
    mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
  };
  MapView2.prototype.remove = function() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  };
  MapView2.prototype.dispose = function() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  };
  MapView2.prototype._renderSymbols = function(mapModel, ecModel, api) {
    var originalData = mapModel.originalData;
    var group = this.group;
    originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }
      var layout2 = originalData.getItemLayout(originalDataIndex);
      if (!layout2 || !layout2.point) {
        return;
      }
      var point4 = layout2.point;
      var offset = layout2.offset;
      var circle2 = new Circle$1({
        style: {
          fill: mapModel.getData().getVisual("style").fill
        },
        shape: {
          cx: point4[0] + offset * 9,
          cy: point4[1],
          r: 3
        },
        silent: true,
        z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
      });
      if (!offset) {
        var fullData = mapModel.mainSeries.getData();
        var name_1 = originalData.getName(originalDataIndex);
        var fullIndex_1 = fullData.indexOfName(name_1);
        var itemModel = originalData.getItemModel(originalDataIndex);
        var labelModel = itemModel.getModel("label");
        var regionGroup = fullData.getItemGraphicEl(fullIndex_1);
        setLabelStyle(circle2, getLabelStatesModels(itemModel), {
          labelFetcher: {
            getFormattedLabel: function(idx, state) {
              return mapModel.getFormattedLabel(fullIndex_1, state);
            }
          },
          defaultText: name_1
        });
        circle2.disableLabelAnimation = true;
        if (!labelModel.get("position")) {
          circle2.setTextConfig({
            position: "bottom"
          });
        }
        regionGroup.onHoverStateChange = function(toState) {
          setStatesFlag(circle2, toState);
        };
      }
      group.add(circle2);
    });
  };
  MapView2.type = "map";
  return MapView2;
}(ChartView$1);
var MapView$1 = MapView;
var MapSeries = function(_super) {
  __extends$1(MapSeries2, _super);
  function MapSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MapSeries2.type;
    _this.needsDrawMap = false;
    _this.seriesGroup = [];
    _this.getTooltipPosition = function(dataIndex) {
      if (dataIndex != null) {
        var name_1 = this.getData().getName(dataIndex);
        var geo = this.coordinateSystem;
        var region = geo.getRegion(name_1);
        return region && geo.dataToPoint(region.getCenter());
      }
    };
    return _this;
  }
  MapSeries2.prototype.getInitialData = function(option) {
    var data = createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
    var dataNameMap = createHashMap();
    var toAppendNames = [];
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      var name_2 = data.getName(i);
      dataNameMap.set(name_2, true);
    }
    var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    each$f(geoSource.regions, function(region) {
      var name2 = region.name;
      if (!dataNameMap.get(name2)) {
        toAppendNames.push(name2);
      }
    });
    data.appendValues([], toAppendNames);
    return data;
  };
  MapSeries2.prototype.getHostGeoModel = function() {
    var geoIndex = this.option.geoIndex;
    return geoIndex != null ? this.ecModel.getComponent("geo", geoIndex) : null;
  };
  MapSeries2.prototype.getMapType = function() {
    return (this.getHostGeoModel() || this).option.map;
  };
  MapSeries2.prototype.getRawValue = function(dataIndex) {
    var data = this.getData();
    return data.get(data.mapDimension("value"), dataIndex);
  };
  MapSeries2.prototype.getRegionModel = function(regionName) {
    var data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  };
  MapSeries2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name2 = data.getName(dataIndex);
    var seriesGroup = this.seriesGroup;
    var seriesNames = [];
    for (var i = 0; i < seriesGroup.length; i++) {
      var otherIndex = seriesGroup[i].originalData.indexOfName(name2);
      var valueDim = data.mapDimension("value");
      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }
    return createTooltipMarkup("section", {
      header: seriesNames.join(", "),
      noHeader: !seriesNames.length,
      blocks: [createTooltipMarkup("nameValue", {
        name: name2,
        value
      })]
    });
  };
  MapSeries2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  MapSeries2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  MapSeries2.prototype.getLegendIcon = function(opt) {
    var iconType = opt.icon || "roundRect";
    var icon = createSymbol$1(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
    icon.setStyle(opt.itemStyle);
    icon.style.stroke = "none";
    if (iconType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = "#fff";
      icon.style.lineWidth = 2;
    }
    return icon;
  };
  MapSeries2.type = "series.map";
  MapSeries2.dependencies = ["geo"];
  MapSeries2.layoutMode = "box";
  MapSeries2.defaultOption = {
    z: 2,
    coordinateSystem: "geo",
    map: "",
    left: "center",
    top: "center",
    aspectScale: null,
    showLegendSymbol: true,
    boundingCoords: null,
    center: null,
    zoom: 1,
    scaleLimit: null,
    selectedMode: true,
    label: {
      show: false,
      color: "#000"
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: "#444",
      areaColor: "#eee"
    },
    emphasis: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        areaColor: "rgba(255,215,0,0.8)"
      }
    },
    select: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    nameProperty: "name"
  };
  return MapSeries2;
}(SeriesModel$1);
var MapSeries$1 = MapSeries;
function dataStatistics(datas, statisticType) {
  var dataNameMap = {};
  each$f(datas, function(data) {
    data.each(data.mapDimension("value"), function(value, idx) {
      var mapKey = "ec-" + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];
      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
    var mapKey = "ec-" + datas[0].getName(idx);
    var sum2 = 0;
    var min5 = Infinity;
    var max4 = -Infinity;
    var len2 = dataNameMap[mapKey].length;
    for (var i = 0; i < len2; i++) {
      min5 = Math.min(min5, dataNameMap[mapKey][i]);
      max4 = Math.max(max4, dataNameMap[mapKey][i]);
      sum2 += dataNameMap[mapKey][i];
    }
    var result;
    if (statisticType === "min") {
      result = min5;
    } else if (statisticType === "max") {
      result = max4;
    } else if (statisticType === "average") {
      result = sum2 / len2;
    } else {
      result = sum2;
    }
    return len2 === 0 ? NaN : result;
  });
}
function mapDataStatistic(ecModel) {
  var seriesGroups = {};
  ecModel.eachSeriesByType("map", function(seriesModel) {
    var hostGeoModel = seriesModel.getHostGeoModel();
    var key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
  });
  each$f(seriesGroups, function(seriesList, key) {
    var data = dataStatistics(map$1(seriesList, function(seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get("mapValueCalculation"));
    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    }
    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}
function mapSymbolLayout(ecModel) {
  var processedMapType = {};
  ecModel.eachSeriesByType("map", function(mapSeries) {
    var mapType = mapSeries.getMapType();
    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }
    var mapSymbolOffsets = {};
    each$f(mapSeries.seriesGroup, function(subMapSeries) {
      var geo = subMapSeries.coordinateSystem;
      var data2 = subMapSeries.originalData;
      if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
        data2.each(data2.mapDimension("value"), function(value, idx) {
          var name2 = data2.getName(idx);
          var region = geo.getRegion(name2);
          if (!region || isNaN(value)) {
            return;
          }
          var offset = mapSymbolOffsets[name2] || 0;
          var point4 = geo.dataToPoint(region.getCenter());
          mapSymbolOffsets[name2] = offset + 1;
          data2.setItemLayout(idx, {
            point: point4,
            offset
          });
        });
      }
    });
    var data = mapSeries.getData();
    data.each(function(idx) {
      var name2 = data.getName(idx);
      var layout2 = data.getItemLayout(idx) || {};
      layout2.showLabel = !mapSymbolOffsets[name2];
      data.setItemLayout(idx, layout2);
    });
    processedMapType[mapType] = true;
  });
}
var v2ApplyTransform = applyTransform$1;
var View = function(_super) {
  __extends$1(View2, _super);
  function View2(name2) {
    var _this = _super.call(this) || this;
    _this.type = "view";
    _this.dimensions = ["x", "y"];
    _this._roamTransformable = new Transformable$1();
    _this._rawTransformable = new Transformable$1();
    _this.name = name2;
    return _this;
  }
  View2.prototype.setBoundingRect = function(x2, y2, width, height) {
    this._rect = new BoundingRect$1(x2, y2, width, height);
    return this._rect;
  };
  View2.prototype.getBoundingRect = function() {
    return this._rect;
  };
  View2.prototype.setViewRect = function(x2, y2, width, height) {
    this._transformTo(x2, y2, width, height);
    this._viewRect = new BoundingRect$1(x2, y2, width, height);
  };
  View2.prototype._transformTo = function(x2, y2, width, height) {
    var rect = this.getBoundingRect();
    var rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new BoundingRect$1(x2, y2, width, height));
    var rawParent = rawTransform.parent;
    rawTransform.parent = null;
    rawTransform.decomposeTransform();
    rawTransform.parent = rawParent;
    this._updateTransform();
  };
  View2.prototype.setCenter = function(centerCoord, api) {
    if (!centerCoord) {
      return;
    }
    this._center = [parsePercent(centerCoord[0], api.getWidth()), parsePercent(centerCoord[1], api.getHeight())];
    this._updateCenterAndZoom();
  };
  View2.prototype.setZoom = function(zoom) {
    zoom = zoom || 1;
    var zoomLimit = this.zoomLimit;
    if (zoomLimit) {
      if (zoomLimit.max != null) {
        zoom = Math.min(zoomLimit.max, zoom);
      }
      if (zoomLimit.min != null) {
        zoom = Math.max(zoomLimit.min, zoom);
      }
    }
    this._zoom = zoom;
    this._updateCenterAndZoom();
  };
  View2.prototype.getDefaultCenter = function() {
    var rawRect = this.getBoundingRect();
    var cx = rawRect.x + rawRect.width / 2;
    var cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  };
  View2.prototype.getCenter = function() {
    return this._center || this.getDefaultCenter();
  };
  View2.prototype.getZoom = function() {
    return this._zoom || 1;
  };
  View2.prototype.getRoamTransform = function() {
    return this._roamTransformable.getLocalTransform();
  };
  View2.prototype._updateCenterAndZoom = function() {
    var rawTransformMatrix = this._rawTransformable.getLocalTransform();
    var roamTransform = this._roamTransformable;
    var defaultCenter = this.getDefaultCenter();
    var center2 = this.getCenter();
    var zoom = this.getZoom();
    center2 = applyTransform$1([], center2, rawTransformMatrix);
    defaultCenter = applyTransform$1([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center2[0];
    roamTransform.originY = center2[1];
    roamTransform.x = defaultCenter[0] - center2[0];
    roamTransform.y = defaultCenter[1] - center2[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;
    this._updateTransform();
  };
  View2.prototype._updateTransform = function() {
    var roamTransformable = this._roamTransformable;
    var rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    copy7(this.transform || (this.transform = []), rawTransformable.transform || create$1());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    invert(this.invTransform, this.transform);
    this.decomposeTransform();
  };
  View2.prototype.getTransformInfo = function() {
    var rawTransformable = this._rawTransformable;
    var roamTransformable = this._roamTransformable;
    var dummyTransformable2 = new Transformable$1();
    dummyTransformable2.transform = roamTransformable.transform;
    dummyTransformable2.decomposeTransform();
    return {
      roam: {
        x: dummyTransformable2.x,
        y: dummyTransformable2.y,
        scaleX: dummyTransformable2.scaleX,
        scaleY: dummyTransformable2.scaleY
      },
      raw: {
        x: rawTransformable.x,
        y: rawTransformable.y,
        scaleX: rawTransformable.scaleX,
        scaleY: rawTransformable.scaleY
      }
    };
  };
  View2.prototype.getViewRect = function() {
    return this._viewRect;
  };
  View2.prototype.getViewRectAfterRoam = function() {
    var rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  };
  View2.prototype.dataToPoint = function(data, noRoam, out2) {
    var transform4 = noRoam ? this._rawTransform : this.transform;
    out2 = out2 || [];
    return transform4 ? v2ApplyTransform(out2, data, transform4) : copy$1(out2, data);
  };
  View2.prototype.pointToData = function(point4) {
    var invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform([], point4, invTransform) : [point4[0], point4[1]];
  };
  View2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$4(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  View2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$4(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  View2.prototype.containPoint = function(point4) {
    return this.getViewRectAfterRoam().contain(point4[0], point4[1]);
  };
  View2.dimensions = ["x", "y"];
  return View2;
}(Transformable$1);
function getCoordSys$4(finder) {
  var seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null;
}
var View$1 = View;
var GEO_DEFAULT_PARAMS = {
  "geoJSON": {
    aspectScale: 0.75,
    invertLongitute: true
  },
  "geoSVG": {
    aspectScale: 1,
    invertLongitute: false
  }
};
var geo2DDimensions = ["lng", "lat"];
var Geo = function(_super) {
  __extends$1(Geo2, _super);
  function Geo2(name2, map5, opt) {
    var _this = _super.call(this, name2) || this;
    _this.dimensions = geo2DDimensions;
    _this.type = "geo";
    _this._nameCoordMap = createHashMap();
    _this.map = map5;
    var projection2 = opt.projection;
    var source2 = geoSourceManager.load(map5, opt.nameMap, opt.nameProperty);
    var resource = geoSourceManager.getGeoResource(map5);
    var resourceType = _this.resourceType = resource ? resource.type : null;
    var regions = _this.regions = source2.regions;
    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];
    _this._regionsMap = source2.regionsMap;
    _this.regions = source2.regions;
    if (projection2) {
      if (resourceType === "geoSVG") {
        {
          warn("Map " + map5 + " with SVG source can't use projection. Only GeoJSON source supports projection.");
        }
        projection2 = null;
      }
      if (!(projection2.project && projection2.unproject)) {
        {
          warn("project and unproject must be both provided in the projeciton.");
        }
        projection2 = null;
      }
    }
    _this.projection = projection2;
    var boundingRect;
    if (projection2) {
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect(projection2);
        boundingRect = boundingRect || regionRect.clone();
        boundingRect.union(regionRect);
      }
    } else {
      boundingRect = source2.boundingRect;
    }
    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
    _this.aspectScale = projection2 ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale);
    _this._invertLongitute = projection2 ? false : defaultParams.invertLongitute;
    return _this;
  }
  Geo2.prototype._transformTo = function(x2, y2, width, height) {
    var rect = this.getBoundingRect();
    var invertLongitute = this._invertLongitute;
    rect = rect.clone();
    if (invertLongitute) {
      rect.y = -rect.y - rect.height;
    }
    var rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new BoundingRect$1(x2, y2, width, height));
    var rawParent = rawTransformable.parent;
    rawTransformable.parent = null;
    rawTransformable.decomposeTransform();
    rawTransformable.parent = rawParent;
    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }
    this._updateTransform();
  };
  Geo2.prototype.getRegion = function(name2) {
    return this._regionsMap.get(name2);
  };
  Geo2.prototype.getRegionByCoord = function(coord) {
    var regions = this.regions;
    for (var i = 0; i < regions.length; i++) {
      var region = regions[i];
      if (region.type === "geoJSON" && region.contain(coord)) {
        return regions[i];
      }
    }
  };
  Geo2.prototype.addGeoCoord = function(name2, geoCoord2) {
    this._nameCoordMap.set(name2, geoCoord2);
  };
  Geo2.prototype.getGeoCoord = function(name2) {
    var region = this._regionsMap.get(name2);
    return this._nameCoordMap.get(name2) || region && region.getCenter();
  };
  Geo2.prototype.dataToPoint = function(data, noRoam, out2) {
    if (isString(data)) {
      data = this.getGeoCoord(data);
    }
    if (data) {
      var projection2 = this.projection;
      if (projection2) {
        data = projection2.project(data);
      }
      return data && this.projectedToPoint(data, noRoam, out2);
    }
  };
  Geo2.prototype.pointToData = function(point4) {
    var projection2 = this.projection;
    if (projection2) {
      point4 = projection2.unproject(point4);
    }
    return point4 && this.pointToProjected(point4);
  };
  Geo2.prototype.pointToProjected = function(point4) {
    return _super.prototype.pointToData.call(this, point4);
  };
  Geo2.prototype.projectedToPoint = function(projected, noRoam, out2) {
    return _super.prototype.dataToPoint.call(this, projected, noRoam, out2);
  };
  Geo2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$3(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  Geo2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$3(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  return Geo2;
}(View$1);
mixin(Geo, View$1);
function getCoordSys$3(finder) {
  var geoModel = finder.geoModel;
  var seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo$1 = Geo;
function resizeGeo(geoModel, api) {
  var boundingCoords = geoModel.get("boundingCoords");
  if (boundingCoords != null) {
    var leftTop_1 = boundingCoords[0];
    var rightBottom_1 = boundingCoords[1];
    if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1]))) {
      {
        console.error("Invalid boundingCoords");
      }
    } else {
      var projection_1 = this.projection;
      if (projection_1) {
        var xMin = leftTop_1[0];
        var yMin = leftTop_1[1];
        var xMax = rightBottom_1[0];
        var yMax = rightBottom_1[1];
        leftTop_1 = [Infinity, Infinity];
        rightBottom_1 = [-Infinity, -Infinity];
        var sampleLine = function(x02, y02, x12, y12) {
          var dx = x12 - x02;
          var dy = y12 - y02;
          for (var i = 0; i <= 100; i++) {
            var p = i / 100;
            var pt = projection_1.project([x02 + dx * p, y02 + dy * p]);
            min$1(leftTop_1, leftTop_1, pt);
            max$1(rightBottom_1, rightBottom_1, pt);
          }
        };
        sampleLine(xMin, yMin, xMax, yMin);
        sampleLine(xMax, yMin, xMax, yMax);
        sampleLine(xMax, yMax, xMin, yMax);
        sampleLine(xMin, yMax, xMax, yMin);
      }
      this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);
    }
  }
  var rect = this.getBoundingRect();
  var centerOption = geoModel.get("layoutCenter");
  var sizeOption = geoModel.get("layoutSize");
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  var aspect = rect.width / rect.height * this.aspectScale;
  var useCenterAndSize = false;
  var center2;
  var size11;
  if (centerOption && sizeOption) {
    center2 = [parsePercent(centerOption[0], viewWidth), parsePercent(centerOption[1], viewHeight)];
    size11 = parsePercent(sizeOption, Math.min(viewWidth, viewHeight));
    if (!isNaN(center2[0]) && !isNaN(center2[1]) && !isNaN(size11)) {
      useCenterAndSize = true;
    } else {
      {
        console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.");
      }
    }
  }
  var viewRect2;
  if (useCenterAndSize) {
    viewRect2 = {};
    if (aspect > 1) {
      viewRect2.width = size11;
      viewRect2.height = size11 / aspect;
    } else {
      viewRect2.height = size11;
      viewRect2.width = size11 * aspect;
    }
    viewRect2.y = center2[1] - viewRect2.height / 2;
    viewRect2.x = center2[0] - viewRect2.width / 2;
  } else {
    var boxLayoutOption = geoModel.getBoxLayoutParams();
    boxLayoutOption.aspect = aspect;
    viewRect2 = getLayoutRect(boxLayoutOption, {
      width: viewWidth,
      height: viewHeight
    });
  }
  this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
  this.setCenter(geoModel.get("center"), api);
  this.setZoom(geoModel.get("zoom"));
}
function setGeoCoords(geo, model) {
  each$f(model.get("geoCoord"), function(geoCoord2, name2) {
    geo.addGeoCoord(name2, geoCoord2);
  });
}
var GeoCreator = function() {
  function GeoCreator2() {
    this.dimensions = geo2DDimensions;
  }
  GeoCreator2.prototype.create = function(ecModel, api) {
    var geoList = [];
    function getCommonGeoProperties(model) {
      return {
        nameProperty: model.get("nameProperty"),
        aspectScale: model.get("aspectScale"),
        projection: model.get("projection")
      };
    }
    ecModel.eachComponent("geo", function(geoModel, idx) {
      var mapName = geoModel.get("map");
      var geo = new Geo$1(mapName + idx, mapName, extend2({
        nameMap: geoModel.get("nameMap")
      }, getCommonGeoProperties(geoModel)));
      geo.zoomLimit = geoModel.get("scaleLimit");
      geoList.push(geo);
      geoModel.coordinateSystem = geo;
      geo.model = geoModel;
      geo.resize = resizeGeo;
      geo.resize(geoModel, api);
    });
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.get("coordinateSystem");
      if (coordSys === "geo") {
        var geoIndex = seriesModel.get("geoIndex") || 0;
        seriesModel.coordinateSystem = geoList[geoIndex];
      }
    });
    var mapModelGroupBySeries = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        var mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    each$f(mapModelGroupBySeries, function(mapSeries, mapType) {
      var nameMapList = map$1(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("nameMap");
      });
      var geo = new Geo$1(mapType, mapType, extend2({
        nameMap: mergeAll(nameMapList)
      }, getCommonGeoProperties(mapSeries[0])));
      geo.zoomLimit = retrieve.apply(null, map$1(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("scaleLimit");
      }));
      geoList.push(geo);
      geo.resize = resizeGeo;
      geo.resize(mapSeries[0], api);
      each$f(mapSeries, function(singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  };
  GeoCreator2.prototype.getFilledRegions = function(originRegionArr, mapName, nameMap, nameProperty) {
    var regionsArr = (originRegionArr || []).slice();
    var dataNameMap = createHashMap();
    for (var i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }
    var source2 = geoSourceManager.load(mapName, nameMap, nameProperty);
    each$f(source2.regions, function(region) {
      var name2 = region.name;
      !dataNameMap.get(name2) && regionsArr.push({
        name: name2
      });
    });
    return regionsArr;
  };
  return GeoCreator2;
}();
var geoCreator = new GeoCreator();
var geoCreator$1 = geoCreator;
var GeoModel = function(_super) {
  __extends$1(GeoModel2, _super);
  function GeoModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GeoModel2.type;
    return _this;
  }
  GeoModel2.prototype.init = function(option, parentModel, ecModel) {
    var source2 = geoSourceManager.getGeoResource(option.map);
    if (source2 && source2.type === "geoJSON") {
      var itemStyle = option.itemStyle = option.itemStyle || {};
      if (!("color" in itemStyle)) {
        itemStyle.color = "#eee";
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    defaultEmphasis(option, "label", ["show"]);
  };
  GeoModel2.prototype.optionUpdated = function() {
    var _this = this;
    var option = this.option;
    option.regions = geoCreator$1.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
    var selectedMap = {};
    this._optionModelMap = reduce(option.regions || [], function(optionModelMap, regionOpt) {
      var regionName = regionOpt.name;
      if (regionName) {
        optionModelMap.set(regionName, new Model$1(regionOpt, _this, _this.ecModel));
        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }
      return optionModelMap;
    }, createHashMap());
    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  };
  GeoModel2.prototype.getRegionModel = function(name2) {
    return this._optionModelMap.get(name2) || new Model$1(null, this, this.ecModel);
  };
  GeoModel2.prototype.getFormattedLabel = function(name2, status) {
    var regionModel = this.getRegionModel(name2);
    var formatter = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get(["emphasis", "label", "formatter"]);
    var params = {
      name: name2
    };
    if (isFunction(formatter)) {
      params.status = status;
      return formatter(params);
    } else if (isString(formatter)) {
      return formatter.replace("{a}", name2 != null ? name2 : "");
    }
  };
  GeoModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  GeoModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  GeoModel2.prototype.select = function(name2) {
    var option = this.option;
    var selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    if (selectedMode !== "multiple") {
      option.selectedMap = null;
    }
    var selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name2] = true;
  };
  GeoModel2.prototype.unSelect = function(name2) {
    var selectedMap = this.option.selectedMap;
    if (selectedMap) {
      selectedMap[name2] = false;
    }
  };
  GeoModel2.prototype.toggleSelected = function(name2) {
    this[this.isSelected(name2) ? "unSelect" : "select"](name2);
  };
  GeoModel2.prototype.isSelected = function(name2) {
    var selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name2]);
  };
  GeoModel2.type = "geo";
  GeoModel2.layoutMode = "box";
  GeoModel2.defaultOption = {
    z: 0,
    show: true,
    left: "center",
    top: "center",
    aspectScale: null,
    silent: false,
    map: "",
    boundingCoords: null,
    center: null,
    zoom: 1,
    scaleLimit: null,
    label: {
      show: false,
      color: "#000"
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: "#444"
    },
    emphasis: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    select: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    regions: []
  };
  return GeoModel2;
}(ComponentModel$1);
var GeoModel$1 = GeoModel;
function getCenterCoord(view, point4) {
  return view.pointToProjected ? view.pointToProjected(point4) : view.pointToData(point4);
}
function updateCenterAndZoom(view, payload, zoomLimit, api) {
  var previousZoom = view.getZoom();
  var center2 = view.getCenter();
  var zoom = payload.zoom;
  var point4 = view.projectedToPoint ? view.projectedToPoint(center2) : view.dataToPoint(center2);
  if (payload.dx != null && payload.dy != null) {
    point4[0] -= payload.dx;
    point4[1] -= payload.dy;
    view.setCenter(getCenterCoord(view, point4), api);
  }
  if (zoom != null) {
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    }
    view.scaleX *= zoom;
    view.scaleY *= zoom;
    var fixX = (payload.originX - view.x) * (zoom - 1);
    var fixY = (payload.originY - view.y) * (zoom - 1);
    view.x -= fixX;
    view.y -= fixY;
    view.updateTransform();
    view.setCenter(getCenterCoord(view, point4), api);
    view.setZoom(zoom * previousZoom);
  }
  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}
var GeoView = function(_super) {
  __extends$1(GeoView2, _super);
  function GeoView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GeoView2.type;
    _this.focusBlurEnabled = true;
    return _this;
  }
  GeoView2.prototype.init = function(ecModel, api) {
    this._api = api;
  };
  GeoView2.prototype.render = function(geoModel, ecModel, api, payload) {
    this._model = geoModel;
    if (!geoModel.get("show")) {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      return;
    }
    if (!this._mapDraw) {
      this._mapDraw = new MapDraw$1(api);
    }
    var mapDraw2 = this._mapDraw;
    mapDraw2.draw(geoModel, ecModel, api, this, payload);
    mapDraw2.group.on("click", this._handleRegionClick, this);
    mapDraw2.group.silent = geoModel.get("silent");
    this.group.add(mapDraw2.group);
    this.updateSelectStatus(geoModel, ecModel, api);
  };
  GeoView2.prototype._handleRegionClick = function(e2) {
    var eventData;
    findEventDispatcher(e2.target, function(current) {
      return (eventData = getECData(current).eventData) != null;
    }, true);
    if (eventData) {
      this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: eventData.name
      });
    }
  };
  GeoView2.prototype.updateSelectStatus = function(model, ecModel, api) {
    var _this = this;
    this._mapDraw.group.traverse(function(node) {
      var eventData = getECData(node).eventData;
      if (eventData) {
        _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);
        return true;
      }
    });
  };
  GeoView2.prototype.findHighDownDispatchers = function(name2) {
    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name2, this._model);
  };
  GeoView2.prototype.dispose = function() {
    this._mapDraw && this._mapDraw.remove();
  };
  GeoView2.type = "geo";
  return GeoView2;
}(ComponentView$1);
var GeoView$1 = GeoView;
function registerMap(mapName, geoJson, specialAreas) {
  geoSourceManager.registerMap(mapName, geoJson, specialAreas);
}
function install$J(registers) {
  registers.registerCoordinateSystem("geo", geoCreator$1);
  registers.registerComponentModel(GeoModel$1);
  registers.registerComponentView(GeoView$1);
  registers.registerImpl("registerMap", registerMap);
  registers.registerImpl("getMap", function(mapName) {
    return geoSourceManager.getMapForUser(mapName);
  });
  function makeAction(method, actionInfo2) {
    actionInfo2.update = "geo:updateSelectStatus";
    registers.registerAction(actionInfo2, function(payload, ecModel) {
      var selected = {};
      var allSelected = [];
      ecModel.eachComponent({
        mainType: "geo",
        query: payload
      }, function(geoModel) {
        geoModel[method](payload.name);
        var geo = geoModel.coordinateSystem;
        each$f(geo.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
        var names = [];
        each$f(selected, function(v, name2) {
          selected[name2] && names.push(name2);
        });
        allSelected.push({
          geoIndex: geoModel.componentIndex,
          name: names
        });
      });
      return {
        selected,
        allSelected,
        name: payload.name
      };
    });
  }
  makeAction("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  });
  makeAction("select", {
    type: "geoSelect",
    event: "geoselected"
  });
  makeAction("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  });
  registers.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(payload, ecModel, api) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      var geo = componentModel.coordinateSystem;
      if (geo.type !== "geo") {
        return;
      }
      var res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"), api);
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === "series") {
        each$f(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}
function install$I(registers) {
  use2(install$J);
  registers.registerChartView(MapView$1);
  registers.registerSeriesModel(MapSeries$1);
  registers.registerLayout(mapSymbolLayout);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
  createLegacyDataSelectAction("map", registers.registerAction);
}
function init8(inRoot) {
  var root = inRoot;
  root.hierNode = {
    defaultAncestor: null,
    ancestor: root,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  var nodes = [root];
  var node;
  var children;
  while (node = nodes.pop()) {
    children = node.children;
    if (node.isExpand && children.length) {
      var n = children.length;
      for (var i = n - 1; i >= 0; i--) {
        var child = children[i];
        child.hierNode = {
          defaultAncestor: null,
          ancestor: child,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i,
          thread: null
        };
        nodes.push(child);
      }
    }
  }
}
function firstWalk(node, separation2) {
  var children = node.isExpand ? node.children : [];
  var siblings = node.parentNode.children;
  var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
  if (children.length) {
    executeShifts(node);
    var midPoint3 = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
    if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
      node.hierNode.modifier = node.hierNode.prelim - midPoint3;
    } else {
      node.hierNode.prelim = midPoint3;
    }
  } else if (subtreeW) {
    node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
  }
  node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
}
function secondWalk(node) {
  var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
  node.setLayout({
    x: nodeX
  }, true);
  node.hierNode.modifier += node.parentNode.hierNode.modifier;
}
function separation(cb) {
  return arguments.length ? cb : defaultSeparation;
}
function radialCoordinate(rad2, r) {
  rad2 -= Math.PI / 2;
  return {
    x: r * Math.cos(rad2),
    y: r * Math.sin(rad2)
  };
}
function getViewRect$4(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function executeShifts(node) {
  var children = node.children;
  var n = children.length;
  var shift = 0;
  var change = 0;
  while (--n >= 0) {
    var child = children[n];
    child.hierNode.prelim += shift;
    child.hierNode.modifier += shift;
    change += child.hierNode.change;
    shift += child.hierNode.shift + change;
  }
}
function apportion(subtreeV, subtreeW, ancestor, separation2) {
  if (subtreeW) {
    var nodeOutRight = subtreeV;
    var nodeInRight = subtreeV;
    var nodeOutLeft = nodeInRight.parentNode.children[0];
    var nodeInLeft = subtreeW;
    var sumOutRight = nodeOutRight.hierNode.modifier;
    var sumInRight = nodeInRight.hierNode.modifier;
    var sumOutLeft = nodeOutLeft.hierNode.modifier;
    var sumInLeft = nodeInLeft.hierNode.modifier;
    while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
      nodeOutRight = nextRight(nodeOutRight);
      nodeOutLeft = nextLeft(nodeOutLeft);
      nodeOutRight.hierNode.ancestor = subtreeV;
      var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
      if (shift > 0) {
        moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
        sumInRight += shift;
        sumOutRight += shift;
      }
      sumInLeft += nodeInLeft.hierNode.modifier;
      sumInRight += nodeInRight.hierNode.modifier;
      sumOutRight += nodeOutRight.hierNode.modifier;
      sumOutLeft += nodeOutLeft.hierNode.modifier;
    }
    if (nodeInLeft && !nextRight(nodeOutRight)) {
      nodeOutRight.hierNode.thread = nodeInLeft;
      nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
    }
    if (nodeInRight && !nextLeft(nodeOutLeft)) {
      nodeOutLeft.hierNode.thread = nodeInRight;
      nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
      ancestor = subtreeV;
    }
  }
  return ancestor;
}
function nextRight(node) {
  var children = node.children;
  return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
}
function nextLeft(node) {
  var children = node.children;
  return children.length && node.isExpand ? children[0] : node.hierNode.thread;
}
function nextAncestor(nodeInLeft, node, ancestor) {
  return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
}
function moveSubtree(wl, wr, shift) {
  var change = shift / (wr.hierNode.i - wl.hierNode.i);
  wr.hierNode.change -= change;
  wr.hierNode.shift += shift;
  wr.hierNode.modifier += shift;
  wr.hierNode.prelim += shift;
  wl.hierNode.change += change;
}
function defaultSeparation(node1, node2) {
  return node1.parentNode === node2.parentNode ? 1 : 2;
}
var TreeEdgeShape = function() {
  function TreeEdgeShape2() {
    this.parentPoint = [];
    this.childPoints = [];
  }
  return TreeEdgeShape2;
}();
var TreePath = function(_super) {
  __extends$1(TreePath2, _super);
  function TreePath2(opts) {
    return _super.call(this, opts) || this;
  }
  TreePath2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  TreePath2.prototype.getDefaultShape = function() {
    return new TreeEdgeShape();
  };
  TreePath2.prototype.buildPath = function(ctx, shape) {
    var childPoints = shape.childPoints;
    var childLen = childPoints.length;
    var parentPoint = shape.parentPoint;
    var firstChildPos = childPoints[0];
    var lastChildPos = childPoints[childLen - 1];
    if (childLen === 1) {
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(firstChildPos[0], firstChildPos[1]);
      return;
    }
    var orient2 = shape.orient;
    var forkDim = orient2 === "TB" || orient2 === "BT" ? 0 : 1;
    var otherDim = 1 - forkDim;
    var forkPosition = parsePercent(shape.forkPosition, 1);
    var tmpPoint = [];
    tmpPoint[forkDim] = parentPoint[forkDim];
    tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
    ctx.moveTo(parentPoint[0], parentPoint[1]);
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.moveTo(firstChildPos[0], firstChildPos[1]);
    tmpPoint[forkDim] = firstChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    tmpPoint[forkDim] = lastChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.lineTo(lastChildPos[0], lastChildPos[1]);
    for (var i = 1; i < childLen - 1; i++) {
      var point4 = childPoints[i];
      ctx.moveTo(point4[0], point4[1]);
      tmpPoint[forkDim] = point4[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    }
  };
  return TreePath2;
}(Path$1);
var TreeView = function(_super) {
  __extends$1(TreeView2, _super);
  function TreeView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TreeView2.type;
    _this._mainGroup = new Group$4();
    return _this;
  }
  TreeView2.prototype.init = function(ecModel, api) {
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: this.group
    };
    this.group.add(this._mainGroup);
  };
  TreeView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var layoutInfo = seriesModel.layoutInfo;
    var group = this._mainGroup;
    var layout2 = seriesModel.get("layout");
    if (layout2 === "radial") {
      group.x = layoutInfo.x + layoutInfo.width / 2;
      group.y = layoutInfo.y + layoutInfo.height / 2;
    } else {
      group.x = layoutInfo.x;
      group.y = layoutInfo.y;
    }
    this._updateViewCoordSys(seriesModel, api);
    this._updateController(seriesModel, ecModel, api);
    var oldData = this._data;
    data.diff(oldData).add(function(newIdx) {
      if (symbolNeedsDraw(data, newIdx)) {
        updateNode(data, newIdx, null, group, seriesModel);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!symbolNeedsDraw(data, newIdx)) {
        symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
        return;
      }
      updateNode(data, newIdx, symbolEl, group, seriesModel);
    }).remove(function(oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (symbolEl) {
        removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
      }
    }).execute();
    this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
    this._updateNodeAndLinkScale(seriesModel);
    if (seriesModel.get("expandAndCollapse") === true) {
      data.eachItemGraphicEl(function(el, dataIndex) {
        el.off("click").on("click", function() {
          api.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: seriesModel.id,
            dataIndex
          });
        });
      });
    }
    this._data = data;
  };
  TreeView2.prototype._updateViewCoordSys = function(seriesModel, api) {
    var data = seriesModel.getData();
    var points2 = [];
    data.each(function(idx) {
      var layout2 = data.getItemLayout(idx);
      if (layout2 && !isNaN(layout2.x) && !isNaN(layout2.y)) {
        points2.push([+layout2.x, +layout2.y]);
      }
    });
    var min5 = [];
    var max4 = [];
    fromPoints(points2, min5, max4);
    var oldMin = this._min;
    var oldMax = this._max;
    if (max4[0] - min5[0] === 0) {
      min5[0] = oldMin ? oldMin[0] : min5[0] - 1;
      max4[0] = oldMax ? oldMax[0] : max4[0] + 1;
    }
    if (max4[1] - min5[1] === 0) {
      min5[1] = oldMin ? oldMin[1] : min5[1] - 1;
      max4[1] = oldMax ? oldMax[1] : max4[1] + 1;
    }
    var viewCoordSys = seriesModel.coordinateSystem = new View$1();
    viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
    viewCoordSys.setBoundingRect(min5[0], min5[1], max4[0] - min5[0], max4[1] - min5[1]);
    viewCoordSys.setCenter(seriesModel.get("center"), api);
    viewCoordSys.setZoom(seriesModel.get("zoom"));
    this.group.attr({
      x: viewCoordSys.x,
      y: viewCoordSys.y,
      scaleX: viewCoordSys.scaleX,
      scaleY: viewCoordSys.scaleY
    });
    this._min = min5;
    this._max = max4;
  };
  TreeView2.prototype._updateController = function(seriesModel, ecModel, api) {
    var _this = this;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    var group = this.group;
    controller.setPointerChecker(function(e2, x2, y2) {
      var rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x2, y2) && !onIrrelevantElement(e2, api, seriesModel);
    });
    controller.enable(seriesModel.get("roam"));
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off("pan").off("zoom").on("pan", function(e2) {
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "treeRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", function(e2) {
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "treeRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
      _this._updateNodeAndLinkScale(seriesModel);
      api.updateLabelLayout();
    });
  };
  TreeView2.prototype._updateNodeAndLinkScale = function(seriesModel) {
    var data = seriesModel.getData();
    var nodeScale = this._getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el.setSymbolScale(nodeScale);
    });
  };
  TreeView2.prototype._getNodeGlobalScale = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type !== "view") {
      return 1;
    }
    var nodeScaleRatio = this._nodeScaleRatio;
    var groupZoom = coordSys.scaleX || 1;
    var roamZoom = coordSys.getZoom();
    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  };
  TreeView2.prototype.dispose = function() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  };
  TreeView2.prototype.remove = function() {
    this._mainGroup.removeAll();
    this._data = null;
  };
  TreeView2.type = "tree";
  return TreeView2;
}(ChartView$1);
function symbolNeedsDraw(data, dataIndex) {
  var layout2 = data.getItemLayout(dataIndex);
  return layout2 && !isNaN(layout2.x) && !isNaN(layout2.y);
}
function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
  var isInit = !symbolEl;
  var node = data.tree.getNodeByDataIndex(dataIndex);
  var itemModel = node.getModel();
  var visualColor = node.getVisual("style").fill;
  var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : "#fff";
  var virtualRoot = data.tree.root;
  var source2 = node.parentNode === virtualRoot ? node : node.parentNode || node;
  var sourceSymbolEl = data.getItemGraphicEl(source2.dataIndex);
  var sourceLayout = source2.getLayout();
  var sourceOldLayout = sourceSymbolEl ? {
    x: sourceSymbolEl.__oldX,
    y: sourceSymbolEl.__oldY,
    rawX: sourceSymbolEl.__radialOldRawX,
    rawY: sourceSymbolEl.__radialOldRawY
  } : sourceLayout;
  var targetLayout = node.getLayout();
  if (isInit) {
    symbolEl = new SymbolClz(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
    symbolEl.x = sourceOldLayout.x;
    symbolEl.y = sourceOldLayout.y;
  } else {
    symbolEl.updateData(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
  }
  symbolEl.__radialOldRawX = symbolEl.__radialRawX;
  symbolEl.__radialOldRawY = symbolEl.__radialRawY;
  symbolEl.__radialRawX = targetLayout.rawX;
  symbolEl.__radialRawY = targetLayout.rawY;
  group.add(symbolEl);
  data.setItemGraphicEl(dataIndex, symbolEl);
  symbolEl.__oldX = symbolEl.x;
  symbolEl.__oldY = symbolEl.y;
  updateProps$1(symbolEl, {
    x: targetLayout.x,
    y: targetLayout.y
  }, seriesModel);
  var symbolPath = symbolEl.getSymbolPath();
  if (seriesModel.get("layout") === "radial") {
    var realRoot = virtualRoot.children[0];
    var rootLayout = realRoot.getLayout();
    var length_1 = realRoot.children.length;
    var rad2 = void 0;
    var isLeft2 = void 0;
    if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {
      var center2 = {
        x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,
        y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2
      };
      rad2 = Math.atan2(center2.y - rootLayout.y, center2.x - rootLayout.x);
      if (rad2 < 0) {
        rad2 = Math.PI * 2 + rad2;
      }
      isLeft2 = center2.x < rootLayout.x;
      if (isLeft2) {
        rad2 = rad2 - Math.PI;
      }
    } else {
      rad2 = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
      if (rad2 < 0) {
        rad2 = Math.PI * 2 + rad2;
      }
      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
        isLeft2 = targetLayout.x < rootLayout.x;
        if (isLeft2) {
          rad2 = rad2 - Math.PI;
        }
      } else {
        isLeft2 = targetLayout.x > rootLayout.x;
        if (!isLeft2) {
          rad2 = rad2 - Math.PI;
        }
      }
    }
    var textPosition = isLeft2 ? "left" : "right";
    var normalLabelModel = itemModel.getModel("label");
    var rotate2 = normalLabelModel.get("rotate");
    var labelRotateRadian = rotate2 * (Math.PI / 180);
    var textContent = symbolPath.getTextContent();
    if (textContent) {
      symbolPath.setTextConfig({
        position: normalLabelModel.get("position") || textPosition,
        rotation: rotate2 == null ? -rad2 : labelRotateRadian,
        origin: "center"
      });
      textContent.setStyle("verticalAlign", "middle");
    }
  }
  var focus = itemModel.get(["emphasis", "focus"]);
  var focusDataIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : null;
  if (focusDataIndices) {
    getECData(symbolEl).focus = focusDataIndices;
  }
  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);
  if (symbolEl.__edge) {
    symbolEl.onHoverStateChange = function(toState) {
      if (toState !== "blur") {
        var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);
        if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {
          setStatesFlag(symbolEl.__edge, toState);
        }
      }
    };
  }
}
function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
  var itemModel = node.getModel();
  var edgeShape = seriesModel.get("edgeShape");
  var layout2 = seriesModel.get("layout");
  var orient2 = seriesModel.getOrient();
  var curvature = seriesModel.get(["lineStyle", "curveness"]);
  var edgeForkPosition = seriesModel.get("edgeForkPosition");
  var lineStyle = itemModel.getModel("lineStyle").getLineStyle();
  var edge = symbolEl.__edge;
  if (edgeShape === "curve") {
    if (node.parentNode && node.parentNode !== virtualRoot) {
      if (!edge) {
        edge = symbolEl.__edge = new BezierCurve$1({
          shape: getEdgeShape(layout2, orient2, curvature, sourceOldLayout, sourceOldLayout)
        });
      }
      updateProps$1(edge, {
        shape: getEdgeShape(layout2, orient2, curvature, sourceLayout, targetLayout)
      }, seriesModel);
    }
  } else if (edgeShape === "polyline") {
    if (layout2 === "orthogonal") {
      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
        var children = node.children;
        var childPoints = [];
        for (var i = 0; i < children.length; i++) {
          var childLayout = children[i].getLayout();
          childPoints.push([childLayout.x, childLayout.y]);
        }
        if (!edge) {
          edge = symbolEl.__edge = new TreePath({
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints: [[targetLayout.x, targetLayout.y]],
              orient: orient2,
              forkPosition: edgeForkPosition
            }
          });
        }
        updateProps$1(edge, {
          shape: {
            parentPoint: [targetLayout.x, targetLayout.y],
            childPoints
          }
        }, seriesModel);
      }
    } else {
      {
        throw new Error("The polyline edgeShape can only be used in orthogonal layout");
      }
    }
  }
  if (edge && !(edgeShape === "polyline" && !node.isExpand)) {
    edge.useStyle(defaults({
      strokeNoScale: true,
      fill: null
    }, lineStyle));
    setStatesStylesFromModel(edge, itemModel, "lineStyle");
    setDefaultStateProxy(edge);
    group.add(edge);
  }
}
function removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {
  var virtualRoot = data.tree.root;
  var _a2 = getSourceNode(virtualRoot, node), source2 = _a2.source, sourceLayout = _a2.sourceLayout;
  var symbolEl = data.getItemGraphicEl(node.dataIndex);
  if (!symbolEl) {
    return;
  }
  var sourceSymbolEl = data.getItemGraphicEl(source2.dataIndex);
  var sourceEdge = sourceSymbolEl.__edge;
  var edge = symbolEl.__edge || (source2.isExpand === false || source2.children.length === 1 ? sourceEdge : void 0);
  var edgeShape = seriesModel.get("edgeShape");
  var layoutOpt = seriesModel.get("layout");
  var orient2 = seriesModel.get("orient");
  var curvature = seriesModel.get(["lineStyle", "curveness"]);
  if (edge) {
    if (edgeShape === "curve") {
      removeElement(edge, {
        shape: getEdgeShape(layoutOpt, orient2, curvature, sourceLayout, sourceLayout),
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb: function() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    } else if (edgeShape === "polyline" && seriesModel.get("layout") === "orthogonal") {
      removeElement(edge, {
        shape: {
          parentPoint: [sourceLayout.x, sourceLayout.y],
          childPoints: [[sourceLayout.x, sourceLayout.y]]
        },
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb: function() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    }
  }
}
function getSourceNode(virtualRoot, node) {
  var source2 = node.parentNode === virtualRoot ? node : node.parentNode || node;
  var sourceLayout;
  while (sourceLayout = source2.getLayout(), sourceLayout == null) {
    source2 = source2.parentNode === virtualRoot ? source2 : source2.parentNode || source2;
  }
  return {
    source: source2,
    sourceLayout
  };
}
function removeNode(data, dataIndex, symbolEl, group, seriesModel) {
  var node = data.tree.getNodeByDataIndex(dataIndex);
  var virtualRoot = data.tree.root;
  var sourceLayout = getSourceNode(virtualRoot, node).sourceLayout;
  var removeAnimationOpt = {
    duration: seriesModel.get("animationDurationUpdate"),
    easing: seriesModel.get("animationEasingUpdate")
  };
  removeElement(symbolEl, {
    x: sourceLayout.x + 1,
    y: sourceLayout.y + 1
  }, seriesModel, {
    cb: function() {
      group.remove(symbolEl);
      data.setItemGraphicEl(dataIndex, null);
    },
    removeOpt: removeAnimationOpt
  });
  symbolEl.fadeOut(null, data.hostModel, {
    fadeLabel: true,
    animation: removeAnimationOpt
  });
  node.children.forEach(function(childNode) {
    removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);
  });
  removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);
}
function getEdgeShape(layoutOpt, orient2, curvature, sourceLayout, targetLayout) {
  var cpx1;
  var cpy1;
  var cpx2;
  var cpy2;
  var x12;
  var x2;
  var y12;
  var y2;
  if (layoutOpt === "radial") {
    x12 = sourceLayout.rawX;
    y12 = sourceLayout.rawY;
    x2 = targetLayout.rawX;
    y2 = targetLayout.rawY;
    var radialCoor1 = radialCoordinate(x12, y12);
    var radialCoor2 = radialCoordinate(x12, y12 + (y2 - y12) * curvature);
    var radialCoor3 = radialCoordinate(x2, y2 + (y12 - y2) * curvature);
    var radialCoor4 = radialCoordinate(x2, y2);
    return {
      x1: radialCoor1.x || 0,
      y1: radialCoor1.y || 0,
      x2: radialCoor4.x || 0,
      y2: radialCoor4.y || 0,
      cpx1: radialCoor2.x || 0,
      cpy1: radialCoor2.y || 0,
      cpx2: radialCoor3.x || 0,
      cpy2: radialCoor3.y || 0
    };
  } else {
    x12 = sourceLayout.x;
    y12 = sourceLayout.y;
    x2 = targetLayout.x;
    y2 = targetLayout.y;
    if (orient2 === "LR" || orient2 === "RL") {
      cpx1 = x12 + (x2 - x12) * curvature;
      cpy1 = y12;
      cpx2 = x2 + (x12 - x2) * curvature;
      cpy2 = y2;
    }
    if (orient2 === "TB" || orient2 === "BT") {
      cpx1 = x12;
      cpy1 = y12 + (y2 - y12) * curvature;
      cpx2 = x2;
      cpy2 = y2 + (y12 - y2) * curvature;
    }
  }
  return {
    x1: x12,
    y1: y12,
    x2,
    y2,
    cpx1,
    cpy1,
    cpx2,
    cpy2
  };
}
var TreeView$1 = TreeView;
var inner$e = makeInner();
function linkSeriesData(opt) {
  var mainData = opt.mainData;
  var datas = opt.datas;
  if (!datas) {
    datas = {
      main: mainData
    };
    opt.datasAttr = {
      main: "data"
    };
  }
  opt.datas = opt.mainData = null;
  linkAll(mainData, datas, opt);
  each$f(datas, function(data) {
    each$f(mainData.TRANSFERABLE_METHODS, function(methodName) {
      data.wrapMethod(methodName, curry$1(transferInjection, opt));
    });
  });
  mainData.wrapMethod("cloneShallow", curry$1(cloneShallowInjection, opt));
  each$f(mainData.CHANGABLE_METHODS, function(methodName) {
    mainData.wrapMethod(methodName, curry$1(changeInjection, opt));
  });
  assert(datas[mainData.dataType] === mainData);
}
function transferInjection(opt, res) {
  if (isMainData(this)) {
    var datas = extend2({}, inner$e(this).datas);
    datas[this.dataType] = res;
    linkAll(res, datas, opt);
  } else {
    linkSingle(res, this.dataType, inner$e(this).mainData, opt);
  }
  return res;
}
function changeInjection(opt, res) {
  opt.struct && opt.struct.update();
  return res;
}
function cloneShallowInjection(opt, res) {
  each$f(inner$e(res).datas, function(data, dataType) {
    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
  });
  return res;
}
function getLinkedData(dataType) {
  var mainData = inner$e(this).mainData;
  return dataType == null || mainData == null ? mainData : inner$e(mainData).datas[dataType];
}
function getLinkedDataAll() {
  var mainData = inner$e(this).mainData;
  return mainData == null ? [{
    data: mainData
  }] : map$1(keys2(inner$e(mainData).datas), function(type) {
    return {
      type,
      data: inner$e(mainData).datas[type]
    };
  });
}
function isMainData(data) {
  return inner$e(data).mainData === data;
}
function linkAll(mainData, datas, opt) {
  inner$e(mainData).datas = {};
  each$f(datas, function(data, dataType) {
    linkSingle(data, dataType, mainData, opt);
  });
}
function linkSingle(data, dataType, mainData, opt) {
  inner$e(mainData).datas[dataType] = data;
  inner$e(data).mainData = mainData;
  data.dataType = dataType;
  if (opt.struct) {
    data[opt.structAttr] = opt.struct;
    opt.struct[opt.datasAttr[dataType]] = data;
  }
  data.getLinkedData = getLinkedData;
  data.getLinkedDataAll = getLinkedDataAll;
}
var TreeNode = function() {
  function TreeNode2(name2, hostTree) {
    this.depth = 0;
    this.height = 0;
    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.isExpand = false;
    this.name = name2 || "";
    this.hostTree = hostTree;
  }
  TreeNode2.prototype.isRemoved = function() {
    return this.dataIndex < 0;
  };
  TreeNode2.prototype.eachNode = function(options, cb, context) {
    if (isFunction(options)) {
      context = cb;
      cb = options;
      options = null;
    }
    options = options || {};
    if (isString(options)) {
      options = {
        order: options
      };
    }
    var order = options.order || "preorder";
    var children = this[options.attr || "children"];
    var suppressVisitSub;
    order === "preorder" && (suppressVisitSub = cb.call(context, this));
    for (var i = 0; !suppressVisitSub && i < children.length; i++) {
      children[i].eachNode(options, cb, context);
    }
    order === "postorder" && cb.call(context, this);
  };
  TreeNode2.prototype.updateDepthAndHeight = function(depth2) {
    var height = 0;
    this.depth = depth2;
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      child.updateDepthAndHeight(depth2 + 1);
      if (child.height > height) {
        height = child.height;
      }
    }
    this.height = height + 1;
  };
  TreeNode2.prototype.getNodeById = function(id) {
    if (this.getId() === id) {
      return this;
    }
    for (var i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      var res = children[i].getNodeById(id);
      if (res) {
        return res;
      }
    }
  };
  TreeNode2.prototype.contains = function(node) {
    if (node === this) {
      return true;
    }
    for (var i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      var res = children[i].contains(node);
      if (res) {
        return res;
      }
    }
  };
  TreeNode2.prototype.getAncestors = function(includeSelf) {
    var ancestors = [];
    var node = includeSelf ? this : this.parentNode;
    while (node) {
      ancestors.push(node);
      node = node.parentNode;
    }
    ancestors.reverse();
    return ancestors;
  };
  TreeNode2.prototype.getAncestorsIndices = function() {
    var indices = [];
    var currNode = this;
    while (currNode) {
      indices.push(currNode.dataIndex);
      currNode = currNode.parentNode;
    }
    indices.reverse();
    return indices;
  };
  TreeNode2.prototype.getDescendantIndices = function() {
    var indices = [];
    this.eachNode(function(childNode) {
      indices.push(childNode.dataIndex);
    });
    return indices;
  };
  TreeNode2.prototype.getValue = function(dimension) {
    var data = this.hostTree.data;
    return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
  };
  TreeNode2.prototype.setLayout = function(layout2, merge4) {
    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout2, merge4);
  };
  TreeNode2.prototype.getLayout = function() {
    return this.hostTree.data.getItemLayout(this.dataIndex);
  };
  TreeNode2.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var hostTree = this.hostTree;
    var itemModel = hostTree.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  TreeNode2.prototype.getLevelModel = function() {
    return (this.hostTree.levelModels || [])[this.depth];
  };
  TreeNode2.prototype.setVisual = function(key, value) {
    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
  };
  TreeNode2.prototype.getVisual = function(key) {
    return this.hostTree.data.getItemVisual(this.dataIndex, key);
  };
  TreeNode2.prototype.getRawIndex = function() {
    return this.hostTree.data.getRawIndex(this.dataIndex);
  };
  TreeNode2.prototype.getId = function() {
    return this.hostTree.data.getId(this.dataIndex);
  };
  TreeNode2.prototype.getChildIndex = function() {
    if (this.parentNode) {
      var children = this.parentNode.children;
      for (var i = 0; i < children.length; ++i) {
        if (children[i] === this) {
          return i;
        }
      }
      return -1;
    }
    return -1;
  };
  TreeNode2.prototype.isAncestorOf = function(node) {
    var parent = node.parentNode;
    while (parent) {
      if (parent === this) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  };
  TreeNode2.prototype.isDescendantOf = function(node) {
    return node !== this && node.isAncestorOf(this);
  };
  return TreeNode2;
}();
var Tree = function() {
  function Tree2(hostModel) {
    this.type = "tree";
    this._nodes = [];
    this.hostModel = hostModel;
  }
  Tree2.prototype.eachNode = function(options, cb, context) {
    this.root.eachNode(options, cb, context);
  };
  Tree2.prototype.getNodeByDataIndex = function(dataIndex) {
    var rawIndex = this.data.getRawIndex(dataIndex);
    return this._nodes[rawIndex];
  };
  Tree2.prototype.getNodeById = function(name2) {
    return this.root.getNodeById(name2);
  };
  Tree2.prototype.update = function() {
    var data = this.data;
    var nodes = this._nodes;
    for (var i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
  };
  Tree2.prototype.clearLayouts = function() {
    this.data.clearItemLayouts();
  };
  Tree2.createTree = function(dataRoot, hostModel, beforeLink) {
    var tree = new Tree2(hostModel);
    var listData = [];
    var dimMax = 1;
    buildHierarchy(dataRoot);
    function buildHierarchy(dataNode, parentNode2) {
      var value = dataNode.value;
      dimMax = Math.max(dimMax, isArray$1(value) ? value.length : 1);
      listData.push(dataNode);
      var node = new TreeNode(convertOptionIdName(dataNode.name, ""), tree);
      parentNode2 ? addChild(node, parentNode2) : tree.root = node;
      tree._nodes.push(node);
      var children = dataNode.children;
      if (children) {
        for (var i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }
    tree.root.updateDepthAndHeight(0);
    var dimensions = prepareSeriesDataSchema(listData, {
      coordDimensions: ["value"],
      dimensionsCount: dimMax
    }).dimensions;
    var list = new SeriesData$1(dimensions, hostModel);
    list.initData(listData);
    beforeLink && beforeLink(list);
    linkSeriesData({
      mainData: list,
      struct: tree,
      structAttr: "tree"
    });
    tree.update();
    return tree;
  };
  return Tree2;
}();
function addChild(child, node) {
  var children = node.children;
  if (child.parentNode === node) {
    return;
  }
  children.push(child);
  child.parentNode = node;
}
var Tree$1 = Tree;
function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
  if (payload && indexOf2(validPayloadTypes, payload.type) >= 0) {
    var root = seriesModel.getData().tree.root;
    var targetNode = payload.targetNode;
    if (isString(targetNode)) {
      targetNode = root.getNodeById(targetNode);
    }
    if (targetNode && root.contains(targetNode)) {
      return {
        node: targetNode
      };
    }
    var targetNodeId = payload.targetNodeId;
    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
      return {
        node: targetNode
      };
    }
  }
}
function getPathToRoot(node) {
  var path = [];
  while (node) {
    node = node.parentNode;
    node && path.push(node);
  }
  return path.reverse();
}
function aboveViewRoot(viewRoot, node) {
  var viewPath = getPathToRoot(viewRoot);
  return indexOf2(viewPath, node) >= 0;
}
function wrapTreePathInfo(node, seriesModel) {
  var treePathInfo = [];
  while (node) {
    var nodeDataIndex = node.dataIndex;
    treePathInfo.push({
      name: node.name,
      dataIndex: nodeDataIndex,
      value: seriesModel.getRawValue(nodeDataIndex)
    });
    node = node.parentNode;
  }
  treePathInfo.reverse();
  return treePathInfo;
}
var TreeSeriesModel = function(_super) {
  __extends$1(TreeSeriesModel2, _super);
  function TreeSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasSymbolVisual = true;
    _this.ignoreStyleOnData = true;
    return _this;
  }
  TreeSeriesModel2.prototype.getInitialData = function(option) {
    var root = {
      name: option.name,
      children: option.data
    };
    var leaves = option.leaves || {};
    var leavesModel = new Model$1(leaves, this, this.ecModel);
    var tree = Tree$1.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        if (!(node && node.children.length && node.isExpand)) {
          model.parentModel = leavesModel;
        }
        return model;
      });
    }
    var treeDepth = 0;
    tree.eachNode("preorder", function(node) {
      if (node.depth > treeDepth) {
        treeDepth = node.depth;
      }
    });
    var expandAndCollapse = option.expandAndCollapse;
    var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
    tree.root.eachNode("preorder", function(node) {
      var item = node.hostTree.data.getRawDataItem(node.dataIndex);
      node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
    });
    return tree.data;
  };
  TreeSeriesModel2.prototype.getOrient = function() {
    var orient2 = this.get("orient");
    if (orient2 === "horizontal") {
      orient2 = "LR";
    } else if (orient2 === "vertical") {
      orient2 = "TB";
    }
    return orient2;
  };
  TreeSeriesModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  TreeSeriesModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  TreeSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var tree = this.getData().tree;
    var realRoot = tree.root.children[0];
    var node = tree.getNodeByDataIndex(dataIndex);
    var value = node.getValue();
    var name2 = node.name;
    while (node && node !== realRoot) {
      name2 = node.parentNode.name + "." + name2;
      node = node.parentNode;
    }
    return createTooltipMarkup("nameValue", {
      name: name2,
      value,
      noValue: isNaN(value) || value == null
    });
  };
  TreeSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);
    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.collapsed = !node.isExpand;
    return params;
  };
  TreeSeriesModel2.type = "series.tree";
  TreeSeriesModel2.layoutMode = "box";
  TreeSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "view",
    left: "12%",
    top: "12%",
    right: "12%",
    bottom: "12%",
    layout: "orthogonal",
    edgeShape: "curve",
    edgeForkPosition: "50%",
    roam: false,
    nodeScaleRatio: 0.4,
    center: null,
    zoom: 1,
    orient: "LR",
    symbol: "emptyCircle",
    symbolSize: 7,
    expandAndCollapse: true,
    initialTreeDepth: 2,
    lineStyle: {
      color: "#ccc",
      width: 1.5,
      curveness: 0.5
    },
    itemStyle: {
      color: "lightsteelblue",
      borderWidth: 1.5
    },
    label: {
      show: true
    },
    animationEasing: "linear",
    animationDuration: 700,
    animationDurationUpdate: 500
  };
  return TreeSeriesModel2;
}(SeriesModel$1);
var TreeSeriesModel$1 = TreeSeriesModel;
function eachAfter(root, callback, separation2) {
  var nodes = [root];
  var next3 = [];
  var node;
  while (node = nodes.pop()) {
    next3.push(node);
    if (node.isExpand) {
      var children = node.children;
      if (children.length) {
        for (var i = 0; i < children.length; i++) {
          nodes.push(children[i]);
        }
      }
    }
  }
  while (node = next3.pop()) {
    callback(node, separation2);
  }
}
function eachBefore(root, callback) {
  var nodes = [root];
  var node;
  while (node = nodes.pop()) {
    callback(node);
    if (node.isExpand) {
      var children = node.children;
      if (children.length) {
        for (var i = children.length - 1; i >= 0; i--) {
          nodes.push(children[i]);
        }
      }
    }
  }
}
function treeLayout(ecModel, api) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    commonLayout(seriesModel, api);
  });
}
function commonLayout(seriesModel, api) {
  var layoutInfo = getViewRect$4(seriesModel, api);
  seriesModel.layoutInfo = layoutInfo;
  var layout2 = seriesModel.get("layout");
  var width = 0;
  var height = 0;
  var separation$1 = null;
  if (layout2 === "radial") {
    width = 2 * Math.PI;
    height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
    separation$1 = separation(function(node1, node2) {
      return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
    });
  } else {
    width = layoutInfo.width;
    height = layoutInfo.height;
    separation$1 = separation();
  }
  var virtualRoot = seriesModel.getData().tree.root;
  var realRoot = virtualRoot.children[0];
  if (realRoot) {
    init8(virtualRoot);
    eachAfter(realRoot, firstWalk, separation$1);
    virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
    eachBefore(realRoot, secondWalk);
    var left_1 = realRoot;
    var right_1 = realRoot;
    var bottom_1 = realRoot;
    eachBefore(realRoot, function(node) {
      var x2 = node.getLayout().x;
      if (x2 < left_1.getLayout().x) {
        left_1 = node;
      }
      if (x2 > right_1.getLayout().x) {
        right_1 = node;
      }
      if (node.depth > bottom_1.depth) {
        bottom_1 = node;
      }
    });
    var delta2 = left_1 === right_1 ? 1 : separation$1(left_1, right_1) / 2;
    var tx_1 = delta2 - left_1.getLayout().x;
    var kx_1 = 0;
    var ky_1 = 0;
    var coorX_1 = 0;
    var coorY_1 = 0;
    if (layout2 === "radial") {
      kx_1 = width / (right_1.getLayout().x + delta2 + tx_1);
      ky_1 = height / (bottom_1.depth - 1 || 1);
      eachBefore(realRoot, function(node) {
        coorX_1 = (node.getLayout().x + tx_1) * kx_1;
        coorY_1 = (node.depth - 1) * ky_1;
        var finalCoor = radialCoordinate(coorX_1, coorY_1);
        node.setLayout({
          x: finalCoor.x,
          y: finalCoor.y,
          rawX: coorX_1,
          rawY: coorY_1
        }, true);
      });
    } else {
      var orient_1 = seriesModel.getOrient();
      if (orient_1 === "RL" || orient_1 === "LR") {
        ky_1 = height / (right_1.getLayout().x + delta2 + tx_1);
        kx_1 = width / (bottom_1.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorY_1 = (node.getLayout().x + tx_1) * ky_1;
          coorX_1 = orient_1 === "LR" ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;
          node.setLayout({
            x: coorX_1,
            y: coorY_1
          }, true);
        });
      } else if (orient_1 === "TB" || orient_1 === "BT") {
        kx_1 = width / (right_1.getLayout().x + delta2 + tx_1);
        ky_1 = height / (bottom_1.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorX_1 = (node.getLayout().x + tx_1) * kx_1;
          coorY_1 = orient_1 === "TB" ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;
          node.setLayout({
            x: coorX_1,
            y: coorY_1
          }, true);
        });
      }
    }
  }
}
function treeVisual(ecModel) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    tree.eachNode(function(node) {
      var model = node.getModel();
      var style = model.getModel("itemStyle").getItemStyle();
      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend2(existsStyle, style);
    });
  });
}
function installTreeAction(registers) {
  registers.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      var dataIndex = payload.dataIndex;
      var tree = seriesModel.getData().tree;
      var node = tree.getNodeByDataIndex(dataIndex);
      node.isExpand = !node.isExpand;
    });
  });
  registers.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    update: "none"
  }, function(payload, ecModel, api) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = updateCenterAndZoom(coordSys, payload, void 0, api);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}
function install$H(registers) {
  registers.registerChartView(TreeView$1);
  registers.registerSeriesModel(TreeSeriesModel$1);
  registers.registerLayout(treeLayout);
  registers.registerVisual(treeVisual);
  installTreeAction(registers);
}
var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function installTreemapAction(registers) {
  for (var i = 0; i < actionTypes.length; i++) {
    registers.registerAction({
      type: actionTypes[i],
      update: "updateView"
    }, noop);
  }
  registers.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model, index2) {
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = retrieveTargetInfo(payload, types, model);
      if (targetInfo) {
        var originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
}
function enableAriaDecalForTree(seriesModel) {
  var data = seriesModel.getData();
  var tree = data.tree;
  var decalPaletteScope2 = {};
  tree.eachNode(function(node) {
    var current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    var decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + "", decalPaletteScope2);
    node.setVisual("decal", decal);
  });
}
var TreemapSeriesModel = function(_super) {
  __extends$1(TreemapSeriesModel2, _super);
  function TreemapSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TreemapSeriesModel2.type;
    _this.preventUsingHoverLayer = true;
    return _this;
  }
  TreemapSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var root = {
      name: option.name,
      children: option.data
    };
    completeTreeValue$1(root);
    var levels = option.levels || [];
    var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
    var designatedVisualModel = new Model$1({
      itemStyle: designatedVisualItemStyle
    }, this, ecModel);
    levels = option.levels = setDefault(levels, ecModel);
    var levelModels = map$1(levels || [], function(levelDefine) {
      return new Model$1(levelDefine, designatedVisualModel, ecModel);
    }, this);
    var tree = Tree$1.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        var levelModel = node ? levelModels[node.depth] : null;
        model.parentModel = levelModel || designatedVisualModel;
        return model;
      });
    }
    return tree.data;
  };
  TreemapSeriesModel2.prototype.optionUpdated = function() {
    this.resetViewRoot();
  };
  TreemapSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name2 = data.getName(dataIndex);
    return createTooltipMarkup("nameValue", {
      name: name2,
      value
    });
  };
  TreemapSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);
    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.treePathInfo = params.treeAncestors;
    return params;
  };
  TreemapSeriesModel2.prototype.setLayoutInfo = function(layoutInfo) {
    this.layoutInfo = this.layoutInfo || {};
    extend2(this.layoutInfo, layoutInfo);
  };
  TreemapSeriesModel2.prototype.mapIdToIndex = function(id) {
    var idIndexMap = this._idIndexMap;
    if (!idIndexMap) {
      idIndexMap = this._idIndexMap = createHashMap();
      this._idIndexMapCount = 0;
    }
    var index2 = idIndexMap.get(id);
    if (index2 == null) {
      idIndexMap.set(id, index2 = this._idIndexMapCount++);
    }
    return index2;
  };
  TreemapSeriesModel2.prototype.getViewRoot = function() {
    return this._viewRoot;
  };
  TreemapSeriesModel2.prototype.resetViewRoot = function(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    var root = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  };
  TreemapSeriesModel2.prototype.enableAriaDecal = function() {
    enableAriaDecalForTree(this);
  };
  TreemapSeriesModel2.type = "series.treemap";
  TreemapSeriesModel2.layoutMode = "box";
  TreemapSeriesModel2.defaultOption = {
    progressive: 0,
    left: "center",
    top: "middle",
    width: "80%",
    height: "80%",
    sort: true,
    clipWindow: "origin",
    squareRatio: 0.5 * (1 + Math.sqrt(5)),
    leafDepth: null,
    drillDownIcon: "\u25B6",
    zoomToNodeRatio: 0.32 * 0.32,
    roam: true,
    nodeClick: "zoomToNode",
    animation: true,
    animationDurationUpdate: 900,
    animationEasing: "quinticInOut",
    breadcrumb: {
      show: true,
      height: 22,
      left: "center",
      top: "bottom",
      emptyItemWidth: 25,
      itemStyle: {
        color: "rgba(0,0,0,0.7)",
        textStyle: {
          color: "#fff"
        }
      },
      emphasis: {
        itemStyle: {
          color: "rgba(0,0,0,0.9)"
        }
      }
    },
    label: {
      show: true,
      distance: 0,
      padding: 5,
      position: "inside",
      color: "#fff",
      overflow: "truncate"
    },
    upperLabel: {
      show: false,
      position: [0, "50%"],
      height: 20,
      overflow: "truncate",
      verticalAlign: "middle"
    },
    itemStyle: {
      color: null,
      colorAlpha: null,
      colorSaturation: null,
      borderWidth: 0,
      gapWidth: 0,
      borderColor: "#fff",
      borderColorSaturation: null
    },
    emphasis: {
      upperLabel: {
        show: true,
        position: [0, "50%"],
        overflow: "truncate",
        verticalAlign: "middle"
      }
    },
    visualDimension: 0,
    visualMin: null,
    visualMax: null,
    color: [],
    colorAlpha: null,
    colorSaturation: null,
    colorMappingBy: "index",
    visibleMin: 10,
    childrenVisibleMin: null,
    levels: []
  };
  return TreemapSeriesModel2;
}(SeriesModel$1);
function completeTreeValue$1(dataNode) {
  var sum2 = 0;
  each$f(dataNode.children, function(child) {
    completeTreeValue$1(child);
    var childValue = child.value;
    isArray$1(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  var thisValue = dataNode.value;
  if (isArray$1(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray$1(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
function setDefault(levels, ecModel) {
  var globalColorList = normalizeToArray(ecModel.get("color"));
  var globalDecalList = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  if (!globalColorList) {
    return;
  }
  levels = levels || [];
  var hasColorDefine;
  var hasDecalDefine;
  each$f(levels, function(levelDefine) {
    var model = new Model$1(levelDefine);
    var modelColor = model.get("color");
    var modelDecal = model.get("decal");
    if (model.get(["itemStyle", "color"]) || modelColor && modelColor !== "none") {
      hasColorDefine = true;
    }
    if (model.get(["itemStyle", "decal"]) || modelDecal && modelDecal !== "none") {
      hasDecalDefine = true;
    }
  });
  var level0 = levels[0] || (levels[0] = {});
  if (!hasColorDefine) {
    level0.color = globalColorList.slice();
  }
  if (!hasDecalDefine && globalDecalList) {
    level0.decal = globalDecalList.slice();
  }
  return levels;
}
var TreemapSeriesModel$1 = TreemapSeriesModel;
var TEXT_PADDING = 8;
var ITEM_GAP = 8;
var ARRAY_LENGTH = 5;
var Breadcrumb = function() {
  function Breadcrumb2(containerGroup) {
    this.group = new Group$4();
    containerGroup.add(this.group);
  }
  Breadcrumb2.prototype.render = function(seriesModel, api, targetNode, onSelect) {
    var model = seriesModel.getModel("breadcrumb");
    var thisGroup = this.group;
    thisGroup.removeAll();
    if (!model.get("show") || !targetNode) {
      return;
    }
    var normalStyleModel = model.getModel("itemStyle");
    var emphasisModel = model.getModel("emphasis");
    var textStyleModel = normalStyleModel.getModel("textStyle");
    var emphasisTextStyleModel = emphasisModel.getModel(["itemStyle", "textStyle"]);
    var layoutParam = {
      pos: {
        left: model.get("left"),
        right: model.get("right"),
        top: model.get("top"),
        bottom: model.get("bottom")
      },
      box: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      emptyItemWidth: model.get("emptyItemWidth"),
      totalWidth: 0,
      renderList: []
    };
    this._prepare(targetNode, layoutParam, textStyleModel);
    this._renderContent(seriesModel, layoutParam, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect);
    positionElement(thisGroup, layoutParam.pos, layoutParam.box);
  };
  Breadcrumb2.prototype._prepare = function(targetNode, layoutParam, textStyleModel) {
    for (var node = targetNode; node; node = node.parentNode) {
      var text = convertOptionIdName(node.getModel().get("name"), "");
      var textRect = textStyleModel.getTextRect(text);
      var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
      layoutParam.totalWidth += itemWidth + ITEM_GAP;
      layoutParam.renderList.push({
        node,
        text,
        width: itemWidth
      });
    }
  };
  Breadcrumb2.prototype._renderContent = function(seriesModel, layoutParam, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect) {
    var lastX = 0;
    var emptyItemWidth = layoutParam.emptyItemWidth;
    var height = seriesModel.get(["breadcrumb", "height"]);
    var availableSize = getAvailableSize(layoutParam.pos, layoutParam.box);
    var totalWidth = layoutParam.totalWidth;
    var renderList = layoutParam.renderList;
    var emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
    for (var i = renderList.length - 1; i >= 0; i--) {
      var item = renderList[i];
      var itemNode = item.node;
      var itemWidth = item.width;
      var text = item.text;
      if (totalWidth > availableSize.width) {
        totalWidth -= itemWidth - emptyItemWidth;
        itemWidth = emptyItemWidth;
        text = null;
      }
      var el = new Polygon$1({
        shape: {
          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
        },
        style: defaults(normalStyleModel.getItemStyle(), {
          lineJoin: "bevel"
        }),
        textContent: new ZRText$1({
          style: createTextStyle(textStyleModel, {
            text
          })
        }),
        textConfig: {
          position: "inside"
        },
        z2: Z2_EMPHASIS_LIFT * 1e4,
        onclick: curry$1(onSelect, itemNode)
      });
      el.disableLabelAnimation = true;
      el.getTextContent().ensureState("emphasis").style = createTextStyle(emphasisTextStyleModel, {
        text
      });
      el.ensureState("emphasis").style = emphasisItemStyle;
      toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      this.group.add(el);
      packEventData(el, seriesModel, itemNode);
      lastX += itemWidth + ITEM_GAP;
    }
  };
  Breadcrumb2.prototype.remove = function() {
    this.group.removeAll();
  };
  return Breadcrumb2;
}();
function makeItemPoints(x2, y2, itemWidth, itemHeight, head, tail) {
  var points2 = [[head ? x2 : x2 - ARRAY_LENGTH, y2], [x2 + itemWidth, y2], [x2 + itemWidth, y2 + itemHeight], [head ? x2 : x2 - ARRAY_LENGTH, y2 + itemHeight]];
  !tail && points2.splice(2, 0, [x2 + itemWidth + ARRAY_LENGTH, y2 + itemHeight / 2]);
  !head && points2.push([x2, y2 + itemHeight / 2]);
  return points2;
}
function packEventData(el, seriesModel, itemNode) {
  getECData(el).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: seriesModel.componentIndex,
    seriesIndex: seriesModel.seriesIndex,
    seriesName: seriesModel.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: itemNode && itemNode.dataIndex,
      name: itemNode && itemNode.name
    },
    treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
  };
}
var Breadcrumb$1 = Breadcrumb;
var AnimationWrap = function() {
  function AnimationWrap2() {
    this._storage = [];
    this._elExistsMap = {};
  }
  AnimationWrap2.prototype.add = function(el, target, duration, delay, easing) {
    if (this._elExistsMap[el.id]) {
      return false;
    }
    this._elExistsMap[el.id] = true;
    this._storage.push({
      el,
      target,
      duration,
      delay,
      easing
    });
    return true;
  };
  AnimationWrap2.prototype.finished = function(callback) {
    this._finishedCallback = callback;
    return this;
  };
  AnimationWrap2.prototype.start = function() {
    var _this = this;
    var count3 = this._storage.length;
    var checkTerminate = function() {
      count3--;
      if (count3 <= 0) {
        _this._storage.length = 0;
        _this._elExistsMap = {};
        _this._finishedCallback && _this._finishedCallback();
      }
    };
    for (var i = 0, len2 = this._storage.length; i < len2; i++) {
      var item = this._storage[i];
      item.el.animateTo(item.target, {
        duration: item.duration,
        delay: item.delay,
        easing: item.easing,
        setToFinal: true,
        done: checkTerminate,
        aborted: checkTerminate
      });
    }
    return this;
  };
  return AnimationWrap2;
}();
function createWrap() {
  return new AnimationWrap();
}
var Group$2 = Group$4;
var Rect$1 = Rect$3;
var DRAG_THRESHOLD = 3;
var PATH_LABEL_NOAMAL = "label";
var PATH_UPPERLABEL_NORMAL = "upperLabel";
var Z2_BASE = Z2_EMPHASIS_LIFT * 10;
var Z2_BG = Z2_EMPHASIS_LIFT * 2;
var Z2_CONTENT = Z2_EMPHASIS_LIFT * 3;
var getStateItemStyle = makeStyleMapper([
  ["fill", "color"],
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
]);
var getItemStyleNormal = function(model) {
  var itemStyle = getStateItemStyle(model);
  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
  return itemStyle;
};
var inner$d = makeInner();
var TreemapView = function(_super) {
  __extends$1(TreemapView2, _super);
  function TreemapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TreemapView2.type;
    _this._state = "ready";
    _this._storage = createStorage();
    return _this;
  }
  TreemapView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var models = ecModel.findComponents({
      mainType: "series",
      subType: "treemap",
      query: payload
    });
    if (indexOf2(models, seriesModel) < 0) {
      return;
    }
    this.seriesModel = seriesModel;
    this.api = api;
    this.ecModel = ecModel;
    var types = ["treemapZoomToNode", "treemapRootToNode"];
    var targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    var payloadType = payload && payload.type;
    var layoutInfo = seriesModel.layoutInfo;
    var isInit = !this._oldTree;
    var thisStorage = this._storage;
    var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
      direction: payload.direction
    } : null;
    var containerGroup = this._giveContainerGroup(layoutInfo);
    var hasAnimation = seriesModel.get("animation");
    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
    hasAnimation && !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
    this._resetController(api);
    this._renderBreadcrumb(seriesModel, api, targetInfo);
  };
  TreemapView2.prototype._giveContainerGroup = function(layoutInfo) {
    var containerGroup = this._containerGroup;
    if (!containerGroup) {
      containerGroup = this._containerGroup = new Group$2();
      this._initEvents(containerGroup);
      this.group.add(containerGroup);
    }
    containerGroup.x = layoutInfo.x;
    containerGroup.y = layoutInfo.y;
    return containerGroup;
  };
  TreemapView2.prototype._doRender = function(containerGroup, seriesModel, reRoot) {
    var thisTree = seriesModel.getData().tree;
    var oldTree = this._oldTree;
    var lastsForAnimation = createStorage();
    var thisStorage = createStorage();
    var oldStorage = this._storage;
    var willInvisibleEls = [];
    function doRenderNode(thisNode, oldNode, parentGroup, depth2) {
      return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth2);
    }
    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
    var willDeleteEls = clearStorage(oldStorage);
    this._oldTree = thisTree;
    this._storage = thisStorage;
    return {
      lastsForAnimation,
      willDeleteEls,
      renderFinally
    };
    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth2) {
      if (sameTree) {
        oldViewChildren = thisViewChildren;
        each$f(thisViewChildren, function(child, index2) {
          !child.isRemoved() && processNode(index2, index2);
        });
      } else {
        new DataDiffer$1(oldViewChildren, thisViewChildren, getKey2, getKey2).add(processNode).update(processNode).remove(curry$1(processNode, null)).execute();
      }
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIndex, oldIndex) {
        var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
        var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
        var group = doRenderNode(thisNode, oldNode, parentGroup, depth2);
        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth2 + 1);
      }
    }
    function clearStorage(storage2) {
      var willDeleteEls2 = createStorage();
      storage2 && each$f(storage2, function(store, storageName) {
        var delEls = willDeleteEls2[storageName];
        each$f(store, function(el) {
          el && (delEls.push(el), inner$d(el).willDelete = true);
        });
      });
      return willDeleteEls2;
    }
    function renderFinally() {
      each$f(willDeleteEls, function(els) {
        each$f(els, function(el) {
          el.parent && el.parent.remove(el);
        });
      });
      each$f(willInvisibleEls, function(el) {
        el.invisible = true;
        el.dirty();
      });
    }
  };
  TreemapView2.prototype._doAnimation = function(containerGroup, renderResult, seriesModel, reRoot) {
    var durationOption = seriesModel.get("animationDurationUpdate");
    var easingOption = seriesModel.get("animationEasing");
    var duration = (isFunction(durationOption) ? 0 : durationOption) || 0;
    var easing = (isFunction(easingOption) ? null : easingOption) || "cubicOut";
    var animationWrap = createWrap();
    each$f(renderResult.willDeleteEls, function(store, storageName) {
      each$f(store, function(el, rawIndex) {
        if (el.invisible) {
          return;
        }
        var parent = el.parent;
        var target;
        var innerStore = inner$d(parent);
        if (reRoot && reRoot.direction === "drillDown") {
          target = parent === reRoot.rootNodeGroup ? {
            shape: {
              x: 0,
              y: 0,
              width: innerStore.nodeWidth,
              height: innerStore.nodeHeight
            },
            style: {
              opacity: 0
            }
          } : {
            style: {
              opacity: 0
            }
          };
        } else {
          var targetX = 0;
          var targetY = 0;
          if (!innerStore.willDelete) {
            targetX = innerStore.nodeWidth / 2;
            targetY = innerStore.nodeHeight / 2;
          }
          target = storageName === "nodeGroup" ? {
            x: targetX,
            y: targetY,
            style: {
              opacity: 0
            }
          } : {
            shape: {
              x: targetX,
              y: targetY,
              width: 0,
              height: 0
            },
            style: {
              opacity: 0
            }
          };
        }
        target && animationWrap.add(el, target, duration, 0, easing);
      });
    });
    each$f(this._storage, function(store, storageName) {
      each$f(store, function(el, rawIndex) {
        var last = renderResult.lastsForAnimation[storageName][rawIndex];
        var target = {};
        if (!last) {
          return;
        }
        if (el instanceof Group$4) {
          if (last.oldX != null) {
            target.x = el.x;
            target.y = el.y;
            el.x = last.oldX;
            el.y = last.oldY;
          }
        } else {
          if (last.oldShape) {
            target.shape = extend2({}, el.shape);
            el.setShape(last.oldShape);
          }
          if (last.fadein) {
            el.setStyle("opacity", 0);
            target.style = {
              opacity: 1
            };
          } else if (el.style.opacity !== 1) {
            target.style = {
              opacity: 1
            };
          }
        }
        animationWrap.add(el, target, duration, 0, easing);
      });
    }, this);
    this._state = "animating";
    animationWrap.finished(bind$1(function() {
      this._state = "ready";
      renderResult.renderFinally();
    }, this)).start();
  };
  TreemapView2.prototype._resetController = function(api) {
    var controller = this._controller;
    if (!controller) {
      controller = this._controller = new RoamController$1(api.getZr());
      controller.enable(this.seriesModel.get("roam"));
      controller.on("pan", bind$1(this._onPan, this));
      controller.on("zoom", bind$1(this._onZoom, this));
    }
    var rect = new BoundingRect$1(0, 0, api.getWidth(), api.getHeight());
    controller.setPointerChecker(function(e2, x2, y2) {
      return rect.contain(x2, y2);
    });
  };
  TreemapView2.prototype._clearController = function() {
    var controller = this._controller;
    if (controller) {
      controller.dispose();
      controller = null;
    }
  };
  TreemapView2.prototype._onPan = function(e2) {
    if (this._state !== "animating" && (Math.abs(e2.dx) > DRAG_THRESHOLD || Math.abs(e2.dy) > DRAG_THRESHOLD)) {
      var root = this.seriesModel.getData().tree.root;
      if (!root) {
        return;
      }
      var rootLayout = root.getLayout();
      if (!rootLayout) {
        return;
      }
      this.api.dispatchAction({
        type: "treemapMove",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rootLayout.x + e2.dx,
          y: rootLayout.y + e2.dy,
          width: rootLayout.width,
          height: rootLayout.height
        }
      });
    }
  };
  TreemapView2.prototype._onZoom = function(e2) {
    var mouseX = e2.originX;
    var mouseY = e2.originY;
    if (this._state !== "animating") {
      var root = this.seriesModel.getData().tree.root;
      if (!root) {
        return;
      }
      var rootLayout = root.getLayout();
      if (!rootLayout) {
        return;
      }
      var rect = new BoundingRect$1(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
      var layoutInfo = this.seriesModel.layoutInfo;
      mouseX -= layoutInfo.x;
      mouseY -= layoutInfo.y;
      var m2 = create$1();
      translate2(m2, m2, [-mouseX, -mouseY]);
      scale$1(m2, m2, [e2.scale, e2.scale]);
      translate2(m2, m2, [mouseX, mouseY]);
      rect.applyTransform(m2);
      this.api.dispatchAction({
        type: "treemapRender",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
    }
  };
  TreemapView2.prototype._initEvents = function(containerGroup) {
    var _this = this;
    containerGroup.on("click", function(e2) {
      if (_this._state !== "ready") {
        return;
      }
      var nodeClick = _this.seriesModel.get("nodeClick", true);
      if (!nodeClick) {
        return;
      }
      var targetInfo = _this.findTarget(e2.offsetX, e2.offsetY);
      if (!targetInfo) {
        return;
      }
      var node = targetInfo.node;
      if (node.getLayout().isLeafRoot) {
        _this._rootToNode(targetInfo);
      } else {
        if (nodeClick === "zoomToNode") {
          _this._zoomToNode(targetInfo);
        } else if (nodeClick === "link") {
          var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
          var link2 = itemModel.get("link", true);
          var linkTarget = itemModel.get("target", true) || "blank";
          link2 && windowOpen(link2, linkTarget);
        }
      }
    }, this);
  };
  TreemapView2.prototype._renderBreadcrumb = function(seriesModel, api, targetInfo) {
    var _this = this;
    if (!targetInfo) {
      targetInfo = seriesModel.get("leafDepth", true) != null ? {
        node: seriesModel.getViewRoot()
      } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
      if (!targetInfo) {
        targetInfo = {
          node: seriesModel.getData().tree.root
        };
      }
    }
    (this._breadcrumb || (this._breadcrumb = new Breadcrumb$1(this.group))).render(seriesModel, api, targetInfo.node, function(node) {
      if (_this._state !== "animating") {
        aboveViewRoot(seriesModel.getViewRoot(), node) ? _this._rootToNode({
          node
        }) : _this._zoomToNode({
          node
        });
      }
    });
  };
  TreemapView2.prototype.remove = function() {
    this._clearController();
    this._containerGroup && this._containerGroup.removeAll();
    this._storage = createStorage();
    this._state = "ready";
    this._breadcrumb && this._breadcrumb.remove();
  };
  TreemapView2.prototype.dispose = function() {
    this._clearController();
  };
  TreemapView2.prototype._zoomToNode = function(targetInfo) {
    this.api.dispatchAction({
      type: "treemapZoomToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  };
  TreemapView2.prototype._rootToNode = function(targetInfo) {
    this.api.dispatchAction({
      type: "treemapRootToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  };
  TreemapView2.prototype.findTarget = function(x2, y2) {
    var targetInfo;
    var viewRoot = this.seriesModel.getViewRoot();
    viewRoot.eachNode({
      attr: "viewChildren",
      order: "preorder"
    }, function(node) {
      var bgEl = this._storage.background[node.getRawIndex()];
      if (bgEl) {
        var point4 = bgEl.transformCoordToLocal(x2, y2);
        var shape = bgEl.shape;
        if (shape.x <= point4[0] && point4[0] <= shape.x + shape.width && shape.y <= point4[1] && point4[1] <= shape.y + shape.height) {
          targetInfo = {
            node,
            offsetX: point4[0],
            offsetY: point4[1]
          };
        } else {
          return false;
        }
      }
    }, this);
    return targetInfo;
  };
  TreemapView2.type = "treemap";
  return TreemapView2;
}(ChartView$1);
function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth2) {
  if (!thisNode) {
    return;
  }
  var thisLayout = thisNode.getLayout();
  var data = seriesModel.getData();
  var nodeModel = thisNode.getModel();
  data.setItemGraphicEl(thisNode.dataIndex, null);
  if (!thisLayout || !thisLayout.isInView) {
    return;
  }
  var thisWidth = thisLayout.width;
  var thisHeight = thisLayout.height;
  var borderWidth = thisLayout.borderWidth;
  var thisInvisible = thisLayout.invisible;
  var thisRawIndex = thisNode.getRawIndex();
  var oldRawIndex = oldNode && oldNode.getRawIndex();
  var thisViewChildren = thisNode.viewChildren;
  var upperHeight = thisLayout.upperHeight;
  var isParent = thisViewChildren && thisViewChildren.length;
  var itemStyleNormalModel = nodeModel.getModel("itemStyle");
  var itemStyleEmphasisModel = nodeModel.getModel(["emphasis", "itemStyle"]);
  var itemStyleBlurModel = nodeModel.getModel(["blur", "itemStyle"]);
  var itemStyleSelectModel = nodeModel.getModel(["select", "itemStyle"]);
  var borderRadius = itemStyleNormalModel.get("borderRadius") || 0;
  var group = giveGraphic("nodeGroup", Group$2);
  if (!group) {
    return;
  }
  parentGroup.add(group);
  group.x = thisLayout.x || 0;
  group.y = thisLayout.y || 0;
  group.markRedraw();
  inner$d(group).nodeWidth = thisWidth;
  inner$d(group).nodeHeight = thisHeight;
  if (thisLayout.isAboveViewRoot) {
    return group;
  }
  var bg = giveGraphic("background", Rect$1, depth2, Z2_BG);
  bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
  var emphasisModel = nodeModel.getModel("emphasis");
  var focus = emphasisModel.get("focus");
  var blurScope = emphasisModel.get("blurScope");
  var isDisabled = emphasisModel.get("disabled");
  var focusOrIndices = focus === "ancestor" ? thisNode.getAncestorsIndices() : focus === "descendant" ? thisNode.getDescendantIndices() : focus;
  if (isParent) {
    if (isHighDownDispatcher(group)) {
      setAsHighDownDispatcher(group, false);
    }
    if (bg) {
      setAsHighDownDispatcher(bg, !isDisabled);
      data.setItemGraphicEl(thisNode.dataIndex, bg);
      enableHoverFocus(bg, focusOrIndices, blurScope);
    }
  } else {
    var content = giveGraphic("content", Rect$1, depth2, Z2_CONTENT);
    content && renderContent(group, content);
    bg.disableMorphing = true;
    if (bg && isHighDownDispatcher(bg)) {
      setAsHighDownDispatcher(bg, false);
    }
    setAsHighDownDispatcher(group, !isDisabled);
    data.setItemGraphicEl(thisNode.dataIndex, group);
    enableHoverFocus(group, focusOrIndices, blurScope);
  }
  return group;
  function renderBackground(group2, bg2, useUpperLabel) {
    var ecData = getECData(bg2);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    bg2.setShape({
      x: 0,
      y: 0,
      width: thisWidth,
      height: thisHeight,
      r: borderRadius
    });
    if (thisInvisible) {
      processInvisible(bg2);
    } else {
      bg2.invisible = false;
      var style = thisNode.getVisual("style");
      var visualBorderColor = style.stroke;
      var normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualBorderColor;
      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      emphasisStyle.fill = itemStyleEmphasisModel.get("borderColor");
      var blurStyle = getStateItemStyle(itemStyleBlurModel);
      blurStyle.fill = itemStyleBlurModel.get("borderColor");
      var selectStyle = getStateItemStyle(itemStyleSelectModel);
      selectStyle.fill = itemStyleSelectModel.get("borderColor");
      if (useUpperLabel) {
        var upperLabelWidth = thisWidth - 2 * borderWidth;
        prepareText(
          bg2,
          visualBorderColor,
          style.opacity,
          {
            x: borderWidth,
            y: 0,
            width: upperLabelWidth,
            height: upperHeight
          }
        );
      } else {
        bg2.removeTextContent();
      }
      bg2.setStyle(normalStyle);
      bg2.ensureState("emphasis").style = emphasisStyle;
      bg2.ensureState("blur").style = blurStyle;
      bg2.ensureState("select").style = selectStyle;
      setDefaultStateProxy(bg2);
    }
    group2.add(bg2);
  }
  function renderContent(group2, content2) {
    var ecData = getECData(content2);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
    var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
    content2.culling = true;
    content2.setShape({
      x: borderWidth,
      y: borderWidth,
      width: contentWidth,
      height: contentHeight,
      r: borderRadius
    });
    if (thisInvisible) {
      processInvisible(content2);
    } else {
      content2.invisible = false;
      var nodeStyle = thisNode.getVisual("style");
      var visualColor = nodeStyle.fill;
      var normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualColor;
      normalStyle.decal = nodeStyle.decal;
      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      var blurStyle = getStateItemStyle(itemStyleBlurModel);
      var selectStyle = getStateItemStyle(itemStyleSelectModel);
      prepareText(content2, visualColor, nodeStyle.opacity, null);
      content2.setStyle(normalStyle);
      content2.ensureState("emphasis").style = emphasisStyle;
      content2.ensureState("blur").style = blurStyle;
      content2.ensureState("select").style = selectStyle;
      setDefaultStateProxy(content2);
    }
    group2.add(content2);
  }
  function processInvisible(element) {
    !element.invisible && willInvisibleEls.push(element);
  }
  function prepareText(rectEl, visualColor, visualOpacity, upperLabelRect) {
    var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
    var defaultText = convertOptionIdName(nodeModel.get("name"), null);
    var isShow = normalLabelModel.getShallow("show");
    setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: isShow ? defaultText : null,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      labelFetcher: seriesModel,
      labelDataIndex: thisNode.dataIndex
    });
    var textEl = rectEl.getTextContent();
    if (!textEl) {
      return;
    }
    var textStyle = textEl.style;
    var textPadding = normalizeCssArray$1(textStyle.padding || 0);
    if (upperLabelRect) {
      rectEl.setTextConfig({
        layoutRect: upperLabelRect
      });
      textEl.disableLabelLayout = true;
    }
    textEl.beforeUpdate = function() {
      var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
      var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);
      if (textStyle.width !== width || textStyle.height !== height) {
        textEl.setStyle({
          width,
          height
        });
      }
    };
    textStyle.truncateMinChar = 2;
    textStyle.lineOverflow = "truncate";
    addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
    var textEmphasisState = textEl.getState("emphasis");
    addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
  }
  function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
    var text = style ? style.text : null;
    if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
      var iconChar = seriesModel.get("drillDownIcon", true);
      style.text = iconChar ? iconChar + " " + text : text;
    }
  }
  function giveGraphic(storageName, Ctor, depth3, z) {
    var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
    var lasts = lastsForAnimation[storageName];
    if (element) {
      oldStorage[storageName][oldRawIndex] = null;
      prepareAnimationWhenHasOld(lasts, element);
    } else if (!thisInvisible) {
      element = new Ctor();
      if (element instanceof Displayable$1) {
        element.z2 = calculateZ2(depth3, z);
      }
      prepareAnimationWhenNoOld(lasts, element);
    }
    return thisStorage[storageName][thisRawIndex] = element;
  }
  function prepareAnimationWhenHasOld(lasts, element) {
    var lastCfg = lasts[thisRawIndex] = {};
    if (element instanceof Group$2) {
      lastCfg.oldX = element.x;
      lastCfg.oldY = element.y;
    } else {
      lastCfg.oldShape = extend2({}, element.shape);
    }
  }
  function prepareAnimationWhenNoOld(lasts, element) {
    var lastCfg = lasts[thisRawIndex] = {};
    var parentNode2 = thisNode.parentNode;
    var isGroup = element instanceof Group$4;
    if (parentNode2 && (!reRoot || reRoot.direction === "drillDown")) {
      var parentOldX = 0;
      var parentOldY = 0;
      var parentOldBg = lastsForAnimation.background[parentNode2.getRawIndex()];
      if (!reRoot && parentOldBg && parentOldBg.oldShape) {
        parentOldX = parentOldBg.oldShape.width;
        parentOldY = parentOldBg.oldShape.height;
      }
      if (isGroup) {
        lastCfg.oldX = 0;
        lastCfg.oldY = parentOldY;
      } else {
        lastCfg.oldShape = {
          x: parentOldX,
          y: parentOldY,
          width: 0,
          height: 0
        };
      }
    }
    lastCfg.fadein = !isGroup;
  }
}
function calculateZ2(depth2, z2InLevel) {
  return depth2 * Z2_BASE + z2InLevel;
}
var TreemapView$1 = TreemapView;
var each$c = each$f;
var isObject = isObject$3;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
var VisualMapping = function() {
  function VisualMapping2(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = clone$4(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = VisualMapping2.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
    if (mappingMethod === "piecewise") {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === "category") {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      assert(mappingMethod !== "linear" || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }
  VisualMapping2.prototype.mapValueToVisual = function(value) {
    var normalized = this._normalizeData(value);
    return this._normalizedToVisual(normalized, value);
  };
  VisualMapping2.prototype.getNormalizer = function() {
    return bind$1(this._normalizeData, this);
  };
  VisualMapping2.listVisualTypes = function() {
    return keys2(VisualMapping2.visualHandlers);
  };
  VisualMapping2.isValidType = function(visualType) {
    return VisualMapping2.visualHandlers.hasOwnProperty(visualType);
  };
  VisualMapping2.eachVisual = function(visual, callback, context) {
    if (isObject$3(visual)) {
      each$f(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };
  VisualMapping2.mapVisual = function(visual, callback, context) {
    var isPrimary;
    var newVisual = isArray$1(visual) ? [] : isObject$3(visual) ? {} : (isPrimary = true, null);
    VisualMapping2.eachVisual(visual, function(v, key) {
      var newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  };
  VisualMapping2.retrieveVisuals = function(obj) {
    var ret = {};
    var hasVisual;
    obj && each$c(VisualMapping2.visualHandlers, function(h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  };
  VisualMapping2.prepareVisualTypes = function(visualTypes) {
    if (isArray$1(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject(visualTypes)) {
      var types_1 = [];
      each$c(visualTypes, function(item, type) {
        types_1.push(type);
      });
      visualTypes = types_1;
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
    });
    return visualTypes;
  };
  VisualMapping2.dependsOn = function(visualType1, visualType2) {
    return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  VisualMapping2.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs3 = Infinity;
    for (var i = 0, len2 = pieceList.length; i < len2; i++) {
      var pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value || isString(pieceValue) && pieceValue === value + "") {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (var i = 0, len2 = pieceList.length; i < len2; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close_1 = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close_1[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close_1[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index2) {
      var newAbs = Math.abs(val - value);
      if (newAbs < abs3) {
        abs3 = newAbs;
        possibleI = index2;
      }
    }
  };
  VisualMapping2.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual("color"),
      getColorMapper: function() {
        var thisOption = this.option;
        return bind$1(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory.call(this, value);
        } : function(value, isNormalized, out2) {
          var returnRGBArray = !!out2;
          !isNormalized && (value = this._normalizeData(value));
          out2 = fastLerp(value, thisOption.parsedVisual, out2);
          return returnRGBArray ? out2 : stringify(out2, "rgba");
        }, this);
      },
      _normalizedToVisual: {
        linear: function(normalized) {
          return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function(color, value) {
      return modifyHSL(color, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function(color, value) {
      return modifyHSL(color, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function(color, value) {
      return modifyHSL(color, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function(color, value) {
      return modifyAlpha(color, value);
    }),
    decal: {
      applyVisual: makeApplyVisual("decal"),
      _normalizedToVisual: {
        linear: null,
        category: doMapCategory,
        piecewise: null,
        fixed: null
      }
    },
    opacity: {
      applyVisual: makeApplyVisual("opacity"),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    },
    liftZ: {
      applyVisual: makeApplyVisual("liftZ"),
      _normalizedToVisual: {
        linear: doMapFixed,
        category: doMapFixed,
        piecewise: doMapFixed,
        fixed: doMapFixed
      }
    },
    symbol: {
      applyVisual: function(value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        setter("symbol", symbolCfg);
      },
      _normalizedToVisual: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual("symbolSize"),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    }
  };
  return VisualMapping2;
}();
function preprocessForPiecewise(thisOption) {
  var pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  each$f(pieceList, function(piece, index2) {
    piece.originIndex = index2;
    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}
function preprocessForSpecifiedCategory(thisOption) {
  var categories = thisOption.categories;
  var categoryMap = thisOption.categoryMap = {};
  var visual = thisOption.visual;
  each$c(categories, function(cate, index2) {
    categoryMap[cate] = index2;
  });
  if (!isArray$1(visual)) {
    var visualArr_1 = [];
    if (isObject$3(visual)) {
      each$c(visual, function(v, cate) {
        var index2 = categoryMap[cate];
        visualArr_1[index2 != null ? index2 : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
      });
    } else {
      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }
    visual = setVisualToOption(thisOption, visualArr_1);
  }
  for (var i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}
function normalizeVisualRange(thisOption, isCategory2) {
  var visual = thisOption.visual;
  var visualArr = [];
  if (isObject$3(visual)) {
    each$c(visual, function(v) {
      visualArr.push(v);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }
  var doNotNeedPair = {
    color: 1,
    symbol: 1
  };
  if (!isCategory2 && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    visualArr[1] = visualArr[0];
  }
  setVisualToOption(thisOption, visualArr);
}
function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function(value, getter, setter) {
      var colorChannel = this.mapValueToVisual(value);
      setter("color", applyValue(getter("color"), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(normalized) {
  var visual = this.option.visual;
  return visual[Math.round(linearMap$2(normalized, [0, 1], [0, visual.length - 1], true))] || {};
}
function makeApplyVisual(visualType) {
  return function(value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}
function doMapCategory(normalized) {
  var visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function(normalized) {
      return linearMap$2(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function(normalized, value) {
      var result = getSpecifiedVisual.call(this, value);
      if (result == null) {
        result = linearMap$2(normalized, sourceExtent, this.option.visual, true);
      }
      return result;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(value) {
  var thisOption = this.option;
  var pieceList = thisOption.pieceList;
  if (thisOption.hasSpecialVisual) {
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    var piece = pieceList[pieceIndex];
    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}
function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;
  if (thisOption.type === "color") {
    thisOption.parsedVisual = map$1(visualArr, function(item) {
      var color = parse2(item);
      if (!color && true) {
        warn("'" + item + "' is an illegal color, fallback to '#000000'", true);
      }
      return color || [0, 0, 0, 1];
    });
  }
  return visualArr;
}
var normalizers = {
  linear: function(value) {
    return linearMap$2(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function(value) {
    var pieceList = this.option.pieceList;
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
    if (pieceIndex != null) {
      return linearMap$2(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function(value) {
    var index2 = this.option.categories ? this.option.categoryMap[value] : value;
    return index2 == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index2;
  },
  fixed: noop
};
function littleThan(close, a, b) {
  return close ? a <= b : a < b;
}
var VisualMapping$1 = VisualMapping;
var ITEM_STYLE_NORMAL = "itemStyle";
var inner$c = makeInner();
var treemapVisual = {
  seriesType: "treemap",
  reset: function(seriesModel) {
    var tree = seriesModel.getData().tree;
    var root = tree.root;
    if (root.isRemoved()) {
      return;
    }
    travelTree(
      root,
      {},
      seriesModel.getViewRoot().getAncestors(),
      seriesModel
    );
  }
};
function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
  var nodeModel = node.getModel();
  var nodeLayout = node.getLayout();
  var data = node.hostTree.data;
  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
    return;
  }
  var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
  var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
  var borderColor = nodeItemStyleModel.get("borderColor");
  var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
  var thisNodeColor;
  if (borderColorSaturation != null) {
    thisNodeColor = calculateColor(visuals);
    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
  }
  existsStyle.stroke = borderColor;
  var viewChildren = node.viewChildren;
  if (!viewChildren || !viewChildren.length) {
    thisNodeColor = calculateColor(visuals);
    existsStyle.fill = thisNodeColor;
  } else {
    var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
    each$f(viewChildren, function(child, index2) {
      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
        var childVisual = mapVisual$1(nodeModel, visuals, child, index2, mapping_1, seriesModel);
        travelTree(child, childVisual, viewRootAncestors, seriesModel);
      }
    });
  }
}
function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
  var visuals = extend2({}, designatedVisual);
  var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
  each$f(["color", "colorAlpha", "colorSaturation"], function(visualName) {
    designatedVisualItemStyle[visualName] = designatedVisual[visualName];
    var val = nodeItemStyleModel.get(visualName);
    designatedVisualItemStyle[visualName] = null;
    val != null && (visuals[visualName] = val);
  });
  return visuals;
}
function calculateColor(visuals) {
  var color = getValueVisualDefine(visuals, "color");
  if (color) {
    var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
    var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
    if (colorSaturation) {
      color = modifyHSL(color, null, null, colorSaturation);
    }
    if (colorAlpha) {
      color = modifyAlpha(color, colorAlpha);
    }
    return color;
  }
}
function calculateBorderColor(borderColorSaturation, thisNodeColor) {
  return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
}
function getValueVisualDefine(visuals, name2) {
  var value = visuals[name2];
  if (value != null && value !== "none") {
    return value;
  }
}
function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
  if (!viewChildren || !viewChildren.length) {
    return;
  }
  var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
  if (!rangeVisual) {
    return;
  }
  var visualMin = nodeModel.get("visualMin");
  var visualMax = nodeModel.get("visualMax");
  var dataExtent = nodeLayout.dataExtent.slice();
  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
  var colorMappingBy = nodeModel.get("colorMappingBy");
  var opt = {
    type: rangeVisual.name,
    dataExtent,
    visual: rangeVisual.range
  };
  if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
    opt.mappingMethod = "category";
    opt.loop = true;
  } else {
    opt.mappingMethod = "linear";
  }
  var mapping = new VisualMapping$1(opt);
  inner$c(mapping).drColorMappingBy = colorMappingBy;
  return mapping;
}
function getRangeVisual(nodeModel, name2) {
  var range = nodeModel.get(name2);
  return isArray$1(range) && range.length ? {
    name: name2,
    range
  } : null;
}
function mapVisual$1(nodeModel, visuals, child, index2, mapping, seriesModel) {
  var childVisuals = extend2({}, visuals);
  if (mapping) {
    var mappingType = mapping.type;
    var colorMappingBy = mappingType === "color" && inner$c(mapping).drColorMappingBy;
    var value = colorMappingBy === "index" ? index2 : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
    childVisuals[mappingType] = mapping.mapValueToVisual(value);
  }
  return childVisuals;
}
var mathMax$3 = Math.max;
var mathMin$3 = Math.min;
var retrieveValue = retrieve;
var each$b = each$f;
var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
var treemapLayout = {
  seriesType: "treemap",
  reset: function(seriesModel, ecModel, api, payload) {
    var ecWidth = api.getWidth();
    var ecHeight = api.getHeight();
    var seriesOption = seriesModel.option;
    var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    var size11 = seriesOption.size || [];
    var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size11[0]), ecWidth);
    var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size11[1]), ecHeight);
    var payloadType = payload && payload.type;
    var types = ["treemapZoomToNode", "treemapRootToNode"];
    var targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
    var viewRoot = seriesModel.getViewRoot();
    var viewAbovePath = getPathToRoot(viewRoot);
    if (payloadType !== "treemapMove") {
      var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
      var sort_1 = seriesOption.sort;
      if (sort_1 && sort_1 !== "asc" && sort_1 !== "desc") {
        sort_1 = "desc";
      }
      var options = {
        squareRatio: seriesOption.squareRatio,
        sort: sort_1,
        leafDepth: seriesOption.leafDepth
      };
      viewRoot.hostTree.clearLayouts();
      var viewRootLayout_1 = {
        x: 0,
        y: 0,
        width: rootSize[0],
        height: rootSize[1],
        area: rootSize[0] * rootSize[1]
      };
      viewRoot.setLayout(viewRootLayout_1);
      squarify(viewRoot, options, false, 0);
      viewRootLayout_1 = viewRoot.getLayout();
      each$b(viewAbovePath, function(node, index2) {
        var childValue = (viewAbovePath[index2 + 1] || viewRoot).getValue();
        node.setLayout(extend2({
          dataExtent: [childValue, childValue],
          borderWidth: 0,
          upperHeight: 0
        }, viewRootLayout_1));
      });
    }
    var treeRoot = seriesModel.getData().tree.root;
    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
    seriesModel.setLayoutInfo(layoutInfo);
    prunning(
      treeRoot,
      new BoundingRect$1(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight),
      viewAbovePath,
      viewRoot,
      0
    );
  }
};
function squarify(node, options, hideChildren, depth2) {
  var width;
  var height;
  if (node.isRemoved()) {
    return;
  }
  var thisLayout = node.getLayout();
  width = thisLayout.width;
  height = thisLayout.height;
  var nodeModel = node.getModel();
  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
  var upperLabelHeight = getUpperLabelHeight(nodeModel);
  var upperHeight = Math.max(borderWidth, upperLabelHeight);
  var layoutOffset = borderWidth - halfGapWidth;
  var layoutOffsetUpper = upperHeight - halfGapWidth;
  node.setLayout({
    borderWidth,
    upperHeight,
    upperLabelHeight
  }, true);
  width = mathMax$3(width - 2 * layoutOffset, 0);
  height = mathMax$3(height - layoutOffset - layoutOffsetUpper, 0);
  var totalArea = width * height;
  var viewChildren = initChildren$1(node, nodeModel, totalArea, options, hideChildren, depth2);
  if (!viewChildren.length) {
    return;
  }
  var rect = {
    x: layoutOffset,
    y: layoutOffsetUpper,
    width,
    height
  };
  var rowFixedLength = mathMin$3(width, height);
  var best = Infinity;
  var row = [];
  row.area = 0;
  for (var i = 0, len2 = viewChildren.length; i < len2; ) {
    var child = viewChildren[i];
    row.push(child);
    row.area += child.getLayout().area;
    var score = worst(row, rowFixedLength, options.squareRatio);
    if (score <= best) {
      i++;
      best = score;
    } else {
      row.area -= row.pop().getLayout().area;
      position(row, rowFixedLength, rect, halfGapWidth, false);
      rowFixedLength = mathMin$3(rect.width, rect.height);
      row.length = row.area = 0;
      best = Infinity;
    }
  }
  if (row.length) {
    position(row, rowFixedLength, rect, halfGapWidth, true);
  }
  if (!hideChildren) {
    var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
      hideChildren = true;
    }
  }
  for (var i = 0, len2 = viewChildren.length; i < len2; i++) {
    squarify(viewChildren[i], options, hideChildren, depth2 + 1);
  }
}
function initChildren$1(node, nodeModel, totalArea, options, hideChildren, depth2) {
  var viewChildren = node.children || [];
  var orderBy = options.sort;
  orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth2;
  if (hideChildren && !overLeafDepth) {
    return node.viewChildren = [];
  }
  viewChildren = filter17(viewChildren, function(child) {
    return !child.isRemoved();
  });
  sort$1(viewChildren, orderBy);
  var info = statistic(nodeModel, viewChildren, orderBy);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  for (var i = 0, len2 = viewChildren.length; i < len2; i++) {
    var area5 = viewChildren[i].getValue() / info.sum * totalArea;
    viewChildren[i].setLayout({
      area: area5
    });
  }
  if (overLeafDepth) {
    viewChildren.length && node.setLayout({
      isLeafRoot: true
    }, true);
    viewChildren.length = 0;
  }
  node.viewChildren = viewChildren;
  node.setLayout({
    dataExtent: info.dataExtent
  }, true);
  return viewChildren;
}
function filterByThreshold(nodeModel, totalArea, sum2, orderBy, orderedChildren) {
  if (!orderBy) {
    return sum2;
  }
  var visibleMin = nodeModel.get("visibleMin");
  var len2 = orderedChildren.length;
  var deletePoint = len2;
  for (var i = len2 - 1; i >= 0; i--) {
    var value = orderedChildren[orderBy === "asc" ? len2 - i - 1 : i].getValue();
    if (value / sum2 * totalArea < visibleMin) {
      deletePoint = i;
      sum2 -= value;
    }
  }
  orderBy === "asc" ? orderedChildren.splice(0, len2 - deletePoint) : orderedChildren.splice(deletePoint, len2 - deletePoint);
  return sum2;
}
function sort$1(viewChildren, orderBy) {
  if (orderBy) {
    viewChildren.sort(function(a, b) {
      var diff2 = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
      return diff2 === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff2;
    });
  }
  return viewChildren;
}
function statistic(nodeModel, children, orderBy) {
  var sum2 = 0;
  for (var i = 0, len2 = children.length; i < len2; i++) {
    sum2 += children[i].getValue();
  }
  var dimension = nodeModel.get("visualDimension");
  var dataExtent;
  if (!children || !children.length) {
    dataExtent = [NaN, NaN];
  } else if (dimension === "value" && orderBy) {
    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
    orderBy === "asc" && dataExtent.reverse();
  } else {
    dataExtent = [Infinity, -Infinity];
    each$b(children, function(child) {
      var value = child.getValue(dimension);
      value < dataExtent[0] && (dataExtent[0] = value);
      value > dataExtent[1] && (dataExtent[1] = value);
    });
  }
  return {
    sum: sum2,
    dataExtent
  };
}
function worst(row, rowFixedLength, ratio) {
  var areaMax = 0;
  var areaMin = Infinity;
  for (var i = 0, area5 = void 0, len2 = row.length; i < len2; i++) {
    area5 = row[i].getLayout().area;
    if (area5) {
      area5 < areaMin && (areaMin = area5);
      area5 > areaMax && (areaMax = area5);
    }
  }
  var squareArea = row.area * row.area;
  var f = rowFixedLength * rowFixedLength * ratio;
  return squareArea ? mathMax$3(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
}
function position(row, rowFixedLength, rect, halfGapWidth, flush) {
  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
  var idx1WhenH = 1 - idx0WhenH;
  var xy = ["x", "y"];
  var wh = ["width", "height"];
  var last = rect[xy[idx0WhenH]];
  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
    rowOtherLength = rect[wh[idx1WhenH]];
  }
  for (var i = 0, rowLen = row.length; i < rowLen; i++) {
    var node = row[i];
    var nodeLayout = {};
    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$3(rowOtherLength - 2 * halfGapWidth, 0);
    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
    var modWH = i === rowLen - 1 || remain < step ? remain : step;
    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$3(modWH - 2 * halfGapWidth, 0);
    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$3(halfGapWidth, wh1 / 2);
    nodeLayout[xy[idx0WhenH]] = last + mathMin$3(halfGapWidth, wh0 / 2);
    last += modWH;
    node.setLayout(nodeLayout, true);
  }
  rect[xy[idx1WhenH]] += rowOtherLength;
  rect[wh[idx1WhenH]] -= rowOtherLength;
}
function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
  var currNode = (targetInfo || {}).node;
  var defaultSize = [containerWidth, containerHeight];
  if (!currNode || currNode === viewRoot) {
    return defaultSize;
  }
  var parent;
  var viewArea = containerWidth * containerHeight;
  var area5 = viewArea * seriesModel.option.zoomToNodeRatio;
  while (parent = currNode.parentNode) {
    var sum2 = 0;
    var siblings = parent.children;
    for (var i = 0, len2 = siblings.length; i < len2; i++) {
      sum2 += siblings[i].getValue();
    }
    var currNodeValue = currNode.getValue();
    if (currNodeValue === 0) {
      return defaultSize;
    }
    area5 *= sum2 / currNodeValue;
    var parentModel = parent.getModel();
    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
    area5 += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area5, 0.5);
    area5 > MAX_SAFE_INTEGER && (area5 = MAX_SAFE_INTEGER);
    currNode = parent;
  }
  area5 < viewArea && (area5 = viewArea);
  var scale4 = Math.pow(area5 / viewArea, 0.5);
  return [containerWidth * scale4, containerHeight * scale4];
}
function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
  if (rootRect) {
    return {
      x: rootRect.x,
      y: rootRect.y
    };
  }
  var defaultPosition = {
    x: 0,
    y: 0
  };
  if (!targetInfo) {
    return defaultPosition;
  }
  var targetNode = targetInfo.node;
  var layout2 = targetNode.getLayout();
  if (!layout2) {
    return defaultPosition;
  }
  var targetCenter = [layout2.width / 2, layout2.height / 2];
  var node = targetNode;
  while (node) {
    var nodeLayout = node.getLayout();
    targetCenter[0] += nodeLayout.x;
    targetCenter[1] += nodeLayout.y;
    node = node.parentNode;
  }
  return {
    x: layoutInfo.width / 2 - targetCenter[0],
    y: layoutInfo.height / 2 - targetCenter[1]
  };
}
function prunning(node, clipRect, viewAbovePath, viewRoot, depth2) {
  var nodeLayout = node.getLayout();
  var nodeInViewAbovePath = viewAbovePath[depth2];
  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
  if (nodeInViewAbovePath && !isAboveViewRoot || depth2 === viewAbovePath.length && node !== viewRoot) {
    return;
  }
  node.setLayout({
    isInView: true,
    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
    isAboveViewRoot
  }, true);
  var childClipRect = new BoundingRect$1(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
  each$b(node.viewChildren || [], function(child) {
    prunning(child, childClipRect, viewAbovePath, viewRoot, depth2 + 1);
  });
}
function getUpperLabelHeight(model) {
  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}
function install$G(registers) {
  registers.registerSeriesModel(TreemapSeriesModel$1);
  registers.registerChartView(TreemapView$1);
  registers.registerVisual(treemapVisual);
  registers.registerLayout(treemapLayout);
  installTreemapAction(registers);
}
function categoryFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (!legendModels || !legendModels.length) {
    return;
  }
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    var categoriesData = graphSeries.getCategoriesData();
    var graph = graphSeries.getGraph();
    var data = graph.data;
    var categoryNames = categoriesData.mapArray(categoriesData.getName);
    data.filterSelf(function(idx) {
      var model = data.getItemModel(idx);
      var category = model.getShallow("category");
      if (category != null) {
        if (isNumber(category)) {
          category = categoryNames[category];
        }
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(category)) {
            return false;
          }
        }
      }
      return true;
    });
  });
}
function categoryVisual(ecModel) {
  var paletteScope = {};
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var categoriesData = seriesModel.getCategoriesData();
    var data = seriesModel.getData();
    var categoryNameIdxMap = {};
    categoriesData.each(function(idx) {
      var name2 = categoriesData.getName(idx);
      categoryNameIdxMap["ec-" + name2] = idx;
      var itemModel = categoriesData.getItemModel(idx);
      var style = itemModel.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = seriesModel.getColorFromPalette(name2, paletteScope);
      }
      categoriesData.setItemVisual(idx, "style", style);
      var symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
      for (var i = 0; i < symbolVisualList.length; i++) {
        var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
        if (symbolVisual != null) {
          categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
        }
      }
    });
    if (categoriesData.count()) {
      data.each(function(idx) {
        var model = data.getItemModel(idx);
        var categoryIdx = model.getShallow("category");
        if (categoryIdx != null) {
          if (isString(categoryIdx)) {
            categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
          }
          var categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
          var style = data.ensureUniqueItemVisual(idx, "style");
          extend2(style, categoryStyle);
          var visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
          for (var i = 0; i < visualList.length; i++) {
            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
          }
        }
      });
    }
  });
}
function normalize$1(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
function graphEdgeVisual(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var graph = seriesModel.getGraph();
    var edgeData = seriesModel.getEdgeData();
    var symbolType = normalize$1(seriesModel.get("edgeSymbol"));
    var symbolSize = normalize$1(seriesModel.get("edgeSymbolSize"));
    edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
    edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
    edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
    edgeData.each(function(idx) {
      var itemModel = edgeData.getItemModel(idx);
      var edge = graph.getEdgeByIndex(idx);
      var symbolType2 = normalize$1(itemModel.getShallow("symbol", true));
      var symbolSize2 = normalize$1(itemModel.getShallow("symbolSize", true));
      var style = itemModel.getModel("lineStyle").getLineStyle();
      var existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
      extend2(existsStyle, style);
      switch (existsStyle.stroke) {
        case "source": {
          var nodeStyle = edge.node1.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
        case "target": {
          var nodeStyle = edge.node2.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
      }
      symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
      symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
      symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
    });
  });
}
var KEY_DELIMITER = "-->";
var getAutoCurvenessParams = function(seriesModel) {
  return seriesModel.get("autoCurveness") || null;
};
var createCurveness = function(seriesModel, appendLength) {
  var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
  var length3 = 20;
  var curvenessList = [];
  if (isNumber(autoCurvenessParmas)) {
    length3 = autoCurvenessParmas;
  } else if (isArray$1(autoCurvenessParmas)) {
    seriesModel.__curvenessList = autoCurvenessParmas;
    return;
  }
  if (appendLength > length3) {
    length3 = appendLength;
  }
  var len2 = length3 % 2 ? length3 + 2 : length3 + 3;
  curvenessList = [];
  for (var i = 0; i < len2; i++) {
    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
  }
  seriesModel.__curvenessList = curvenessList;
};
var getKeyOfEdges = function(n1, n2, seriesModel) {
  var source2 = [n1.id, n1.dataIndex].join(".");
  var target = [n2.id, n2.dataIndex].join(".");
  return [seriesModel.uid, source2, target].join(KEY_DELIMITER);
};
var getOppositeKey = function(key) {
  var keys3 = key.split(KEY_DELIMITER);
  return [keys3[0], keys3[2], keys3[1]].join(KEY_DELIMITER);
};
var getEdgeFromMap = function(edge, seriesModel) {
  var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  return seriesModel.__edgeMap[key];
};
var getTotalLengthBetweenNodes = function(edge, seriesModel) {
  var len2 = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
  var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
  return len2 + lenV;
};
var getEdgeMapLengthWithKey = function(key, seriesModel) {
  var edgeMap = seriesModel.__edgeMap;
  return edgeMap[key] ? edgeMap[key].length : 0;
};
function initCurvenessList(seriesModel) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  seriesModel.__curvenessList = [];
  seriesModel.__edgeMap = {};
  createCurveness(seriesModel);
}
function createEdgeMapForCurveness(n1, n2, seriesModel, index2) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  var key = getKeyOfEdges(n1, n2, seriesModel);
  var edgeMap = seriesModel.__edgeMap;
  var oppositeEdges = edgeMap[getOppositeKey(key)];
  if (edgeMap[key] && !oppositeEdges) {
    edgeMap[key].isForward = true;
  } else if (oppositeEdges && edgeMap[key]) {
    oppositeEdges.isForward = true;
    edgeMap[key].isForward = false;
  }
  edgeMap[key] = edgeMap[key] || [];
  edgeMap[key].push(index2);
}
function getCurvenessForEdge(edge, seriesModel, index2, needReverse) {
  var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
  var isArrayParam = isArray$1(autoCurvenessParams);
  if (!autoCurvenessParams) {
    return null;
  }
  var edgeArray = getEdgeFromMap(edge, seriesModel);
  if (!edgeArray) {
    return null;
  }
  var edgeIndex = -1;
  for (var i = 0; i < edgeArray.length; i++) {
    if (edgeArray[i] === index2) {
      edgeIndex = i;
      break;
    }
  }
  var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
  createCurveness(seriesModel, totalLen);
  edge.lineStyle = edge.lineStyle || {};
  var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  var curvenessList = seriesModel.__curvenessList;
  var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
  if (!edgeArray.isForward) {
    var oppositeKey = getOppositeKey(curKey);
    var len2 = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
    var resValue = curvenessList[edgeIndex + len2 + parityCorrection];
    if (needReverse) {
      if (isArrayParam) {
        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
          return (len2 + parityCorrection) % 2 ? resValue : -resValue;
        } else {
          return ((len2 % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return (len2 + parityCorrection) % 2 ? resValue : -resValue;
      }
    } else {
      return curvenessList[edgeIndex + len2 + parityCorrection];
    }
  } else {
    return curvenessList[parityCorrection + edgeIndex];
  }
}
function simpleLayout(seriesModel) {
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  var graph = seriesModel.getGraph();
  graph.eachNode(function(node) {
    var model = node.getModel();
    node.setLayout([+model.get("x"), +model.get("y")]);
  });
  simpleLayoutEdge(graph, seriesModel);
}
function simpleLayoutEdge(graph, seriesModel) {
  graph.eachEdge(function(edge, index2) {
    var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, seriesModel, index2, true), 0);
    var p1 = clone$3(edge.node1.getLayout());
    var p2 = clone$3(edge.node2.getLayout());
    var points2 = [p1, p2];
    if (+curveness) {
      points2.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
    }
    edge.setLayout(points2);
  });
}
function graphSimpleLayout(ecModel, api) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var layout2 = seriesModel.get("layout");
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      var data_1 = seriesModel.getData();
      var dimensions_1 = [];
      each$f(coordSys.dimensions, function(coordDim) {
        dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));
      });
      for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {
        var value = [];
        var hasValue = false;
        for (var i = 0; i < dimensions_1.length; i++) {
          var val = data_1.get(dimensions_1[i], dataIndex);
          if (!isNaN(val)) {
            hasValue = true;
          }
          value.push(val);
        }
        if (hasValue) {
          data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));
        } else {
          data_1.setItemLayout(dataIndex, [NaN, NaN]);
        }
      }
      simpleLayoutEdge(data_1.graph, seriesModel);
    } else if (!layout2 || layout2 === "none") {
      simpleLayout(seriesModel);
    }
  });
}
function getNodeGlobalScale(seriesModel) {
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys.type !== "view") {
    return 1;
  }
  var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
  var groupZoom = coordSys.scaleX;
  var roamZoom = coordSys.getZoom();
  var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
  return nodeScale / groupZoom;
}
function getSymbolSize(node) {
  var symbolSize = node.getVisual("symbolSize");
  if (symbolSize instanceof Array) {
    symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
  }
  return +symbolSize;
}
var PI$2 = Math.PI;
var _symbolRadiansHalf = [];
function circularLayout(seriesModel, basedOn, draggingNode, pointer) {
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  var rect = coordSys.getBoundingRect();
  var nodeData = seriesModel.getData();
  var graph = nodeData.graph;
  var cx = rect.width / 2 + rect.x;
  var cy = rect.height / 2 + rect.y;
  var r = Math.min(rect.width, rect.height) / 2;
  var count3 = nodeData.count();
  nodeData.setLayout({
    cx,
    cy
  });
  if (!count3) {
    return;
  }
  if (draggingNode) {
    var _a2 = coordSys.pointToData(pointer), tempX = _a2[0], tempY = _a2[1];
    var v = [tempX - cx, tempY - cy];
    normalize$3(v, v);
    scale$2(v, v, r);
    draggingNode.setLayout([cx + v[0], cy + v[1]], true);
    var circularRotateLabel = seriesModel.get(["circular", "rotateLabel"]);
    rotateNodeLabel(draggingNode, circularRotateLabel, cx, cy);
  }
  _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count3);
  graph.eachEdge(function(edge, index2) {
    var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(edge, seriesModel, index2), 0);
    var p1 = clone$3(edge.node1.getLayout());
    var p2 = clone$3(edge.node2.getLayout());
    var cp1;
    var x12 = (p1[0] + p2[0]) / 2;
    var y12 = (p1[1] + p2[1]) / 2;
    if (+curveness) {
      curveness *= 3;
      cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
    }
    edge.setLayout([p1, p2, cp1]);
  });
}
var _layoutNodesBasedOn = {
  value: function(seriesModel, graph, nodeData, r, cx, cy, count3) {
    var angle4 = 0;
    var sum2 = nodeData.getSum("value");
    var unitAngle = Math.PI * 2 / (sum2 || count3);
    graph.eachNode(function(node) {
      var value = node.getValue("value");
      var radianHalf = unitAngle * (sum2 ? value : 1) / 2;
      angle4 += radianHalf;
      node.setLayout([r * Math.cos(angle4) + cx, r * Math.sin(angle4) + cy]);
      angle4 += radianHalf;
    });
  },
  symbolSize: function(seriesModel, graph, nodeData, r, cx, cy, count3) {
    var sumRadian = 0;
    _symbolRadiansHalf.length = count3;
    var nodeScale = getNodeGlobalScale(seriesModel);
    graph.eachNode(function(node) {
      var symbolSize = getSymbolSize(node);
      isNaN(symbolSize) && (symbolSize = 2);
      symbolSize < 0 && (symbolSize = 0);
      symbolSize *= nodeScale;
      var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
      isNaN(symbolRadianHalf) && (symbolRadianHalf = PI$2 / 2);
      _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
      sumRadian += symbolRadianHalf * 2;
    });
    var halfRemainRadian = (2 * PI$2 - sumRadian) / count3 / 2;
    var angle4 = 0;
    graph.eachNode(function(node) {
      var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
      angle4 += radianHalf;
      (!node.getLayout() || !node.getLayout().fixed) && node.setLayout([r * Math.cos(angle4) + cx, r * Math.sin(angle4) + cy]);
      angle4 += radianHalf;
    });
  }
};
function rotateNodeLabel(node, circularRotateLabel, cx, cy) {
  var el = node.getGraphicEl();
  if (!el) {
    return;
  }
  var nodeModel = node.getModel();
  var labelRotate = nodeModel.get(["label", "rotate"]) || 0;
  var symbolPath = el.getSymbolPath();
  if (circularRotateLabel) {
    var pos = node.getLayout();
    var rad2 = Math.atan2(pos[1] - cy, pos[0] - cx);
    if (rad2 < 0) {
      rad2 = Math.PI * 2 + rad2;
    }
    var isLeft2 = pos[0] < cx;
    if (isLeft2) {
      rad2 = rad2 - Math.PI;
    }
    var textPosition = isLeft2 ? "left" : "right";
    symbolPath.setTextConfig({
      rotation: -rad2,
      position: textPosition,
      origin: "center"
    });
    var emphasisState = symbolPath.ensureState("emphasis");
    extend2(emphasisState.textConfig || (emphasisState.textConfig = {}), {
      position: textPosition
    });
  } else {
    symbolPath.setTextConfig({
      rotation: labelRotate *= Math.PI / 180
    });
  }
}
function graphCircularLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    if (seriesModel.get("layout") === "circular") {
      circularLayout(seriesModel, "symbolSize");
    }
  });
}
var scaleAndAdd = scaleAndAdd$1;
function forceLayout(inNodes, inEdges, opts) {
  var nodes = inNodes;
  var edges2 = inEdges;
  var rect = opts.rect;
  var width = rect.width;
  var height = rect.height;
  var center2 = [rect.x + width / 2, rect.y + height / 2];
  var gravity = opts.gravity == null ? 0.1 : opts.gravity;
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    if (!n.p) {
      n.p = create$2(width * (Math.random() - 0.5) + center2[0], height * (Math.random() - 0.5) + center2[1]);
    }
    n.pp = clone$3(n.p);
    n.edges = null;
  }
  var initialFriction = opts.friction == null ? 0.6 : opts.friction;
  var friction = initialFriction;
  var beforeStepCallback;
  var afterStepCallback;
  return {
    warmUp: function() {
      friction = initialFriction * 0.8;
    },
    setFixed: function(idx) {
      nodes[idx].fixed = true;
    },
    setUnfixed: function(idx) {
      nodes[idx].fixed = false;
    },
    beforeStep: function(cb) {
      beforeStepCallback = cb;
    },
    afterStep: function(cb) {
      afterStepCallback = cb;
    },
    step: function(cb) {
      beforeStepCallback && beforeStepCallback(nodes, edges2);
      var v12 = [];
      var nLen = nodes.length;
      for (var i2 = 0; i2 < edges2.length; i2++) {
        var e2 = edges2[i2];
        if (e2.ignoreForceLayout) {
          continue;
        }
        var n1 = e2.n1;
        var n2 = e2.n2;
        sub(v12, n2.p, n1.p);
        var d = len(v12) - e2.d;
        var w = n2.w / (n1.w + n2.w);
        if (isNaN(w)) {
          w = 0;
        }
        normalize$3(v12, v12);
        !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
        !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
      }
      for (var i2 = 0; i2 < nLen; i2++) {
        var n3 = nodes[i2];
        if (!n3.fixed) {
          sub(v12, center2, n3.p);
          scaleAndAdd(n3.p, n3.p, v12, gravity * friction);
        }
      }
      for (var i2 = 0; i2 < nLen; i2++) {
        var n1 = nodes[i2];
        for (var j = i2 + 1; j < nLen; j++) {
          var n2 = nodes[j];
          sub(v12, n2.p, n1.p);
          var d = len(v12);
          if (d === 0) {
            set$1(v12, Math.random() - 0.5, Math.random() - 0.5);
            d = 1;
          }
          var repFact = (n1.rep + n2.rep) / d / d;
          !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
          !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
        }
      }
      var v = [];
      for (var i2 = 0; i2 < nLen; i2++) {
        var n3 = nodes[i2];
        if (!n3.fixed) {
          sub(v, n3.p, n3.pp);
          scaleAndAdd(n3.p, n3.p, v, friction);
          copy$1(n3.pp, n3.p);
        }
      }
      friction = friction * 0.992;
      var finished = friction < 0.01;
      afterStepCallback && afterStepCallback(nodes, edges2, finished);
      cb && cb(finished);
    }
  };
}
function graphForceLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    var coordSys = graphSeries.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    if (graphSeries.get("layout") === "force") {
      var preservedPoints_1 = graphSeries.preservedPoints || {};
      var graph_1 = graphSeries.getGraph();
      var nodeData_1 = graph_1.data;
      var edgeData = graph_1.edgeData;
      var forceModel = graphSeries.getModel("force");
      var initLayout = forceModel.get("initLayout");
      if (graphSeries.preservedPoints) {
        nodeData_1.each(function(idx) {
          var id = nodeData_1.getId(idx);
          nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);
        });
      } else if (!initLayout || initLayout === "none") {
        simpleLayout(graphSeries);
      } else if (initLayout === "circular") {
        circularLayout(graphSeries, "value");
      }
      var nodeDataExtent_1 = nodeData_1.getDataExtent("value");
      var edgeDataExtent_1 = edgeData.getDataExtent("value");
      var repulsion = forceModel.get("repulsion");
      var edgeLength = forceModel.get("edgeLength");
      var repulsionArr_1 = isArray$1(repulsion) ? repulsion : [repulsion, repulsion];
      var edgeLengthArr_1 = isArray$1(edgeLength) ? edgeLength : [edgeLength, edgeLength];
      edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];
      var nodes_1 = nodeData_1.mapArray("value", function(value, idx) {
        var point4 = nodeData_1.getItemLayout(idx);
        var rep = linearMap$2(value, nodeDataExtent_1, repulsionArr_1);
        if (isNaN(rep)) {
          rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;
        }
        return {
          w: rep,
          rep,
          fixed: nodeData_1.getItemModel(idx).get("fixed"),
          p: !point4 || isNaN(point4[0]) || isNaN(point4[1]) ? null : point4
        };
      });
      var edges2 = edgeData.mapArray("value", function(value, idx) {
        var edge = graph_1.getEdgeByIndex(idx);
        var d = linearMap$2(value, edgeDataExtent_1, edgeLengthArr_1);
        if (isNaN(d)) {
          d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;
        }
        var edgeModel = edge.getModel();
        var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
        return {
          n1: nodes_1[edge.node1.dataIndex],
          n2: nodes_1[edge.node2.dataIndex],
          d,
          curveness,
          ignoreForceLayout: edgeModel.get("ignoreForceLayout")
        };
      });
      var rect = coordSys.getBoundingRect();
      var forceInstance = forceLayout(nodes_1, edges2, {
        rect,
        gravity: forceModel.get("gravity"),
        friction: forceModel.get("friction")
      });
      forceInstance.beforeStep(function(nodes, edges3) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].fixed) {
            copy$1(nodes[i].p, graph_1.getNodeByIndex(i).getLayout());
          }
        }
      });
      forceInstance.afterStep(function(nodes, edges3, stopped) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (!nodes[i].fixed) {
            graph_1.getNodeByIndex(i).setLayout(nodes[i].p);
          }
          preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p;
        }
        for (var i = 0, l = edges3.length; i < l; i++) {
          var e2 = edges3[i];
          var edge = graph_1.getEdgeByIndex(i);
          var p1 = e2.n1.p;
          var p2 = e2.n2.p;
          var points2 = edge.getLayout();
          points2 = points2 ? points2.slice() : [];
          points2[0] = points2[0] || [];
          points2[1] = points2[1] || [];
          copy$1(points2[0], p1);
          copy$1(points2[1], p2);
          if (+e2.curveness) {
            points2[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e2.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e2.curveness];
          }
          edge.setLayout(points2);
        }
      });
      graphSeries.forceLayout = forceInstance;
      graphSeries.preservedPoints = preservedPoints_1;
      forceInstance.step();
    } else {
      graphSeries.forceLayout = null;
    }
  });
}
function getViewRect$3(seriesModel, api, aspect) {
  var option = extend2(seriesModel.getBoxLayoutParams(), {
    aspect
  });
  return getLayoutRect(option, {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function createViewCoordSys(ecModel, api) {
  var viewList = [];
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var coordSysType = seriesModel.get("coordinateSystem");
    if (!coordSysType || coordSysType === "view") {
      var data_1 = seriesModel.getData();
      var positions = data_1.mapArray(function(idx) {
        var itemModel = data_1.getItemModel(idx);
        return [+itemModel.get("x"), +itemModel.get("y")];
      });
      var min5 = [];
      var max4 = [];
      fromPoints(positions, min5, max4);
      if (max4[0] - min5[0] === 0) {
        max4[0] += 1;
        min5[0] -= 1;
      }
      if (max4[1] - min5[1] === 0) {
        max4[1] += 1;
        min5[1] -= 1;
      }
      var aspect = (max4[0] - min5[0]) / (max4[1] - min5[1]);
      var viewRect2 = getViewRect$3(seriesModel, api, aspect);
      if (isNaN(aspect)) {
        min5 = [viewRect2.x, viewRect2.y];
        max4 = [viewRect2.x + viewRect2.width, viewRect2.y + viewRect2.height];
      }
      var bbWidth = max4[0] - min5[0];
      var bbHeight = max4[1] - min5[1];
      var viewWidth = viewRect2.width;
      var viewHeight = viewRect2.height;
      var viewCoordSys = seriesModel.coordinateSystem = new View$1();
      viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
      viewCoordSys.setBoundingRect(min5[0], min5[1], bbWidth, bbHeight);
      viewCoordSys.setViewRect(viewRect2.x, viewRect2.y, viewWidth, viewHeight);
      viewCoordSys.setCenter(seriesModel.get("center"), api);
      viewCoordSys.setZoom(seriesModel.get("zoom"));
      viewList.push(viewCoordSys);
    }
  });
  return viewList;
}
var straightLineProto = Line$3.prototype;
var bezierCurveProto = BezierCurve$1.prototype;
var StraightLineShape = function() {
  function StraightLineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return StraightLineShape2;
}();
(function(_super) {
  __extends$1(CurveShape, _super);
  function CurveShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return CurveShape;
})(StraightLineShape);
function isStraightLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}
var ECLinePath = function(_super) {
  __extends$1(ECLinePath2, _super);
  function ECLinePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-line";
    return _this;
  }
  ECLinePath2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECLinePath2.prototype.getDefaultShape = function() {
    return new StraightLineShape();
  };
  ECLinePath2.prototype.buildPath = function(ctx, shape) {
    if (isStraightLine(shape)) {
      straightLineProto.buildPath.call(this, ctx, shape);
    } else {
      bezierCurveProto.buildPath.call(this, ctx, shape);
    }
  };
  ECLinePath2.prototype.pointAt = function(t) {
    if (isStraightLine(this.shape)) {
      return straightLineProto.pointAt.call(this, t);
    } else {
      return bezierCurveProto.pointAt.call(this, t);
    }
  };
  ECLinePath2.prototype.tangentAt = function(t) {
    var shape = this.shape;
    var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return normalize$3(p, p);
  };
  return ECLinePath2;
}(Path$1);
var ECLinePath$1 = ECLinePath;
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(symbolCategory) {
  return "_" + symbolCategory + "Type";
}
function createSymbol(name2, lineData, idx) {
  var symbolType = lineData.getItemVisual(idx, name2);
  if (!symbolType || symbolType === "none") {
    return;
  }
  var symbolSize = lineData.getItemVisual(idx, name2 + "Size");
  var symbolRotate = lineData.getItemVisual(idx, name2 + "Rotate");
  var symbolOffset = lineData.getItemVisual(idx, name2 + "Offset");
  var symbolKeepAspect = lineData.getItemVisual(idx, name2 + "KeepAspect");
  var symbolSizeArr = normalizeSymbolSize(symbolSize);
  var symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
  var symbolPath = createSymbol$1(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);
  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
  symbolPath.name = name2;
  return symbolPath;
}
function createLine(points2) {
  var line = new ECLinePath$1({
    name: "line",
    subPixelOptimize: true
  });
  setLinePoints(line.shape, points2);
  return line;
}
function setLinePoints(targetShape, points2) {
  targetShape.x1 = points2[0][0];
  targetShape.y1 = points2[0][1];
  targetShape.x2 = points2[1][0];
  targetShape.y2 = points2[1][1];
  targetShape.percent = 1;
  var cp1 = points2[2];
  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}
var Line = function(_super) {
  __extends$1(Line2, _super);
  function Line2(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;
    _this._createLine(lineData, idx, seriesScope);
    return _this;
  }
  Line2.prototype._createLine = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var linePoints = lineData.getItemLayout(idx);
    var line = createLine(linePoints);
    line.shape.percent = 0;
    initProps(line, {
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line);
    each$f(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Line2.prototype.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName("line");
    var linePoints = lineData.getItemLayout(idx);
    var target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    updateProps$1(line, target, seriesModel, idx);
    each$f(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbolType = lineData.getItemVisual(idx, symbolCategory);
      var key = makeSymbolTypeKey(symbolCategory);
      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        var symbol = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol);
      }
      this[key] = symbolType;
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Line2.prototype.getLinePath = function() {
    return this.childAt(0);
  };
  Line2.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName("line");
    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    var blurLineStyle = seriesScope && seriesScope.blurLineStyle;
    var selectLineStyle = seriesScope && seriesScope.selectLineStyle;
    var labelStatesModels = seriesScope && seriesScope.labelStatesModels;
    var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    var focus = seriesScope && seriesScope.focus;
    var blurScope = seriesScope && seriesScope.blurScope;
    if (!seriesScope || lineData.hasItemOption) {
      var itemModel = lineData.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      blurLineStyle = itemModel.getModel(["blur", "lineStyle"]).getLineStyle();
      selectLineStyle = itemModel.getModel(["select", "lineStyle"]).getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      labelStatesModels = getLabelStatesModels(itemModel);
    }
    var lineStyle = lineData.getItemVisual(idx, "style");
    var visualColor = lineStyle.stroke;
    line.useStyle(lineStyle);
    line.style.fill = null;
    line.style.strokeNoScale = true;
    line.ensureState("emphasis").style = emphasisLineStyle;
    line.ensureState("blur").style = blurLineStyle;
    line.ensureState("select").style = selectLineStyle;
    each$f(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol = this.childOfName(symbolCategory);
      if (symbol) {
        symbol.setColor(visualColor);
        symbol.style.opacity = lineStyle.opacity;
        for (var i = 0; i < SPECIAL_STATES.length; i++) {
          var stateName = SPECIAL_STATES[i];
          var lineState = line.getState(stateName);
          if (lineState) {
            var lineStateStyle = lineState.style || {};
            var state = symbol.ensureState(stateName);
            var stateStyle = state.style || (state.style = {});
            if (lineStateStyle.stroke != null) {
              stateStyle[symbol.__isEmptyBrush ? "stroke" : "fill"] = lineStateStyle.stroke;
            }
            if (lineStateStyle.opacity != null) {
              stateStyle.opacity = lineStateStyle.opacity;
            }
          }
        }
        symbol.markRedraw();
      }
    }, this);
    var rawVal = seriesModel.getRawValue(idx);
    setLabelStyle(this, labelStatesModels, {
      labelDataIndex: idx,
      labelFetcher: {
        getFormattedLabel: function(dataIndex, stateName) {
          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
        }
      },
      inheritColor: visualColor || "#000",
      defaultOpacity: lineStyle.opacity,
      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round$3(rawVal) : rawVal) + ""
    });
    var label = this.getTextContent();
    if (label) {
      var labelNormalModel = labelStatesModels.normal;
      label.__align = label.style.align;
      label.__verticalAlign = label.style.verticalAlign;
      label.__position = labelNormalModel.get("position") || "middle";
      var distance11 = labelNormalModel.get("distance");
      if (!isArray$1(distance11)) {
        distance11 = [distance11, distance11];
      }
      label.__labelDistance = distance11;
    }
    this.setTextConfig({
      position: null,
      local: true,
      inside: false
    });
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Line2.prototype.highlight = function() {
    enterEmphasis(this);
  };
  Line2.prototype.downplay = function() {
    leaveEmphasis(this);
  };
  Line2.prototype.updateLayout = function(lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  };
  Line2.prototype.setLinePoints = function(points2) {
    var linePath = this.childOfName("line");
    setLinePoints(linePath.shape, points2);
    linePath.dirty();
  };
  Line2.prototype.beforeUpdate = function() {
    var lineGroup = this;
    var symbolFrom = lineGroup.childOfName("fromSymbol");
    var symbolTo = lineGroup.childOfName("toSymbol");
    var label = lineGroup.getTextContent();
    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
      return;
    }
    var invScale = 1;
    var parentNode2 = this.parent;
    while (parentNode2) {
      if (parentNode2.scaleX) {
        invScale /= parentNode2.scaleX;
      }
      parentNode2 = parentNode2.parent;
    }
    var line = lineGroup.childOfName("line");
    if (!this.__dirty && !line.__dirty) {
      return;
    }
    var percent = line.shape.percent;
    var fromPos = line.pointAt(0);
    var toPos = line.pointAt(percent);
    var d = sub([], toPos, fromPos);
    normalize$3(d, d);
    function setSymbolRotation(symbol, percent2) {
      var specifiedRotation = symbol.__specifiedRotation;
      if (specifiedRotation == null) {
        var tangent2 = line.tangentAt(percent2);
        symbol.attr("rotation", (percent2 === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent2[1], tangent2[0]));
      } else {
        symbol.attr("rotation", specifiedRotation);
      }
    }
    if (symbolFrom) {
      symbolFrom.setPosition(fromPos);
      setSymbolRotation(symbolFrom, 0);
      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
      symbolFrom.markRedraw();
    }
    if (symbolTo) {
      symbolTo.setPosition(toPos);
      setSymbolRotation(symbolTo, 1);
      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
      symbolTo.markRedraw();
    }
    if (label && !label.ignore) {
      label.x = label.y = 0;
      label.originX = label.originY = 0;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var distance11 = label.__labelDistance;
      var distanceX = distance11[0] * invScale;
      var distanceY = distance11[1] * invScale;
      var halfPercent = percent / 2;
      var tangent = line.tangentAt(halfPercent);
      var n = [tangent[1], -tangent[0]];
      var cp = line.pointAt(halfPercent);
      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }
      var dir3 = tangent[0] < 0 ? -1 : 1;
      if (label.__position !== "start" && label.__position !== "end") {
        var rotation = -Math.atan2(tangent[1], tangent[0]);
        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }
        label.rotation = rotation;
      }
      var dy = void 0;
      switch (label.__position) {
        case "insideStartTop":
        case "insideMiddleTop":
        case "insideEndTop":
        case "middle":
          dy = -distanceY;
          textVerticalAlign = "bottom";
          break;
        case "insideStartBottom":
        case "insideMiddleBottom":
        case "insideEndBottom":
          dy = distanceY;
          textVerticalAlign = "top";
          break;
        default:
          dy = 0;
          textVerticalAlign = "middle";
      }
      switch (label.__position) {
        case "end":
          label.x = d[0] * distanceX + toPos[0];
          label.y = d[1] * distanceY + toPos[1];
          textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
          textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
          break;
        case "start":
          label.x = -d[0] * distanceX + fromPos[0];
          label.y = -d[1] * distanceY + fromPos[1];
          textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
          textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
          break;
        case "insideStartTop":
        case "insideStart":
        case "insideStartBottom":
          label.x = distanceX * dir3 + fromPos[0];
          label.y = fromPos[1] + dy;
          textAlign = tangent[0] < 0 ? "right" : "left";
          label.originX = -distanceX * dir3;
          label.originY = -dy;
          break;
        case "insideMiddleTop":
        case "insideMiddle":
        case "insideMiddleBottom":
        case "middle":
          label.x = cp[0];
          label.y = cp[1] + dy;
          textAlign = "center";
          label.originY = -dy;
          break;
        case "insideEndTop":
        case "insideEnd":
        case "insideEndBottom":
          label.x = -distanceX * dir3 + toPos[0];
          label.y = toPos[1] + dy;
          textAlign = tangent[0] >= 0 ? "right" : "left";
          label.originX = distanceX * dir3;
          label.originY = -dy;
          break;
      }
      label.scaleX = label.scaleY = invScale;
      label.setStyle({
        verticalAlign: label.__verticalAlign || textVerticalAlign,
        align: label.__align || textAlign
      });
    }
  };
  return Line2;
}(Group$4);
var Line$1 = Line;
var LineDraw = function() {
  function LineDraw2(LineCtor) {
    this.group = new Group$4();
    this._LineCtor = LineCtor || Line$1;
  }
  LineDraw2.prototype.updateData = function(lineData) {
    var _this = this;
    this._progressiveEls = null;
    var lineDraw = this;
    var group = lineDraw.group;
    var oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData;
    if (!oldLineData) {
      group.removeAll();
    }
    var seriesScope = makeSeriesScope$1(lineData);
    lineData.diff(oldLineData).add(function(idx) {
      _this._doAdd(lineData, idx, seriesScope);
    }).update(function(newIdx, oldIdx) {
      _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove(function(idx) {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  };
  LineDraw2.prototype.updateLayout = function() {
    var lineData = this._lineData;
    if (!lineData) {
      return;
    }
    lineData.eachItemGraphicEl(function(el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  };
  LineDraw2.prototype.incrementalPrepareUpdate = function(lineData) {
    this._seriesScope = makeSeriesScope$1(lineData);
    this._lineData = null;
    this.group.removeAll();
  };
  LineDraw2.prototype.incrementalUpdate = function(taskParams, lineData) {
    this._progressiveEls = [];
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup && !isEffectObject(el2)) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var itemLayout = lineData.getItemLayout(idx);
      if (lineNeedsDraw(itemLayout)) {
        var el = new this._LineCtor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  };
  LineDraw2.prototype.remove = function() {
    this.group.removeAll();
  };
  LineDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  LineDraw2.prototype._doAdd = function(lineData, idx, seriesScope) {
    var itemLayout = lineData.getItemLayout(idx);
    if (!lineNeedsDraw(itemLayout)) {
      return;
    }
    var el = new this._LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    this.group.add(el);
  };
  LineDraw2.prototype._doUpdate = function(oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    var itemEl = oldLineData.getItemGraphicEl(oldIdx);
    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      this.group.remove(itemEl);
      return;
    }
    if (!itemEl) {
      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }
    newLineData.setItemGraphicEl(newIdx, itemEl);
    this.group.add(itemEl);
  };
  return LineDraw2;
}();
function isEffectObject(el) {
  return el.animators && el.animators.length > 0;
}
function makeSeriesScope$1(lineData) {
  var hostModel = lineData.hostModel;
  var emphasisModel = hostModel.getModel("emphasis");
  return {
    lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: emphasisModel.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: hostModel.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: hostModel.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: emphasisModel.get("disabled"),
    blurScope: emphasisModel.get("blurScope"),
    focus: emphasisModel.get("focus"),
    labelStatesModels: getLabelStatesModels(hostModel)
  };
}
function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}
function lineNeedsDraw(pts) {
  return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
var LineDraw$1 = LineDraw;
var v1 = [];
var v2 = [];
var v3 = [];
var quadraticAt = quadraticAt$1;
var v2DistSquare = distSquare;
var mathAbs = Math.abs;
function intersectCurveCircle(curvePoints, center2, radius) {
  var p0 = curvePoints[0];
  var p1 = curvePoints[1];
  var p2 = curvePoints[2];
  var d = Infinity;
  var t;
  var radiusSquare = radius * radius;
  var interval = 0.1;
  for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
    v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
    v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
    var diff2 = mathAbs(v2DistSquare(v1, center2) - radiusSquare);
    if (diff2 < d) {
      d = diff2;
      t = _t;
    }
  }
  for (var i = 0; i < 32; i++) {
    var next3 = t + interval;
    v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
    v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
    v3[0] = quadraticAt(p0[0], p1[0], p2[0], next3);
    v3[1] = quadraticAt(p0[1], p1[1], p2[1], next3);
    var diff2 = v2DistSquare(v2, center2) - radiusSquare;
    if (mathAbs(diff2) < 0.01) {
      break;
    }
    var nextDiff = v2DistSquare(v3, center2) - radiusSquare;
    interval /= 2;
    if (diff2 < 0) {
      if (nextDiff >= 0) {
        t = t + interval;
      } else {
        t = t - interval;
      }
    } else {
      if (nextDiff >= 0) {
        t = t - interval;
      } else {
        t = t + interval;
      }
    }
  }
  return t;
}
function adjustEdge(graph, scale4) {
  var tmp0 = [];
  var quadraticSubdivide$1 = quadraticSubdivide;
  var pts = [[], [], []];
  var pts2 = [[], []];
  var v = [];
  scale4 /= 2;
  graph.eachEdge(function(edge, idx) {
    var linePoints = edge.getLayout();
    var fromSymbol = edge.getVisual("fromSymbol");
    var toSymbol = edge.getVisual("toSymbol");
    if (!linePoints.__original) {
      linePoints.__original = [clone$3(linePoints[0]), clone$3(linePoints[1])];
      if (linePoints[2]) {
        linePoints.__original.push(clone$3(linePoints[2]));
      }
    }
    var originalPoints = linePoints.__original;
    if (linePoints[2] != null) {
      copy$1(pts[0], originalPoints[0]);
      copy$1(pts[1], originalPoints[2]);
      copy$1(pts[2], originalPoints[1]);
      if (fromSymbol && fromSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node1);
        var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale4);
        quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[0][0] = tmp0[3];
        pts[1][0] = tmp0[4];
        quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[0][1] = tmp0[3];
        pts[1][1] = tmp0[4];
      }
      if (toSymbol && toSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node2);
        var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale4);
        quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[1][0] = tmp0[1];
        pts[2][0] = tmp0[2];
        quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[1][1] = tmp0[1];
        pts[2][1] = tmp0[2];
      }
      copy$1(linePoints[0], pts[0]);
      copy$1(linePoints[1], pts[2]);
      copy$1(linePoints[2], pts[1]);
    } else {
      copy$1(pts2[0], originalPoints[0]);
      copy$1(pts2[1], originalPoints[1]);
      sub(v, pts2[1], pts2[0]);
      normalize$3(v, v);
      if (fromSymbol && fromSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node1);
        scaleAndAdd$1(pts2[0], pts2[0], v, symbolSize * scale4);
      }
      if (toSymbol && toSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node2);
        scaleAndAdd$1(pts2[1], pts2[1], v, -symbolSize * scale4);
      }
      copy$1(linePoints[0], pts2[0]);
      copy$1(linePoints[1], pts2[1]);
    }
  });
}
function isViewCoordSys(coordSys) {
  return coordSys.type === "view";
}
var GraphView = function(_super) {
  __extends$1(GraphView2, _super);
  function GraphView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphView2.type;
    return _this;
  }
  GraphView2.prototype.init = function(ecModel, api) {
    var symbolDraw = new SymbolDraw$1();
    var lineDraw = new LineDraw$1();
    var group = this.group;
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: group
    };
    group.add(symbolDraw.group);
    group.add(lineDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineDraw = lineDraw;
    this._firstRender = true;
  };
  GraphView2.prototype.render = function(seriesModel, ecModel, api) {
    var _this = this;
    var coordSys = seriesModel.coordinateSystem;
    this._model = seriesModel;
    var symbolDraw = this._symbolDraw;
    var lineDraw = this._lineDraw;
    var group = this.group;
    if (isViewCoordSys(coordSys)) {
      var groupNewProp = {
        x: coordSys.x,
        y: coordSys.y,
        scaleX: coordSys.scaleX,
        scaleY: coordSys.scaleY
      };
      if (this._firstRender) {
        group.attr(groupNewProp);
      } else {
        updateProps$1(group, groupNewProp, seriesModel);
      }
    }
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    var data = seriesModel.getData();
    symbolDraw.updateData(data);
    var edgeData = seriesModel.getEdgeData();
    lineDraw.updateData(edgeData);
    this._updateNodeAndLinkScale();
    this._updateController(seriesModel, ecModel, api);
    clearTimeout(this._layoutTimeout);
    var forceLayout2 = seriesModel.forceLayout;
    var layoutAnimation = seriesModel.get(["force", "layoutAnimation"]);
    if (forceLayout2) {
      this._startForceLayoutIteration(forceLayout2, layoutAnimation);
    }
    var layout2 = seriesModel.get("layout");
    data.graph.eachNode(function(node) {
      var idx = node.dataIndex;
      var el = node.getGraphicEl();
      var itemModel = node.getModel();
      if (!el) {
        return;
      }
      el.off("drag").off("dragend");
      var draggable = itemModel.get("draggable");
      if (draggable) {
        el.on("drag", function(e2) {
          switch (layout2) {
            case "force":
              forceLayout2.warmUp();
              !_this._layouting && _this._startForceLayoutIteration(forceLayout2, layoutAnimation);
              forceLayout2.setFixed(idx);
              data.setItemLayout(idx, [el.x, el.y]);
              break;
            case "circular":
              data.setItemLayout(idx, [el.x, el.y]);
              node.setLayout({
                fixed: true
              }, true);
              circularLayout(seriesModel, "symbolSize", node, [e2.offsetX, e2.offsetY]);
              _this.updateLayout(seriesModel);
              break;
            case "none":
            default:
              data.setItemLayout(idx, [el.x, el.y]);
              simpleLayoutEdge(seriesModel.getGraph(), seriesModel);
              _this.updateLayout(seriesModel);
              break;
          }
        }).on("dragend", function() {
          if (forceLayout2) {
            forceLayout2.setUnfixed(idx);
          }
        });
      }
      el.setDraggable(draggable && !!forceLayout2, !!itemModel.get("cursor"));
      var focus = itemModel.get(["emphasis", "focus"]);
      if (focus === "adjacency") {
        getECData(el).focus = node.getAdjacentDataIndices();
      }
    });
    data.graph.eachEdge(function(edge) {
      var el = edge.getGraphicEl();
      var focus = edge.getModel().get(["emphasis", "focus"]);
      if (!el) {
        return;
      }
      if (focus === "adjacency") {
        getECData(el).focus = {
          edge: [edge.dataIndex],
          node: [edge.node1.dataIndex, edge.node2.dataIndex]
        };
      }
    });
    var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get(["circular", "rotateLabel"]);
    var cx = data.getLayout("cx");
    var cy = data.getLayout("cy");
    data.graph.eachNode(function(node) {
      rotateNodeLabel(node, circularRotateLabel, cx, cy);
    });
    this._firstRender = false;
  };
  GraphView2.prototype.dispose = function() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  };
  GraphView2.prototype._startForceLayoutIteration = function(forceLayout2, layoutAnimation) {
    var self2 = this;
    (function step() {
      forceLayout2.step(function(stopped) {
        self2.updateLayout(self2._model);
        (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
      });
    })();
  };
  GraphView2.prototype._updateController = function(seriesModel, ecModel, api) {
    var _this = this;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    var group = this.group;
    controller.setPointerChecker(function(e2, x2, y2) {
      var rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x2, y2) && !onIrrelevantElement(e2, api, seriesModel);
    });
    if (!isViewCoordSys(seriesModel.coordinateSystem)) {
      controller.disable();
      return;
    }
    controller.enable(seriesModel.get("roam"));
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off("pan").off("zoom").on("pan", function(e2) {
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", function(e2) {
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
      _this._updateNodeAndLinkScale();
      adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      _this._lineDraw.updateLayout();
      api.updateLabelLayout();
    });
  };
  GraphView2.prototype._updateNodeAndLinkScale = function() {
    var seriesModel = this._model;
    var data = seriesModel.getData();
    var nodeScale = getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el && el.setSymbolScale(nodeScale);
    });
  };
  GraphView2.prototype.updateLayout = function(seriesModel) {
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    this._symbolDraw.updateLayout();
    this._lineDraw.updateLayout();
  };
  GraphView2.prototype.remove = function(ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove();
    this._lineDraw && this._lineDraw.remove();
  };
  GraphView2.type = "graph";
  return GraphView2;
}(ChartView$1);
var GraphView$1 = GraphView;
function generateNodeKey(id) {
  return "_EC_" + id;
}
var Graph = function() {
  function Graph2(directed) {
    this.type = "graph";
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    this._edgesMap = {};
    this._directed = directed || false;
  }
  Graph2.prototype.isDirected = function() {
    return this._directed;
  };
  Graph2.prototype.addNode = function(id, dataIndex) {
    id = id == null ? "" + dataIndex : "" + id;
    var nodesMap = this._nodesMap;
    if (nodesMap[generateNodeKey(id)]) {
      {
        console.error("Graph nodes have duplicate name or id");
      }
      return;
    }
    var node = new GraphNode(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[generateNodeKey(id)] = node;
    return node;
  };
  Graph2.prototype.getNodeByIndex = function(dataIndex) {
    var rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  };
  Graph2.prototype.getNodeById = function(id) {
    return this._nodesMap[generateNodeKey(id)];
  };
  Graph2.prototype.addEdge = function(n1, n2, dataIndex) {
    var nodesMap = this._nodesMap;
    var edgesMap = this._edgesMap;
    if (isNumber(n1)) {
      n1 = this.nodes[n1];
    }
    if (isNumber(n2)) {
      n2 = this.nodes[n2];
    }
    if (!(n1 instanceof GraphNode)) {
      n1 = nodesMap[generateNodeKey(n1)];
    }
    if (!(n2 instanceof GraphNode)) {
      n2 = nodesMap[generateNodeKey(n2)];
    }
    if (!n1 || !n2) {
      return;
    }
    var key = n1.id + "-" + n2.id;
    var edge = new GraphEdge(n1, n2, dataIndex);
    edge.hostGraph = this;
    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }
    n1.edges.push(edge);
    if (n1 !== n2) {
      n2.edges.push(edge);
    }
    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  };
  Graph2.prototype.getEdgeByIndex = function(dataIndex) {
    var rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  };
  Graph2.prototype.getEdge = function(n1, n2) {
    if (n1 instanceof GraphNode) {
      n1 = n1.id;
    }
    if (n2 instanceof GraphNode) {
      n2 = n2.id;
    }
    var edgesMap = this._edgesMap;
    if (this._directed) {
      return edgesMap[n1 + "-" + n2];
    } else {
      return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
    }
  };
  Graph2.prototype.eachNode = function(cb, context) {
    var nodes = this.nodes;
    var len2 = nodes.length;
    for (var i = 0; i < len2; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  };
  Graph2.prototype.eachEdge = function(cb, context) {
    var edges2 = this.edges;
    var len2 = edges2.length;
    for (var i = 0; i < len2; i++) {
      if (edges2[i].dataIndex >= 0 && edges2[i].node1.dataIndex >= 0 && edges2[i].node2.dataIndex >= 0) {
        cb.call(context, edges2[i], i);
      }
    }
  };
  Graph2.prototype.breadthFirstTraverse = function(cb, startNode, direction, context) {
    if (!(startNode instanceof GraphNode)) {
      startNode = this._nodesMap[generateNodeKey(startNode)];
    }
    if (!startNode) {
      return;
    }
    var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }
    if (cb.call(context, startNode, null)) {
      return;
    }
    var queue = [startNode];
    while (queue.length) {
      var currentNode = queue.shift();
      var edges2 = currentNode[edgeType];
      for (var i = 0; i < edges2.length; i++) {
        var e2 = edges2[i];
        var otherNode = e2.node1 === currentNode ? e2.node2 : e2.node1;
        if (!otherNode.__visited) {
          if (cb.call(context, otherNode, currentNode)) {
            return;
          }
          queue.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  };
  Graph2.prototype.update = function() {
    var data = this.data;
    var edgeData = this.edgeData;
    var nodes = this.nodes;
    var edges2 = this.edges;
    for (var i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
    edgeData.filterSelf(function(idx) {
      var edge = edges2[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    });
    for (var i = 0, len2 = edges2.length; i < len2; i++) {
      edges2[i].dataIndex = -1;
    }
    for (var i = 0, len2 = edgeData.count(); i < len2; i++) {
      edges2[edgeData.getRawIndex(i)].dataIndex = i;
    }
  };
  Graph2.prototype.clone = function() {
    var graph = new Graph2(this._directed);
    var nodes = this.nodes;
    var edges2 = this.edges;
    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(nodes[i].id, nodes[i].dataIndex);
    }
    for (var i = 0; i < edges2.length; i++) {
      var e2 = edges2[i];
      graph.addEdge(e2.node1.id, e2.node2.id, e2.dataIndex);
    }
    return graph;
  };
  return Graph2;
}();
var GraphNode = function() {
  function GraphNode2(id, dataIndex) {
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.dataIndex = -1;
    this.id = id == null ? "" : id;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  GraphNode2.prototype.degree = function() {
    return this.edges.length;
  };
  GraphNode2.prototype.inDegree = function() {
    return this.inEdges.length;
  };
  GraphNode2.prototype.outDegree = function() {
    return this.outEdges.length;
  };
  GraphNode2.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var graph = this.hostGraph;
    var itemModel = graph.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  GraphNode2.prototype.getAdjacentDataIndices = function() {
    var dataIndices = {
      edge: [],
      node: []
    };
    for (var i = 0; i < this.edges.length; i++) {
      var adjacentEdge = this.edges[i];
      if (adjacentEdge.dataIndex < 0) {
        continue;
      }
      dataIndices.edge.push(adjacentEdge.dataIndex);
      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
    }
    return dataIndices;
  };
  return GraphNode2;
}();
var GraphEdge = function() {
  function GraphEdge2(n1, n2, dataIndex) {
    this.dataIndex = -1;
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  GraphEdge2.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var graph = this.hostGraph;
    var itemModel = graph.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  GraphEdge2.prototype.getAdjacentDataIndices = function() {
    return {
      edge: [this.dataIndex],
      node: [this.node1.dataIndex, this.node2.dataIndex]
    };
  };
  return GraphEdge2;
}();
function createGraphDataProxyMixin(hostName, dataName) {
  return {
    getValue: function(dimension) {
      var data = this[hostName][dataName];
      return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
    },
    setVisual: function(key, value) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
    },
    getVisual: function(key) {
      return this[hostName][dataName].getItemVisual(this.dataIndex, key);
    },
    setLayout: function(layout2, merge4) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout2, merge4);
    },
    getLayout: function() {
      return this[hostName][dataName].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[hostName][dataName].getRawIndex(this.dataIndex);
    }
  };
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
var Graph$1 = Graph;
function createGraphFromNodeEdge(nodes, edges2, seriesModel, directed, beforeLink) {
  var graph = new Graph$1(directed);
  for (var i = 0; i < nodes.length; i++) {
    graph.addNode(retrieve(
      nodes[i].id,
      nodes[i].name,
      i
    ), i);
  }
  var linkNameList = [];
  var validEdges = [];
  var linkCount = 0;
  for (var i = 0; i < edges2.length; i++) {
    var link2 = edges2[i];
    var source2 = link2.source;
    var target = link2.target;
    if (graph.addEdge(source2, target, linkCount)) {
      validEdges.push(link2);
      linkNameList.push(retrieve(convertOptionIdName(link2.id, null), source2 + " > " + target));
      linkCount++;
    }
  }
  var coordSys = seriesModel.get("coordinateSystem");
  var nodeData;
  if (coordSys === "cartesian2d" || coordSys === "polar") {
    nodeData = createSeriesData(nodes, seriesModel);
  } else {
    var coordSysCtor = CoordinateSystem.get(coordSys);
    var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];
    if (indexOf2(coordDimensions, "value") < 0) {
      coordDimensions.concat(["value"]);
    }
    var dimensions = prepareSeriesDataSchema(nodes, {
      coordDimensions,
      encodeDefine: seriesModel.getEncode()
    }).dimensions;
    nodeData = new SeriesData$1(dimensions, seriesModel);
    nodeData.initData(nodes);
  }
  var edgeData = new SeriesData$1(["value"], seriesModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  linkSeriesData({
    mainData: nodeData,
    struct: graph,
    structAttr: "graph",
    datas: {
      node: nodeData,
      edge: edgeData
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  });
  graph.update();
  return graph;
}
var GraphSeriesModel = function(_super) {
  __extends$1(GraphSeriesModel2, _super);
  function GraphSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  GraphSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    var self2 = this;
    function getCategoriesData() {
      return self2._categoriesData;
    }
    this.legendVisualProvider = new LegendVisualProvider$1(getCategoriesData, getCategoriesData);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  };
  GraphSeriesModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  };
  GraphSeriesModel2.prototype.mergeDefaultAndTheme = function(option) {
    _super.prototype.mergeDefaultAndTheme.apply(this, arguments);
    defaultEmphasis(option, "edgeLabel", ["show"]);
  };
  GraphSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var edges2 = option.edges || option.links || [];
    var nodes = option.data || option.nodes || [];
    var self2 = this;
    if (nodes && edges2) {
      initCurvenessList(this);
      var graph = createGraphFromNodeEdge(nodes, edges2, this, true, beforeLink);
      each$f(graph.edges, function(edge) {
        createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
      }, this);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model) {
        var categoriesModels = self2._categoriesModels;
        var categoryIdx = model.getShallow("category");
        var categoryModel = categoriesModels[categoryIdx];
        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }
        return model;
      });
      var oldGetModel = Model$1.prototype.getModel;
      function newGetModel(path, parentModel) {
        var model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          var newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  };
  GraphSeriesModel2.prototype.getGraph = function() {
    return this.getData().graph;
  };
  GraphSeriesModel2.prototype.getEdgeData = function() {
    return this.getGraph().edgeData;
  };
  GraphSeriesModel2.prototype.getCategoriesData = function() {
    return this._categoriesData;
  };
  GraphSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    if (dataType === "edge") {
      var nodeData = this.getData();
      var params = this.getDataParams(dataIndex, dataType);
      var edge = nodeData.graph.getEdgeByIndex(dataIndex);
      var sourceName = nodeData.getName(edge.node1.dataIndex);
      var targetName = nodeData.getName(edge.node2.dataIndex);
      var nameArr = [];
      sourceName != null && nameArr.push(sourceName);
      targetName != null && nameArr.push(targetName);
      return createTooltipMarkup("nameValue", {
        name: nameArr.join(" > "),
        value: params.value,
        noValue: params.value == null
      });
    }
    var nodeMarkup = defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
    return nodeMarkup;
  };
  GraphSeriesModel2.prototype._updateCategoriesData = function() {
    var categories = map$1(this.option.categories || [], function(category) {
      return category.value != null ? category : extend2({
        value: 0
      }, category);
    });
    var categoriesData = new SeriesData$1(["value"], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function(idx) {
      return categoriesData.getItemModel(idx);
    });
  };
  GraphSeriesModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  GraphSeriesModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  GraphSeriesModel2.prototype.isAnimationEnabled = function() {
    return _super.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
  };
  GraphSeriesModel2.type = "series.graph";
  GraphSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
  GraphSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "view",
    legendHoverLink: true,
    layout: null,
    circular: {
      rotateLabel: false
    },
    force: {
      initLayout: null,
      repulsion: [0, 50],
      gravity: 0.1,
      friction: 0.6,
      edgeLength: 30,
      layoutAnimation: true
    },
    left: "center",
    top: "center",
    symbol: "circle",
    symbolSize: 10,
    edgeSymbol: ["none", "none"],
    edgeSymbolSize: 10,
    edgeLabel: {
      position: "middle",
      distance: 5
    },
    draggable: false,
    roam: false,
    center: null,
    zoom: 1,
    nodeScaleRatio: 0.6,
    label: {
      show: false,
      formatter: "{b}"
    },
    itemStyle: {},
    lineStyle: {
      color: "#aaa",
      width: 1,
      opacity: 0.5
    },
    emphasis: {
      scale: true,
      label: {
        show: true
      }
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  };
  return GraphSeriesModel2;
}(SeriesModel$1);
var GraphSeriesModel$1 = GraphSeriesModel;
var actionInfo$1 = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function install$F(registers) {
  registers.registerChartView(GraphView$1);
  registers.registerSeriesModel(GraphSeriesModel$1);
  registers.registerProcessor(categoryFilter);
  registers.registerVisual(categoryVisual);
  registers.registerVisual(graphEdgeVisual);
  registers.registerLayout(graphSimpleLayout);
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);
  registers.registerLayout(graphForceLayout);
  registers.registerCoordinateSystem("graphView", {
    dimensions: View$1.dimensions,
    create: createViewCoordSys
  });
  registers.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, noop);
  registers.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, noop);
  registers.registerAction(actionInfo$1, function(payload, ecModel, api) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = updateCenterAndZoom(coordSys, payload, void 0, api);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}
var PointerShape = function() {
  function PointerShape2() {
    this.angle = 0;
    this.width = 10;
    this.r = 10;
    this.x = 0;
    this.y = 0;
  }
  return PointerShape2;
}();
var PointerPath = function(_super) {
  __extends$1(PointerPath2, _super);
  function PointerPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "pointer";
    return _this;
  }
  PointerPath2.prototype.getDefaultShape = function() {
    return new PointerShape();
  };
  PointerPath2.prototype.buildPath = function(ctx, shape) {
    var mathCos2 = Math.cos;
    var mathSin2 = Math.sin;
    var r = shape.r;
    var width = shape.width;
    var angle4 = shape.angle;
    var x2 = shape.x - mathCos2(angle4) * width * (width >= r / 3 ? 1 : 2);
    var y2 = shape.y - mathSin2(angle4) * width * (width >= r / 3 ? 1 : 2);
    angle4 = shape.angle - Math.PI / 2;
    ctx.moveTo(x2, y2);
    ctx.lineTo(shape.x + mathCos2(angle4) * width, shape.y + mathSin2(angle4) * width);
    ctx.lineTo(shape.x + mathCos2(shape.angle) * r, shape.y + mathSin2(shape.angle) * r);
    ctx.lineTo(shape.x - mathCos2(angle4) * width, shape.y - mathSin2(angle4) * width);
    ctx.lineTo(x2, y2);
  };
  return PointerPath2;
}(Path$1);
var PointerPath$1 = PointerPath;
function parsePosition(seriesModel, api) {
  var center2 = seriesModel.get("center");
  var width = api.getWidth();
  var height = api.getHeight();
  var size11 = Math.min(width, height);
  var cx = parsePercent(center2[0], api.getWidth());
  var cy = parsePercent(center2[1], api.getHeight());
  var r = parsePercent(seriesModel.get("radius"), size11 / 2);
  return {
    cx,
    cy,
    r
  };
}
function formatLabel(value, labelFormatter) {
  var label = value == null ? "" : value + "";
  if (labelFormatter) {
    if (isString(labelFormatter)) {
      label = labelFormatter.replace("{value}", label);
    } else if (isFunction(labelFormatter)) {
      label = labelFormatter(value);
    }
  }
  return label;
}
var GaugeView = function(_super) {
  __extends$1(GaugeView2, _super);
  function GaugeView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GaugeView2.type;
    return _this;
  }
  GaugeView2.prototype.render = function(seriesModel, ecModel, api) {
    this.group.removeAll();
    var colorList2 = seriesModel.get(["axisLine", "lineStyle", "color"]);
    var posInfo = parsePosition(seriesModel, api);
    this._renderMain(seriesModel, ecModel, api, colorList2, posInfo);
    this._data = seriesModel.getData();
  };
  GaugeView2.prototype.dispose = function() {
  };
  GaugeView2.prototype._renderMain = function(seriesModel, ecModel, api, colorList2, posInfo) {
    var group = this.group;
    var clockwise = seriesModel.get("clockwise");
    var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
    var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
    var axisLineModel = seriesModel.getModel("axisLine");
    var roundCap = axisLineModel.get("roundCap");
    var MainPath = roundCap ? Sausage : Sector$1;
    var showAxis = axisLineModel.get("show");
    var lineStyleModel = axisLineModel.getModel("lineStyle");
    var axisLineWidth = lineStyleModel.get("width");
    var angles = [startAngle, endAngle];
    normalizeArcAngles(angles, !clockwise);
    startAngle = angles[0];
    endAngle = angles[1];
    var angleRangeSpan = endAngle - startAngle;
    var prevEndAngle = startAngle;
    for (var i = 0; showAxis && i < colorList2.length; i++) {
      var percent = Math.min(Math.max(colorList2[i][0], 0), 1);
      endAngle = startAngle + angleRangeSpan * percent;
      var sector2 = new MainPath({
        shape: {
          startAngle: prevEndAngle,
          endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0: posInfo.r - axisLineWidth,
          r: posInfo.r
        },
        silent: true
      });
      sector2.setStyle({
        fill: colorList2[i][1]
      });
      sector2.setStyle(lineStyleModel.getLineStyle(
        ["color", "width"]
      ));
      group.add(sector2);
      prevEndAngle = endAngle;
    }
    var getColor = function(percent2) {
      if (percent2 <= 0) {
        return colorList2[0][1];
      }
      var i2;
      for (i2 = 0; i2 < colorList2.length; i2++) {
        if (colorList2[i2][0] >= percent2 && (i2 === 0 ? 0 : colorList2[i2 - 1][0]) < percent2) {
          return colorList2[i2][1];
        }
      }
      return colorList2[i2 - 1][1];
    };
    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);
    this._renderAnchor(seriesModel, posInfo);
    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
  };
  GaugeView2.prototype._renderTicks = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var cx = posInfo.cx;
    var cy = posInfo.cy;
    var r = posInfo.r;
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var splitLineModel = seriesModel.getModel("splitLine");
    var tickModel = seriesModel.getModel("axisTick");
    var labelModel = seriesModel.getModel("axisLabel");
    var splitNumber = seriesModel.get("splitNumber");
    var subSplitNumber = tickModel.get("splitNumber");
    var splitLineLen = parsePercent(splitLineModel.get("length"), r);
    var tickLen = parsePercent(tickModel.get("length"), r);
    var angle4 = startAngle;
    var step = (endAngle - startAngle) / splitNumber;
    var subStep = step / subSplitNumber;
    var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
    var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
    var splitLineDistance = splitLineModel.get("distance");
    var unitX;
    var unitY;
    for (var i = 0; i <= splitNumber; i++) {
      unitX = Math.cos(angle4);
      unitY = Math.sin(angle4);
      if (splitLineModel.get("show")) {
        var distance11 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
        var splitLine = new Line$3({
          shape: {
            x1: unitX * (r - distance11) + cx,
            y1: unitY * (r - distance11) + cy,
            x2: unitX * (r - splitLineLen - distance11) + cx,
            y2: unitY * (r - splitLineLen - distance11) + cy
          },
          style: splitLineStyle,
          silent: true
        });
        if (splitLineStyle.stroke === "auto") {
          splitLine.setStyle({
            stroke: getColor(i / splitNumber)
          });
        }
        group.add(splitLine);
      }
      if (labelModel.get("show")) {
        var distance11 = labelModel.get("distance") + splitLineDistance;
        var label = formatLabel(round$3(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
        var autoColor = getColor(i / splitNumber);
        var textStyleX = unitX * (r - splitLineLen - distance11) + cx;
        var textStyleY = unitY * (r - splitLineLen - distance11) + cy;
        var rotateType = labelModel.get("rotate");
        var rotate2 = 0;
        if (rotateType === "radial") {
          rotate2 = -angle4 + 2 * Math.PI;
          if (rotate2 > Math.PI / 2) {
            rotate2 += Math.PI;
          }
        } else if (rotateType === "tangential") {
          rotate2 = -angle4 - Math.PI / 2;
        } else if (isNumber(rotateType)) {
          rotate2 = rotateType * Math.PI / 180;
        }
        if (rotate2 === 0) {
          group.add(new ZRText$1({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
              align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true
          }));
        } else {
          group.add(new ZRText$1({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true,
            originX: textStyleX,
            originY: textStyleY,
            rotation: rotate2
          }));
        }
      }
      if (tickModel.get("show") && i !== splitNumber) {
        var distance11 = tickModel.get("distance");
        distance11 = distance11 ? distance11 + axisLineWidth : axisLineWidth;
        for (var j = 0; j <= subSplitNumber; j++) {
          unitX = Math.cos(angle4);
          unitY = Math.sin(angle4);
          var tickLine = new Line$3({
            shape: {
              x1: unitX * (r - distance11) + cx,
              y1: unitY * (r - distance11) + cy,
              x2: unitX * (r - tickLen - distance11) + cx,
              y2: unitY * (r - tickLen - distance11) + cy
            },
            silent: true,
            style: tickLineStyle
          });
          if (tickLineStyle.stroke === "auto") {
            tickLine.setStyle({
              stroke: getColor((i + j / subSplitNumber) / splitNumber)
            });
          }
          group.add(tickLine);
          angle4 += subStep;
        }
        angle4 -= subStep;
      } else {
        angle4 += step;
      }
    }
  };
  GaugeView2.prototype._renderPointer = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var oldData = this._data;
    var oldProgressData = this._progressEls;
    var progressList = [];
    var showPointer2 = seriesModel.get(["pointer", "show"]);
    var progressModel = seriesModel.getModel("progress");
    var showProgress = progressModel.get("show");
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var valueExtent = [minVal, maxVal];
    var angleExtent = [startAngle, endAngle];
    function createPointer(idx, angle4) {
      var itemModel = data.getItemModel(idx);
      var pointerModel = itemModel.getModel("pointer");
      var pointerWidth = parsePercent(pointerModel.get("width"), posInfo.r);
      var pointerLength = parsePercent(pointerModel.get("length"), posInfo.r);
      var pointerStr = seriesModel.get(["pointer", "icon"]);
      var pointerOffset = pointerModel.get("offsetCenter");
      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);
      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);
      var pointerKeepAspect = pointerModel.get("keepAspect");
      var pointer;
      if (pointerStr) {
        pointer = createSymbol$1(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
      } else {
        pointer = new PointerPath$1({
          shape: {
            angle: -Math.PI / 2,
            width: pointerWidth,
            r: pointerLength,
            x: pointerOffsetX,
            y: pointerOffsetY
          }
        });
      }
      pointer.rotation = -(angle4 + Math.PI / 2);
      pointer.x = posInfo.cx;
      pointer.y = posInfo.cy;
      return pointer;
    }
    function createProgress(idx, endAngle2) {
      var roundCap = progressModel.get("roundCap");
      var ProgressPath = roundCap ? Sausage : Sector$1;
      var isOverlap = progressModel.get("overlap");
      var progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
      var progress = new ProgressPath({
        shape: {
          startAngle,
          endAngle: endAngle2,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0,
          r
        }
      });
      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);
      return progress;
    }
    if (showProgress || showPointer2) {
      data.diff(oldData).add(function(idx) {
        var val = data.get(valueDim, idx);
        if (showPointer2) {
          var pointer = createPointer(idx, startAngle);
          initProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap$2(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }
        if (showProgress) {
          var progress = createProgress(idx, startAngle);
          var isClip = progressModel.get("clip");
          initProps(progress, {
            shape: {
              endAngle: linearMap$2(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
          progressList[idx] = progress;
        }
      }).update(function(newIdx, oldIdx) {
        var val = data.get(valueDim, newIdx);
        if (showPointer2) {
          var previousPointer = oldData.getItemGraphicEl(oldIdx);
          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
          var pointer = createPointer(newIdx, previousRotate);
          pointer.rotation = previousRotate;
          updateProps$1(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap$2(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }
        if (showProgress) {
          var previousProgress = oldProgressData[oldIdx];
          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
          var progress = createProgress(newIdx, previousEndAngle);
          var isClip = progressModel.get("clip");
          updateProps$1(progress, {
            shape: {
              endAngle: linearMap$2(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
          progressList[newIdx] = progress;
        }
      }).execute();
      data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var emphasisModel = itemModel.getModel("emphasis");
        var focus = emphasisModel.get("focus");
        var blurScope = emphasisModel.get("blurScope");
        var emphasisDisabled = emphasisModel.get("disabled");
        if (showPointer2) {
          var pointer = data.getItemGraphicEl(idx);
          var symbolStyle = data.getItemVisual(idx, "style");
          var visualColor = symbolStyle.fill;
          if (pointer instanceof ZRImage$1) {
            var pathStyle = pointer.style;
            pointer.useStyle(extend2({
              image: pathStyle.image,
              x: pathStyle.x,
              y: pathStyle.y,
              width: pathStyle.width,
              height: pathStyle.height
            }, symbolStyle));
          } else {
            pointer.useStyle(symbolStyle);
            pointer.type !== "pointer" && pointer.setColor(visualColor);
          }
          pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor(linearMap$2(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          pointer.z2EmphasisLift = 0;
          setStatesStylesFromModel(pointer, itemModel);
          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
        }
        if (showProgress) {
          var progress = progressList[idx];
          progress.useStyle(data.getItemVisual(idx, "style"));
          progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
          progress.z2EmphasisLift = 0;
          setStatesStylesFromModel(progress, itemModel);
          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
        }
      });
      this._progressEls = progressList;
    }
  };
  GaugeView2.prototype._renderAnchor = function(seriesModel, posInfo) {
    var anchorModel = seriesModel.getModel("anchor");
    var showAnchor = anchorModel.get("show");
    if (showAnchor) {
      var anchorSize = anchorModel.get("size");
      var anchorType = anchorModel.get("icon");
      var offsetCenter = anchorModel.get("offsetCenter");
      var anchorKeepAspect = anchorModel.get("keepAspect");
      var anchor = createSymbol$1(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
      anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
      anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
      this.group.add(anchor);
    }
  };
  GaugeView2.prototype._renderTitleAndDetail = function(seriesModel, ecModel, api, getColor, posInfo) {
    var _this = this;
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var contentGroup = new Group$4();
    var newTitleEls = [];
    var newDetailEls = [];
    var hasAnimation = seriesModel.isAnimationEnabled();
    var showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
    data.diff(this._data).add(function(idx) {
      newTitleEls[idx] = new ZRText$1({
        silent: true
      });
      newDetailEls[idx] = new ZRText$1({
        silent: true
      });
    }).update(function(idx, oldIdx) {
      newTitleEls[idx] = _this._titleEls[oldIdx];
      newDetailEls[idx] = _this._detailEls[oldIdx];
    }).execute();
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var value = data.get(valueDim, idx);
      var itemGroup = new Group$4();
      var autoColor = getColor(linearMap$2(value, [minVal, maxVal], [0, 1], true));
      var itemTitleModel = itemModel.getModel("title");
      if (itemTitleModel.get("show")) {
        var titleOffsetCenter = itemTitleModel.get("offsetCenter");
        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);
        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);
        var labelEl = newTitleEls[idx];
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemTitleModel, {
            x: titleX,
            y: titleY,
            text: data.getName(idx),
            align: "center",
            verticalAlign: "middle"
          }, {
            inheritColor: autoColor
          })
        });
        itemGroup.add(labelEl);
      }
      var itemDetailModel = itemModel.getModel("detail");
      if (itemDetailModel.get("show")) {
        var detailOffsetCenter = itemDetailModel.get("offsetCenter");
        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);
        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);
        var width = parsePercent(itemDetailModel.get("width"), posInfo.r);
        var height = parsePercent(itemDetailModel.get("height"), posInfo.r);
        var detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
        var labelEl = newDetailEls[idx];
        var formatter_1 = itemDetailModel.get("formatter");
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemDetailModel, {
            x: detailX,
            y: detailY,
            text: formatLabel(value, formatter_1),
            width: isNaN(width) ? null : width,
            height: isNaN(height) ? null : height,
            align: "center",
            verticalAlign: "middle"
          }, {
            inheritColor: detailColor
          })
        });
        setLabelValueAnimation(labelEl, {
          normal: itemDetailModel
        }, value, function(value2) {
          return formatLabel(value2, formatter_1);
        });
        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
          getFormattedLabel: function(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);
          }
        });
        itemGroup.add(labelEl);
      }
      contentGroup.add(itemGroup);
    });
    this.group.add(contentGroup);
    this._titleEls = newTitleEls;
    this._detailEls = newDetailEls;
  };
  GaugeView2.type = "gauge";
  return GaugeView2;
}(ChartView$1);
var GaugeView$1 = GaugeView;
var GaugeSeriesModel = function(_super) {
  __extends$1(GaugeSeriesModel2, _super);
  function GaugeSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GaugeSeriesModel2.type;
    _this.visualStyleAccessPath = "itemStyle";
    return _this;
  }
  GaugeSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, ["value"]);
  };
  GaugeSeriesModel2.type = "series.gauge";
  GaugeSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    center: ["50%", "50%"],
    legendHoverLink: true,
    radius: "75%",
    startAngle: 225,
    endAngle: -45,
    clockwise: true,
    min: 0,
    max: 100,
    splitNumber: 10,
    axisLine: {
      show: true,
      roundCap: false,
      lineStyle: {
        color: [[1, "#E6EBF8"]],
        width: 10
      }
    },
    progress: {
      show: false,
      overlap: true,
      width: 10,
      roundCap: false,
      clip: true
    },
    splitLine: {
      show: true,
      length: 10,
      distance: 10,
      lineStyle: {
        color: "#63677A",
        width: 3,
        type: "solid"
      }
    },
    axisTick: {
      show: true,
      splitNumber: 5,
      length: 6,
      distance: 10,
      lineStyle: {
        color: "#63677A",
        width: 1,
        type: "solid"
      }
    },
    axisLabel: {
      show: true,
      distance: 15,
      color: "#464646",
      fontSize: 12,
      rotate: 0
    },
    pointer: {
      icon: null,
      offsetCenter: [0, 0],
      show: true,
      showAbove: true,
      length: "60%",
      width: 6,
      keepAspect: false
    },
    anchor: {
      show: false,
      showAbove: false,
      size: 6,
      icon: "circle",
      offsetCenter: [0, 0],
      keepAspect: false,
      itemStyle: {
        color: "#fff",
        borderWidth: 0,
        borderColor: "#5470c6"
      }
    },
    title: {
      show: true,
      offsetCenter: [0, "20%"],
      color: "#464646",
      fontSize: 16,
      valueAnimation: false
    },
    detail: {
      show: true,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      borderColor: "#ccc",
      width: 100,
      height: null,
      padding: [5, 10],
      offsetCenter: [0, "40%"],
      color: "#464646",
      fontSize: 30,
      fontWeight: "bold",
      lineHeight: 30,
      valueAnimation: false
    }
  };
  return GaugeSeriesModel2;
}(SeriesModel$1);
var GaugeSeriesModel$1 = GaugeSeriesModel;
function install$E(registers) {
  registers.registerChartView(GaugeView$1);
  registers.registerSeriesModel(GaugeSeriesModel$1);
}
var opacityAccessPath$1 = ["itemStyle", "opacity"];
var FunnelPiece = function(_super) {
  __extends$1(FunnelPiece2, _super);
  function FunnelPiece2(data, idx) {
    var _this = _super.call(this) || this;
    var polygon4 = _this;
    var labelLine = new Polyline$3();
    var text = new ZRText$1();
    polygon4.setTextContent(text);
    _this.setTextGuideLine(labelLine);
    _this.updateData(data, idx, true);
    return _this;
  }
  FunnelPiece2.prototype.updateData = function(data, idx, firstCreate) {
    var polygon4 = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var opacity = itemModel.get(opacityAccessPath$1);
    opacity = opacity == null ? 1 : opacity;
    if (!firstCreate) {
      saveOldStyle(polygon4);
    }
    polygon4.useStyle(data.getItemVisual(idx, "style"));
    polygon4.style.lineJoin = "round";
    if (firstCreate) {
      polygon4.setShape({
        points: layout2.points
      });
      polygon4.style.opacity = 0;
      initProps(polygon4, {
        style: {
          opacity
        }
      }, seriesModel, idx);
    } else {
      updateProps$1(polygon4, {
        style: {
          opacity
        },
        shape: {
          points: layout2.points
        }
      }, seriesModel, idx);
    }
    setStatesStylesFromModel(polygon4, itemModel);
    this._updateLabel(data, idx);
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  FunnelPiece2.prototype._updateLabel = function(data, idx) {
    var polygon4 = this;
    var labelLine = this.getTextGuideLine();
    var labelText = polygon4.getTextContent();
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var labelLayout2 = layout2.label;
    var style = data.getItemVisual(idx, "style");
    var visualColor = style.fill;
    setLabelStyle(
      labelText,
      getLabelStatesModels(itemModel),
      {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText: data.getName(idx)
      },
      {
        normal: {
          align: labelLayout2.textAlign,
          verticalAlign: labelLayout2.verticalAlign
        }
      }
    );
    polygon4.setTextConfig({
      local: true,
      inside: !!labelLayout2.inside,
      insideStroke: visualColor,
      outsideFill: visualColor
    });
    var linePoints = labelLayout2.linePoints;
    labelLine.setShape({
      points: linePoints
    });
    polygon4.textGuideLineConfig = {
      anchor: linePoints ? new Point$1(linePoints[0][0], linePoints[0][1]) : null
    };
    updateProps$1(labelText, {
      style: {
        x: labelLayout2.x,
        y: labelLayout2.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout2.rotation,
      originX: labelLayout2.x,
      originY: labelLayout2.y,
      z2: 10
    });
    setLabelLineStyle(polygon4, getLabelLineStatesModels(itemModel), {
      stroke: visualColor
    });
  };
  return FunnelPiece2;
}(Polygon$1);
var FunnelView = function(_super) {
  __extends$1(FunnelView2, _super);
  function FunnelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = FunnelView2.type;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  FunnelView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    data.diff(oldData).add(function(idx) {
      var funnelPiece = new FunnelPiece(data, idx);
      data.setItemGraphicEl(idx, funnelPiece);
      group.add(funnelPiece);
    }).update(function(newIdx, oldIdx) {
      var piece = oldData.getItemGraphicEl(oldIdx);
      piece.updateData(data, newIdx);
      group.add(piece);
      data.setItemGraphicEl(newIdx, piece);
    }).remove(function(idx) {
      var piece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piece, seriesModel, idx);
    }).execute();
    this._data = data;
  };
  FunnelView2.prototype.remove = function() {
    this.group.removeAll();
    this._data = null;
  };
  FunnelView2.prototype.dispose = function() {
  };
  FunnelView2.type = "funnel";
  return FunnelView2;
}(ChartView$1);
var FunnelView$1 = FunnelView;
var FunnelSeriesModel = function(_super) {
  __extends$1(FunnelSeriesModel2, _super);
  function FunnelSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = FunnelSeriesModel2.type;
    return _this;
  }
  FunnelSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  FunnelSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
  };
  FunnelSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  FunnelSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var data = this.getData();
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    var valueDim = data.mapDimension("value");
    var sum2 = data.getSum(valueDim);
    params.percent = !sum2 ? 0 : +(data.get(valueDim, dataIndex) / sum2 * 100).toFixed(2);
    params.$vars.push("percent");
    return params;
  };
  FunnelSeriesModel2.type = "series.funnel";
  FunnelSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    minSize: "0%",
    maxSize: "100%",
    sort: "descending",
    orient: "vertical",
    gap: 0,
    funnelAlign: "center",
    label: {
      show: true,
      position: "outer"
    },
    labelLine: {
      show: true,
      length: 20,
      lineStyle: {
        width: 1
      }
    },
    itemStyle: {
      borderColor: "#fff",
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true
      }
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  };
  return FunnelSeriesModel2;
}(SeriesModel$1);
var FunnelSeriesModel$1 = FunnelSeriesModel;
function getViewRect$2(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getSortedIndices(data, sort4) {
  var valueDim = data.mapDimension("value");
  var valueArr = data.mapArray(valueDim, function(val) {
    return val;
  });
  var indices = [];
  var isAscending = sort4 === "ascending";
  for (var i = 0, len2 = data.count(); i < len2; i++) {
    indices[i] = i;
  }
  if (isFunction(sort4)) {
    indices.sort(sort4);
  } else if (sort4 !== "none") {
    indices.sort(function(a, b) {
      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
    });
  }
  return indices;
}
function labelLayout(data) {
  var seriesModel = data.hostModel;
  var orient2 = seriesModel.get("orient");
  data.each(function(idx) {
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position");
    var labelLineModel = itemModel.getModel("labelLine");
    var layout2 = data.getItemLayout(idx);
    var points2 = layout2.points;
    var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
    var textAlign;
    var textX;
    var textY;
    var linePoints;
    if (isLabelInside) {
      if (labelPosition === "insideLeft") {
        textX = (points2[0][0] + points2[3][0]) / 2 + 5;
        textY = (points2[0][1] + points2[3][1]) / 2;
        textAlign = "left";
      } else if (labelPosition === "insideRight") {
        textX = (points2[1][0] + points2[2][0]) / 2 - 5;
        textY = (points2[1][1] + points2[2][1]) / 2;
        textAlign = "right";
      } else {
        textX = (points2[0][0] + points2[1][0] + points2[2][0] + points2[3][0]) / 4;
        textY = (points2[0][1] + points2[1][1] + points2[2][1] + points2[3][1]) / 4;
        textAlign = "center";
      }
      linePoints = [[textX, textY], [textX, textY]];
    } else {
      var x12 = void 0;
      var y12 = void 0;
      var x2 = void 0;
      var y2 = void 0;
      var labelLineLen = labelLineModel.get("length");
      {
        if (orient2 === "vertical" && ["top", "bottom"].indexOf(labelPosition) > -1) {
          labelPosition = "left";
          console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.");
        }
        if (orient2 === "horizontal" && ["left", "right"].indexOf(labelPosition) > -1) {
          labelPosition = "bottom";
          console.warn("Position error: Funnel chart on horizontal orient dose not support left and right.");
        }
      }
      if (labelPosition === "left") {
        x12 = (points2[3][0] + points2[0][0]) / 2;
        y12 = (points2[3][1] + points2[0][1]) / 2;
        x2 = x12 - labelLineLen;
        textX = x2 - 5;
        textAlign = "right";
      } else if (labelPosition === "right") {
        x12 = (points2[1][0] + points2[2][0]) / 2;
        y12 = (points2[1][1] + points2[2][1]) / 2;
        x2 = x12 + labelLineLen;
        textX = x2 + 5;
        textAlign = "left";
      } else if (labelPosition === "top") {
        x12 = (points2[3][0] + points2[0][0]) / 2;
        y12 = (points2[3][1] + points2[0][1]) / 2;
        y2 = y12 - labelLineLen;
        textY = y2 - 5;
        textAlign = "center";
      } else if (labelPosition === "bottom") {
        x12 = (points2[1][0] + points2[2][0]) / 2;
        y12 = (points2[1][1] + points2[2][1]) / 2;
        y2 = y12 + labelLineLen;
        textY = y2 + 5;
        textAlign = "center";
      } else if (labelPosition === "rightTop") {
        x12 = orient2 === "horizontal" ? points2[3][0] : points2[1][0];
        y12 = orient2 === "horizontal" ? points2[3][1] : points2[1][1];
        if (orient2 === "horizontal") {
          y2 = y12 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x12 + labelLineLen;
          textX = x2 + 5;
          textAlign = "top";
        }
      } else if (labelPosition === "rightBottom") {
        x12 = points2[2][0];
        y12 = points2[2][1];
        if (orient2 === "horizontal") {
          y2 = y12 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x12 + labelLineLen;
          textX = x2 + 5;
          textAlign = "bottom";
        }
      } else if (labelPosition === "leftTop") {
        x12 = points2[0][0];
        y12 = orient2 === "horizontal" ? points2[0][1] : points2[1][1];
        if (orient2 === "horizontal") {
          y2 = y12 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x12 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else if (labelPosition === "leftBottom") {
        x12 = orient2 === "horizontal" ? points2[1][0] : points2[3][0];
        y12 = orient2 === "horizontal" ? points2[1][1] : points2[2][1];
        if (orient2 === "horizontal") {
          y2 = y12 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x12 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else {
        x12 = (points2[1][0] + points2[2][0]) / 2;
        y12 = (points2[1][1] + points2[2][1]) / 2;
        if (orient2 === "horizontal") {
          y2 = y12 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x12 + labelLineLen;
          textX = x2 + 5;
          textAlign = "left";
        }
      }
      if (orient2 === "horizontal") {
        x2 = x12;
        textX = x2;
      } else {
        y2 = y12;
        textY = y2;
      }
      linePoints = [[x12, y12], [x2, y2]];
    }
    layout2.label = {
      linePoints,
      x: textX,
      y: textY,
      verticalAlign: "middle",
      textAlign,
      inside: isLabelInside
    };
  });
}
function funnelLayout(ecModel, api) {
  ecModel.eachSeriesByType("funnel", function(seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var sort4 = seriesModel.get("sort");
    var viewRect2 = getViewRect$2(seriesModel, api);
    var orient2 = seriesModel.get("orient");
    var viewWidth = viewRect2.width;
    var viewHeight = viewRect2.height;
    var indices = getSortedIndices(data, sort4);
    var x2 = viewRect2.x;
    var y2 = viewRect2.y;
    var sizeExtent = orient2 === "horizontal" ? [parsePercent(seriesModel.get("minSize"), viewHeight), parsePercent(seriesModel.get("maxSize"), viewHeight)] : [parsePercent(seriesModel.get("minSize"), viewWidth), parsePercent(seriesModel.get("maxSize"), viewWidth)];
    var dataExtent = data.getDataExtent(valueDim);
    var min5 = seriesModel.get("min");
    var max4 = seriesModel.get("max");
    if (min5 == null) {
      min5 = Math.min(dataExtent[0], 0);
    }
    if (max4 == null) {
      max4 = dataExtent[1];
    }
    var funnelAlign = seriesModel.get("funnelAlign");
    var gap = seriesModel.get("gap");
    var viewSize = orient2 === "horizontal" ? viewWidth : viewHeight;
    var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
    var getLinePoints = function(idx2, offset) {
      if (orient2 === "horizontal") {
        var val_1 = data.get(valueDim, idx2) || 0;
        var itemHeight = linearMap$2(val_1, [min5, max4], sizeExtent, true);
        var y02 = void 0;
        switch (funnelAlign) {
          case "top":
            y02 = y2;
            break;
          case "center":
            y02 = y2 + (viewHeight - itemHeight) / 2;
            break;
          case "bottom":
            y02 = y2 + (viewHeight - itemHeight);
            break;
        }
        return [[offset, y02], [offset, y02 + itemHeight]];
      }
      var val = data.get(valueDim, idx2) || 0;
      var itemWidth = linearMap$2(val, [min5, max4], sizeExtent, true);
      var x02;
      switch (funnelAlign) {
        case "left":
          x02 = x2;
          break;
        case "center":
          x02 = x2 + (viewWidth - itemWidth) / 2;
          break;
        case "right":
          x02 = x2 + viewWidth - itemWidth;
          break;
      }
      return [[x02, offset], [x02 + itemWidth, offset]];
    };
    if (sort4 === "ascending") {
      itemSize = -itemSize;
      gap = -gap;
      if (orient2 === "horizontal") {
        x2 += viewWidth;
      } else {
        y2 += viewHeight;
      }
      indices = indices.reverse();
    }
    for (var i = 0; i < indices.length; i++) {
      var idx = indices[i];
      var nextIdx = indices[i + 1];
      var itemModel = data.getItemModel(idx);
      if (orient2 === "horizontal") {
        var width = itemModel.get(["itemStyle", "width"]);
        if (width == null) {
          width = itemSize;
        } else {
          width = parsePercent(width, viewWidth);
          if (sort4 === "ascending") {
            width = -width;
          }
        }
        var start2 = getLinePoints(idx, x2);
        var end2 = getLinePoints(nextIdx, x2 + width);
        x2 += width + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      } else {
        var height = itemModel.get(["itemStyle", "height"]);
        if (height == null) {
          height = itemSize;
        } else {
          height = parsePercent(height, viewHeight);
          if (sort4 === "ascending") {
            height = -height;
          }
        }
        var start2 = getLinePoints(idx, y2);
        var end2 = getLinePoints(nextIdx, y2 + height);
        y2 += height + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      }
    }
    labelLayout(data);
  });
}
function install$D(registers) {
  registers.registerChartView(FunnelView$1);
  registers.registerSeriesModel(FunnelSeriesModel$1);
  registers.registerLayout(funnelLayout);
  registers.registerProcessor(dataFilter$1("funnel"));
}
var DEFAULT_SMOOTH = 0.3;
var ParallelView$2 = function(_super) {
  __extends$1(ParallelView2, _super);
  function ParallelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelView2.type;
    _this._dataGroup = new Group$4();
    _this._initialized = false;
    return _this;
  }
  ParallelView2.prototype.init = function() {
    this.group.add(this._dataGroup);
  };
  ParallelView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._progressiveEls = null;
    var dataGroup = this._dataGroup;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coordSys = seriesModel.coordinateSystem;
    var dimensions = coordSys.dimensions;
    var seriesScope = makeSeriesScope(seriesModel);
    data.diff(oldData).add(add16).update(update).remove(remove6).execute();
    function add16(newDataIndex) {
      var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
      updateElCommon(line, data, newDataIndex, seriesScope);
    }
    function update(newDataIndex, oldDataIndex) {
      var line = oldData.getItemGraphicEl(oldDataIndex);
      var points2 = createLinePoints(data, newDataIndex, dimensions, coordSys);
      data.setItemGraphicEl(newDataIndex, line);
      updateProps$1(line, {
        shape: {
          points: points2
        }
      }, seriesModel, newDataIndex);
      saveOldStyle(line);
      updateElCommon(line, data, newDataIndex, seriesScope);
    }
    function remove6(oldDataIndex) {
      var line = oldData.getItemGraphicEl(oldDataIndex);
      dataGroup.remove(line);
    }
    if (!this._initialized) {
      this._initialized = true;
      var clipPath = createGridClipShape$2(coordSys, seriesModel, function() {
        setTimeout(function() {
          dataGroup.removeClipPath();
        });
      });
      dataGroup.setClipPath(clipPath);
    }
    this._data = data;
  };
  ParallelView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    this._initialized = true;
    this._data = null;
    this._dataGroup.removeAll();
  };
  ParallelView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var dimensions = coordSys.dimensions;
    var seriesScope = makeSeriesScope(seriesModel);
    var progressiveEls = this._progressiveEls = [];
    for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
      var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
      line.incremental = true;
      updateElCommon(line, data, dataIndex, seriesScope);
      progressiveEls.push(line);
    }
  };
  ParallelView2.prototype.remove = function() {
    this._dataGroup && this._dataGroup.removeAll();
    this._data = null;
  };
  ParallelView2.type = "parallel";
  return ParallelView2;
}(ChartView$1);
function createGridClipShape$2(coordSys, seriesModel, cb) {
  var parallelModel = coordSys.model;
  var rect = coordSys.getRect();
  var rectEl = new Rect$3({
    shape: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    }
  });
  var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
  rectEl.setShape(dim, 0);
  initProps(rectEl, {
    shape: {
      width: rect.width,
      height: rect.height
    }
  }, seriesModel, cb);
  return rectEl;
}
function createLinePoints(data, dataIndex, dimensions, coordSys) {
  var points2 = [];
  for (var i = 0; i < dimensions.length; i++) {
    var dimName = dimensions[i];
    var value = data.get(data.mapDimension(dimName), dataIndex);
    if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
      points2.push(coordSys.dataToPoint(value, dimName));
    }
  }
  return points2;
}
function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
  var points2 = createLinePoints(data, dataIndex, dimensions, coordSys);
  var line = new Polyline$3({
    shape: {
      points: points2
    },
    z2: 10
  });
  dataGroup.add(line);
  data.setItemGraphicEl(dataIndex, line);
  return line;
}
function makeSeriesScope(seriesModel) {
  var smooth = seriesModel.get("smooth", true);
  smooth === true && (smooth = DEFAULT_SMOOTH);
  smooth = numericToNumber(smooth);
  eqNaN(smooth) && (smooth = 0);
  return {
    smooth
  };
}
function updateElCommon(el, data, dataIndex, seriesScope) {
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.fill = null;
  el.setShape("smooth", seriesScope.smooth);
  var itemModel = data.getItemModel(dataIndex);
  var emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel, "lineStyle");
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function isEmptyValue(val, axisType) {
  return axisType === "category" ? val == null : val == null || isNaN(val);
}
var ParallelView$3 = ParallelView$2;
var ParallelSeriesModel = function(_super) {
  __extends$1(ParallelSeriesModel2, _super);
  function ParallelSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelSeriesModel2.type;
    _this.visualStyleAccessPath = "lineStyle";
    _this.visualDrawType = "stroke";
    return _this;
  }
  ParallelSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: bind$1(makeDefaultEncode, null, this)
    });
  };
  ParallelSeriesModel2.prototype.getRawIndicesByActiveState = function(activeState) {
    var coordSys = this.coordinateSystem;
    var data = this.getData();
    var indices = [];
    coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
      if (activeState === theActiveState) {
        indices.push(data.getRawIndex(dataIndex));
      }
    });
    return indices;
  };
  ParallelSeriesModel2.type = "series.parallel";
  ParallelSeriesModel2.dependencies = ["parallel"];
  ParallelSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "parallel",
    parallelIndex: 0,
    label: {
      show: false
    },
    inactiveOpacity: 0.05,
    activeOpacity: 1,
    lineStyle: {
      width: 1,
      opacity: 0.45,
      type: "solid"
    },
    emphasis: {
      label: {
        show: false
      }
    },
    progressive: 500,
    smooth: false,
    animationEasing: "linear"
  };
  return ParallelSeriesModel2;
}(SeriesModel$1);
function makeDefaultEncode(seriesModel) {
  var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
  if (!parallelModel) {
    return;
  }
  var encodeDefine = {};
  each$f(parallelModel.dimensions, function(axisDim) {
    var dataDimIndex = convertDimNameToNumber(axisDim);
    encodeDefine[axisDim] = dataDimIndex;
  });
  return encodeDefine;
}
function convertDimNameToNumber(dimName) {
  return +dimName.replace("dim", "");
}
var ParallelSeriesModel$1 = ParallelSeriesModel;
var opacityAccessPath = ["lineStyle", "opacity"];
var parallelVisual = {
  seriesType: "parallel",
  reset: function(seriesModel, ecModel) {
    var coordSys = seriesModel.coordinateSystem;
    var opacityMap = {
      normal: seriesModel.get(["lineStyle", "opacity"]),
      active: seriesModel.get("activeOpacity"),
      inactive: seriesModel.get("inactiveOpacity")
    };
    return {
      progress: function(params, data) {
        coordSys.eachActiveState(data, function(activeState, dataIndex) {
          var opacity = opacityMap[activeState];
          if (activeState === "normal" && data.hasItemOption) {
            var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath, true);
            itemOpacity != null && (opacity = itemOpacity);
          }
          var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          existsStyle.opacity = opacity;
        }, params.start, params.end);
      }
    };
  }
};
var parallelVisual$1 = parallelVisual;
function parallelPreprocessor(option) {
  createParallelIfNeeded(option);
  mergeAxisOptionFromParallel(option);
}
function createParallelIfNeeded(option) {
  if (option.parallel) {
    return;
  }
  var hasParallelSeries = false;
  each$f(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "parallel") {
      hasParallelSeries = true;
    }
  });
  if (hasParallelSeries) {
    option.parallel = [{}];
  }
}
function mergeAxisOptionFromParallel(option) {
  var axes = normalizeToArray(option.parallelAxis);
  each$f(axes, function(axisOption) {
    if (!isObject$3(axisOption)) {
      return;
    }
    var parallelIndex = axisOption.parallelIndex || 0;
    var parallelOption = normalizeToArray(option.parallel)[parallelIndex];
    if (parallelOption && parallelOption.parallelAxisDefault) {
      merge3(axisOption, parallelOption.parallelAxisDefault, false);
    }
  });
}
var CLICK_THRESHOLD = 5;
var ParallelView = function(_super) {
  __extends$1(ParallelView2, _super);
  function ParallelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelView2.type;
    return _this;
  }
  ParallelView2.prototype.render = function(parallelModel, ecModel, api) {
    this._model = parallelModel;
    this._api = api;
    if (!this._handlers) {
      this._handlers = {};
      each$f(handlers$1, function(handler, eventName) {
        api.getZr().on(eventName, this._handlers[eventName] = bind$1(handler, this));
      }, this);
    }
    createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
  };
  ParallelView2.prototype.dispose = function(ecModel, api) {
    clear$1(this, "_throttledDispatchExpand");
    each$f(this._handlers, function(handler, eventName) {
      api.getZr().off(eventName, handler);
    });
    this._handlers = null;
  };
  ParallelView2.prototype._throttledDispatchExpand = function(opt) {
    this._dispatchExpand(opt);
  };
  ParallelView2.prototype._dispatchExpand = function(opt) {
    opt && this._api.dispatchAction(extend2({
      type: "parallelAxisExpand"
    }, opt));
  };
  ParallelView2.type = "parallel";
  return ParallelView2;
}(ComponentView$1);
var handlers$1 = {
  mousedown: function(e2) {
    if (checkTrigger(this, "click")) {
      this._mouseDownPoint = [e2.offsetX, e2.offsetY];
    }
  },
  mouseup: function(e2) {
    var mouseDownPoint = this._mouseDownPoint;
    if (checkTrigger(this, "click") && mouseDownPoint) {
      var point4 = [e2.offsetX, e2.offsetY];
      var dist3 = Math.pow(mouseDownPoint[0] - point4[0], 2) + Math.pow(mouseDownPoint[1] - point4[1], 2);
      if (dist3 > CLICK_THRESHOLD) {
        return;
      }
      var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      result.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: result.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e2) {
    if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
      return;
    }
    var model = this._model;
    var result = model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
    var behavior = result.behavior;
    behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
    this._throttledDispatchExpand(behavior === "none" ? null : {
      axisExpandWindow: result.axisExpandWindow,
      animation: behavior === "jump" ? null : {
        duration: 0
      }
    });
  }
};
function checkTrigger(view, triggerOn) {
  var model = view._model;
  return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
}
var ParallelView$1 = ParallelView;
var ParallelModel = function(_super) {
  __extends$1(ParallelModel2, _super);
  function ParallelModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelModel2.type;
    return _this;
  }
  ParallelModel2.prototype.init = function() {
    _super.prototype.init.apply(this, arguments);
    this.mergeOption({});
  };
  ParallelModel2.prototype.mergeOption = function(newOption) {
    var thisOption = this.option;
    newOption && merge3(thisOption, newOption, true);
    this._initDimensions();
  };
  ParallelModel2.prototype.contains = function(model, ecModel) {
    var parallelIndex = model.get("parallelIndex");
    return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
  };
  ParallelModel2.prototype.setAxisExpand = function(opt) {
    each$f(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name2) {
      if (opt.hasOwnProperty(name2)) {
        this.option[name2] = opt[name2];
      }
    }, this);
  };
  ParallelModel2.prototype._initDimensions = function() {
    var dimensions = this.dimensions = [];
    var parallelAxisIndex = this.parallelAxisIndex = [];
    var axisModels = filter17(this.ecModel.queryComponents({
      mainType: "parallelAxis"
    }), function(axisModel) {
      return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
    }, this);
    each$f(axisModels, function(axisModel) {
      dimensions.push("dim" + axisModel.get("dim"));
      parallelAxisIndex.push(axisModel.componentIndex);
    });
  };
  ParallelModel2.type = "parallel";
  ParallelModel2.dependencies = ["parallelAxis"];
  ParallelModel2.layoutMode = "box";
  ParallelModel2.defaultOption = {
    z: 0,
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    layout: "horizontal",
    axisExpandable: false,
    axisExpandCenter: null,
    axisExpandCount: 0,
    axisExpandWidth: 50,
    axisExpandRate: 17,
    axisExpandDebounce: 50,
    axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
    axisExpandTriggerOn: "click",
    parallelAxisDefault: null
  };
  return ParallelModel2;
}(ComponentModel$1);
var ParallelModel$1 = ParallelModel;
var ParallelAxis = function(_super) {
  __extends$1(ParallelAxis2, _super);
  function ParallelAxis2(dim, scale4, coordExtent, axisType, axisIndex) {
    var _this = _super.call(this, dim, scale4, coordExtent) || this;
    _this.type = axisType || "value";
    _this.axisIndex = axisIndex;
    return _this;
  }
  ParallelAxis2.prototype.isHorizontal = function() {
    return this.coordinateSystem.getModel().get("layout") !== "horizontal";
  };
  return ParallelAxis2;
}(Axis$1);
var ParallelAxis$1 = ParallelAxis;
function sliderMove(delta2, handleEnds, extent3, handleIndex, minSpan, maxSpan) {
  delta2 = delta2 || 0;
  var extentSpan = extent3[1] - extent3[0];
  if (minSpan != null) {
    minSpan = restrict$1(minSpan, [0, extentSpan]);
  }
  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }
  if (handleIndex === "all") {
    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict$1(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict$1(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }
  handleEnds[0] = restrict$1(handleEnds[0], extent3);
  handleEnds[1] = restrict$1(handleEnds[1], extent3);
  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta2;
  var extentMinSpan = minSpan || 0;
  var realExtent = extent3.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict$1(handleEnds[handleIndex], realExtent);
  var currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  }
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }
  return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
  var dist3 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
  return {
    span: Math.abs(dist3),
    sign: dist3 > 0 ? -1 : dist3 < 0 ? 1 : handleIndex ? -1 : 1
  };
}
function restrict$1(value, extend3) {
  return Math.min(extend3[1] != null ? extend3[1] : Infinity, Math.max(extend3[0] != null ? extend3[0] : -Infinity, value));
}
var each$a = each$f;
var mathMin$2 = Math.min;
var mathMax$2 = Math.max;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var round = round$3;
var PI$1 = Math.PI;
var Parallel = function() {
  function Parallel2(parallelModel, ecModel, api) {
    this.type = "parallel";
    this._axesMap = createHashMap();
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api);
  }
  Parallel2.prototype._init = function(parallelModel, ecModel, api) {
    var dimensions = parallelModel.dimensions;
    var parallelAxisIndex = parallelModel.parallelAxisIndex;
    each$a(dimensions, function(dim, idx) {
      var axisIndex = parallelAxisIndex[idx];
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axis = this._axesMap.set(dim, new ParallelAxis$1(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisIndex));
      var isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = axisModel.coordinateSystem = this;
    }, this);
  };
  Parallel2.prototype.update = function(ecModel, api) {
    this._updateAxesFromSeries(this._model, ecModel);
  };
  Parallel2.prototype.containPoint = function(point4) {
    var layoutInfo = this._makeLayoutInfo();
    var axisBase = layoutInfo.axisBase;
    var layoutBase = layoutInfo.layoutBase;
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var pAxis = point4[1 - pixelDimIndex];
    var pLayout = point4[pixelDimIndex];
    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
  };
  Parallel2.prototype.getModel = function() {
    return this._model;
  };
  Parallel2.prototype._updateAxesFromSeries = function(parallelModel, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      if (!parallelModel.contains(seriesModel, ecModel)) {
        return;
      }
      var data = seriesModel.getData();
      each$a(this.dimensions, function(dim) {
        var axis = this._axesMap.get(dim);
        axis.scale.unionExtentFromData(data, data.mapDimension(dim));
        niceScaleExtent(axis.scale, axis.model);
      }, this);
    }, this);
  };
  Parallel2.prototype.resize = function(parallelModel, api) {
    this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._layoutAxes();
  };
  Parallel2.prototype.getRect = function() {
    return this._rect;
  };
  Parallel2.prototype._makeLayoutInfo = function() {
    var parallelModel = this._model;
    var rect = this._rect;
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    var layout2 = parallelModel.get("layout");
    var pixelDimIndex = layout2 === "horizontal" ? 0 : 1;
    var layoutLength = rect[wh[pixelDimIndex]];
    var layoutExtent = [0, layoutLength];
    var axisCount = this.dimensions.length;
    var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
    var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
    var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
    var axisExpandWindow = parallelModel.get("axisExpandWindow");
    var winSize;
    if (!axisExpandWindow) {
      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
      var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2);
      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    } else {
      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    }
    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
    axisCollapseWidth < 3 && (axisCollapseWidth = 0);
    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
    return {
      layout: layout2,
      pixelDimIndex,
      layoutBase: rect[xy[pixelDimIndex]],
      layoutLength,
      axisBase: rect[xy[1 - pixelDimIndex]],
      axisLength: rect[wh[1 - pixelDimIndex]],
      axisExpandable,
      axisExpandWidth,
      axisCollapseWidth,
      axisExpandWindow,
      axisCount,
      winInnerIndices,
      axisExpandWindow0Pos
    };
  };
  Parallel2.prototype._layoutAxes = function() {
    var rect = this._rect;
    var axes = this._axesMap;
    var dimensions = this.dimensions;
    var layoutInfo = this._makeLayoutInfo();
    var layout2 = layoutInfo.layout;
    axes.each(function(axis) {
      var axisExtent = [0, layoutInfo.axisLength];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
    });
    each$a(dimensions, function(dim, idx) {
      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
      var positionTable = {
        horizontal: {
          x: posInfo.position,
          y: layoutInfo.axisLength
        },
        vertical: {
          x: 0,
          y: posInfo.position
        }
      };
      var rotationTable = {
        horizontal: PI$1 / 2,
        vertical: 0
      };
      var position2 = [positionTable[layout2].x + rect.x, positionTable[layout2].y + rect.y];
      var rotation = rotationTable[layout2];
      var transform4 = create$1();
      rotate(transform4, transform4, rotation);
      translate2(transform4, transform4, position2);
      this._axesLayout[dim] = {
        position: position2,
        rotation,
        transform: transform4,
        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
        axisLabelShow: posInfo.axisLabelShow,
        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
        tickDirection: 1,
        labelDirection: 1
      };
    }, this);
  };
  Parallel2.prototype.getAxis = function(dim) {
    return this._axesMap.get(dim);
  };
  Parallel2.prototype.dataToPoint = function(value, dim) {
    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
  };
  Parallel2.prototype.eachActiveState = function(data, callback, start2, end2) {
    start2 == null && (start2 = 0);
    end2 == null && (end2 = data.count());
    var axesMap = this._axesMap;
    var dimensions = this.dimensions;
    var dataDimensions = [];
    var axisModels = [];
    each$f(dimensions, function(axisDim) {
      dataDimensions.push(data.mapDimension(axisDim));
      axisModels.push(axesMap.get(axisDim).model);
    });
    var hasActiveSet = this.hasAxisBrushed();
    for (var dataIndex = start2; dataIndex < end2; dataIndex++) {
      var activeState = void 0;
      if (!hasActiveSet) {
        activeState = "normal";
      } else {
        activeState = "active";
        var values3 = data.getValues(dataDimensions, dataIndex);
        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
          var state = axisModels[j].getActiveState(values3[j]);
          if (state === "inactive") {
            activeState = "inactive";
            break;
          }
        }
      }
      callback(activeState, dataIndex);
    }
  };
  Parallel2.prototype.hasAxisBrushed = function() {
    var dimensions = this.dimensions;
    var axesMap = this._axesMap;
    var hasActiveSet = false;
    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
      if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
        hasActiveSet = true;
      }
    }
    return hasActiveSet;
  };
  Parallel2.prototype.axisCoordToPoint = function(coord, dim) {
    var axisLayout = this._axesLayout[dim];
    return applyTransform([coord, 0], axisLayout.transform);
  };
  Parallel2.prototype.getAxisLayout = function(dim) {
    return clone$4(this._axesLayout[dim]);
  };
  Parallel2.prototype.getSlidedAxisExpandWindow = function(point4) {
    var layoutInfo = this._makeLayoutInfo();
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
    var winSize = axisExpandWindow[1] - axisExpandWindow[0];
    var extent3 = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
    if (!this.containPoint(point4)) {
      return {
        behavior: "none",
        axisExpandWindow
      };
    }
    var pointCoord = point4[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
    var delta2;
    var behavior = "slide";
    var axisCollapseWidth = layoutInfo.axisCollapseWidth;
    var triggerArea = this._model.get("axisExpandSlideTriggerArea");
    var useJump = triggerArea[0] != null;
    if (axisCollapseWidth) {
      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
        behavior = "jump";
        delta2 = pointCoord - winSize * triggerArea[2];
      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
        behavior = "jump";
        delta2 = pointCoord - winSize * (1 - triggerArea[2]);
      } else {
        (delta2 = pointCoord - winSize * triggerArea[1]) >= 0 && (delta2 = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta2 = 0);
      }
      delta2 *= layoutInfo.axisExpandWidth / axisCollapseWidth;
      delta2 ? sliderMove(delta2, axisExpandWindow, extent3, "all") : behavior = "none";
    } else {
      var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
      var pos = extent3[1] * pointCoord / winSize2;
      axisExpandWindow = [mathMax$2(0, pos - winSize2 / 2)];
      axisExpandWindow[1] = mathMin$2(extent3[1], axisExpandWindow[0] + winSize2);
      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
    }
    return {
      axisExpandWindow,
      behavior
    };
  };
  return Parallel2;
}();
function restrict(len2, extent3) {
  return mathMin$2(mathMax$2(len2, extent3[0]), extent3[1]);
}
function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
  return {
    position: step * axisIndex,
    axisNameAvailableWidth: step,
    axisLabelShow: true
  };
}
function layoutAxisWithExpand(axisIndex, layoutInfo) {
  var layoutLength = layoutInfo.layoutLength;
  var axisExpandWidth = layoutInfo.axisExpandWidth;
  var axisCount = layoutInfo.axisCount;
  var axisCollapseWidth = layoutInfo.axisCollapseWidth;
  var winInnerIndices = layoutInfo.winInnerIndices;
  var position2;
  var axisNameAvailableWidth = axisCollapseWidth;
  var axisLabelShow = false;
  var nameTruncateMaxWidth;
  if (axisIndex < winInnerIndices[0]) {
    position2 = axisIndex * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  } else if (axisIndex <= winInnerIndices[1]) {
    position2 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
    axisNameAvailableWidth = axisExpandWidth;
    axisLabelShow = true;
  } else {
    position2 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  }
  return {
    position: position2,
    axisNameAvailableWidth,
    axisLabelShow,
    nameTruncateMaxWidth
  };
}
var Parallel$1 = Parallel;
function createParallelCoordSys(ecModel, api) {
  var coordSysList = [];
  ecModel.eachComponent("parallel", function(parallelModel, idx) {
    var coordSys = new Parallel$1(parallelModel, ecModel, api);
    coordSys.name = "parallel_" + idx;
    coordSys.resize(parallelModel, api);
    parallelModel.coordinateSystem = coordSys;
    coordSys.model = parallelModel;
    coordSysList.push(coordSys);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "parallel") {
      var parallelModel = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = parallelModel.coordinateSystem;
    }
  });
  return coordSysList;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
var parallelCoordSysCreator$1 = parallelCoordSysCreator;
var ParallelAxisModel = function(_super) {
  __extends$1(ParallelAxisModel2, _super);
  function ParallelAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelAxisModel2.type;
    _this.activeIntervals = [];
    return _this;
  }
  ParallelAxisModel2.prototype.getAreaSelectStyle = function() {
    return makeStyleMapper([
      ["fill", "color"],
      ["lineWidth", "borderWidth"],
      ["stroke", "borderColor"],
      ["width", "width"],
      ["opacity", "opacity"]
    ])(this.getModel("areaSelectStyle"));
  };
  ParallelAxisModel2.prototype.setActiveIntervals = function(intervals) {
    var activeIntervals = this.activeIntervals = clone$4(intervals);
    if (activeIntervals) {
      for (var i = activeIntervals.length - 1; i >= 0; i--) {
        asc$2(activeIntervals[i]);
      }
    }
  };
  ParallelAxisModel2.prototype.getActiveState = function(value) {
    var activeIntervals = this.activeIntervals;
    if (!activeIntervals.length) {
      return "normal";
    }
    if (value == null || isNaN(+value)) {
      return "inactive";
    }
    if (activeIntervals.length === 1) {
      var interval = activeIntervals[0];
      if (interval[0] <= value && value <= interval[1]) {
        return "active";
      }
    } else {
      for (var i = 0, len2 = activeIntervals.length; i < len2; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return "active";
        }
      }
    }
    return "inactive";
  };
  return ParallelAxisModel2;
}(ComponentModel$1);
mixin(ParallelAxisModel, AxisModelCommonMixin);
var ParallelAxisModel$1 = ParallelAxisModel;
var BRUSH_PANEL_GLOBAL = true;
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
var mathPow = Math.pow;
var COVER_Z = 1e4;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = "globalPan";
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: true,
  brushMode: "single",
  removeOnClick: false
};
var baseUID = 0;
var BrushController = function(_super) {
  __extends$1(BrushController2, _super);
  function BrushController2(zr) {
    var _this = _super.call(this) || this;
    _this._track = [];
    _this._covers = [];
    _this._handlers = {};
    {
      assert(zr);
    }
    _this._zr = zr;
    _this.group = new Group$4();
    _this._uid = "brushController_" + baseUID++;
    each$f(pointerHandlers, function(handler, eventName) {
      this._handlers[eventName] = bind$1(handler, this);
    }, _this);
    return _this;
  }
  BrushController2.prototype.enableBrush = function(brushOption) {
    {
      assert(this._mounted);
    }
    this._brushType && this._doDisableBrush();
    brushOption.brushType && this._doEnableBrush(brushOption);
    return this;
  };
  BrushController2.prototype._doEnableBrush = function(brushOption) {
    var zr = this._zr;
    if (!this._enableGlobalPan) {
      take(zr, MUTEX_RESOURCE_KEY, this._uid);
    }
    each$f(this._handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
    this._brushType = brushOption.brushType;
    this._brushOption = merge3(clone$4(DEFAULT_BRUSH_OPT), brushOption, true);
  };
  BrushController2.prototype._doDisableBrush = function() {
    var zr = this._zr;
    release(zr, MUTEX_RESOURCE_KEY, this._uid);
    each$f(this._handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
    this._brushType = this._brushOption = null;
  };
  BrushController2.prototype.setPanels = function(panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels_1 = this._panels = {};
      each$f(panelOpts, function(panelOpts2) {
        panels_1[panelOpts2.panelId] = clone$4(panelOpts2);
      });
    } else {
      this._panels = null;
    }
    return this;
  };
  BrushController2.prototype.mount = function(opt) {
    opt = opt || {};
    {
      this._mounted = true;
    }
    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;
    this._zr.add(thisGroup);
    thisGroup.attr({
      x: opt.x || 0,
      y: opt.y || 0,
      rotation: opt.rotation || 0,
      scaleX: opt.scaleX || 1,
      scaleY: opt.scaleY || 1
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  };
  BrushController2.prototype.updateCovers = function(coverConfigList) {
    {
      assert(this._mounted);
    }
    coverConfigList = map$1(coverConfigList, function(coverConfig) {
      return merge3(clone$4(DEFAULT_BRUSH_OPT), coverConfig, true);
    });
    var tmpIdPrefix = "\0-brush-index-";
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new DataDiffer$1(oldCovers, coverConfigList, oldGetKey, getKey2).add(addOrUpdate).update(addOrUpdate).remove(remove6).execute();
    return this;
    function getKey2(brushOption, index2) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index2) + "-" + brushOption.brushType;
    }
    function oldGetKey(cover, index2) {
      return getKey2(cover.__brushOption, index2);
    }
    function addOrUpdate(newIndex, oldIndex) {
      var newBrushInternal = coverConfigList[newIndex];
      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
        updateCoverAfterCreation(controller, cover);
      }
    }
    function remove6(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  };
  BrushController2.prototype.unmount = function() {
    {
      if (!this._mounted) {
        return;
      }
    }
    this.enableBrush(false);
    clearCovers(this);
    this._zr.remove(this.group);
    {
      this._mounted = false;
    }
    return this;
  };
  BrushController2.prototype.dispose = function() {
    this.unmount();
    this.off();
  };
  return BrushController2;
}(Eventful$1);
function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ$1(cover, brushOption);
  controller.group.add(cover);
  return cover;
}
function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);
  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ$1(creatingCover, creatingCover.__brushOption);
  }
  return creatingCover;
}
function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}
function updateZ$1(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function(el) {
    el.z = z;
    el.z2 = z;
  });
}
function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}
function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
}
function getPanelByPoint(controller, e2, localCursorPoint) {
  var panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  var panel;
  var transform4 = controller._transform;
  each$f(panels, function(pn) {
    pn.isTargetByCursor(e2, localCursorPoint, transform4) && (panel = pn);
  });
  return panel;
}
function getPanelByCover(controller, cover) {
  var panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  var panelId = cover.__brushOption.panelId;
  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(controller) {
  var covers2 = controller._covers;
  var originalLength = covers2.length;
  each$f(covers2, function(cover) {
    controller.group.remove(cover);
  }, controller);
  covers2.length = 0;
  return !!originalLength;
}
function trigger(controller, opt) {
  var areas = map$1(controller._covers, function(cover) {
    var brushOption = cover.__brushOption;
    var range = clone$4(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range
    };
  });
  controller.trigger("brush", {
    areas,
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}
function shouldShowCover(controller) {
  var track = controller._track;
  if (!track.length) {
    return false;
  }
  var p2 = track[track.length - 1];
  var p1 = track[0];
  var dx = p2[0] - p1[0];
  var dy = p2[1] - p1[1];
  var dist3 = mathPow(dx * dx + dy * dy, 0.5);
  return dist3 > UNSELECT_THRESHOLD;
}
function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}
function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
  var cover = new Group$4();
  cover.add(new Rect$3({
    name: "main",
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: "move",
    drift: curry$1(driftRect, rectRangeConverter, controller, cover, ["n", "s", "w", "e"]),
    ondragend: curry$1(trigger, controller, {
      isEnd: true
    })
  }));
  each$f(edgeNameSequences, function(nameSequence) {
    cover.add(new Rect$3({
      name: nameSequence.join(""),
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry$1(driftRect, rectRangeConverter, controller, cover, nameSequence),
      ondragend: curry$1(trigger, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}
function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax$1(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x2 = localRange[0][0];
  var y2 = localRange[1][0];
  var xa = x2 - lineWidth / 2;
  var ya = y2 - lineWidth / 2;
  var x22 = localRange[0][1];
  var y22 = localRange[1][1];
  var x2a = x22 - handleSize + lineWidth / 2;
  var y2a = y22 - handleSize + lineWidth / 2;
  var width = x22 - x2;
  var height = y22 - y2;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, "main", x2, y2, width, height);
  if (brushOption.transformable) {
    updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
  }
}
function updateCommon$1(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? "move" : "default"
  });
  each$f([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(nameSequence) {
    var el = cover.childOfName(nameSequence.join(""));
    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
    });
  });
}
function updateRectShape(controller, cover, name2, x2, y2, w, h) {
  var el = cover.childOfName(name2);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x2, y2], [x2 + w, y2 + h]])));
}
function makeStyle(brushOption) {
  return defaults({
    strokeNoScale: true
  }, brushOption.brushStyle);
}
function formatRectRange(x2, y2, x22, y22) {
  var min5 = [mathMin$1(x2, x22), mathMin$1(y2, y22)];
  var max4 = [mathMax$1(x2, x22), mathMax$1(y2, y22)];
  return [
    [min5[0], max4[0]],
    [min5[1], max4[1]]
  ];
}
function getTransform(controller) {
  return getTransform$1(controller.group);
}
function getGlobalDirection1(controller, localDirName) {
  var map5 = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  };
  var inverseMap = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  };
  var dir3 = transformDirection(map5[localDirName], getTransform(controller));
  return inverseMap[dir3];
}
function getGlobalDirection2(controller, localDirNameSeq) {
  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
  (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
  return globalDir.join("");
}
function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
  var brushOption = cover.__brushOption;
  var rectRange = rectRangeConverter.toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  each$f(dirNameSequence, function(dirName) {
    var ind = DIRECTION_MAP[dirName];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}
function driftPolygon(controller, cover, dx, dy) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  each$f(range, function(point4) {
    point4[0] += localDelta[0];
    point4[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}
function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}
function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone$4(data);
}
function pointsToRect(points2) {
  var xmin = mathMin$1(points2[0][0], points2[1][0]);
  var ymin = mathMin$1(points2[0][1], points2[1][1]);
  var xmax = mathMax$1(points2[0][0], points2[1][0]);
  var ymax = mathMax$1(points2[0][1], points2[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}
function resetCursor(controller, e2, localCursorPoint) {
  if (!controller._brushType || isOutsideZrArea(controller, e2.offsetX, e2.offsetY)) {
    return;
  }
  var zr = controller._zr;
  var covers2 = controller._covers;
  var currPanel = getPanelByPoint(controller, e2, localCursorPoint);
  if (!controller._dragging) {
    for (var i = 0; i < covers2.length; i++) {
      var brushOption = covers2[i].__brushOption;
      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers2[i], localCursorPoint[0], localCursorPoint[1])) {
        return;
      }
    }
  }
  currPanel && zr.setCursorStyle("crosshair");
}
function preventDefault(e2) {
  var rawE = e2.event;
  rawE.preventDefault && rawE.preventDefault();
}
function mainShapeContain(cover, x2, y2) {
  return cover.childOfName("main").contain(x2, y2);
}
function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;
  controller._track.push(localCursorPoint.slice());
  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === "single" && clearCovers(controller);
      var brushOption = clone$4(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);
      controller._covers.push(creatingCover);
    }
    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }
      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
    if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd,
        removeOnClick: true
      };
    }
  }
  return eventParams;
}
function determineBrushType(brushType, panel) {
  if (brushType === "auto") {
    {
      assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"');
    }
    return panel.defaultBrushType;
  }
  return brushType;
}
var pointerHandlers = {
  mousedown: function(e2) {
    if (this._dragging) {
      handleDragEnd(this, e2);
    } else if (!e2.target || !e2.target.draggable) {
      preventDefault(e2);
      var localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function(e2) {
    var x2 = e2.offsetX;
    var y2 = e2.offsetY;
    var localCursorPoint = this.group.transformCoordToLocal(x2, y2);
    resetCursor(this, e2, localCursorPoint);
    if (this._dragging) {
      preventDefault(e2);
      var eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
      eventParams && trigger(this, eventParams);
    }
  },
  mouseup: function(e2) {
    handleDragEnd(this, e2);
  }
};
function handleDragEnd(controller, e2) {
  if (controller._dragging) {
    preventDefault(e2);
    var x2 = e2.offsetX;
    var y2 = e2.offsetY;
    var localCursorPoint = controller.group.transformCoordToLocal(x2, y2);
    var eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
    controller._dragging = false;
    controller._track = [];
    controller._creatingCover = null;
    eventParams && trigger(controller, eventParams);
  }
}
function isOutsideZrArea(controller, x2, y2) {
  var zr = controller._zr;
  return x2 < 0 || x2 > zr.getWidth() || y2 < 0 || y2 > zr.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(controller, brushOption) {
      function returnInput(range) {
        return range;
      }
      return createBaseRectCover({
        toRectRange: returnInput,
        fromRectRange: returnInput
      }, controller, brushOption, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(controller, brushOption) {
      var cover = new Group$4();
      cover.add(new Polyline$3({
        name: "main",
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function(localTrack) {
      return localTrack;
    },
    endCreating: function(controller, cover) {
      cover.remove(cover.childAt(0));
      cover.add(new Polygon$1({
        name: "main",
        draggable: true,
        drift: curry$1(driftPolygon, controller, cover),
        ondragend: curry$1(trigger, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
};
function getLineRenderer(xyIndex) {
  return {
    createCover: function(controller, brushOption) {
      return createBaseRectCover({
        toRectRange: function(range) {
          var rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        },
        fromRectRange: function(rectRange) {
          return rectRange[xyIndex];
        }
      }, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
    },
    getCreatingRange: function(localTrack) {
      var ends = getTrackEnds(localTrack);
      var min5 = mathMin$1(ends[0][xyIndex], ends[1][xyIndex]);
      var max4 = mathMax$1(ends[0][xyIndex], ends[1][xyIndex]);
      return [min5, max4];
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      var otherExtent;
      var panel = getPanelByCover(controller, cover);
      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }
      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  };
}
var BrushController$1 = BrushController;
function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function(localPoints) {
    return clipPointsByRect(localPoints, rect);
  };
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function(xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base2 = idx ? rect.x : rect.y;
    return [base2, base2 + (brushWidth || 0)];
  };
}
function makeRectIsTargetByCursor(rect, api, targetModel) {
  var boundingRect = normalizeRect(rect);
  return function(e2, localCursorPoint) {
    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api, targetModel);
  };
}
function normalizeRect(rect) {
  return BoundingRect$1.create(rect);
}
var elementList$1 = ["axisLine", "axisTickLabel", "axisName"];
var ParallelAxisView = function(_super) {
  __extends$1(ParallelAxisView2, _super);
  function ParallelAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelAxisView2.type;
    return _this;
  }
  ParallelAxisView2.prototype.init = function(ecModel, api) {
    _super.prototype.init.apply(this, arguments);
    (this._brushController = new BrushController$1(api.getZr())).on("brush", bind$1(this._onBrush, this));
  };
  ParallelAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
      return;
    }
    this.axisModel = axisModel;
    this.api = api;
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$4();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var coordSysModel = getCoordSysModel(axisModel, ecModel);
    var coordSys = coordSysModel.coordinateSystem;
    var areaSelectStyle = axisModel.getAreaSelectStyle();
    var areaWidth = areaSelectStyle.width;
    var dim = axisModel.axis.dim;
    var axisLayout = coordSys.getAxisLayout(dim);
    var builderOpt = extend2({
      strokeContainThreshold: areaWidth
    }, axisLayout);
    var axisBuilder = new AxisBuilder$1(axisModel, builderOpt);
    each$f(elementList$1, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
  };
  ParallelAxisView2.prototype._refreshBrushController = function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
    var extent3 = axisModel.axis.getExtent();
    var extentLen = extent3[1] - extent3[0];
    var extra = Math.min(30, Math.abs(extentLen) * 0.1);
    var rect = BoundingRect$1.create({
      x: extent3[0],
      y: -areaWidth / 2,
      width: extentLen,
      height: areaWidth
    });
    rect.x -= extra;
    rect.width += 2 * extra;
    this._brushController.mount({
      enableGlobalPan: true,
      rotation: builderOpt.rotation,
      x: builderOpt.position[0],
      y: builderOpt.position[1]
    }).setPanels([{
      panelId: "pl",
      clipPath: makeRectPanelClipPath(rect),
      isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),
      getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
    }]).enableBrush({
      brushType: "lineX",
      brushStyle: areaSelectStyle,
      removeOnClick: true
    }).updateCovers(getCoverInfoList(axisModel));
  };
  ParallelAxisView2.prototype._onBrush = function(eventParam) {
    var coverInfoList = eventParam.areas;
    var axisModel = this.axisModel;
    var axis = axisModel.axis;
    var intervals = map$1(coverInfoList, function(coverInfo) {
      return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
    });
    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
      this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: axisModel.id,
        intervals
      });
    }
  };
  ParallelAxisView2.prototype.dispose = function() {
    this._brushController.dispose();
  };
  ParallelAxisView2.type = "parallelAxis";
  return ParallelAxisView2;
}(ComponentView$1);
function fromAxisAreaSelect(axisModel, ecModel, payload) {
  return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
    mainType: "parallelAxis",
    query: payload
  })[0] === axisModel;
}
function getCoverInfoList(axisModel) {
  var axis = axisModel.axis;
  return map$1(axisModel.activeIntervals, function(interval) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
    };
  });
}
function getCoordSysModel(axisModel, ecModel) {
  return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
}
var ParallelAxisView$1 = ParallelAxisView;
var actionInfo = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
};
function installParallelActions(registers) {
  registers.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallelAxis",
      query: payload
    }, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallel",
      query: payload
    }, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
}
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: true,
  z: 10
};
function install$C(registers) {
  registers.registerComponentView(ParallelView$1);
  registers.registerComponentModel(ParallelModel$1);
  registers.registerCoordinateSystem("parallel", parallelCoordSysCreator$1);
  registers.registerPreprocessor(parallelPreprocessor);
  registers.registerComponentModel(ParallelAxisModel$1);
  registers.registerComponentView(ParallelAxisView$1);
  axisModelCreator(registers, "parallel", ParallelAxisModel$1, defaultAxisOption);
  installParallelActions(registers);
}
function install$B(registers) {
  use2(install$C);
  registers.registerChartView(ParallelView$3);
  registers.registerSeriesModel(ParallelSeriesModel$1);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual$1);
}
var SankeyPathShape = function() {
  function SankeyPathShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.cpx2 = 0;
    this.cpy2 = 0;
    this.extent = 0;
  }
  return SankeyPathShape2;
}();
var SankeyPath = function(_super) {
  __extends$1(SankeyPath2, _super);
  function SankeyPath2(opts) {
    return _super.call(this, opts) || this;
  }
  SankeyPath2.prototype.getDefaultShape = function() {
    return new SankeyPathShape();
  };
  SankeyPath2.prototype.buildPath = function(ctx, shape) {
    var extent3 = shape.extent;
    ctx.moveTo(shape.x1, shape.y1);
    ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
    if (shape.orient === "vertical") {
      ctx.lineTo(shape.x2 + extent3, shape.y2);
      ctx.bezierCurveTo(shape.cpx2 + extent3, shape.cpy2, shape.cpx1 + extent3, shape.cpy1, shape.x1 + extent3, shape.y1);
    } else {
      ctx.lineTo(shape.x2, shape.y2 + extent3);
      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent3, shape.cpx1, shape.cpy1 + extent3, shape.x1, shape.y1 + extent3);
    }
    ctx.closePath();
  };
  SankeyPath2.prototype.highlight = function() {
    enterEmphasis(this);
  };
  SankeyPath2.prototype.downplay = function() {
    leaveEmphasis(this);
  };
  return SankeyPath2;
}(Path$1);
var SankeyView = function(_super) {
  __extends$1(SankeyView2, _super);
  function SankeyView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SankeyView2.type;
    _this._focusAdjacencyDisabled = false;
    return _this;
  }
  SankeyView2.prototype.render = function(seriesModel, ecModel, api) {
    var sankeyView = this;
    var graph = seriesModel.getGraph();
    var group = this.group;
    var layoutInfo = seriesModel.layoutInfo;
    var width = layoutInfo.width;
    var height = layoutInfo.height;
    var nodeData = seriesModel.getData();
    var edgeData = seriesModel.getData("edge");
    var orient2 = seriesModel.get("orient");
    this._model = seriesModel;
    group.removeAll();
    group.x = layoutInfo.x;
    group.y = layoutInfo.y;
    graph.eachEdge(function(edge) {
      var curve = new SankeyPath();
      var ecData = getECData(curve);
      ecData.dataIndex = edge.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      ecData.dataType = "edge";
      var edgeModel = edge.getModel();
      var lineStyleModel = edgeModel.getModel("lineStyle");
      var curvature = lineStyleModel.get("curveness");
      var n1Layout = edge.node1.getLayout();
      var node1Model = edge.node1.getModel();
      var dragX1 = node1Model.get("localX");
      var dragY1 = node1Model.get("localY");
      var n2Layout = edge.node2.getLayout();
      var node2Model = edge.node2.getModel();
      var dragX2 = node2Model.get("localX");
      var dragY2 = node2Model.get("localY");
      var edgeLayout = edge.getLayout();
      var x12;
      var y12;
      var x2;
      var y2;
      var cpx1;
      var cpy1;
      var cpx2;
      var cpy2;
      curve.shape.extent = Math.max(1, edgeLayout.dy);
      curve.shape.orient = orient2;
      if (orient2 === "vertical") {
        x12 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
        y12 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
        x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
        y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
        cpx1 = x12;
        cpy1 = y12 * (1 - curvature) + y2 * curvature;
        cpx2 = x2;
        cpy2 = y12 * curvature + y2 * (1 - curvature);
      } else {
        x12 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
        y12 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
        x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
        y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
        cpx1 = x12 * (1 - curvature) + x2 * curvature;
        cpy1 = y12;
        cpx2 = x12 * curvature + x2 * (1 - curvature);
        cpy2 = y2;
      }
      curve.setShape({
        x1: x12,
        y1: y12,
        x2,
        y2,
        cpx1,
        cpy1,
        cpx2,
        cpy2
      });
      curve.useStyle(lineStyleModel.getItemStyle());
      switch (curve.style.fill) {
        case "source":
          curve.style.fill = edge.node1.getVisual("color");
          curve.style.decal = edge.node1.getVisual("style").decal;
          break;
        case "target":
          curve.style.fill = edge.node2.getVisual("color");
          curve.style.decal = edge.node2.getVisual("style").decal;
          break;
        case "gradient":
          var sourceColor = edge.node1.getVisual("color");
          var targetColor = edge.node2.getVisual("color");
          if (isString(sourceColor) && isString(targetColor)) {
            curve.style.fill = new LinearGradient$1(0, 0, +(orient2 === "horizontal"), +(orient2 === "vertical"), [{
              color: sourceColor,
              offset: 0
            }, {
              color: targetColor,
              offset: 1
            }]);
          }
      }
      var emphasisModel = edgeModel.getModel("emphasis");
      setStatesStylesFromModel(curve, edgeModel, "lineStyle", function(model) {
        return model.getItemStyle();
      });
      group.add(curve);
      edgeData.setItemGraphicEl(edge.dataIndex, curve);
      var focus = emphasisModel.get("focus");
      toggleHoverEmphasis(curve, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      getECData(curve).dataType = "edge";
    });
    graph.eachNode(function(node) {
      var layout2 = node.getLayout();
      var itemModel = node.getModel();
      var dragX = itemModel.get("localX");
      var dragY = itemModel.get("localY");
      var emphasisModel = itemModel.getModel("emphasis");
      var rect = new Rect$3({
        shape: {
          x: dragX != null ? dragX * width : layout2.x,
          y: dragY != null ? dragY * height : layout2.y,
          width: layout2.dx,
          height: layout2.dy
        },
        style: itemModel.getModel("itemStyle").getItemStyle(),
        z2: 10
      });
      setLabelStyle(rect, getLabelStatesModels(itemModel), {
        labelFetcher: seriesModel,
        labelDataIndex: node.dataIndex,
        defaultText: node.id
      });
      rect.disableLabelAnimation = true;
      rect.setStyle("fill", node.getVisual("color"));
      rect.setStyle("decal", node.getVisual("style").decal);
      setStatesStylesFromModel(rect, itemModel);
      group.add(rect);
      nodeData.setItemGraphicEl(node.dataIndex, rect);
      getECData(rect).dataType = "node";
      var focus = emphasisModel.get("focus");
      toggleHoverEmphasis(rect, focus === "adjacency" ? node.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    nodeData.eachItemGraphicEl(function(el, dataIndex) {
      var itemModel = nodeData.getItemModel(dataIndex);
      if (itemModel.get("draggable")) {
        el.drift = function(dx, dy) {
          sankeyView._focusAdjacencyDisabled = true;
          this.shape.x += dx;
          this.shape.y += dy;
          this.dirty();
          api.dispatchAction({
            type: "dragNode",
            seriesId: seriesModel.id,
            dataIndex: nodeData.getRawIndex(dataIndex),
            localX: this.shape.x / width,
            localY: this.shape.y / height
          });
        };
        el.ondragend = function() {
          sankeyView._focusAdjacencyDisabled = false;
        };
        el.draggable = true;
        el.cursor = "move";
      }
    });
    if (!this._data && seriesModel.isAnimationEnabled()) {
      group.setClipPath(createGridClipShape$1(group.getBoundingRect(), seriesModel, function() {
        group.removeClipPath();
      }));
    }
    this._data = seriesModel.getData();
  };
  SankeyView2.prototype.dispose = function() {
  };
  SankeyView2.type = "sankey";
  return SankeyView2;
}(ChartView$1);
function createGridClipShape$1(rect, seriesModel, cb) {
  var rectEl = new Rect$3({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      width: rect.width + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var SankeyView$1 = SankeyView;
var SankeySeriesModel = function(_super) {
  __extends$1(SankeySeriesModel2, _super);
  function SankeySeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SankeySeriesModel2.type;
    return _this;
  }
  SankeySeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var links = option.edges || option.links;
    var nodes = option.data || option.nodes;
    var levels = option.levels;
    this.levelModels = [];
    var levelModels = this.levelModels;
    for (var i = 0; i < levels.length; i++) {
      if (levels[i].depth != null && levels[i].depth >= 0) {
        levelModels[levels[i].depth] = new Model$1(levels[i], this, ecModel);
      } else {
        {
          throw new Error("levels[i].depth is mandatory and should be natural number");
        }
      }
    }
    if (nodes && links) {
      var graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var seriesModel = model.parentModel;
        var layout2 = seriesModel.getData().getItemLayout(idx);
        if (layout2) {
          var nodeDepth = layout2.depth;
          var levelModel = seriesModel.levelModels[nodeDepth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
      edgeData.wrapMethod("getItemModel", function(model, idx) {
        var seriesModel = model.parentModel;
        var edge = seriesModel.getGraph().getEdgeByIndex(idx);
        var layout2 = edge.node1.getLayout();
        if (layout2) {
          var depth2 = layout2.depth;
          var levelModel = seriesModel.levelModels[depth2];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
    }
  };
  SankeySeriesModel2.prototype.setNodePosition = function(dataIndex, localPosition) {
    var nodes = this.option.data || this.option.nodes;
    var dataItem = nodes[dataIndex];
    dataItem.localX = localPosition[0];
    dataItem.localY = localPosition[1];
  };
  SankeySeriesModel2.prototype.getGraph = function() {
    return this.getData().graph;
  };
  SankeySeriesModel2.prototype.getEdgeData = function() {
    return this.getGraph().edgeData;
  };
  SankeySeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    function noValue(val) {
      return isNaN(val) || val == null;
    }
    if (dataType === "edge") {
      var params = this.getDataParams(dataIndex, dataType);
      var rawDataOpt = params.data;
      var edgeValue = params.value;
      var edgeName = rawDataOpt.source + " -- " + rawDataOpt.target;
      return createTooltipMarkup("nameValue", {
        name: edgeName,
        value: edgeValue,
        noValue: noValue(edgeValue)
      });
    } else {
      var node = this.getGraph().getNodeByIndex(dataIndex);
      var value = node.getLayout().value;
      var name_1 = this.getDataParams(dataIndex, dataType).data.name;
      return createTooltipMarkup("nameValue", {
        name: name_1 != null ? name_1 + "" : null,
        value,
        noValue: noValue(value)
      });
    }
  };
  SankeySeriesModel2.prototype.optionUpdated = function() {
  };
  SankeySeriesModel2.prototype.getDataParams = function(dataIndex, dataType) {
    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
    if (params.value == null && dataType === "node") {
      var node = this.getGraph().getNodeByIndex(dataIndex);
      var nodeValue = node.getLayout().value;
      params.value = nodeValue;
    }
    return params;
  };
  SankeySeriesModel2.type = "series.sankey";
  SankeySeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "view",
    left: "5%",
    top: "5%",
    right: "20%",
    bottom: "5%",
    orient: "horizontal",
    nodeWidth: 20,
    nodeGap: 8,
    draggable: true,
    layoutIterations: 32,
    label: {
      show: true,
      position: "right",
      fontSize: 12
    },
    levels: [],
    nodeAlign: "justify",
    lineStyle: {
      color: "#314656",
      opacity: 0.2,
      curveness: 0.5
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        opacity: 0.5
      }
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    animationEasing: "linear",
    animationDuration: 1e3
  };
  return SankeySeriesModel2;
}(SeriesModel$1);
var SankeySeriesModel$1 = SankeySeriesModel;
function sankeyLayout(ecModel, api) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    var nodeWidth = seriesModel.get("nodeWidth");
    var nodeGap = seriesModel.get("nodeGap");
    var layoutInfo = getViewRect$1(seriesModel, api);
    seriesModel.layoutInfo = layoutInfo;
    var width = layoutInfo.width;
    var height = layoutInfo.height;
    var graph = seriesModel.getGraph();
    var nodes = graph.nodes;
    var edges2 = graph.edges;
    computeNodeValues(nodes);
    var filteredNodes = filter17(nodes, function(node) {
      return node.getLayout().value === 0;
    });
    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
    var orient2 = seriesModel.get("orient");
    var nodeAlign = seriesModel.get("nodeAlign");
    layoutSankey(nodes, edges2, nodeWidth, nodeGap, width, height, iterations, orient2, nodeAlign);
  });
}
function getViewRect$1(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function layoutSankey(nodes, edges2, nodeWidth, nodeGap, width, height, iterations, orient2, nodeAlign) {
  computeNodeBreadths(nodes, edges2, nodeWidth, width, height, orient2, nodeAlign);
  computeNodeDepths(nodes, edges2, height, width, nodeGap, iterations, orient2);
  computeEdgeDepths(nodes, orient2);
}
function computeNodeValues(nodes) {
  each$f(nodes, function(node) {
    var value1 = sum(node.outEdges, getEdgeValue);
    var value2 = sum(node.inEdges, getEdgeValue);
    var nodeRawValue = node.getValue() || 0;
    var value = Math.max(value1, value2, nodeRawValue);
    node.setLayout({
      value
    }, true);
  });
}
function computeNodeBreadths(nodes, edges2, nodeWidth, width, height, orient2, nodeAlign) {
  var remainEdges = [];
  var indegreeArr = [];
  var zeroIndegrees = [];
  var nextTargetNode = [];
  var x2 = 0;
  for (var i = 0; i < edges2.length; i++) {
    remainEdges[i] = 1;
  }
  for (var i = 0; i < nodes.length; i++) {
    indegreeArr[i] = nodes[i].inEdges.length;
    if (indegreeArr[i] === 0) {
      zeroIndegrees.push(nodes[i]);
    }
  }
  var maxNodeDepth = -1;
  while (zeroIndegrees.length) {
    for (var idx = 0; idx < zeroIndegrees.length; idx++) {
      var node = zeroIndegrees[idx];
      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      var isItemDepth = item.depth != null && item.depth >= 0;
      if (isItemDepth && item.depth > maxNodeDepth) {
        maxNodeDepth = item.depth;
      }
      node.setLayout({
        depth: isItemDepth ? item.depth : x2
      }, true);
      orient2 === "vertical" ? node.setLayout({
        dy: nodeWidth
      }, true) : node.setLayout({
        dx: nodeWidth
      }, true);
      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
        var edge = node.outEdges[edgeIdx];
        var indexEdge = edges2.indexOf(edge);
        remainEdges[indexEdge] = 0;
        var targetNode = edge.node2;
        var nodeIndex = nodes.indexOf(targetNode);
        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
          nextTargetNode.push(targetNode);
        }
      }
    }
    ++x2;
    zeroIndegrees = nextTargetNode;
    nextTargetNode = [];
  }
  for (var i = 0; i < remainEdges.length; i++) {
    if (remainEdges[i] === 1) {
      throw new Error("Sankey is a DAG, the original data has cycle!");
    }
  }
  var maxDepth2 = maxNodeDepth > x2 - 1 ? maxNodeDepth : x2 - 1;
  if (nodeAlign && nodeAlign !== "left") {
    adjustNodeWithNodeAlign(nodes, nodeAlign, orient2, maxDepth2);
  }
  var kx = orient2 === "vertical" ? (height - nodeWidth) / maxDepth2 : (width - nodeWidth) / maxDepth2;
  scaleNodeBreadths(nodes, kx, orient2);
}
function isNodeDepth(node) {
  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
  return item.depth != null && item.depth >= 0;
}
function adjustNodeWithNodeAlign(nodes, nodeAlign, orient2, maxDepth2) {
  if (nodeAlign === "right") {
    var nextSourceNode = [];
    var remainNodes = nodes;
    var nodeHeight = 0;
    while (remainNodes.length) {
      for (var i = 0; i < remainNodes.length; i++) {
        var node = remainNodes[i];
        node.setLayout({
          skNodeHeight: nodeHeight
        }, true);
        for (var j = 0; j < node.inEdges.length; j++) {
          var edge = node.inEdges[j];
          if (nextSourceNode.indexOf(edge.node1) < 0) {
            nextSourceNode.push(edge.node1);
          }
        }
      }
      remainNodes = nextSourceNode;
      nextSourceNode = [];
      ++nodeHeight;
    }
    each$f(nodes, function(node2) {
      if (!isNodeDepth(node2)) {
        node2.setLayout({
          depth: Math.max(0, maxDepth2 - node2.getLayout().skNodeHeight)
        }, true);
      }
    });
  } else if (nodeAlign === "justify") {
    moveSinksRight(nodes, maxDepth2);
  }
}
function moveSinksRight(nodes, maxDepth2) {
  each$f(nodes, function(node) {
    if (!isNodeDepth(node) && !node.outEdges.length) {
      node.setLayout({
        depth: maxDepth2
      }, true);
    }
  });
}
function scaleNodeBreadths(nodes, kx, orient2) {
  each$f(nodes, function(node) {
    var nodeDepth = node.getLayout().depth * kx;
    orient2 === "vertical" ? node.setLayout({
      y: nodeDepth
    }, true) : node.setLayout({
      x: nodeDepth
    }, true);
  });
}
function computeNodeDepths(nodes, edges2, height, width, nodeGap, iterations, orient2) {
  var nodesByBreadth = prepareNodesByBreadth(nodes, orient2);
  initializeNodeDepth(nodesByBreadth, edges2, height, width, nodeGap, orient2);
  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient2);
  for (var alpha = 1; iterations > 0; iterations--) {
    alpha *= 0.99;
    relaxRightToLeft(nodesByBreadth, alpha, orient2);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient2);
    relaxLeftToRight(nodesByBreadth, alpha, orient2);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient2);
  }
}
function prepareNodesByBreadth(nodes, orient2) {
  var nodesByBreadth = [];
  var keyAttr = orient2 === "vertical" ? "y" : "x";
  var groupResult = groupData(nodes, function(node) {
    return node.getLayout()[keyAttr];
  });
  groupResult.keys.sort(function(a, b) {
    return a - b;
  });
  each$f(groupResult.keys, function(key) {
    nodesByBreadth.push(groupResult.buckets.get(key));
  });
  return nodesByBreadth;
}
function initializeNodeDepth(nodesByBreadth, edges2, height, width, nodeGap, orient2) {
  var minKy = Infinity;
  each$f(nodesByBreadth, function(nodes) {
    var n = nodes.length;
    var sum2 = 0;
    each$f(nodes, function(node) {
      sum2 += node.getLayout().value;
    });
    var ky = orient2 === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
    if (ky < minKy) {
      minKy = ky;
    }
  });
  each$f(nodesByBreadth, function(nodes) {
    each$f(nodes, function(node, i) {
      var nodeDy = node.getLayout().value * minKy;
      if (orient2 === "vertical") {
        node.setLayout({
          x: i
        }, true);
        node.setLayout({
          dx: nodeDy
        }, true);
      } else {
        node.setLayout({
          y: i
        }, true);
        node.setLayout({
          dy: nodeDy
        }, true);
      }
    });
  });
  each$f(edges2, function(edge) {
    var edgeDy = +edge.getValue() * minKy;
    edge.setLayout({
      dy: edgeDy
    }, true);
  });
}
function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient2) {
  var keyAttr = orient2 === "vertical" ? "x" : "y";
  each$f(nodesByBreadth, function(nodes) {
    nodes.sort(function(a, b) {
      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
    });
    var nodeX;
    var node;
    var dy;
    var y02 = 0;
    var n = nodes.length;
    var nodeDyAttr = orient2 === "vertical" ? "dx" : "dy";
    for (var i = 0; i < n; i++) {
      node = nodes[i];
      dy = y02 - node.getLayout()[keyAttr];
      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] + dy;
        orient2 === "vertical" ? node.setLayout({
          x: nodeX
        }, true) : node.setLayout({
          y: nodeX
        }, true);
      }
      y02 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
    }
    var viewWidth = orient2 === "vertical" ? width : height;
    dy = y02 - nodeGap - viewWidth;
    if (dy > 0) {
      nodeX = node.getLayout()[keyAttr] - dy;
      orient2 === "vertical" ? node.setLayout({
        x: nodeX
      }, true) : node.setLayout({
        y: nodeX
      }, true);
      y02 = nodeX;
      for (var i = n - 2; i >= 0; --i) {
        node = nodes[i];
        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y02;
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient2 === "vertical" ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
        }
        y02 = node.getLayout()[keyAttr];
      }
    }
  });
}
function relaxRightToLeft(nodesByBreadth, alpha, orient2) {
  each$f(nodesByBreadth.slice().reverse(), function(nodes) {
    each$f(nodes, function(node) {
      if (node.outEdges.length) {
        var y2 = sum(node.outEdges, weightedTarget, orient2) / sum(node.outEdges, getEdgeValue);
        if (isNaN(y2)) {
          var len2 = node.outEdges.length;
          y2 = len2 ? sum(node.outEdges, centerTarget, orient2) / len2 : 0;
        }
        if (orient2 === "vertical") {
          var nodeX = node.getLayout().x + (y2 - center(node, orient2)) * alpha;
          node.setLayout({
            x: nodeX
          }, true);
        } else {
          var nodeY = node.getLayout().y + (y2 - center(node, orient2)) * alpha;
          node.setLayout({
            y: nodeY
          }, true);
        }
      }
    });
  });
}
function weightedTarget(edge, orient2) {
  return center(edge.node2, orient2) * edge.getValue();
}
function centerTarget(edge, orient2) {
  return center(edge.node2, orient2);
}
function weightedSource(edge, orient2) {
  return center(edge.node1, orient2) * edge.getValue();
}
function centerSource(edge, orient2) {
  return center(edge.node1, orient2);
}
function center(node, orient2) {
  return orient2 === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
}
function getEdgeValue(edge) {
  return edge.getValue();
}
function sum(array, cb, orient2) {
  var sum2 = 0;
  var len2 = array.length;
  var i = -1;
  while (++i < len2) {
    var value = +cb(array[i], orient2);
    if (!isNaN(value)) {
      sum2 += value;
    }
  }
  return sum2;
}
function relaxLeftToRight(nodesByBreadth, alpha, orient2) {
  each$f(nodesByBreadth, function(nodes) {
    each$f(nodes, function(node) {
      if (node.inEdges.length) {
        var y2 = sum(node.inEdges, weightedSource, orient2) / sum(node.inEdges, getEdgeValue);
        if (isNaN(y2)) {
          var len2 = node.inEdges.length;
          y2 = len2 ? sum(node.inEdges, centerSource, orient2) / len2 : 0;
        }
        if (orient2 === "vertical") {
          var nodeX = node.getLayout().x + (y2 - center(node, orient2)) * alpha;
          node.setLayout({
            x: nodeX
          }, true);
        } else {
          var nodeY = node.getLayout().y + (y2 - center(node, orient2)) * alpha;
          node.setLayout({
            y: nodeY
          }, true);
        }
      }
    });
  });
}
function computeEdgeDepths(nodes, orient2) {
  var keyAttr = orient2 === "vertical" ? "x" : "y";
  each$f(nodes, function(node) {
    node.outEdges.sort(function(a, b) {
      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
    });
    node.inEdges.sort(function(a, b) {
      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
    });
  });
  each$f(nodes, function(node) {
    var sy = 0;
    var ty = 0;
    each$f(node.outEdges, function(edge) {
      edge.setLayout({
        sy
      }, true);
      sy += edge.getLayout().dy;
    });
    each$f(node.inEdges, function(edge) {
      edge.setLayout({
        ty
      }, true);
      ty += edge.getLayout().dy;
    });
  });
}
function sankeyVisual(ecModel) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    var graph = seriesModel.getGraph();
    var nodes = graph.nodes;
    if (nodes.length) {
      var minValue_1 = Infinity;
      var maxValue_1 = -Infinity;
      each$f(nodes, function(node) {
        var nodeValue = node.getLayout().value;
        if (nodeValue < minValue_1) {
          minValue_1 = nodeValue;
        }
        if (nodeValue > maxValue_1) {
          maxValue_1 = nodeValue;
        }
      });
      each$f(nodes, function(node) {
        var mapping = new VisualMapping$1({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [minValue_1, maxValue_1],
          visual: seriesModel.get("color")
        });
        var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
        var customColor = node.getModel().get(["itemStyle", "color"]);
        if (customColor != null) {
          node.setVisual("color", customColor);
          node.setVisual("style", {
            fill: customColor
          });
        } else {
          node.setVisual("color", mapValueToColor);
          node.setVisual("style", {
            fill: mapValueToColor
          });
        }
      });
    }
  });
}
function install$A(registers) {
  registers.registerChartView(SankeyView$1);
  registers.registerSeriesModel(SankeySeriesModel$1);
  registers.registerLayout(sankeyLayout);
  registers.registerVisual(sankeyVisual);
  registers.registerAction({
    type: "dragNode",
    event: "dragnode",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: payload
    }, function(seriesModel) {
      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
    });
  });
}
var WhiskerBoxCommonMixin = function() {
  function WhiskerBoxCommonMixin2() {
  }
  WhiskerBoxCommonMixin2.prototype.getInitialData = function(option, ecModel) {
    var ordinalMeta;
    var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
    var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
    var xAxisType = xAxisModel.get("type");
    var yAxisType = yAxisModel.get("type");
    var addOrdinal;
    if (xAxisType === "category") {
      option.layout = "horizontal";
      ordinalMeta = xAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else if (yAxisType === "category") {
      option.layout = "vertical";
      ordinalMeta = yAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else {
      option.layout = option.layout || "horizontal";
    }
    var coordDims = ["x", "y"];
    var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
    var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
    var otherAxisDim = coordDims[1 - baseAxisDimIndex];
    var axisModels = [xAxisModel, yAxisModel];
    var baseAxisType = axisModels[baseAxisDimIndex].get("type");
    var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
    var data = option.data;
    if (data && addOrdinal) {
      var newOptionData_1 = [];
      each$f(data, function(item, index2) {
        var newItem;
        if (isArray$1(item)) {
          newItem = item.slice();
          item.unshift(index2);
        } else if (isArray$1(item.value)) {
          newItem = extend2({}, item);
          newItem.value = newItem.value.slice();
          item.value.unshift(index2);
        } else {
          newItem = item;
        }
        newOptionData_1.push(newItem);
      });
      option.data = newOptionData_1;
    }
    var defaultValueDimensions = this.defaultValueDimensions;
    var coordDimensions = [{
      name: baseAxisDim,
      type: getDimensionTypeByAxis(baseAxisType),
      ordinalMeta,
      otherDims: {
        tooltip: false,
        itemName: 0
      },
      dimsDef: ["base"]
    }, {
      name: otherAxisDim,
      type: getDimensionTypeByAxis(otherAxisType),
      dimsDef: defaultValueDimensions.slice()
    }];
    return createSeriesDataSimply(this, {
      coordDimensions,
      dimensionsCount: defaultValueDimensions.length + 1,
      encodeDefaulter: curry$1(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
    });
  };
  WhiskerBoxCommonMixin2.prototype.getBaseAxis = function() {
    var dim = this._baseAxisDim;
    return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
  };
  return WhiskerBoxCommonMixin2;
}();
var BoxplotSeriesModel = function(_super) {
  __extends$1(BoxplotSeriesModel2, _super);
  function BoxplotSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BoxplotSeriesModel2.type;
    _this.defaultValueDimensions = [{
      name: "min",
      defaultTooltip: true
    }, {
      name: "Q1",
      defaultTooltip: true
    }, {
      name: "median",
      defaultTooltip: true
    }, {
      name: "Q3",
      defaultTooltip: true
    }, {
      name: "max",
      defaultTooltip: true
    }];
    _this.visualDrawType = "stroke";
    return _this;
  }
  BoxplotSeriesModel2.type = "series.boxplot";
  BoxplotSeriesModel2.dependencies = ["xAxis", "yAxis", "grid"];
  BoxplotSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    layout: null,
    boxWidth: [7, 50],
    itemStyle: {
      color: "#fff",
      borderWidth: 1
    },
    emphasis: {
      scale: true,
      itemStyle: {
        borderWidth: 2,
        shadowBlur: 5,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    },
    animationDuration: 800
  };
  return BoxplotSeriesModel2;
}(SeriesModel$1);
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);
var BoxplotSeriesModel$1 = BoxplotSeriesModel;
var BoxplotView = function(_super) {
  __extends$1(BoxplotView2, _super);
  function BoxplotView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BoxplotView2.type;
    return _this;
  }
  BoxplotView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var group = this.group;
    var oldData = this._data;
    if (!this._data) {
      group.removeAll();
    }
    var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        var itemLayout = data.getItemLayout(newIdx);
        var symbolEl = createNormalBox$1(itemLayout, data, newIdx, constDim, true);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(symbolEl);
        return;
      }
      var itemLayout = data.getItemLayout(newIdx);
      if (!symbolEl) {
        symbolEl = createNormalBox$1(itemLayout, data, newIdx, constDim);
      } else {
        saveOldStyle(symbolEl);
        updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };
  BoxplotView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var data = this._data;
    this._data = null;
    data && data.eachItemGraphicEl(function(el) {
      el && group.remove(el);
    });
  };
  BoxplotView2.type = "boxplot";
  return BoxplotView2;
}(ChartView$1);
var BoxPathShape = function() {
  function BoxPathShape2() {
  }
  return BoxPathShape2;
}();
var BoxPath = function(_super) {
  __extends$1(BoxPath2, _super);
  function BoxPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "boxplotBoxPath";
    return _this;
  }
  BoxPath2.prototype.getDefaultShape = function() {
    return new BoxPathShape();
  };
  BoxPath2.prototype.buildPath = function(ctx, shape) {
    var ends = shape.points;
    var i = 0;
    ctx.moveTo(ends[i][0], ends[i][1]);
    i++;
    for (; i < 4; i++) {
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
    ctx.closePath();
    for (; i < ends.length; i++) {
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
  };
  return BoxPath2;
}(Path$1);
function createNormalBox$1(itemLayout, data, dataIndex, constDim, isInit) {
  var ends = itemLayout.ends;
  var el = new BoxPath({
    shape: {
      points: isInit ? transInit$1(ends, constDim, itemLayout) : ends
    }
  });
  updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
  return el;
}
function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
  var seriesModel = data.hostModel;
  var updateMethod = graphic[isInit ? "initProps" : "updateProps"];
  updateMethod(el, {
    shape: {
      points: itemLayout.ends
    }
  }, seriesModel, dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.z2 = 100;
  var itemModel = data.getItemModel(dataIndex);
  var emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit$1(points2, dim, itemLayout) {
  return map$1(points2, function(point4) {
    point4 = point4.slice();
    point4[dim] = itemLayout.initBaseline;
    return point4;
  });
}
var BoxplotView$1 = BoxplotView;
function boxplotVisual(ecModel, api) {
}
var each$9 = each$f;
function boxplotLayout(ecModel) {
  var groupResult = groupSeriesByAxis(ecModel);
  each$9(groupResult, function(groupItem) {
    var seriesModels = groupItem.seriesModels;
    if (!seriesModels.length) {
      return;
    }
    calculateBase(groupItem);
    each$9(seriesModels, function(seriesModel, idx) {
      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
    });
  });
}
function groupSeriesByAxis(ecModel) {
  var result = [];
  var axisList = [];
  ecModel.eachSeriesByType("boxplot", function(seriesModel) {
    var baseAxis = seriesModel.getBaseAxis();
    var idx = indexOf2(axisList, baseAxis);
    if (idx < 0) {
      idx = axisList.length;
      axisList[idx] = baseAxis;
      result[idx] = {
        axis: baseAxis,
        seriesModels: []
      };
    }
    result[idx].seriesModels.push(seriesModel);
  });
  return result;
}
function calculateBase(groupItem) {
  var baseAxis = groupItem.axis;
  var seriesModels = groupItem.seriesModels;
  var seriesCount = seriesModels.length;
  var boxWidthList = groupItem.boxWidthList = [];
  var boxOffsetList = groupItem.boxOffsetList = [];
  var boundList = [];
  var bandWidth;
  if (baseAxis.type === "category") {
    bandWidth = baseAxis.getBandWidth();
  } else {
    var maxDataCount_1 = 0;
    each$9(seriesModels, function(seriesModel) {
      maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());
    });
    var extent3 = baseAxis.getExtent();
    bandWidth = Math.abs(extent3[1] - extent3[0]) / maxDataCount_1;
  }
  each$9(seriesModels, function(seriesModel) {
    var boxWidthBound = seriesModel.get("boxWidth");
    if (!isArray$1(boxWidthBound)) {
      boxWidthBound = [boxWidthBound, boxWidthBound];
    }
    boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);
  });
  var availableWidth = bandWidth * 0.8 - 2;
  var boxGap = availableWidth / seriesCount * 0.3;
  var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
  var base2 = boxWidth / 2 - availableWidth / 2;
  each$9(seriesModels, function(seriesModel, idx) {
    boxOffsetList.push(base2);
    base2 += boxGap + boxWidth;
    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
  });
}
function layoutSingleSeries(seriesModel, offset, boxWidth) {
  var coordSys = seriesModel.coordinateSystem;
  var data = seriesModel.getData();
  var halfWidth = boxWidth / 2;
  var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
  var vDimIdx = 1 - cDimIdx;
  var coordDims = ["x", "y"];
  var cDim = data.mapDimension(coordDims[cDimIdx]);
  var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
  if (cDim == null || vDims.length < 5) {
    return;
  }
  for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
    var axisDimVal = data.get(cDim, dataIndex);
    var median = getPoint(axisDimVal, vDims[2], dataIndex);
    var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
    var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
    var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
    var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
    var ends = [];
    addBodyEnd(ends, end2, false);
    addBodyEnd(ends, end4, true);
    ends.push(end1, end2, end5, end4);
    layEndLine(ends, end1);
    layEndLine(ends, end5);
    layEndLine(ends, median);
    data.setItemLayout(dataIndex, {
      initBaseline: median[vDimIdx],
      ends
    });
  }
  function getPoint(axisDimVal2, dim, dataIndex2) {
    var val = data.get(dim, dataIndex2);
    var p = [];
    p[cDimIdx] = axisDimVal2;
    p[vDimIdx] = val;
    var point4;
    if (isNaN(axisDimVal2) || isNaN(val)) {
      point4 = [NaN, NaN];
    } else {
      point4 = coordSys.dataToPoint(p);
      point4[cDimIdx] += offset;
    }
    return point4;
  }
  function addBodyEnd(ends2, point4, start2) {
    var point1 = point4.slice();
    var point22 = point4.slice();
    point1[cDimIdx] += halfWidth;
    point22[cDimIdx] -= halfWidth;
    start2 ? ends2.push(point1, point22) : ends2.push(point22, point1);
  }
  function layEndLine(ends2, endCenter) {
    var from = endCenter.slice();
    var to = endCenter.slice();
    from[cDimIdx] -= halfWidth;
    to[cDimIdx] += halfWidth;
    ends2.push(from, to);
  }
}
function prepareBoxplotData(rawData, opt) {
  opt = opt || {};
  var boxData = [];
  var outliers = [];
  var boundIQR = opt.boundIQR;
  var useExtreme = boundIQR === "none" || boundIQR === 0;
  for (var i = 0; i < rawData.length; i++) {
    var ascList = asc$2(rawData[i].slice());
    var Q1 = quantile(ascList, 0.25);
    var Q2 = quantile(ascList, 0.5);
    var Q3 = quantile(ascList, 0.75);
    var min5 = ascList[0];
    var max4 = ascList[ascList.length - 1];
    var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
    var low = useExtreme ? min5 : Math.max(min5, Q1 - bound);
    var high = useExtreme ? max4 : Math.min(max4, Q3 + bound);
    var itemNameFormatter = opt.itemNameFormatter;
    var itemName = isFunction(itemNameFormatter) ? itemNameFormatter({
      value: i
    }) : isString(itemNameFormatter) ? itemNameFormatter.replace("{value}", i + "") : i + "";
    boxData.push([itemName, low, Q1, Q2, Q3, high]);
    for (var j = 0; j < ascList.length; j++) {
      var dataItem = ascList[j];
      if (dataItem < low || dataItem > high) {
        var outlier = [itemName, dataItem];
        outliers.push(outlier);
      }
    }
  }
  return {
    boxData,
    outliers
  };
}
var boxplotTransform = {
  type: "echarts:boxplot",
  transform: function transform3(params) {
    var upstream = params.upstream;
    if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      var errMsg = "";
      {
        errMsg = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].");
      }
      throwError(errMsg);
    }
    var result = prepareBoxplotData(upstream.getRawData(), params.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: result.boxData
    }, {
      data: result.outliers
    }];
  }
};
function install$z(registers) {
  registers.registerSeriesModel(BoxplotSeriesModel$1);
  registers.registerChartView(BoxplotView$1);
  registers.registerVisual(boxplotVisual);
  registers.registerLayout(boxplotLayout);
  registers.registerTransform(boxplotTransform);
}
var SKIP_PROPS = ["color", "borderColor"];
var CandlestickView = function(_super) {
  __extends$1(CandlestickView2, _super);
  function CandlestickView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CandlestickView2.type;
    return _this;
  }
  CandlestickView2.prototype.render = function(seriesModel, ecModel, api) {
    this.group.removeClipPath();
    this._progressiveEls = null;
    this._updateDrawMode(seriesModel);
    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
  };
  CandlestickView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    this._clear();
    this._updateDrawMode(seriesModel);
  };
  CandlestickView2.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
    this._progressiveEls = [];
    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
  };
  CandlestickView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  CandlestickView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  CandlestickView2.prototype._renderNormal = function(seriesModel) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var isSimpleBox = data.getLayout("isSimpleBox");
    var needsClip = seriesModel.get("clip", true);
    var coord = seriesModel.coordinateSystem;
    var clipArea = coord.getArea && coord.getArea();
    if (!this._data) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        var itemLayout = data.getItemLayout(newIdx);
        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          return;
        }
        var el = createNormalBox(itemLayout, newIdx, true);
        initProps(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }
    }).update(function(newIdx, oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(el);
        return;
      }
      var itemLayout = data.getItemLayout(newIdx);
      if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
        group.remove(el);
        return;
      }
      if (!el) {
        el = createNormalBox(itemLayout);
      } else {
        updateProps$1(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        saveOldStyle(el);
      }
      setBoxCommon(el, data, newIdx, isSimpleBox);
      group.add(el);
      data.setItemGraphicEl(newIdx, el);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };
  CandlestickView2.prototype._renderLarge = function(seriesModel) {
    this._clear();
    createLarge(seriesModel, this.group);
    var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
  };
  CandlestickView2.prototype._incrementalRenderNormal = function(params, seriesModel) {
    var data = seriesModel.getData();
    var isSimpleBox = data.getLayout("isSimpleBox");
    var dataIndex;
    while ((dataIndex = params.next()) != null) {
      var itemLayout = data.getItemLayout(dataIndex);
      var el = createNormalBox(itemLayout);
      setBoxCommon(el, data, dataIndex, isSimpleBox);
      el.incremental = true;
      this.group.add(el);
      this._progressiveEls.push(el);
    }
  };
  CandlestickView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  };
  CandlestickView2.prototype.remove = function(ecModel) {
    this._clear();
  };
  CandlestickView2.prototype._clear = function() {
    this.group.removeAll();
    this._data = null;
  };
  CandlestickView2.type = "candlestick";
  return CandlestickView2;
}(ChartView$1);
var NormalBoxPathShape = function() {
  function NormalBoxPathShape2() {
  }
  return NormalBoxPathShape2;
}();
var NormalBoxPath = function(_super) {
  __extends$1(NormalBoxPath2, _super);
  function NormalBoxPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "normalCandlestickBox";
    return _this;
  }
  NormalBoxPath2.prototype.getDefaultShape = function() {
    return new NormalBoxPathShape();
  };
  NormalBoxPath2.prototype.buildPath = function(ctx, shape) {
    var ends = shape.points;
    if (this.__simpleBox) {
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[6][0], ends[6][1]);
    } else {
      ctx.moveTo(ends[0][0], ends[0][1]);
      ctx.lineTo(ends[1][0], ends[1][1]);
      ctx.lineTo(ends[2][0], ends[2][1]);
      ctx.lineTo(ends[3][0], ends[3][1]);
      ctx.closePath();
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[5][0], ends[5][1]);
      ctx.moveTo(ends[6][0], ends[6][1]);
      ctx.lineTo(ends[7][0], ends[7][1]);
    }
  };
  return NormalBoxPath2;
}(Path$1);
function createNormalBox(itemLayout, dataIndex, isInit) {
  var ends = itemLayout.ends;
  return new NormalBoxPath({
    shape: {
      points: isInit ? transInit(ends, itemLayout) : ends
    },
    z2: 100
  });
}
function isNormalBoxClipped(clipArea, itemLayout) {
  var clipped = true;
  for (var i = 0; i < itemLayout.ends.length; i++) {
    if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
      clipped = false;
      break;
    }
  }
  return clipped;
}
function setBoxCommon(el, data, dataIndex, isSimpleBox) {
  var itemModel = data.getItemModel(dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.__simpleBox = isSimpleBox;
  setStatesStylesFromModel(el, itemModel);
}
function transInit(points2, itemLayout) {
  return map$1(points2, function(point4) {
    point4 = point4.slice();
    point4[1] = itemLayout.initBaseline;
    return point4;
  });
}
var LargeBoxPathShape = function() {
  function LargeBoxPathShape2() {
  }
  return LargeBoxPathShape2;
}();
var LargeBoxPath = function(_super) {
  __extends$1(LargeBoxPath2, _super);
  function LargeBoxPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeCandlestickBox";
    return _this;
  }
  LargeBoxPath2.prototype.getDefaultShape = function() {
    return new LargeBoxPathShape();
  };
  LargeBoxPath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    for (var i = 0; i < points2.length; ) {
      if (this.__sign === points2[i++]) {
        var x2 = points2[i++];
        ctx.moveTo(x2, points2[i++]);
        ctx.lineTo(x2, points2[i++]);
      } else {
        i += 3;
      }
    }
  };
  return LargeBoxPath2;
}(Path$1);
function createLarge(seriesModel, group, progressiveEls, incremental) {
  var data = seriesModel.getData();
  var largePoints = data.getLayout("largePoints");
  var elP = new LargeBoxPath({
    shape: {
      points: largePoints
    },
    __sign: 1,
    ignoreCoarsePointer: true
  });
  group.add(elP);
  var elN = new LargeBoxPath({
    shape: {
      points: largePoints
    },
    __sign: -1,
    ignoreCoarsePointer: true
  });
  group.add(elN);
  setLargeStyle(1, elP, seriesModel);
  setLargeStyle(-1, elN, seriesModel);
  if (incremental) {
    elP.incremental = true;
    elN.incremental = true;
  }
  if (progressiveEls) {
    progressiveEls.push(elP, elN);
  }
}
function setLargeStyle(sign2, el, seriesModel, data) {
  var borderColor = seriesModel.get(["itemStyle", sign2 > 0 ? "borderColor" : "borderColor0"]) || seriesModel.get(["itemStyle", sign2 > 0 ? "color" : "color0"]);
  var itemStyle = seriesModel.getModel("itemStyle").getItemStyle(SKIP_PROPS);
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
}
var CandlestickView$1 = CandlestickView;
var CandlestickSeriesModel = function(_super) {
  __extends$1(CandlestickSeriesModel2, _super);
  function CandlestickSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CandlestickSeriesModel2.type;
    _this.defaultValueDimensions = [{
      name: "open",
      defaultTooltip: true
    }, {
      name: "close",
      defaultTooltip: true
    }, {
      name: "lowest",
      defaultTooltip: true
    }, {
      name: "highest",
      defaultTooltip: true
    }];
    return _this;
  }
  CandlestickSeriesModel2.prototype.getShadowDim = function() {
    return "open";
  };
  CandlestickSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    var itemLayout = data.getItemLayout(dataIndex);
    return itemLayout && selectors.rect(itemLayout.brushRect);
  };
  CandlestickSeriesModel2.type = "series.candlestick";
  CandlestickSeriesModel2.dependencies = ["xAxis", "yAxis", "grid"];
  CandlestickSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    layout: null,
    clip: true,
    itemStyle: {
      color: "#eb5454",
      color0: "#47b262",
      borderColor: "#eb5454",
      borderColor0: "#47b262",
      borderWidth: 1
    },
    emphasis: {
      scale: true,
      itemStyle: {
        borderWidth: 2
      }
    },
    barMaxWidth: null,
    barMinWidth: null,
    barWidth: null,
    large: true,
    largeThreshold: 600,
    progressive: 3e3,
    progressiveThreshold: 1e4,
    progressiveChunkMode: "mod",
    animationEasing: "linear",
    animationDuration: 300
  };
  return CandlestickSeriesModel2;
}(SeriesModel$1);
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);
var CandlestickSeriesModel$1 = CandlestickSeriesModel;
function candlestickPreprocessor(option) {
  if (!option || !isArray$1(option.series)) {
    return;
  }
  each$f(option.series, function(seriesItem) {
    if (isObject$3(seriesItem) && seriesItem.type === "k") {
      seriesItem.type = "candlestick";
    }
  });
}
var positiveBorderColorQuery = ["itemStyle", "borderColor"];
var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
var positiveColorQuery = ["itemStyle", "color"];
var negativeColorQuery = ["itemStyle", "color0"];
var candlestickVisual = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    function getColor(sign2, model) {
      return model.get(sign2 > 0 ? positiveColorQuery : negativeColorQuery);
    }
    function getBorderColor(sign2, model) {
      return model.get(sign2 > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var isLargeRender = seriesModel.pipelineContext.large;
    return !isLargeRender && {
      progress: function(params, data) {
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var itemModel = data.getItemModel(dataIndex);
          var sign2 = data.getItemLayout(dataIndex).sign;
          var style = itemModel.getItemStyle();
          style.fill = getColor(sign2, itemModel);
          style.stroke = getBorderColor(sign2, itemModel) || style.fill;
          var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          extend2(existsStyle, style);
        }
      }
    };
  }
};
var candlestickVisual$1 = candlestickVisual;
var candlestickLayout = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    var candleWidth = calculateCandleWidth(seriesModel, data);
    var cDimIdx = 0;
    var vDimIdx = 1;
    var coordDims = ["x", "y"];
    var cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));
    var vDimsI = map$1(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);
    var openDimI = vDimsI[0];
    var closeDimI = vDimsI[1];
    var lowestDimI = vDimsI[2];
    var highestDimI = vDimsI[3];
    data.setLayout({
      candleWidth,
      isSimpleBox: candleWidth <= 1.3
    });
    if (cDimI < 0 || vDimsI.length < 4) {
      return;
    }
    return {
      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
    };
    function normalProgress(params, data2) {
      var dataIndex;
      var store = data2.getStore();
      while ((dataIndex = params.next()) != null) {
        var axisDimVal = store.get(cDimI, dataIndex);
        var openVal = store.get(openDimI, dataIndex);
        var closeVal = store.get(closeDimI, dataIndex);
        var lowestVal = store.get(lowestDimI, dataIndex);
        var highestVal = store.get(highestDimI, dataIndex);
        var ocLow = Math.min(openVal, closeVal);
        var ocHigh = Math.max(openVal, closeVal);
        var ocLowPoint = getPoint(ocLow, axisDimVal);
        var ocHighPoint = getPoint(ocHigh, axisDimVal);
        var lowestPoint = getPoint(lowestVal, axisDimVal);
        var highestPoint = getPoint(highestVal, axisDimVal);
        var ends = [];
        addBodyEnd(ends, ocHighPoint, 0);
        addBodyEnd(ends, ocLowPoint, 1);
        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
        data2.setItemLayout(dataIndex, {
          sign: getSign(store, dataIndex, openVal, closeVal, closeDimI),
          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
          ends,
          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
        });
      }
      function getPoint(val, axisDimVal2) {
        var p = [];
        p[cDimIdx] = axisDimVal2;
        p[vDimIdx] = val;
        return isNaN(axisDimVal2) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
      }
      function addBodyEnd(ends2, point4, start2) {
        var point1 = point4.slice();
        var point22 = point4.slice();
        point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);
        point22[cDimIdx] = subPixelOptimize(point22[cDimIdx] - candleWidth / 2, 1, true);
        start2 ? ends2.push(point1, point22) : ends2.push(point22, point1);
      }
      function makeBrushRect(lowestVal2, highestVal2, axisDimVal2) {
        var pmin = getPoint(lowestVal2, axisDimVal2);
        var pmax = getPoint(highestVal2, axisDimVal2);
        pmin[cDimIdx] -= candleWidth / 2;
        pmax[cDimIdx] -= candleWidth / 2;
        return {
          x: pmin[0],
          y: pmin[1],
          width: candleWidth,
          height: pmax[1] - pmin[1]
        };
      }
      function subPixelOptimizePoint(point4) {
        point4[cDimIdx] = subPixelOptimize(point4[cDimIdx], 1);
        return point4;
      }
    }
    function largeProgress(params, data2) {
      var points2 = createFloat32Array(params.count * 4);
      var offset = 0;
      var point4;
      var tmpIn = [];
      var tmpOut = [];
      var dataIndex;
      var store = data2.getStore();
      while ((dataIndex = params.next()) != null) {
        var axisDimVal = store.get(cDimI, dataIndex);
        var openVal = store.get(openDimI, dataIndex);
        var closeVal = store.get(closeDimI, dataIndex);
        var lowestVal = store.get(lowestDimI, dataIndex);
        var highestVal = store.get(highestDimI, dataIndex);
        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
          points2[offset++] = NaN;
          offset += 3;
          continue;
        }
        points2[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI);
        tmpIn[cDimIdx] = axisDimVal;
        tmpIn[vDimIdx] = lowestVal;
        point4 = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points2[offset++] = point4 ? point4[0] : NaN;
        points2[offset++] = point4 ? point4[1] : NaN;
        tmpIn[vDimIdx] = highestVal;
        point4 = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points2[offset++] = point4 ? point4[1] : NaN;
      }
      data2.setLayout("largePoints", points2);
    }
  }
};
function getSign(store, dataIndex, openVal, closeVal, closeDimI) {
  var sign2;
  if (openVal > closeVal) {
    sign2 = -1;
  } else if (openVal < closeVal) {
    sign2 = 1;
  } else {
    sign2 = dataIndex > 0 ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
  }
  return sign2;
}
function calculateCandleWidth(seriesModel, data) {
  var baseAxis = seriesModel.getBaseAxis();
  var extent3;
  var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent3 = baseAxis.getExtent(), Math.abs(extent3[1] - extent3[0]) / data.count());
  var barMaxWidth = parsePercent(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
  var barMinWidth = parsePercent(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
  var barWidth = seriesModel.get("barWidth");
  return barWidth != null ? parsePercent(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
}
var candlestickLayout$1 = candlestickLayout;
function install$y(registers) {
  registers.registerChartView(CandlestickView$1);
  registers.registerSeriesModel(CandlestickSeriesModel$1);
  registers.registerPreprocessor(candlestickPreprocessor);
  registers.registerVisual(candlestickVisual$1);
  registers.registerLayout(candlestickLayout$1);
}
function updateRipplePath(rippleGroup, effectCfg) {
  var color = effectCfg.rippleEffectColor || effectCfg.color;
  rippleGroup.eachChild(function(ripplePath) {
    ripplePath.attr({
      z: effectCfg.z,
      zlevel: effectCfg.zlevel,
      style: {
        stroke: effectCfg.brushType === "stroke" ? color : null,
        fill: effectCfg.brushType === "fill" ? color : null
      }
    });
  });
}
var EffectSymbol = function(_super) {
  __extends$1(EffectSymbol2, _super);
  function EffectSymbol2(data, idx) {
    var _this = _super.call(this) || this;
    var symbol = new SymbolClz(data, idx);
    var rippleGroup = new Group$4();
    _this.add(symbol);
    _this.add(rippleGroup);
    _this.updateData(data, idx);
    return _this;
  }
  EffectSymbol2.prototype.stopEffectAnimation = function() {
    this.childAt(1).removeAll();
  };
  EffectSymbol2.prototype.startEffectAnimation = function(effectCfg) {
    var symbolType = effectCfg.symbolType;
    var color = effectCfg.color;
    var rippleNumber = effectCfg.rippleNumber;
    var rippleGroup = this.childAt(1);
    for (var i = 0; i < rippleNumber; i++) {
      var ripplePath = createSymbol$1(symbolType, -1, -1, 2, 2, color);
      ripplePath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 99,
        silent: true,
        scaleX: 0.5,
        scaleY: 0.5
      });
      var delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset;
      ripplePath.animate("", true).when(effectCfg.period, {
        scaleX: effectCfg.rippleScale / 2,
        scaleY: effectCfg.rippleScale / 2
      }).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {
        opacity: 0
      }).delay(delay).start();
      rippleGroup.add(ripplePath);
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  EffectSymbol2.prototype.updateEffectAnimation = function(effectCfg) {
    var oldEffectCfg = this._effectCfg;
    var rippleGroup = this.childAt(1);
    var DIFFICULT_PROPS = ["symbolType", "period", "rippleScale", "rippleNumber"];
    for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
      var propName = DIFFICULT_PROPS[i];
      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  EffectSymbol2.prototype.highlight = function() {
    enterEmphasis(this);
  };
  EffectSymbol2.prototype.downplay = function() {
    leaveEmphasis(this);
  };
  EffectSymbol2.prototype.getSymbolType = function() {
    var symbol = this.childAt(0);
    return symbol && symbol.getSymbolType();
  };
  EffectSymbol2.prototype.updateData = function(data, idx) {
    var _this = this;
    var seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    var rippleGroup = this.childAt(1);
    var itemModel = data.getItemModel(idx);
    var symbolType = data.getItemVisual(idx, "symbol");
    var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
    var symbolStyle = data.getItemVisual(idx, "style");
    var color = symbolStyle && symbolStyle.fill;
    var emphasisModel = itemModel.getModel("emphasis");
    rippleGroup.setScale(symbolSize);
    rippleGroup.traverse(function(ripplePath) {
      ripplePath.setStyle("fill", color);
    });
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      rippleGroup.x = symbolOffset[0];
      rippleGroup.y = symbolOffset[1];
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    var effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get("showEffectOn");
    effectCfg.rippleScale = itemModel.get(["rippleEffect", "scale"]);
    effectCfg.brushType = itemModel.get(["rippleEffect", "brushType"]);
    effectCfg.period = itemModel.get(["rippleEffect", "period"]) * 1e3;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = seriesModel.getShallow("z") || 0;
    effectCfg.zlevel = seriesModel.getShallow("zlevel") || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color;
    effectCfg.rippleEffectColor = itemModel.get(["rippleEffect", "color"]);
    effectCfg.rippleNumber = itemModel.get(["rippleEffect", "number"]);
    if (effectCfg.showEffectOn === "render") {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      this._effectCfg = null;
      this.stopEffectAnimation();
      this.onHoverStateChange = function(toState) {
        if (toState === "emphasis") {
          if (effectCfg.showEffectOn !== "render") {
            _this.startEffectAnimation(effectCfg);
          }
        } else if (toState === "normal") {
          if (effectCfg.showEffectOn !== "render") {
            _this.stopEffectAnimation();
          }
        }
      };
    }
    this._effectCfg = effectCfg;
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  EffectSymbol2.prototype.fadeOut = function(cb) {
    cb && cb();
  };
  return EffectSymbol2;
}(Group$4);
var EffectSymbol$1 = EffectSymbol;
var EffectScatterView = function(_super) {
  __extends$1(EffectScatterView2, _super);
  function EffectScatterView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = EffectScatterView2.type;
    return _this;
  }
  EffectScatterView2.prototype.init = function() {
    this._symbolDraw = new SymbolDraw$1(EffectSymbol$1);
  };
  EffectScatterView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var effectSymbolDraw = this._symbolDraw;
    effectSymbolDraw.updateData(data, {
      clipShape: this._getClipShape(seriesModel)
    });
    this.group.add(effectSymbolDraw.group);
  };
  EffectScatterView2.prototype._getClipShape = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get("clip", true) ? clipArea : null;
  };
  EffectScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    this.group.dirty();
    var res = pointsLayout("").reset(seriesModel, ecModel, api);
    if (res.progress) {
      res.progress({
        start: 0,
        end: data.count(),
        count: data.count()
      }, data);
    }
    this._symbolDraw.updateLayout();
  };
  EffectScatterView2.prototype._updateGroupTransform = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.getRoamTransform) {
      this.group.transform = clone$2(coordSys.getRoamTransform());
      this.group.decomposeTransform();
    }
  };
  EffectScatterView2.prototype.remove = function(ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove(true);
  };
  EffectScatterView2.type = "effectScatter";
  return EffectScatterView2;
}(ChartView$1);
var EffectScatterView$1 = EffectScatterView;
var EffectScatterSeriesModel = function(_super) {
  __extends$1(EffectScatterSeriesModel2, _super);
  function EffectScatterSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = EffectScatterSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  EffectScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  EffectScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  };
  EffectScatterSeriesModel2.type = "series.effectScatter";
  EffectScatterSeriesModel2.dependencies = ["grid", "polar"];
  EffectScatterSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    legendHoverLink: true,
    effectType: "ripple",
    progressive: 0,
    showEffectOn: "render",
    clip: true,
    rippleEffect: {
      period: 4,
      scale: 2.5,
      brushType: "fill",
      number: 3
    },
    universalTransition: {
      divideShape: "clone"
    },
    symbolSize: 10
  };
  return EffectScatterSeriesModel2;
}(SeriesModel$1);
var EffectScatterSeriesModel$1 = EffectScatterSeriesModel;
function install$x(registers) {
  registers.registerChartView(EffectScatterView$1);
  registers.registerSeriesModel(EffectScatterSeriesModel$1);
  registers.registerLayout(pointsLayout("effectScatter"));
}
var EffectLine = function(_super) {
  __extends$1(EffectLine2, _super);
  function EffectLine2(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;
    _this.add(_this.createLine(lineData, idx, seriesScope));
    _this._updateEffectSymbol(lineData, idx);
    return _this;
  }
  EffectLine2.prototype.createLine = function(lineData, idx, seriesScope) {
    return new Line$1(lineData, idx, seriesScope);
  };
  EffectLine2.prototype._updateEffectSymbol = function(lineData, idx) {
    var itemModel = lineData.getItemModel(idx);
    var effectModel = itemModel.getModel("effect");
    var size11 = effectModel.get("symbolSize");
    var symbolType = effectModel.get("symbol");
    if (!isArray$1(size11)) {
      size11 = [size11, size11];
    }
    var lineStyle = lineData.getItemVisual(idx, "style");
    var color = effectModel.get("color") || lineStyle && lineStyle.stroke;
    var symbol = this.childAt(1);
    if (this._symbolType !== symbolType) {
      this.remove(symbol);
      symbol = createSymbol$1(symbolType, -0.5, -0.5, 1, 1, color);
      symbol.z2 = 100;
      symbol.culling = true;
      this.add(symbol);
    }
    if (!symbol) {
      return;
    }
    symbol.setStyle("shadowColor", color);
    symbol.setStyle(effectModel.getItemStyle(["color"]));
    symbol.scaleX = size11[0];
    symbol.scaleY = size11[1];
    symbol.setColor(color);
    this._symbolType = symbolType;
    this._symbolScale = size11;
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  EffectLine2.prototype._updateEffectAnimation = function(lineData, effectModel, idx) {
    var symbol = this.childAt(1);
    if (!symbol) {
      return;
    }
    var points2 = lineData.getItemLayout(idx);
    var period = effectModel.get("period") * 1e3;
    var loop = effectModel.get("loop");
    var roundTrip = effectModel.get("roundTrip");
    var constantSpeed = effectModel.get("constantSpeed");
    var delayExpr = retrieve(effectModel.get("delay"), function(idx2) {
      return idx2 / lineData.count() * period / 3;
    });
    symbol.ignore = true;
    this._updateAnimationPoints(symbol, points2);
    if (constantSpeed > 0) {
      period = this._getLineLength(symbol) / constantSpeed * 1e3;
    }
    if (period !== this._period || loop !== this._loop || roundTrip !== this._roundTrip) {
      symbol.stopAnimation();
      var delayNum = void 0;
      if (isFunction(delayExpr)) {
        delayNum = delayExpr(idx);
      } else {
        delayNum = delayExpr;
      }
      if (symbol.__t > 0) {
        delayNum = -period * symbol.__t;
      }
      this._animateSymbol(symbol, period, delayNum, loop, roundTrip);
    }
    this._period = period;
    this._loop = loop;
    this._roundTrip = roundTrip;
  };
  EffectLine2.prototype._animateSymbol = function(symbol, period, delayNum, loop, roundTrip) {
    if (period > 0) {
      symbol.__t = 0;
      var self_1 = this;
      var animator = symbol.animate("", loop).when(roundTrip ? period * 2 : period, {
        __t: roundTrip ? 2 : 1
      }).delay(delayNum).during(function() {
        self_1._updateSymbolPosition(symbol);
      });
      if (!loop) {
        animator.done(function() {
          self_1.remove(symbol);
        });
      }
      animator.start();
    }
  };
  EffectLine2.prototype._getLineLength = function(symbol) {
    return dist$1(symbol.__p1, symbol.__cp1) + dist$1(symbol.__cp1, symbol.__p2);
  };
  EffectLine2.prototype._updateAnimationPoints = function(symbol, points2) {
    symbol.__p1 = points2[0];
    symbol.__p2 = points2[1];
    symbol.__cp1 = points2[2] || [(points2[0][0] + points2[1][0]) / 2, (points2[0][1] + points2[1][1]) / 2];
  };
  EffectLine2.prototype.updateData = function(lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);
    this._updateEffectSymbol(lineData, idx);
  };
  EffectLine2.prototype._updateSymbolPosition = function(symbol) {
    var p1 = symbol.__p1;
    var p2 = symbol.__p2;
    var cp1 = symbol.__cp1;
    var t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
    var pos = [symbol.x, symbol.y];
    var lastPos = pos.slice();
    var quadraticAt2 = quadraticAt$1;
    var quadraticDerivativeAt$1 = quadraticDerivativeAt;
    pos[0] = quadraticAt2(p1[0], cp1[0], p2[0], t);
    pos[1] = quadraticAt2(p1[1], cp1[1], p2[1], t);
    var tx = symbol.__t < 1 ? quadraticDerivativeAt$1(p1[0], cp1[0], p2[0], t) : quadraticDerivativeAt$1(p2[0], cp1[0], p1[0], 1 - t);
    var ty = symbol.__t < 1 ? quadraticDerivativeAt$1(p1[1], cp1[1], p2[1], t) : quadraticDerivativeAt$1(p2[1], cp1[1], p1[1], 1 - t);
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
      if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
        symbol.scaleY = dist$1(lastPos, pos) * 1.05;
        if (t === 1) {
          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
        }
      } else if (symbol.__lastT === 1) {
        symbol.scaleY = 2 * dist$1(p1, pos);
      } else {
        symbol.scaleY = this._symbolScale[1];
      }
    }
    symbol.__lastT = symbol.__t;
    symbol.ignore = false;
    symbol.x = pos[0];
    symbol.y = pos[1];
  };
  EffectLine2.prototype.updateLayout = function(lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    var effectModel = lineData.getItemModel(idx).getModel("effect");
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  return EffectLine2;
}(Group$4);
var EffectLine$1 = EffectLine;
var Polyline = function(_super) {
  __extends$1(Polyline2, _super);
  function Polyline2(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;
    _this._createPolyline(lineData, idx, seriesScope);
    return _this;
  }
  Polyline2.prototype._createPolyline = function(lineData, idx, seriesScope) {
    var points2 = lineData.getItemLayout(idx);
    var line = new Polyline$3({
      shape: {
        points: points2
      }
    });
    this.add(line);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Polyline2.prototype.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childAt(0);
    var target = {
      shape: {
        points: lineData.getItemLayout(idx)
      }
    };
    updateProps$1(line, target, seriesModel, idx);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Polyline2.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
    var line = this.childAt(0);
    var itemModel = lineData.getItemModel(idx);
    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    var focus = seriesScope && seriesScope.focus;
    var blurScope = seriesScope && seriesScope.blurScope;
    var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    if (!seriesScope || lineData.hasItemOption) {
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
    }
    line.useStyle(lineData.getItemVisual(idx, "style"));
    line.style.fill = null;
    line.style.strokeNoScale = true;
    var lineEmphasisState = line.ensureState("emphasis");
    lineEmphasisState.style = emphasisLineStyle;
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Polyline2.prototype.updateLayout = function(lineData, idx) {
    var polyline = this.childAt(0);
    polyline.setShape("points", lineData.getItemLayout(idx));
  };
  return Polyline2;
}(Group$4);
var Polyline$1 = Polyline;
var EffectPolyline = function(_super) {
  __extends$1(EffectPolyline2, _super);
  function EffectPolyline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._lastFrame = 0;
    _this._lastFramePercent = 0;
    return _this;
  }
  EffectPolyline2.prototype.createLine = function(lineData, idx, seriesScope) {
    return new Polyline$1(lineData, idx, seriesScope);
  };
  EffectPolyline2.prototype._updateAnimationPoints = function(symbol, points2) {
    this._points = points2;
    var accLenArr = [0];
    var len2 = 0;
    for (var i = 1; i < points2.length; i++) {
      var p1 = points2[i - 1];
      var p2 = points2[i];
      len2 += dist$1(p1, p2);
      accLenArr.push(len2);
    }
    if (len2 === 0) {
      this._length = 0;
      return;
    }
    for (var i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len2;
    }
    this._offsets = accLenArr;
    this._length = len2;
  };
  EffectPolyline2.prototype._getLineLength = function() {
    return this._length;
  };
  EffectPolyline2.prototype._updateSymbolPosition = function(symbol) {
    var t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
    var points2 = this._points;
    var offsets = this._offsets;
    var len2 = points2.length;
    if (!offsets) {
      return;
    }
    var lastFrame = this._lastFrame;
    var frame;
    if (t < this._lastFramePercent) {
      var start2 = Math.min(lastFrame + 1, len2 - 1);
      for (frame = start2; frame >= 0; frame--) {
        if (offsets[frame] <= t) {
          break;
        }
      }
      frame = Math.min(frame, len2 - 2);
    } else {
      for (frame = lastFrame; frame < len2; frame++) {
        if (offsets[frame] > t) {
          break;
        }
      }
      frame = Math.min(frame - 1, len2 - 2);
    }
    var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
    var p0 = points2[frame];
    var p1 = points2[frame + 1];
    symbol.x = p0[0] * (1 - p) + p * p1[0];
    symbol.y = p0[1] * (1 - p) + p * p1[1];
    var tx = symbol.__t < 1 ? p1[0] - p0[0] : p0[0] - p1[0];
    var ty = symbol.__t < 1 ? p1[1] - p0[1] : p0[1] - p1[1];
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    this._lastFrame = frame;
    this._lastFramePercent = t;
    symbol.ignore = false;
  };
  return EffectPolyline2;
}(EffectLine$1);
var EffectPolyline$1 = EffectPolyline;
var LargeLinesPathShape = function() {
  function LargeLinesPathShape2() {
    this.polyline = false;
    this.curveness = 0;
    this.segs = [];
  }
  return LargeLinesPathShape2;
}();
var LargeLinesPath = function(_super) {
  __extends$1(LargeLinesPath2, _super);
  function LargeLinesPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this._off = 0;
    _this.hoverDataIdx = -1;
    return _this;
  }
  LargeLinesPath2.prototype.reset = function() {
    this.notClear = false;
    this._off = 0;
  };
  LargeLinesPath2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  LargeLinesPath2.prototype.getDefaultShape = function() {
    return new LargeLinesPathShape();
  };
  LargeLinesPath2.prototype.buildPath = function(ctx, shape) {
    var segs = shape.segs;
    var curveness = shape.curveness;
    var i;
    if (shape.polyline) {
      for (i = this._off; i < segs.length; ) {
        var count3 = segs[i++];
        if (count3 > 0) {
          ctx.moveTo(segs[i++], segs[i++]);
          for (var k = 1; k < count3; k++) {
            ctx.lineTo(segs[i++], segs[i++]);
          }
        }
      }
    } else {
      for (i = this._off; i < segs.length; ) {
        var x02 = segs[i++];
        var y02 = segs[i++];
        var x12 = segs[i++];
        var y12 = segs[i++];
        ctx.moveTo(x02, y02);
        if (curveness > 0) {
          var x2 = (x02 + x12) / 2 - (y02 - y12) * curveness;
          var y2 = (y02 + y12) / 2 - (x12 - x02) * curveness;
          ctx.quadraticCurveTo(x2, y2, x12, y12);
        } else {
          ctx.lineTo(x12, y12);
        }
      }
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  };
  LargeLinesPath2.prototype.findDataIndex = function(x2, y2) {
    var shape = this.shape;
    var segs = shape.segs;
    var curveness = shape.curveness;
    var lineWidth = this.style.lineWidth;
    if (shape.polyline) {
      var dataIndex = 0;
      for (var i = 0; i < segs.length; ) {
        var count3 = segs[i++];
        if (count3 > 0) {
          var x02 = segs[i++];
          var y02 = segs[i++];
          for (var k = 1; k < count3; k++) {
            var x12 = segs[i++];
            var y12 = segs[i++];
            if (containStroke$4(x02, y02, x12, y12, lineWidth, x2, y2)) {
              return dataIndex;
            }
          }
        }
        dataIndex++;
      }
    } else {
      var dataIndex = 0;
      for (var i = 0; i < segs.length; ) {
        var x02 = segs[i++];
        var y02 = segs[i++];
        var x12 = segs[i++];
        var y12 = segs[i++];
        if (curveness > 0) {
          var x22 = (x02 + x12) / 2 - (y02 - y12) * curveness;
          var y22 = (y02 + y12) / 2 - (x12 - x02) * curveness;
          if (containStroke$2(x02, y02, x22, y22, x12, y12, lineWidth, x2, y2)) {
            return dataIndex;
          }
        } else {
          if (containStroke$4(x02, y02, x12, y12, lineWidth, x2, y2)) {
            return dataIndex;
          }
        }
        dataIndex++;
      }
    }
    return -1;
  };
  LargeLinesPath2.prototype.contain = function(x2, y2) {
    var localPos = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    x2 = localPos[0];
    y2 = localPos[1];
    if (rect.contain(x2, y2)) {
      var dataIdx = this.hoverDataIdx = this.findDataIndex(x2, y2);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  };
  LargeLinesPath2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    if (!rect) {
      var shape = this.shape;
      var points2 = shape.segs;
      var minX2 = Infinity;
      var minY2 = Infinity;
      var maxX2 = -Infinity;
      var maxY2 = -Infinity;
      for (var i = 0; i < points2.length; ) {
        var x2 = points2[i++];
        var y2 = points2[i++];
        minX2 = Math.min(x2, minX2);
        maxX2 = Math.max(x2, maxX2);
        minY2 = Math.min(y2, minY2);
        maxY2 = Math.max(y2, maxY2);
      }
      rect = this._rect = new BoundingRect$1(minX2, minY2, maxX2, maxY2);
    }
    return rect;
  };
  return LargeLinesPath2;
}(Path$1);
var LargeLineDraw = function() {
  function LargeLineDraw2() {
    this.group = new Group$4();
  }
  LargeLineDraw2.prototype.updateData = function(data) {
    this._clear();
    var lineEl = this._create();
    lineEl.setShape({
      segs: data.getLayout("linesPoints")
    });
    this._setCommon(lineEl, data);
  };
  LargeLineDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this.group.removeAll();
    this._clear();
  };
  LargeLineDraw2.prototype.incrementalUpdate = function(taskParams, data) {
    var lastAdded = this._newAdded[0];
    var linePoints = data.getLayout("linesPoints");
    var oldSegs = lastAdded && lastAdded.shape.segs;
    if (oldSegs && oldSegs.length < 2e4) {
      var oldLen = oldSegs.length;
      var newSegs = new Float32Array(oldLen + linePoints.length);
      newSegs.set(oldSegs);
      newSegs.set(linePoints, oldLen);
      lastAdded.setShape({
        segs: newSegs
      });
    } else {
      this._newAdded = [];
      var lineEl = this._create();
      lineEl.incremental = true;
      lineEl.setShape({
        segs: linePoints
      });
      this._setCommon(lineEl, data);
      lineEl.__startIndex = taskParams.start;
    }
  };
  LargeLineDraw2.prototype.remove = function() {
    this._clear();
  };
  LargeLineDraw2.prototype.eachRendered = function(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  };
  LargeLineDraw2.prototype._create = function() {
    var lineEl = new LargeLinesPath({
      cursor: "default",
      ignoreCoarsePointer: true
    });
    this._newAdded.push(lineEl);
    this.group.add(lineEl);
    return lineEl;
  };
  LargeLineDraw2.prototype._setCommon = function(lineEl, data, isIncremental) {
    var hostModel = data.hostModel;
    lineEl.setShape({
      polyline: hostModel.get("polyline"),
      curveness: hostModel.get(["lineStyle", "curveness"])
    });
    lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
    lineEl.style.strokeNoScale = true;
    var style = data.getVisual("style");
    if (style && style.stroke) {
      lineEl.setStyle("stroke", style.stroke);
    }
    lineEl.setStyle("fill", null);
    var ecData = getECData(lineEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    lineEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      var dataIndex = lineEl.hoverDataIdx;
      if (dataIndex > 0) {
        ecData.dataIndex = dataIndex + lineEl.__startIndex;
      }
    });
  };
  LargeLineDraw2.prototype._clear = function() {
    this._newAdded = [];
    this.group.removeAll();
  };
  return LargeLineDraw2;
}();
var LargeLineDraw$1 = LargeLineDraw;
var linesLayout = {
  seriesType: "lines",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      {
        error("The lines series must have a coordinate system.");
      }
      return;
    }
    var isPolyline = seriesModel.get("polyline");
    var isLarge = seriesModel.pipelineContext.large;
    return {
      progress: function(params, lineData) {
        var lineCoords = [];
        if (isLarge) {
          var points2 = void 0;
          var segCount = params.end - params.start;
          if (isPolyline) {
            var totalCoordsCount = 0;
            for (var i = params.start; i < params.end; i++) {
              totalCoordsCount += seriesModel.getLineCoordsCount(i);
            }
            points2 = new Float32Array(segCount + totalCoordsCount * 2);
          } else {
            points2 = new Float32Array(segCount * 4);
          }
          var offset = 0;
          var pt = [];
          for (var i = params.start; i < params.end; i++) {
            var len2 = seriesModel.getLineCoords(i, lineCoords);
            if (isPolyline) {
              points2[offset++] = len2;
            }
            for (var k = 0; k < len2; k++) {
              pt = coordSys.dataToPoint(lineCoords[k], false, pt);
              points2[offset++] = pt[0];
              points2[offset++] = pt[1];
            }
          }
          lineData.setLayout("linesPoints", points2);
        } else {
          for (var i = params.start; i < params.end; i++) {
            var itemModel = lineData.getItemModel(i);
            var len2 = seriesModel.getLineCoords(i, lineCoords);
            var pts = [];
            if (isPolyline) {
              for (var j = 0; j < len2; j++) {
                pts.push(coordSys.dataToPoint(lineCoords[j]));
              }
            } else {
              pts[0] = coordSys.dataToPoint(lineCoords[0]);
              pts[1] = coordSys.dataToPoint(lineCoords[1]);
              var curveness = itemModel.get(["lineStyle", "curveness"]);
              if (+curveness) {
                pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
              }
            }
            lineData.setItemLayout(i, pts);
          }
        }
      }
    };
  }
};
var linesLayout$1 = linesLayout;
var LinesView = function(_super) {
  __extends$1(LinesView2, _super);
  function LinesView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LinesView2.type;
    return _this;
  }
  LinesView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var lineDraw = this._updateLineDraw(data, seriesModel);
    var zlevel = seriesModel.get("zlevel");
    var trailLength = seriesModel.get(["effect", "trailLength"]);
    var zr = api.getZr();
    var isSvg = zr.painter.getType() === "svg";
    if (!isSvg) {
      zr.painter.getLayer(zlevel).clear(true);
    }
    if (this._lastZlevel != null && !isSvg) {
      zr.configLayer(this._lastZlevel, {
        motionBlur: false
      });
    }
    if (this._showEffect(seriesModel) && trailLength > 0) {
      if (!isSvg) {
        zr.configLayer(zlevel, {
          motionBlur: true,
          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
        });
      } else {
        console.warn("SVG render mode doesn't support lines with trail effect");
      }
    }
    lineDraw.updateData(data);
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
    this._lastZlevel = zlevel;
    this._finished = true;
  };
  LinesView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var lineDraw = this._updateLineDraw(data, seriesModel);
    lineDraw.incrementalPrepareUpdate(data);
    this._clearLayer(api);
    this._finished = false;
  };
  LinesView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
    this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
    this._finished = taskParams.end === seriesModel.getData().count();
  };
  LinesView2.prototype.eachRendered = function(cb) {
    this._lineDraw && this._lineDraw.eachRendered(cb);
  };
  LinesView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var pipelineContext = seriesModel.pipelineContext;
    if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
      return {
        update: true
      };
    } else {
      var res = linesLayout$1.reset(seriesModel, ecModel, api);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._lineDraw.updateLayout();
      this._clearLayer(api);
    }
  };
  LinesView2.prototype._updateLineDraw = function(data, seriesModel) {
    var lineDraw = this._lineDraw;
    var hasEffect = this._showEffect(seriesModel);
    var isPolyline = !!seriesModel.get("polyline");
    var pipelineContext = seriesModel.pipelineContext;
    var isLargeDraw = pipelineContext.large;
    {
      if (hasEffect && isLargeDraw) {
        console.warn("Large lines not support effect");
      }
    }
    if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
      if (lineDraw) {
        lineDraw.remove();
      }
      lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw$1() : new LineDraw$1(isPolyline ? hasEffect ? EffectPolyline$1 : Polyline$1 : hasEffect ? EffectLine$1 : Line$1);
      this._hasEffet = hasEffect;
      this._isPolyline = isPolyline;
      this._isLargeDraw = isLargeDraw;
    }
    this.group.add(lineDraw.group);
    return lineDraw;
  };
  LinesView2.prototype._showEffect = function(seriesModel) {
    return !!seriesModel.get(["effect", "show"]);
  };
  LinesView2.prototype._clearLayer = function(api) {
    var zr = api.getZr();
    var isSvg = zr.painter.getType() === "svg";
    if (!isSvg && this._lastZlevel != null) {
      zr.painter.getLayer(this._lastZlevel).clear(true);
    }
  };
  LinesView2.prototype.remove = function(ecModel, api) {
    this._lineDraw && this._lineDraw.remove();
    this._lineDraw = null;
    this._clearLayer(api);
  };
  LinesView2.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  LinesView2.type = "lines";
  return LinesView2;
}(ChartView$1);
var LinesView$1 = LinesView;
var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
function compatEc2(seriesOpt) {
  var data = seriesOpt.data;
  if (data && data[0] && data[0][0] && data[0][0].coord) {
    {
      console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }");
    }
    seriesOpt.data = map$1(data, function(itemOpt) {
      var coords = [itemOpt[0].coord, itemOpt[1].coord];
      var target = {
        coords
      };
      if (itemOpt[0].name) {
        target.fromName = itemOpt[0].name;
      }
      if (itemOpt[1].name) {
        target.toName = itemOpt[1].name;
      }
      return mergeAll([target, itemOpt[0], itemOpt[1]]);
    });
  }
}
var LinesSeriesModel = function(_super) {
  __extends$1(LinesSeriesModel2, _super);
  function LinesSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LinesSeriesModel2.type;
    _this.visualStyleAccessPath = "lineStyle";
    _this.visualDrawType = "stroke";
    return _this;
  }
  LinesSeriesModel2.prototype.init = function(option) {
    option.data = option.data || [];
    compatEc2(option);
    var result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    _super.prototype.init.apply(this, arguments);
  };
  LinesSeriesModel2.prototype.mergeOption = function(option) {
    compatEc2(option);
    if (option.data) {
      var result = this._processFlatCoordsArray(option.data);
      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;
      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
    }
    _super.prototype.mergeOption.apply(this, arguments);
  };
  LinesSeriesModel2.prototype.appendData = function(params) {
    var result = this._processFlatCoordsArray(params.data);
    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
      }
      params.data = new Float32Array(result.count);
    }
    this.getRawData().appendData(params.data);
  };
  LinesSeriesModel2.prototype._getCoordsFromItemModel = function(idx) {
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    {
      if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
        throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
      }
    }
    return coords;
  };
  LinesSeriesModel2.prototype.getLineCoordsCount = function(idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  };
  LinesSeriesModel2.prototype.getLineCoords = function(idx, out2) {
    if (this._flatCoordsOffset) {
      var offset = this._flatCoordsOffset[idx * 2];
      var len2 = this._flatCoordsOffset[idx * 2 + 1];
      for (var i = 0; i < len2; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = this._flatCoords[offset + i * 2];
        out2[i][1] = this._flatCoords[offset + i * 2 + 1];
      }
      return len2;
    } else {
      var coords = this._getCoordsFromItemModel(idx);
      for (var i = 0; i < coords.length; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = coords[i][0];
        out2[i][1] = coords[i][1];
      }
      return coords.length;
    }
  };
  LinesSeriesModel2.prototype._processFlatCoordsArray = function(data) {
    var startOffset = 0;
    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    }
    if (isNumber(data[0])) {
      var len2 = data.length;
      var coordsOffsetAndLenStorage = new Uint32Arr(len2);
      var coordsStorage = new Float64Arr(len2);
      var coordsCursor = 0;
      var offsetCursor = 0;
      var dataCount = 0;
      for (var i = 0; i < len2; ) {
        dataCount++;
        var count3 = data[i++];
        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
        coordsOffsetAndLenStorage[offsetCursor++] = count3;
        for (var k = 0; k < count3; k++) {
          var x2 = data[i++];
          var y2 = data[i++];
          coordsStorage[coordsCursor++] = x2;
          coordsStorage[coordsCursor++] = y2;
          if (i > len2) {
            {
              throw new Error("Invalid data format.");
            }
          }
        }
      }
      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }
    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  };
  LinesSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    {
      var CoordSys = CoordinateSystem.get(option.coordinateSystem);
      if (!CoordSys) {
        throw new Error("Unkown coordinate system " + option.coordinateSystem);
      }
    }
    var lineData = new SeriesData$1(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  };
  LinesSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var itemModel = data.getItemModel(dataIndex);
    var name2 = itemModel.get("name");
    if (name2) {
      return name2;
    }
    var fromName = itemModel.get("fromName");
    var toName = itemModel.get("toName");
    var nameArr = [];
    fromName != null && nameArr.push(fromName);
    toName != null && nameArr.push(toName);
    return createTooltipMarkup("nameValue", {
      name: nameArr.join(" > ")
    });
  };
  LinesSeriesModel2.prototype.preventIncremental = function() {
    return !!this.get(["effect", "show"]);
  };
  LinesSeriesModel2.prototype.getProgressive = function() {
    var progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 1e4 : this.get("progressive");
    }
    return progressive;
  };
  LinesSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 2e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  };
  LinesSeriesModel2.prototype.getZLevelKey = function() {
    var effectModel = this.getModel("effect");
    var trailLength = effectModel.get("trailLength");
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : effectModel.get("show") && trailLength > 0 ? trailLength + "" : "";
  };
  LinesSeriesModel2.type = "series.lines";
  LinesSeriesModel2.dependencies = ["grid", "polar", "geo", "calendar"];
  LinesSeriesModel2.defaultOption = {
    coordinateSystem: "geo",
    z: 2,
    legendHoverLink: true,
    xAxisIndex: 0,
    yAxisIndex: 0,
    symbol: ["none", "none"],
    symbolSize: [10, 10],
    geoIndex: 0,
    effect: {
      show: false,
      period: 4,
      constantSpeed: 0,
      symbol: "circle",
      symbolSize: 3,
      loop: true,
      trailLength: 0.2
    },
    large: false,
    largeThreshold: 2e3,
    polyline: false,
    clip: true,
    label: {
      show: false,
      position: "end"
    },
    lineStyle: {
      opacity: 0.5
    }
  };
  return LinesSeriesModel2;
}(SeriesModel$1);
var LinesSeriesModel$1 = LinesSeriesModel;
function normalize4(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
var linesVisual = {
  seriesType: "lines",
  reset: function(seriesModel) {
    var symbolType = normalize4(seriesModel.get("symbol"));
    var symbolSize = normalize4(seriesModel.get("symbolSize"));
    var data = seriesModel.getData();
    data.setVisual("fromSymbol", symbolType && symbolType[0]);
    data.setVisual("toSymbol", symbolType && symbolType[1]);
    data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    function dataEach(data2, idx) {
      var itemModel = data2.getItemModel(idx);
      var symbolType2 = normalize4(itemModel.getShallow("symbol", true));
      var symbolSize2 = normalize4(itemModel.getShallow("symbolSize", true));
      symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
      symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
      symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
var linesVisual$1 = linesVisual;
function install$w(registers) {
  registers.registerChartView(LinesView$1);
  registers.registerSeriesModel(LinesSeriesModel$1);
  registers.registerLayout(linesLayout$1);
  registers.registerVisual(linesVisual$1);
}
var GRADIENT_LEVELS = 256;
var HeatmapLayer = function() {
  function HeatmapLayer2() {
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {
      inRange: null,
      outOfRange: null
    };
    var canvas = platformApi.createCanvas();
    this.canvas = canvas;
  }
  HeatmapLayer2.prototype.update = function(data, width, height, normalize5, colorFunc, isInRange) {
    var brush2 = this._getBrush();
    var gradientInRange = this._getGradient(colorFunc, "inRange");
    var gradientOutOfRange = this._getGradient(colorFunc, "outOfRange");
    var r = this.pointSize + this.blurSize;
    var canvas = this.canvas;
    var ctx = canvas.getContext("2d");
    var len2 = data.length;
    canvas.width = width;
    canvas.height = height;
    for (var i = 0; i < len2; ++i) {
      var p = data[i];
      var x2 = p[0];
      var y2 = p[1];
      var value = p[2];
      var alpha = normalize5(value);
      ctx.globalAlpha = alpha;
      ctx.drawImage(brush2, x2 - r, y2 - r);
    }
    if (!canvas.width || !canvas.height) {
      return canvas;
    }
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var pixels = imageData.data;
    var offset = 0;
    var pixelLen = pixels.length;
    var minOpacity = this.minOpacity;
    var maxOpacity = this.maxOpacity;
    var diffOpacity = maxOpacity - minOpacity;
    while (offset < pixelLen) {
      var alpha = pixels[offset + 3] / 256;
      var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
      if (alpha > 0) {
        var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
        pixels[offset++] = gradient[gradientOffset];
        pixels[offset++] = gradient[gradientOffset + 1];
        pixels[offset++] = gradient[gradientOffset + 2];
        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
      } else {
        offset += 4;
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  };
  HeatmapLayer2.prototype._getBrush = function() {
    var brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas());
    var r = this.pointSize + this.blurSize;
    var d = r * 2;
    brushCanvas.width = d;
    brushCanvas.height = d;
    var ctx = brushCanvas.getContext("2d");
    ctx.clearRect(0, 0, d, d);
    ctx.shadowOffsetX = d;
    ctx.shadowBlur = this.blurSize;
    ctx.shadowColor = "#000";
    ctx.beginPath();
    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return brushCanvas;
  };
  HeatmapLayer2.prototype._getGradient = function(colorFunc, state) {
    var gradientPixels = this._gradientPixels;
    var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
    var color = [0, 0, 0, 0];
    var off = 0;
    for (var i = 0; i < 256; i++) {
      colorFunc[state](i / 255, true, color);
      pixelsSingleState[off++] = color[0];
      pixelsSingleState[off++] = color[1];
      pixelsSingleState[off++] = color[2];
      pixelsSingleState[off++] = color[3];
    }
    return pixelsSingleState;
  };
  return HeatmapLayer2;
}();
var HeatmapLayer$1 = HeatmapLayer;
function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  pieceList = map$1(pieceList, function(piece) {
    return {
      interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
    };
  });
  var len2 = pieceList.length;
  var lastIndex = 0;
  return function(val) {
    var i;
    for (i = lastIndex; i < len2; i++) {
      var interval = pieceList[i].interval;
      if (interval[0] <= val && val <= interval[1]) {
        lastIndex = i;
        break;
      }
    }
    if (i === len2) {
      for (i = lastIndex - 1; i >= 0; i--) {
        var interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
    }
    return i >= 0 && i < len2 && selected[i];
  };
}
function getIsInContinuousRange(dataExtent, range) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
  return function(val) {
    return val >= range[0] && val <= range[1];
  };
}
function isGeoCoordSys(coordSys) {
  var dimensions = coordSys.dimensions;
  return dimensions[0] === "lng" && dimensions[1] === "lat";
}
var HeatmapView = function(_super) {
  __extends$1(HeatmapView2, _super);
  function HeatmapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = HeatmapView2.type;
    return _this;
  }
  HeatmapView2.prototype.render = function(seriesModel, ecModel, api) {
    var visualMapOfThisSeries;
    ecModel.eachComponent("visualMap", function(visualMap) {
      visualMap.eachTargetSeries(function(targetSeries) {
        if (targetSeries === seriesModel) {
          visualMapOfThisSeries = visualMap;
        }
      });
    });
    {
      if (!visualMapOfThisSeries) {
        throw new Error("Heatmap must use with visualMap");
      }
    }
    this._progressiveEls = null;
    this.group.removeAll();
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
      this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
    } else if (isGeoCoordSys(coordSys)) {
      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
    }
  };
  HeatmapView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    this.group.removeAll();
  };
  HeatmapView2.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys) {
      if (isGeoCoordSys(coordSys)) {
        this.render(seriesModel, ecModel, api);
      } else {
        this._progressiveEls = [];
        this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
      }
    }
  };
  HeatmapView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  HeatmapView2.prototype._renderOnCartesianAndCalendar = function(seriesModel, api, start2, end2, incremental) {
    var coordSys = seriesModel.coordinateSystem;
    var isCartesian2d = isCoordinateSystemType(coordSys, "cartesian2d");
    var width;
    var height;
    var xAxisExtent;
    var yAxisExtent;
    if (isCartesian2d) {
      var xAxis = coordSys.getAxis("x");
      var yAxis = coordSys.getAxis("y");
      {
        if (!(xAxis.type === "category" && yAxis.type === "category")) {
          throw new Error("Heatmap on cartesian must have two category axes");
        }
        if (!(xAxis.onBand && yAxis.onBand)) {
          throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
      }
      width = xAxis.getBandWidth() + 0.5;
      height = yAxis.getBandWidth() + 0.5;
      xAxisExtent = xAxis.scale.getExtent();
      yAxisExtent = yAxis.scale.getExtent();
    }
    var group = this.group;
    var data = seriesModel.getData();
    var emphasisStyle = seriesModel.getModel(["emphasis", "itemStyle"]).getItemStyle();
    var blurStyle = seriesModel.getModel(["blur", "itemStyle"]).getItemStyle();
    var selectStyle = seriesModel.getModel(["select", "itemStyle"]).getItemStyle();
    var borderRadius = seriesModel.get(["itemStyle", "borderRadius"]);
    var labelStatesModels = getLabelStatesModels(seriesModel);
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    var dataDims = isCartesian2d ? [data.mapDimension("x"), data.mapDimension("y"), data.mapDimension("value")] : [data.mapDimension("time"), data.mapDimension("value")];
    for (var idx = start2; idx < end2; idx++) {
      var rect = void 0;
      var style = data.getItemVisual(idx, "style");
      if (isCartesian2d) {
        var dataDimX = data.get(dataDims[0], idx);
        var dataDimY = data.get(dataDims[1], idx);
        if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
          continue;
        }
        var point4 = coordSys.dataToPoint([dataDimX, dataDimY]);
        rect = new Rect$3({
          shape: {
            x: point4[0] - width / 2,
            y: point4[1] - height / 2,
            width,
            height
          },
          style
        });
      } else {
        if (isNaN(data.get(dataDims[1], idx))) {
          continue;
        }
        rect = new Rect$3({
          z2: 1,
          shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
          style
        });
      }
      if (data.hasItemOption) {
        var itemModel = data.getItemModel(idx);
        var emphasisModel_1 = itemModel.getModel("emphasis");
        emphasisStyle = emphasisModel_1.getModel("itemStyle").getItemStyle();
        blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
        selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
        borderRadius = itemModel.get(["itemStyle", "borderRadius"]);
        focus = emphasisModel_1.get("focus");
        blurScope = emphasisModel_1.get("blurScope");
        emphasisDisabled = emphasisModel_1.get("disabled");
        labelStatesModels = getLabelStatesModels(itemModel);
      }
      rect.shape.r = borderRadius;
      var rawValue = seriesModel.getRawValue(idx);
      var defaultText = "-";
      if (rawValue && rawValue[2] != null) {
        defaultText = rawValue[2] + "";
      }
      setLabelStyle(rect, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText
      });
      rect.ensureState("emphasis").style = emphasisStyle;
      rect.ensureState("blur").style = blurStyle;
      rect.ensureState("select").style = selectStyle;
      toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
      rect.incremental = incremental;
      if (incremental) {
        rect.states.emphasis.hoverLayer = true;
      }
      group.add(rect);
      data.setItemGraphicEl(idx, rect);
      if (this._progressiveEls) {
        this._progressiveEls.push(rect);
      }
    }
  };
  HeatmapView2.prototype._renderOnGeo = function(geo, seriesModel, visualMapModel, api) {
    var inRangeVisuals = visualMapModel.targetVisuals.inRange;
    var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
    var data = seriesModel.getData();
    var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer$1();
    hmLayer.blurSize = seriesModel.get("blurSize");
    hmLayer.pointSize = seriesModel.get("pointSize");
    hmLayer.minOpacity = seriesModel.get("minOpacity");
    hmLayer.maxOpacity = seriesModel.get("maxOpacity");
    var rect = geo.getViewRect().clone();
    var roamTransform = geo.getRoamTransform();
    rect.applyTransform(roamTransform);
    var x2 = Math.max(rect.x, 0);
    var y2 = Math.max(rect.y, 0);
    var x22 = Math.min(rect.width + rect.x, api.getWidth());
    var y22 = Math.min(rect.height + rect.y, api.getHeight());
    var width = x22 - x2;
    var height = y22 - y2;
    var dims = [data.mapDimension("lng"), data.mapDimension("lat"), data.mapDimension("value")];
    var points2 = data.mapArray(dims, function(lng, lat2, value) {
      var pt = geo.dataToPoint([lng, lat2]);
      pt[0] -= x2;
      pt[1] -= y2;
      pt.push(value);
      return pt;
    });
    var dataExtent = visualMapModel.getExtent();
    var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
    hmLayer.update(points2, width, height, inRangeVisuals.color.getNormalizer(), {
      inRange: inRangeVisuals.color.getColorMapper(),
      outOfRange: outOfRangeVisuals.color.getColorMapper()
    }, isInRange);
    var img = new ZRImage$1({
      style: {
        width,
        height,
        x: x2,
        y: y2,
        image: hmLayer.canvas
      },
      silent: true
    });
    this.group.add(img);
  };
  HeatmapView2.type = "heatmap";
  return HeatmapView2;
}(ChartView$1);
var HeatmapView$1 = HeatmapView;
var HeatmapSeriesModel = function(_super) {
  __extends$1(HeatmapSeriesModel2, _super);
  function HeatmapSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = HeatmapSeriesModel2.type;
    return _this;
  }
  HeatmapSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      generateCoord: "value"
    });
  };
  HeatmapSeriesModel2.prototype.preventIncremental = function() {
    var coordSysCreator = CoordinateSystem.get(this.get("coordinateSystem"));
    if (coordSysCreator && coordSysCreator.dimensions) {
      return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
    }
  };
  HeatmapSeriesModel2.type = "series.heatmap";
  HeatmapSeriesModel2.dependencies = ["grid", "geo", "calendar"];
  HeatmapSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    geoIndex: 0,
    blurSize: 30,
    pointSize: 20,
    maxOpacity: 1,
    minOpacity: 0,
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  };
  return HeatmapSeriesModel2;
}(SeriesModel$1);
var HeatmapSeriesModel$1 = HeatmapSeriesModel;
function install$v(registers) {
  registers.registerChartView(HeatmapView$1);
  registers.registerSeriesModel(HeatmapSeriesModel$1);
}
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
var LAYOUT_ATTRS = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}];
var pathForLineWidth = new Circle$1();
var PictorialBarView = function(_super) {
  __extends$1(PictorialBarView2, _super);
  function PictorialBarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PictorialBarView2.type;
    return _this;
  }
  PictorialBarView2.prototype.render = function(seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var cartesian2 = seriesModel.coordinateSystem;
    var baseAxis = cartesian2.getBaseAxis();
    var isHorizontal2 = baseAxis.isHorizontal();
    var coordSysRect = cartesian2.master.getRect();
    var opt = {
      ecSize: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      seriesModel,
      coordSys: cartesian2,
      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
      isHorizontal: isHorizontal2,
      valueDim: LAYOUT_ATTRS[+isHorizontal2],
      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal2]
    };
    data.diff(oldData).add(function(dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }
      var itemModel = getItemModel(data, dataIndex);
      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
      var bar = createBar(data, opt, symbolMeta);
      data.setItemGraphicEl(dataIndex, bar);
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).update(function(newIndex, oldIndex) {
      var bar = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex)) {
        group.remove(bar);
        return;
      }
      var itemModel = getItemModel(data, newIndex);
      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
      var pictorialShapeStr = getShapeStr(data, symbolMeta);
      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
        group.remove(bar);
        data.setItemGraphicEl(newIndex, null);
        bar = null;
      }
      if (bar) {
        updateBar(bar, opt, symbolMeta);
      } else {
        bar = createBar(data, opt, symbolMeta, true);
      }
      data.setItemGraphicEl(newIndex, bar);
      bar.__pictorialSymbolMeta = symbolMeta;
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).remove(function(dataIndex) {
      var bar = oldData.getItemGraphicEl(dataIndex);
      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
    }).execute();
    this._data = data;
    return this.group;
  };
  PictorialBarView2.prototype.remove = function(ecModel, api) {
    var group = this.group;
    var data = this._data;
    if (ecModel.get("animation")) {
      if (data) {
        data.eachItemGraphicEl(function(bar) {
          removeBar(data, getECData(bar).dataIndex, ecModel, bar);
        });
      }
    } else {
      group.removeAll();
    }
  };
  PictorialBarView2.type = "pictorialBar";
  return PictorialBarView2;
}(ChartView$1);
function getSymbolMeta(data, dataIndex, itemModel, opt) {
  var layout2 = data.getItemLayout(dataIndex);
  var symbolRepeat = itemModel.get("symbolRepeat");
  var symbolClip = itemModel.get("symbolClip");
  var symbolPosition = itemModel.get("symbolPosition") || "start";
  var symbolRotate = itemModel.get("symbolRotate");
  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
  var isAnimationEnabled2 = itemModel.isAnimationEnabled();
  var symbolMeta = {
    dataIndex,
    layout: layout2,
    itemModel,
    symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
    style: data.getItemVisual(dataIndex, "style"),
    symbolClip,
    symbolRepeat,
    symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
    symbolPatternSize,
    rotation,
    animationModel: isAnimationEnabled2 ? itemModel : null,
    hoverScale: isAnimationEnabled2 && itemModel.get(["emphasis", "scale"]),
    z2: itemModel.getShallow("z", true) || 0
  };
  prepareBarLength(itemModel, symbolRepeat, layout2, opt, symbolMeta);
  prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
  var symbolSize = symbolMeta.symbolSize;
  var symbolOffset = normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize);
  prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
  return symbolMeta;
}
function prepareBarLength(itemModel, symbolRepeat, layout2, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var symbolBoundingData = itemModel.get("symbolBoundingData");
  var valueAxis2 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
  var zeroPx = valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(0));
  var pxSignIdx = 1 - +(layout2[valueDim.wh] <= 0);
  var boundingLength;
  if (isArray$1(symbolBoundingData)) {
    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis2, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis2, symbolBoundingData[1]) - zeroPx];
    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
    boundingLength = symbolBoundingExtent[pxSignIdx];
  } else if (symbolBoundingData != null) {
    boundingLength = convertToCoordOnAxis(valueAxis2, symbolBoundingData) - zeroPx;
  } else if (symbolRepeat) {
    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
  } else {
    boundingLength = layout2[valueDim.wh];
  }
  outputSymbolMeta.boundingLength = boundingLength;
  if (symbolRepeat) {
    outputSymbolMeta.repeatCutLength = layout2[valueDim.wh];
  }
  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : -1;
}
function convertToCoordOnAxis(axis, value) {
  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
}
function prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var categoryDim = opt.categoryDim;
  var categorySize = Math.abs(layout2[categoryDim.wh]);
  var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
  var parsedSymbolSize;
  if (isArray$1(symbolSize)) {
    parsedSymbolSize = symbolSize.slice();
  } else {
    if (symbolSize == null) {
      parsedSymbolSize = ["100%", "100%"];
    } else {
      parsedSymbolSize = [symbolSize, symbolSize];
    }
  }
  parsedSymbolSize[categoryDim.index] = parsePercent(parsedSymbolSize[categoryDim.index], categorySize);
  parsedSymbolSize[valueDim.index] = parsePercent(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
  outputSymbolMeta.symbolSize = parsedSymbolSize;
  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];
  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}
function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  if (valueLineWidth) {
    pathForLineWidth.attr({
      scaleX: symbolScale[0],
      scaleY: symbolScale[1],
      rotation
    });
    pathForLineWidth.updateTransform();
    valueLineWidth /= pathForLineWidth.getLineScale();
    valueLineWidth *= symbolScale[opt.valueDim.index];
  }
  outputSymbolMeta.valueLineWidth = valueLineWidth || 0;
}
function prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
  var categoryDim = opt.categoryDim;
  var valueDim = opt.valueDim;
  var pxSign = outputSymbolMeta.pxSign;
  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
  var pathLen = unitLength;
  if (symbolRepeat) {
    var absBoundingLength = Math.abs(boundingLength);
    var symbolMargin = retrieve(itemModel.get("symbolMargin"), "15%") + "";
    var hasEndGap = false;
    if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
      hasEndGap = true;
      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
    }
    var symbolMarginNumeric = parsePercent(symbolMargin, symbolSize[valueDim.index]);
    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    var repeatSpecified = isNumeric(symbolRepeat);
    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
    var mDiff = absBoundingLength - repeatTimes * unitLength;
    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
    uLenWithMargin = unitLength + symbolMarginNumeric * 2;
    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    if (!repeatSpecified && symbolRepeat !== "fixed") {
      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
    }
    pathLen = repeatTimes * uLenWithMargin - endFix;
    outputSymbolMeta.repeatTimes = repeatTimes;
    outputSymbolMeta.symbolMargin = symbolMarginNumeric;
  }
  var sizeFix = pxSign * (pathLen / 2);
  var pathPosition = outputSymbolMeta.pathPosition = [];
  pathPosition[categoryDim.index] = layout2[categoryDim.wh] / 2;
  pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
  if (symbolOffset) {
    pathPosition[0] += symbolOffset[0];
    pathPosition[1] += symbolOffset[1];
  }
  var bundlePosition = outputSymbolMeta.bundlePosition = [];
  bundlePosition[categoryDim.index] = layout2[categoryDim.xy];
  bundlePosition[valueDim.index] = layout2[valueDim.xy];
  var barRectShape = outputSymbolMeta.barRectShape = extend2({}, layout2);
  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout2[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
  barRectShape[categoryDim.wh] = layout2[categoryDim.wh];
  var clipShape = outputSymbolMeta.clipShape = {};
  clipShape[categoryDim.xy] = -layout2[categoryDim.xy];
  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
  clipShape[valueDim.xy] = 0;
  clipShape[valueDim.wh] = layout2[valueDim.wh];
}
function createPath(symbolMeta) {
  var symbolPatternSize = symbolMeta.symbolPatternSize;
  var path = createSymbol$1(
    symbolMeta.symbolType,
    -symbolPatternSize / 2,
    -symbolPatternSize / 2,
    symbolPatternSize,
    symbolPatternSize
  );
  path.attr({
    culling: true
  });
  path.type !== "image" && path.setStyle({
    strokeNoScale: true
  });
  return path;
}
function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var symbolSize = symbolMeta.symbolSize;
  var valueLineWidth = symbolMeta.valueLineWidth;
  var pathPosition = symbolMeta.pathPosition;
  var valueDim = opt.valueDim;
  var repeatTimes = symbolMeta.repeatTimes || 0;
  var index2 = 0;
  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
  eachPath(bar, function(path2) {
    path2.__pictorialAnimationIndex = index2;
    path2.__pictorialRepeatTimes = repeatTimes;
    if (index2 < repeatTimes) {
      updateAttr(path2, null, makeTarget(index2), symbolMeta, isUpdate);
    } else {
      updateAttr(path2, null, {
        scaleX: 0,
        scaleY: 0
      }, symbolMeta, isUpdate, function() {
        bundle.remove(path2);
      });
    }
    index2++;
  });
  for (; index2 < repeatTimes; index2++) {
    var path = createPath(symbolMeta);
    path.__pictorialAnimationIndex = index2;
    path.__pictorialRepeatTimes = repeatTimes;
    bundle.add(path);
    var target = makeTarget(index2);
    updateAttr(path, {
      x: target.x,
      y: target.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: target.scaleX,
      scaleY: target.scaleY,
      rotation: target.rotation
    }, symbolMeta, isUpdate);
  }
  function makeTarget(index3) {
    var position2 = pathPosition.slice();
    var pxSign = symbolMeta.pxSign;
    var i = index3;
    if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
      i = repeatTimes - 1 - index3;
    }
    position2[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
    return {
      x: position2[0],
      y: position2[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    };
  }
}
function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var mainPath = bar.__pictorialMainPath;
  if (!mainPath) {
    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
    bundle.add(mainPath);
    updateAttr(mainPath, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: symbolMeta.rotation
    }, {
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1]
    }, symbolMeta, isUpdate);
  } else {
    updateAttr(mainPath, null, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
  var rectShape = extend2({}, symbolMeta.barRectShape);
  var barRect = bar.__pictorialBarRect;
  if (!barRect) {
    barRect = bar.__pictorialBarRect = new Rect$3({
      z2: 2,
      shape: rectShape,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    });
    barRect.disableMorphing = true;
    bar.add(barRect);
  } else {
    updateAttr(barRect, null, {
      shape: rectShape
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
  if (symbolMeta.symbolClip) {
    var clipPath = bar.__pictorialClipPath;
    var clipShape = extend2({}, symbolMeta.clipShape);
    var valueDim = opt.valueDim;
    var animationModel = symbolMeta.animationModel;
    var dataIndex = symbolMeta.dataIndex;
    if (clipPath) {
      updateProps$1(clipPath, {
        shape: clipShape
      }, animationModel, dataIndex);
    } else {
      clipShape[valueDim.wh] = 0;
      clipPath = new Rect$3({
        shape: clipShape
      });
      bar.__pictorialBundle.setClipPath(clipPath);
      bar.__pictorialClipPath = clipPath;
      var target = {};
      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
      graphic[isUpdate ? "updateProps" : "initProps"](clipPath, {
        shape: target
      }, animationModel, dataIndex);
    }
  }
}
function getItemModel(data, dataIndex) {
  var itemModel = data.getItemModel(dataIndex);
  itemModel.getAnimationDelayParams = getAnimationDelayParams;
  itemModel.isAnimationEnabled = isAnimationEnabled;
  return itemModel;
}
function getAnimationDelayParams(path) {
  return {
    index: path.__pictorialAnimationIndex,
    count: path.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(data, opt, symbolMeta, isUpdate) {
  var bar = new Group$4();
  var bundle = new Group$4();
  bar.add(bundle);
  bar.__pictorialBundle = bundle;
  bundle.x = symbolMeta.bundlePosition[0];
  bundle.y = symbolMeta.bundlePosition[1];
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta);
  }
  createOrUpdateBarRect(bar, symbolMeta, isUpdate);
  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
  bar.__pictorialSymbolMeta = symbolMeta;
  return bar;
}
function updateBar(bar, opt, symbolMeta) {
  var animationModel = symbolMeta.animationModel;
  var dataIndex = symbolMeta.dataIndex;
  var bundle = bar.__pictorialBundle;
  updateProps$1(bundle, {
    x: symbolMeta.bundlePosition[0],
    y: symbolMeta.bundlePosition[1]
  }, animationModel, dataIndex);
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
  }
  createOrUpdateBarRect(bar, symbolMeta, true);
  createOrUpdateClip(bar, opt, symbolMeta, true);
}
function removeBar(data, dataIndex, animationModel, bar) {
  var labelRect = bar.__pictorialBarRect;
  labelRect && labelRect.removeTextContent();
  var paths = [];
  eachPath(bar, function(path) {
    paths.push(path);
  });
  bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath);
  bar.__pictorialClipPath && (animationModel = null);
  each$f(paths, function(path) {
    removeElement(path, {
      scaleX: 0,
      scaleY: 0
    }, animationModel, dataIndex, function() {
      bar.parent && bar.parent.remove(bar);
    });
  });
  data.setItemGraphicEl(dataIndex, null);
}
function getShapeStr(data, symbolMeta) {
  return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
}
function eachPath(bar, cb, context) {
  each$f(bar.__pictorialBundle.children(), function(el) {
    el !== bar.__pictorialBarRect && cb.call(context, el);
  });
}
function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
  immediateAttrs && el.attr(immediateAttrs);
  if (symbolMeta.symbolClip && !isUpdate) {
    animationAttrs && el.attr(animationAttrs);
  } else {
    animationAttrs && graphic[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
  }
}
function updateCommon(bar, opt, symbolMeta) {
  var dataIndex = symbolMeta.dataIndex;
  var itemModel = symbolMeta.itemModel;
  var emphasisModel = itemModel.getModel("emphasis");
  var emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
  var blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
  var selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
  var cursorStyle = itemModel.getShallow("cursor");
  var focus = emphasisModel.get("focus");
  var blurScope = emphasisModel.get("blurScope");
  var hoverScale = emphasisModel.get("scale");
  eachPath(bar, function(path) {
    if (path instanceof ZRImage$1) {
      var pathStyle = path.style;
      path.useStyle(extend2({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolMeta.style));
    } else {
      path.useStyle(symbolMeta.style);
    }
    var emphasisState = path.ensureState("emphasis");
    emphasisState.style = emphasisStyle;
    if (hoverScale) {
      emphasisState.scaleX = path.scaleX * 1.1;
      emphasisState.scaleY = path.scaleY * 1.1;
    }
    path.ensureState("blur").style = blurStyle;
    path.ensureState("select").style = selectStyle;
    cursorStyle && (path.cursor = cursorStyle);
    path.z2 = symbolMeta.z2;
  });
  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
  var barRect = bar.__pictorialBarRect;
  setLabelStyle(barRect, getLabelStatesModels(itemModel), {
    labelFetcher: opt.seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
    inheritColor: symbolMeta.style.fill,
    defaultOpacity: symbolMeta.style.opacity,
    defaultOutsidePosition: barPositionOutside
  });
  toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
}
function toIntTimes(times) {
  var roundedTimes = Math.round(times);
  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}
var PictorialBarView$1 = PictorialBarView;
var PictorialBarSeriesModel = function(_super) {
  __extends$1(PictorialBarSeriesModel2, _super);
  function PictorialBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PictorialBarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    _this.defaultSymbol = "roundRect";
    return _this;
  }
  PictorialBarSeriesModel2.prototype.getInitialData = function(option) {
    option.stack = null;
    return _super.prototype.getInitialData.apply(this, arguments);
  };
  PictorialBarSeriesModel2.type = "series.pictorialBar";
  PictorialBarSeriesModel2.dependencies = ["grid"];
  PictorialBarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    symbol: "circle",
    symbolSize: null,
    symbolRotate: null,
    symbolPosition: null,
    symbolOffset: null,
    symbolMargin: null,
    symbolRepeat: false,
    symbolRepeatDirection: "end",
    symbolClip: false,
    symbolBoundingData: null,
    symbolPatternSize: 400,
    barGap: "-100%",
    progressive: 0,
    emphasis: {
      scale: false
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  });
  return PictorialBarSeriesModel2;
}(BaseBarSeriesModel$1);
var PictorialBarSeriesModel$1 = PictorialBarSeriesModel;
function install$u(registers) {
  registers.registerChartView(PictorialBarView$1);
  registers.registerSeriesModel(PictorialBarSeriesModel$1);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "pictorialBar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}
var ThemeRiverView = function(_super) {
  __extends$1(ThemeRiverView2, _super);
  function ThemeRiverView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ThemeRiverView2.type;
    _this._layers = [];
    return _this;
  }
  ThemeRiverView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var self2 = this;
    var group = this.group;
    var layersSeries = seriesModel.getLayerSeries();
    var layoutInfo = data.getLayout("layoutInfo");
    var rect = layoutInfo.rect;
    var boundaryGap = layoutInfo.boundaryGap;
    group.x = 0;
    group.y = rect.y + boundaryGap[0];
    function keyGetter(item) {
      return item.name;
    }
    var dataDiffer = new DataDiffer$1(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
    var newLayersGroups = [];
    dataDiffer.add(bind$1(process2, this, "add")).update(bind$1(process2, this, "update")).remove(bind$1(process2, this, "remove")).execute();
    function process2(status, idx, oldIdx) {
      var oldLayersGroups = self2._layers;
      if (status === "remove") {
        group.remove(oldLayersGroups[idx]);
        return;
      }
      var points0 = [];
      var points1 = [];
      var style;
      var indices = layersSeries[idx].indices;
      var j = 0;
      for (; j < indices.length; j++) {
        var layout2 = data.getItemLayout(indices[j]);
        var x2 = layout2.x;
        var y02 = layout2.y0;
        var y2 = layout2.y;
        points0.push(x2, y02);
        points1.push(x2, y02 + y2);
        style = data.getItemVisual(indices[j], "style");
      }
      var polygon4;
      var textLayout = data.getItemLayout(indices[0]);
      var labelModel = seriesModel.getModel("label");
      var margin = labelModel.get("margin");
      var emphasisModel = seriesModel.getModel("emphasis");
      if (status === "add") {
        var layerGroup = newLayersGroups[idx] = new Group$4();
        polygon4 = new ECPolygon({
          shape: {
            points: points0,
            stackedOnPoints: points1,
            smooth: 0.4,
            stackedOnSmooth: 0.4,
            smoothConstraint: false
          },
          z2: 0
        });
        layerGroup.add(polygon4);
        group.add(layerGroup);
        if (seriesModel.isAnimationEnabled()) {
          polygon4.setClipPath(createGridClipShape(polygon4.getBoundingRect(), seriesModel, function() {
            polygon4.removeClipPath();
          }));
        }
      } else {
        var layerGroup = oldLayersGroups[oldIdx];
        polygon4 = layerGroup.childAt(0);
        group.add(layerGroup);
        newLayersGroups[idx] = layerGroup;
        updateProps$1(polygon4, {
          shape: {
            points: points0,
            stackedOnPoints: points1
          }
        }, seriesModel);
        saveOldStyle(polygon4);
      }
      setLabelStyle(polygon4, getLabelStatesModels(seriesModel), {
        labelDataIndex: indices[j - 1],
        defaultText: data.getName(indices[j - 1]),
        inheritColor: style.fill
      }, {
        normal: {
          verticalAlign: "middle"
        }
      });
      polygon4.setTextConfig({
        position: null,
        local: true
      });
      var labelEl = polygon4.getTextContent();
      if (labelEl) {
        labelEl.x = textLayout.x - margin;
        labelEl.y = textLayout.y0 + textLayout.y / 2;
      }
      polygon4.useStyle(style);
      data.setItemGraphicEl(idx, polygon4);
      setStatesStylesFromModel(polygon4, seriesModel);
      toggleHoverEmphasis(polygon4, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    }
    this._layersSeries = layersSeries;
    this._layers = newLayersGroups;
  };
  ThemeRiverView2.type = "themeRiver";
  return ThemeRiverView2;
}(ChartView$1);
function createGridClipShape(rect, seriesModel, cb) {
  var rectEl = new Rect$3({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      x: rect.x - 50,
      width: rect.width + 100,
      height: rect.height + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var ThemeRiverView$1 = ThemeRiverView;
var DATA_NAME_INDEX = 2;
var ThemeRiverSeriesModel = function(_super) {
  __extends$1(ThemeRiverSeriesModel2, _super);
  function ThemeRiverSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ThemeRiverSeriesModel2.type;
    return _this;
  }
  ThemeRiverSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
  };
  ThemeRiverSeriesModel2.prototype.fixData = function(data) {
    var rawDataLength = data.length;
    var timeValueKeys = {};
    var groupResult = groupData(data, function(item) {
      if (!timeValueKeys.hasOwnProperty(item[0] + "")) {
        timeValueKeys[item[0] + ""] = -1;
      }
      return item[2];
    });
    var layerData = [];
    groupResult.buckets.each(function(items, key) {
      layerData.push({
        name: key,
        dataList: items
      });
    });
    var layerNum = layerData.length;
    for (var k = 0; k < layerNum; ++k) {
      var name_1 = layerData[k].name;
      for (var j = 0; j < layerData[k].dataList.length; ++j) {
        var timeValue = layerData[k].dataList[j][0] + "";
        timeValueKeys[timeValue] = k;
      }
      for (var timeValue in timeValueKeys) {
        if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
          timeValueKeys[timeValue] = k;
          data[rawDataLength] = [timeValue, 0, name_1];
          rawDataLength++;
        }
      }
    }
    return data;
  };
  ThemeRiverSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var singleAxisModel = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    var axisType = singleAxisModel.get("type");
    var filterData = filter17(option.data, function(dataItem) {
      return dataItem[2] !== void 0;
    });
    var data = this.fixData(filterData || []);
    var nameList = [];
    var nameMap = this.nameMap = createHashMap();
    var count3 = 0;
    for (var i = 0; i < data.length; ++i) {
      nameList.push(data[i][DATA_NAME_INDEX]);
      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
        nameMap.set(data[i][DATA_NAME_INDEX], count3);
        count3++;
      }
    }
    var dimensions = prepareSeriesDataSchema(data, {
      coordDimensions: ["single"],
      dimensionsDefine: [{
        name: "time",
        type: getDimensionTypeByAxis(axisType)
      }, {
        name: "value",
        type: "float"
      }, {
        name: "name",
        type: "ordinal"
      }],
      encodeDefine: {
        single: 0,
        value: 1,
        itemName: 2
      }
    }).dimensions;
    var list = new SeriesData$1(dimensions, this);
    list.initData(data);
    return list;
  };
  ThemeRiverSeriesModel2.prototype.getLayerSeries = function() {
    var data = this.getData();
    var lenCount = data.count();
    var indexArr = [];
    for (var i = 0; i < lenCount; ++i) {
      indexArr[i] = i;
    }
    var timeDim = data.mapDimension("single");
    var groupResult = groupData(indexArr, function(index2) {
      return data.get("name", index2);
    });
    var layerSeries = [];
    groupResult.buckets.each(function(items, key) {
      items.sort(function(index1, index2) {
        return data.get(timeDim, index1) - data.get(timeDim, index2);
      });
      layerSeries.push({
        name: key,
        indices: items
      });
    });
    return layerSeries;
  };
  ThemeRiverSeriesModel2.prototype.getAxisTooltipData = function(dim, value, baseAxis) {
    if (!isArray$1(dim)) {
      dim = dim ? [dim] : [];
    }
    var data = this.getData();
    var layerSeries = this.getLayerSeries();
    var indices = [];
    var layerNum = layerSeries.length;
    var nestestValue;
    for (var i = 0; i < layerNum; ++i) {
      var minDist = Number.MAX_VALUE;
      var nearestIdx = -1;
      var pointNum = layerSeries[i].indices.length;
      for (var j = 0; j < pointNum; ++j) {
        var theValue = data.get(dim[0], layerSeries[i].indices[j]);
        var dist3 = Math.abs(theValue - value);
        if (dist3 <= minDist) {
          nestestValue = theValue;
          minDist = dist3;
          nearestIdx = layerSeries[i].indices[j];
        }
      }
      indices.push(nearestIdx);
    }
    return {
      dataIndices: indices,
      nestestValue
    };
  };
  ThemeRiverSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var name2 = data.getName(dataIndex);
    var value = data.get(data.mapDimension("value"), dataIndex);
    return createTooltipMarkup("nameValue", {
      name: name2,
      value
    });
  };
  ThemeRiverSeriesModel2.type = "series.themeRiver";
  ThemeRiverSeriesModel2.dependencies = ["singleAxis"];
  ThemeRiverSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    coordinateSystem: "singleAxis",
    boundaryGap: ["10%", "10%"],
    singleAxisIndex: 0,
    animationEasing: "linear",
    label: {
      margin: 4,
      show: true,
      position: "left",
      fontSize: 11
    },
    emphasis: {
      label: {
        show: true
      }
    }
  };
  return ThemeRiverSeriesModel2;
}(SeriesModel$1);
var ThemeRiverSeriesModel$1 = ThemeRiverSeriesModel;
function themeRiverLayout(ecModel, api) {
  ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
    var data = seriesModel.getData();
    var single = seriesModel.coordinateSystem;
    var layoutInfo = {};
    var rect = single.getRect();
    layoutInfo.rect = rect;
    var boundaryGap = seriesModel.get("boundaryGap");
    var axis = single.getAxis();
    layoutInfo.boundaryGap = boundaryGap;
    if (axis.orient === "horizontal") {
      boundaryGap[0] = parsePercent(boundaryGap[0], rect.height);
      boundaryGap[1] = parsePercent(boundaryGap[1], rect.height);
      var height = rect.height - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, height);
    } else {
      boundaryGap[0] = parsePercent(boundaryGap[0], rect.width);
      boundaryGap[1] = parsePercent(boundaryGap[1], rect.width);
      var width = rect.width - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, width);
    }
    data.setLayout("layoutInfo", layoutInfo);
  });
}
function doThemeRiverLayout(data, seriesModel, height) {
  if (!data.count()) {
    return;
  }
  var coordSys = seriesModel.coordinateSystem;
  var layerSeries = seriesModel.getLayerSeries();
  var timeDim = data.mapDimension("single");
  var valueDim = data.mapDimension("value");
  var layerPoints = map$1(layerSeries, function(singleLayer) {
    return map$1(singleLayer.indices, function(idx) {
      var pt = coordSys.dataToPoint(data.get(timeDim, idx));
      pt[1] = data.get(valueDim, idx);
      return pt;
    });
  });
  var base2 = computeBaseline(layerPoints);
  var baseLine = base2.y0;
  var ky = height / base2.max;
  var n = layerSeries.length;
  var m2 = layerSeries[0].indices.length;
  var baseY0;
  for (var j = 0; j < m2; ++j) {
    baseY0 = baseLine[j] * ky;
    data.setItemLayout(layerSeries[0].indices[j], {
      layerIndex: 0,
      x: layerPoints[0][j][0],
      y0: baseY0,
      y: layerPoints[0][j][1] * ky
    });
    for (var i = 1; i < n; ++i) {
      baseY0 += layerPoints[i - 1][j][1] * ky;
      data.setItemLayout(layerSeries[i].indices[j], {
        layerIndex: i,
        x: layerPoints[i][j][0],
        y0: baseY0,
        y: layerPoints[i][j][1] * ky
      });
    }
  }
}
function computeBaseline(data) {
  var layerNum = data.length;
  var pointNum = data[0].length;
  var sums = [];
  var y02 = [];
  var max4 = 0;
  for (var i = 0; i < pointNum; ++i) {
    var temp2 = 0;
    for (var j = 0; j < layerNum; ++j) {
      temp2 += data[j][i][1];
    }
    if (temp2 > max4) {
      max4 = temp2;
    }
    sums.push(temp2);
  }
  for (var k = 0; k < pointNum; ++k) {
    y02[k] = (max4 - sums[k]) / 2;
  }
  max4 = 0;
  for (var l = 0; l < pointNum; ++l) {
    var sum2 = sums[l] + y02[l];
    if (sum2 > max4) {
      max4 = sum2;
    }
  }
  return {
    y0: y02,
    max: max4
  };
}
function install$t(registers) {
  registers.registerChartView(ThemeRiverView$1);
  registers.registerSeriesModel(ThemeRiverSeriesModel$1);
  registers.registerLayout(themeRiverLayout);
  registers.registerProcessor(dataFilter$1("themeRiver"));
}
var DEFAULT_SECTOR_Z = 2;
var DEFAULT_TEXT_Z = 4;
var SunburstPiece = function(_super) {
  __extends$1(SunburstPiece2, _super);
  function SunburstPiece2(node, seriesModel, ecModel, api) {
    var _this = _super.call(this) || this;
    _this.z2 = DEFAULT_SECTOR_Z;
    _this.textConfig = {
      inside: true
    };
    getECData(_this).seriesIndex = seriesModel.seriesIndex;
    var text = new ZRText$1({
      z2: DEFAULT_TEXT_Z,
      silent: node.getModel().get(["label", "silent"])
    });
    _this.setTextContent(text);
    _this.updateData(true, node, seriesModel, ecModel, api);
    return _this;
  }
  SunburstPiece2.prototype.updateData = function(firstCreate, node, seriesModel, ecModel, api) {
    this.node = node;
    node.piece = this;
    seriesModel = seriesModel || this._seriesModel;
    ecModel = ecModel || this._ecModel;
    var sector2 = this;
    getECData(sector2).dataIndex = node.dataIndex;
    var itemModel = node.getModel();
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = node.getLayout();
    var sectorShape = extend2({}, layout2);
    sectorShape.label = null;
    var normalStyle = node.getVisual("style");
    normalStyle.lineJoin = "bevel";
    var decal = node.getVisual("decal");
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, api);
    }
    var cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend2(sectorShape, cornerRadius);
    each$f(SPECIAL_STATES, function(stateName) {
      var state = sector2.ensureState(stateName);
      var itemStyleModel = itemModel.getModel([stateName, "itemStyle"]);
      state.style = itemStyleModel.getItemStyle();
      var cornerRadius2 = getSectorCornerRadius(itemStyleModel, sectorShape);
      if (cornerRadius2) {
        state.shape = cornerRadius2;
      }
    });
    if (firstCreate) {
      sector2.setShape(sectorShape);
      sector2.shape.r = layout2.r0;
      updateProps$1(sector2, {
        shape: {
          r: layout2.r
        }
      }, seriesModel, node.dataIndex);
    } else {
      updateProps$1(sector2, {
        shape: sectorShape
      }, seriesModel);
      saveOldStyle(sector2);
    }
    sector2.useStyle(normalStyle);
    this._updateLabel(seriesModel);
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector2.attr("cursor", cursorStyle);
    this._seriesModel = seriesModel || this._seriesModel;
    this._ecModel = ecModel || this._ecModel;
    var focus = emphasisModel.get("focus");
    var focusOrIndices = focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : focus;
    toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  SunburstPiece2.prototype._updateLabel = function(seriesModel) {
    var _this = this;
    var itemModel = this.node.getModel();
    var normalLabelModel = itemModel.getModel("label");
    var layout2 = this.node.getLayout();
    var angle4 = layout2.endAngle - layout2.startAngle;
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var sector2 = this;
    var label = sector2.getTextContent();
    var dataIndex = this.node.dataIndex;
    var labelMinAngle = normalLabelModel.get("minAngle") / 180 * Math.PI;
    var isNormalShown = normalLabelModel.get("show") && !(labelMinAngle != null && Math.abs(angle4) < labelMinAngle);
    label.ignore = !isNormalShown;
    each$f(DISPLAY_STATES, function(stateName) {
      var labelStateModel = stateName === "normal" ? itemModel.getModel("label") : itemModel.getModel([stateName, "label"]);
      var isNormal = stateName === "normal";
      var state = isNormal ? label : label.ensureState(stateName);
      var text = seriesModel.getFormattedLabel(dataIndex, stateName);
      if (isNormal) {
        text = text || _this.node.name;
      }
      state.style = createTextStyle(labelStateModel, {}, null, stateName !== "normal", true);
      if (text) {
        state.style.text = text;
      }
      var isShown = labelStateModel.get("show");
      if (isShown != null && !isNormal) {
        state.ignore = !isShown;
      }
      var labelPosition = getLabelAttr(labelStateModel, "position");
      var sectorState = isNormal ? sector2 : sector2.states[stateName];
      var labelColor = sectorState.style.fill;
      sectorState.textConfig = {
        outsideFill: labelStateModel.get("color") === "inherit" ? labelColor : null,
        inside: labelPosition !== "outside"
      };
      var r;
      var labelPadding = getLabelAttr(labelStateModel, "distance") || 0;
      var textAlign = getLabelAttr(labelStateModel, "align");
      if (labelPosition === "outside") {
        r = layout2.r + labelPadding;
        textAlign = midAngle > Math.PI / 2 ? "right" : "left";
      } else {
        if (!textAlign || textAlign === "center") {
          if (angle4 === 2 * Math.PI && layout2.r0 === 0) {
            r = 0;
          } else {
            r = (layout2.r + layout2.r0) / 2;
          }
          textAlign = "center";
        } else if (textAlign === "left") {
          r = layout2.r0 + labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "right";
          }
        } else if (textAlign === "right") {
          r = layout2.r - labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "left";
          }
        }
      }
      state.style.align = textAlign;
      state.style.verticalAlign = getLabelAttr(labelStateModel, "verticalAlign") || "middle";
      state.x = r * dx + layout2.cx;
      state.y = r * dy + layout2.cy;
      var rotateType = getLabelAttr(labelStateModel, "rotate");
      var rotate2 = 0;
      if (rotateType === "radial") {
        rotate2 = -midAngle;
        if (rotate2 < -Math.PI / 2) {
          rotate2 += Math.PI;
        }
      } else if (rotateType === "tangential") {
        rotate2 = Math.PI / 2 - midAngle;
        if (rotate2 > Math.PI / 2) {
          rotate2 -= Math.PI;
        } else if (rotate2 < -Math.PI / 2) {
          rotate2 += Math.PI;
        }
      } else if (isNumber(rotateType)) {
        rotate2 = rotateType * Math.PI / 180;
      }
      state.rotation = rotate2;
    });
    function getLabelAttr(model, name2) {
      var stateAttr = model.get(name2);
      if (stateAttr == null) {
        return normalLabelModel.get(name2);
      }
      return stateAttr;
    }
    label.dirtyStyle();
  };
  return SunburstPiece2;
}(Sector$1);
var SunburstPiece$1 = SunburstPiece;
var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
var HIGHLIGHT_ACTION = "sunburstHighlight";
var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(registers) {
  registers.registerAction({
    type: ROOT_TO_NODE_ACTION,
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model, index2) {
      var targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
      if (targetInfo) {
        var originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
  registers.registerAction({
    type: HIGHLIGHT_ACTION,
    update: "none"
  }, function(payload, ecModel, api) {
    payload = extend2({}, payload);
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleHighlight);
    function handleHighlight(model) {
      var targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
      if (targetInfo) {
        payload.dataIndex = targetInfo.node.dataIndex;
      }
    }
    {
      deprecateReplaceLog("sunburstHighlight", "highlight");
    }
    api.dispatchAction(extend2(payload, {
      type: "highlight"
    }));
  });
  registers.registerAction({
    type: UNHIGHLIGHT_ACTION,
    update: "updateView"
  }, function(payload, ecModel, api) {
    payload = extend2({}, payload);
    {
      deprecateReplaceLog("sunburstUnhighlight", "downplay");
    }
    api.dispatchAction(extend2(payload, {
      type: "downplay"
    }));
  });
}
var SunburstView = function(_super) {
  __extends$1(SunburstView2, _super);
  function SunburstView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SunburstView2.type;
    return _this;
  }
  SunburstView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var self2 = this;
    this.seriesModel = seriesModel;
    this.api = api;
    this.ecModel = ecModel;
    var data = seriesModel.getData();
    var virtualRoot = data.tree.root;
    var newRoot = seriesModel.getViewRoot();
    var group = this.group;
    var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
    var newChildren = [];
    newRoot.eachNode(function(node) {
      newChildren.push(node);
    });
    var oldChildren = this._oldChildren || [];
    dualTravel(newChildren, oldChildren);
    renderRollUp(virtualRoot, newRoot);
    this._initEvents();
    this._oldChildren = newChildren;
    function dualTravel(newChildren2, oldChildren2) {
      if (newChildren2.length === 0 && oldChildren2.length === 0) {
        return;
      }
      new DataDiffer$1(oldChildren2, newChildren2, getKey2, getKey2).add(processNode).update(processNode).remove(curry$1(processNode, null)).execute();
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIdx, oldIdx) {
        var newNode = newIdx == null ? null : newChildren2[newIdx];
        var oldNode = oldIdx == null ? null : oldChildren2[oldIdx];
        doRenderNode(newNode, oldNode);
      }
    }
    function doRenderNode(newNode, oldNode) {
      if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
        newNode = null;
      }
      if (newNode !== virtualRoot && oldNode !== virtualRoot) {
        if (oldNode && oldNode.piece) {
          if (newNode) {
            oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api);
            data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
          } else {
            removeNode2(oldNode);
          }
        } else if (newNode) {
          var piece = new SunburstPiece$1(newNode, seriesModel, ecModel, api);
          group.add(piece);
          data.setItemGraphicEl(newNode.dataIndex, piece);
        }
      }
    }
    function removeNode2(node) {
      if (!node) {
        return;
      }
      if (node.piece) {
        group.remove(node.piece);
        node.piece = null;
      }
    }
    function renderRollUp(virtualRoot2, viewRoot) {
      if (viewRoot.depth > 0) {
        if (self2.virtualPiece) {
          self2.virtualPiece.updateData(false, virtualRoot2, seriesModel, ecModel, api);
        } else {
          self2.virtualPiece = new SunburstPiece$1(virtualRoot2, seriesModel, ecModel, api);
          group.add(self2.virtualPiece);
        }
        viewRoot.piece.off("click");
        self2.virtualPiece.on("click", function(e2) {
          self2._rootToNode(viewRoot.parentNode);
        });
      } else if (self2.virtualPiece) {
        group.remove(self2.virtualPiece);
        self2.virtualPiece = null;
      }
    }
  };
  SunburstView2.prototype._initEvents = function() {
    var _this = this;
    this.group.off("click");
    this.group.on("click", function(e2) {
      var targetFound = false;
      var viewRoot = _this.seriesModel.getViewRoot();
      viewRoot.eachNode(function(node) {
        if (!targetFound && node.piece && node.piece === e2.target) {
          var nodeClick = node.getModel().get("nodeClick");
          if (nodeClick === "rootToNode") {
            _this._rootToNode(node);
          } else if (nodeClick === "link") {
            var itemModel = node.getModel();
            var link2 = itemModel.get("link");
            if (link2) {
              var linkTarget = itemModel.get("target", true) || "_blank";
              windowOpen(link2, linkTarget);
            }
          }
          targetFound = true;
        }
      });
    });
  };
  SunburstView2.prototype._rootToNode = function(node) {
    if (node !== this.seriesModel.getViewRoot()) {
      this.api.dispatchAction({
        type: ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: node
      });
    }
  };
  SunburstView2.prototype.containPoint = function(point4, seriesModel) {
    var treeRoot = seriesModel.getData();
    var itemLayout = treeRoot.getItemLayout(0);
    if (itemLayout) {
      var dx = point4[0] - itemLayout.cx;
      var dy = point4[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  SunburstView2.type = "sunburst";
  return SunburstView2;
}(ChartView$1);
var SunburstView$1 = SunburstView;
var SunburstSeriesModel = function(_super) {
  __extends$1(SunburstSeriesModel2, _super);
  function SunburstSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SunburstSeriesModel2.type;
    _this.ignoreStyleOnData = true;
    return _this;
  }
  SunburstSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var root = {
      name: option.name,
      children: option.data
    };
    completeTreeValue(root);
    var levelModels = this._levelModels = map$1(option.levels || [], function(levelDefine) {
      return new Model$1(levelDefine, this, ecModel);
    }, this);
    var tree = Tree$1.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        var levelModel = levelModels[node.depth];
        levelModel && (model.parentModel = levelModel);
        return model;
      });
    }
    return tree.data;
  };
  SunburstSeriesModel2.prototype.optionUpdated = function() {
    this.resetViewRoot();
  };
  SunburstSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);
    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treePathInfo = wrapTreePathInfo(node, this);
    return params;
  };
  SunburstSeriesModel2.prototype.getLevelModel = function(node) {
    return this._levelModels && this._levelModels[node.depth];
  };
  SunburstSeriesModel2.prototype.getViewRoot = function() {
    return this._viewRoot;
  };
  SunburstSeriesModel2.prototype.resetViewRoot = function(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    var root = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  };
  SunburstSeriesModel2.prototype.enableAriaDecal = function() {
    enableAriaDecalForTree(this);
  };
  SunburstSeriesModel2.type = "series.sunburst";
  SunburstSeriesModel2.defaultOption = {
    z: 2,
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    minAngle: 0,
    stillShowZeroSum: true,
    nodeClick: "rootToNode",
    renderLabelForZeroData: false,
    label: {
      rotate: "radial",
      show: true,
      opacity: 1,
      align: "center",
      position: "inside",
      distance: 5,
      silent: true
    },
    itemStyle: {
      borderWidth: 1,
      borderColor: "white",
      borderType: "solid",
      shadowBlur: 0,
      shadowColor: "rgba(0, 0, 0, 0.2)",
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    emphasis: {
      focus: "descendant"
    },
    blur: {
      itemStyle: {
        opacity: 0.2
      },
      label: {
        opacity: 0.1
      }
    },
    animationType: "expansion",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    data: [],
    sort: "desc"
  };
  return SunburstSeriesModel2;
}(SeriesModel$1);
function completeTreeValue(dataNode) {
  var sum2 = 0;
  each$f(dataNode.children, function(child) {
    completeTreeValue(child);
    var childValue = child.value;
    isArray$1(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  var thisValue = dataNode.value;
  if (isArray$1(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray$1(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
var SunburstSeriesModel$1 = SunburstSeriesModel;
var RADIAN = Math.PI / 180;
function sunburstLayout(seriesType2, ecModel, api) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    var center2 = seriesModel.get("center");
    var radius = seriesModel.get("radius");
    if (!isArray$1(radius)) {
      radius = [0, radius];
    }
    if (!isArray$1(center2)) {
      center2 = [center2, center2];
    }
    var width = api.getWidth();
    var height = api.getHeight();
    var size11 = Math.min(width, height);
    var cx = parsePercent(center2[0], width);
    var cy = parsePercent(center2[1], height);
    var r0 = parsePercent(radius[0], size11 / 2);
    var r = parsePercent(radius[1], size11 / 2);
    var startAngle = -seriesModel.get("startAngle") * RADIAN;
    var minAngle = seriesModel.get("minAngle") * RADIAN;
    var virtualRoot = seriesModel.getData().tree.root;
    var treeRoot = seriesModel.getViewRoot();
    var rootDepth = treeRoot.depth;
    var sort4 = seriesModel.get("sort");
    if (sort4 != null) {
      initChildren(treeRoot, sort4);
    }
    var validDataCount = 0;
    each$f(treeRoot.children, function(child) {
      !isNaN(child.getValue()) && validDataCount++;
    });
    var sum2 = treeRoot.getValue();
    var unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    var renderRollupNode = treeRoot.depth > 0;
    var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
    var rPerLevel = (r - r0) / (levels || 1);
    var clockwise = seriesModel.get("clockwise");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var dir3 = clockwise ? 1 : -1;
    var renderNode2 = function(node, startAngle2) {
      if (!node) {
        return;
      }
      var endAngle = startAngle2;
      if (node !== virtualRoot) {
        var value = node.getValue();
        var angle5 = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        if (angle5 < minAngle) {
          angle5 = minAngle;
        }
        endAngle = startAngle2 + dir3 * angle5;
        var depth2 = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
        var rStart2 = r0 + rPerLevel * depth2;
        var rEnd2 = r0 + rPerLevel * (depth2 + 1);
        var levelModel = seriesModel.getLevelModel(node);
        if (levelModel) {
          var r0_1 = levelModel.get("r0", true);
          var r_1 = levelModel.get("r", true);
          var radius_1 = levelModel.get("radius", true);
          if (radius_1 != null) {
            r0_1 = radius_1[0];
            r_1 = radius_1[1];
          }
          r0_1 != null && (rStart2 = parsePercent(r0_1, size11 / 2));
          r_1 != null && (rEnd2 = parsePercent(r_1, size11 / 2));
        }
        node.setLayout({
          angle: angle5,
          startAngle: startAngle2,
          endAngle,
          clockwise,
          cx,
          cy,
          r0: rStart2,
          r: rEnd2
        });
      }
      if (node.children && node.children.length) {
        var siblingAngle_1 = 0;
        each$f(node.children, function(node2) {
          siblingAngle_1 += renderNode2(node2, startAngle2 + siblingAngle_1);
        });
      }
      return endAngle - startAngle2;
    };
    if (renderRollupNode) {
      var rStart = r0;
      var rEnd = r0 + rPerLevel;
      var angle4 = Math.PI * 2;
      virtualRoot.setLayout({
        angle: angle4,
        startAngle,
        endAngle: startAngle + angle4,
        clockwise,
        cx,
        cy,
        r0: rStart,
        r: rEnd
      });
    }
    renderNode2(treeRoot, startAngle);
  });
}
function initChildren(node, sortOrder) {
  var children = node.children || [];
  node.children = sort3(children, sortOrder);
  if (children.length) {
    each$f(node.children, function(child) {
      initChildren(child, sortOrder);
    });
  }
}
function sort3(children, sortOrder) {
  if (isFunction(sortOrder)) {
    var sortTargets = map$1(children, function(child, idx) {
      var value = child.getValue();
      return {
        params: {
          depth: child.depth,
          height: child.height,
          dataIndex: child.dataIndex,
          getValue: function() {
            return value;
          }
        },
        index: idx
      };
    });
    sortTargets.sort(function(a, b) {
      return sortOrder(a.params, b.params);
    });
    return map$1(sortTargets, function(target) {
      return children[target.index];
    });
  } else {
    var isAsc_1 = sortOrder === "asc";
    return children.sort(function(a, b) {
      var diff2 = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);
      return diff2 === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff2;
    });
  }
}
function sunburstVisual(ecModel) {
  var paletteScope = {};
  function pickColor(node, seriesModel, treeHeight) {
    var current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    var color = seriesModel.getColorFromPalette(current.name || current.dataIndex + "", paletteScope);
    if (node.depth > 1 && isString(color)) {
      color = lift(color, (node.depth - 1) / (treeHeight - 1) * 0.5);
    }
    return color;
  }
  ecModel.eachSeriesByType("sunburst", function(seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    tree.eachNode(function(node) {
      var model = node.getModel();
      var style = model.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = pickColor(node, seriesModel, tree.root.height);
      }
      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend2(existsStyle, style);
    });
  });
}
function install$s(registers) {
  registers.registerChartView(SunburstView$1);
  registers.registerSeriesModel(SunburstSeriesModel$1);
  registers.registerLayout(curry$1(sunburstLayout, "sunburst"));
  registers.registerProcessor(curry$1(dataFilter$1, "sunburst"));
  registers.registerVisual(sunburstVisual);
  installSunburstAction(registers);
}
var STYLE_VISUAL_TYPE = {
  color: "fill",
  borderColor: "stroke"
};
var NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
};
var customInnerStore = makeInner();
var CustomSeriesModel = function(_super) {
  __extends$1(CustomSeriesModel2, _super);
  function CustomSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CustomSeriesModel2.type;
    return _this;
  }
  CustomSeriesModel2.prototype.optionUpdated = function() {
    this.currentZLevel = this.get("zlevel", true);
    this.currentZ = this.get("z", true);
  };
  CustomSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this);
  };
  CustomSeriesModel2.prototype.getDataParams = function(dataIndex, dataType, el) {
    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
    el && (params.info = customInnerStore(el).info);
    return params;
  };
  CustomSeriesModel2.type = "series.custom";
  CustomSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
  CustomSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    legendHoverLink: true,
    clip: false
  };
  return CustomSeriesModel2;
}(SeriesModel$1);
var CustomSeriesModel$1 = CustomSeriesModel;
function dataToCoordSize$3(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map$1(["x", "y"], function(dim, dimIdx) {
    var axis = this.getAxis(dim);
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }, this);
}
function cartesianPrepareCustom(coordSys) {
  var rect = coordSys.master.getRect();
  return {
    coordSys: {
      type: "cartesian2d",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind$1(dataToCoordSize$3, coordSys)
    }
  };
}
function dataToCoordSize$2(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map$1([0, 1], function(dimIdx) {
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var p1 = [];
    var p2 = [];
    p1[dimIdx] = val - halfSize;
    p2[dimIdx] = val + halfSize;
    p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
  }, this);
}
function geoPrepareCustom(coordSys) {
  var rect = coordSys.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      zoom: coordSys.getZoom()
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind$1(dataToCoordSize$2, coordSys)
    }
  };
}
function dataToCoordSize$1(dataSize, dataItem) {
  var axis = this.getAxis();
  var val = dataItem instanceof Array ? dataItem[0] : dataItem;
  var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
  return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
}
function singlePrepareCustom(coordSys) {
  var rect = coordSys.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(val) {
        return coordSys.dataToPoint(val);
      },
      size: bind$1(dataToCoordSize$1, coordSys)
    }
  };
}
function dataToCoordSize(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map$1(["Radius", "Angle"], function(dim, dimIdx) {
    var getterName = "get" + dim + "Axis";
    var axis = this[getterName]();
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    if (dim === "Angle") {
      result = result * Math.PI / 180;
    }
    return result;
  }, this);
}
function polarPrepareCustom(coordSys) {
  var radiusAxis = coordSys.getRadiusAxis();
  var angleAxis = coordSys.getAngleAxis();
  var radius = radiusAxis.getExtent();
  radius[0] > radius[1] && radius.reverse();
  return {
    coordSys: {
      type: "polar",
      cx: coordSys.cx,
      cy: coordSys.cy,
      r: radius[1],
      r0: radius[0]
    },
    api: {
      coord: function(data) {
        var radius2 = radiusAxis.dataToRadius(data[0]);
        var angle4 = angleAxis.dataToAngle(data[1]);
        var coord = coordSys.coordToPoint([radius2, angle4]);
        coord.push(radius2, angle4 * Math.PI / 180);
        return coord;
      },
      size: bind$1(dataToCoordSize, coordSys)
    }
  };
}
function calendarPrepareCustom(coordSys) {
  var rect = coordSys.getRect();
  var rangeInfo = coordSys.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      cellWidth: coordSys.getCellWidth(),
      cellHeight: coordSys.getCellHeight(),
      rangeInfo: {
        start: rangeInfo.start,
        end: rangeInfo.end,
        weeks: rangeInfo.weeks,
        dayCount: rangeInfo.allDay
      }
    },
    api: {
      coord: function(data, clamp3) {
        return coordSys.dataToPoint(data, clamp3);
      }
    }
  };
}
var deprecatedLogs = {};
function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
}
function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
  var srcStyle = hostStyle;
  var textConfig;
  var textContent;
  var textContentStyle;
  if (elType === "text") {
    textContentStyle = srcStyle;
  } else {
    textContentStyle = {};
    hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
    hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
    hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
    hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
    hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
    hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
    hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
    hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
    textContent = {
      type: "text",
      style: textContentStyle,
      silent: true
    };
    textConfig = {};
    var hasOwnPos = hasOwn(srcStyle, "textPosition");
    if (isNormal) {
      textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
    } else {
      hasOwnPos && (textConfig.position = srcStyle.textPosition);
    }
    hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
    hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
    hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
    hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
  }
  convertEC4CompatibleRichItem(textContentStyle, hostStyle);
  each$f(textContentStyle.rich, function(richItem) {
    convertEC4CompatibleRichItem(richItem, richItem);
  });
  return {
    textConfig,
    textContent
  };
}
function convertEC4CompatibleRichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  richItem.font = richItem.textFont || richItem.font;
  hasOwn(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
  hasOwn(richItem, "textAlign") && (out2.align = richItem.textAlign);
  hasOwn(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
  hasOwn(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
  hasOwn(richItem, "textWidth") && (out2.width = richItem.textWidth);
  hasOwn(richItem, "textHeight") && (out2.height = richItem.textHeight);
  hasOwn(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
  hasOwn(richItem, "textPadding") && (out2.padding = richItem.textPadding);
  hasOwn(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
  hasOwn(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
  hasOwn(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
  hasOwn(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
  hasOwn(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
  hasOwn(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
  hasOwn(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
  var out2 = itemStl;
  out2.textPosition = out2.textPosition || txCfg.position || "inside";
  txCfg.offset != null && (out2.textOffset = txCfg.offset);
  txCfg.rotation != null && (out2.textRotation = txCfg.rotation);
  txCfg.distance != null && (out2.textDistance = txCfg.distance);
  var isInside2 = out2.textPosition.indexOf("inside") >= 0;
  var hostFill = itemStl.fill || "#000";
  convertToEC4RichItem(out2, txStl);
  var textFillNotSet = out2.textFill == null;
  if (isInside2) {
    if (textFillNotSet) {
      out2.textFill = txCfg.insideFill || "#fff";
      !out2.textStroke && txCfg.insideStroke && (out2.textStroke = txCfg.insideStroke);
      !out2.textStroke && (out2.textStroke = hostFill);
      out2.textStrokeWidth == null && (out2.textStrokeWidth = 2);
    }
  } else {
    if (textFillNotSet) {
      out2.textFill = itemStl.fill || txCfg.outsideFill || "#000";
    }
    !out2.textStroke && txCfg.outsideStroke && (out2.textStroke = txCfg.outsideStroke);
  }
  out2.text = txStl.text;
  out2.rich = txStl.rich;
  each$f(txStl.rich, function(richItem) {
    convertToEC4RichItem(richItem, richItem);
  });
  return out2;
}
function convertToEC4RichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  hasOwn(richItem, "fill") && (out2.textFill = richItem.fill);
  hasOwn(richItem, "stroke") && (out2.textStroke = richItem.fill);
  hasOwn(richItem, "lineWidth") && (out2.textStrokeWidth = richItem.lineWidth);
  hasOwn(richItem, "font") && (out2.font = richItem.font);
  hasOwn(richItem, "fontStyle") && (out2.fontStyle = richItem.fontStyle);
  hasOwn(richItem, "fontWeight") && (out2.fontWeight = richItem.fontWeight);
  hasOwn(richItem, "fontSize") && (out2.fontSize = richItem.fontSize);
  hasOwn(richItem, "fontFamily") && (out2.fontFamily = richItem.fontFamily);
  hasOwn(richItem, "align") && (out2.textAlign = richItem.align);
  hasOwn(richItem, "verticalAlign") && (out2.textVerticalAlign = richItem.verticalAlign);
  hasOwn(richItem, "lineHeight") && (out2.textLineHeight = richItem.lineHeight);
  hasOwn(richItem, "width") && (out2.textWidth = richItem.width);
  hasOwn(richItem, "height") && (out2.textHeight = richItem.height);
  hasOwn(richItem, "backgroundColor") && (out2.textBackgroundColor = richItem.backgroundColor);
  hasOwn(richItem, "padding") && (out2.textPadding = richItem.padding);
  hasOwn(richItem, "borderColor") && (out2.textBorderColor = richItem.borderColor);
  hasOwn(richItem, "borderWidth") && (out2.textBorderWidth = richItem.borderWidth);
  hasOwn(richItem, "borderRadius") && (out2.textBorderRadius = richItem.borderRadius);
  hasOwn(richItem, "shadowColor") && (out2.textBoxShadowColor = richItem.shadowColor);
  hasOwn(richItem, "shadowBlur") && (out2.textBoxShadowBlur = richItem.shadowBlur);
  hasOwn(richItem, "shadowOffsetX") && (out2.textBoxShadowOffsetX = richItem.shadowOffsetX);
  hasOwn(richItem, "shadowOffsetY") && (out2.textBoxShadowOffsetY = richItem.shadowOffsetY);
  hasOwn(richItem, "textShadowColor") && (out2.textShadowColor = richItem.textShadowColor);
  hasOwn(richItem, "textShadowBlur") && (out2.textShadowBlur = richItem.textShadowBlur);
  hasOwn(richItem, "textShadowOffsetX") && (out2.textShadowOffsetX = richItem.textShadowOffsetX);
  hasOwn(richItem, "textShadowOffsetY") && (out2.textShadowOffsetY = richItem.textShadowOffsetY);
}
function warnDeprecated(deprecated, insteadApproach) {
  {
    var key = deprecated + "^_^" + insteadApproach;
    if (!deprecatedLogs[key]) {
      console.warn('[ECharts] DEPRECATED: "' + deprecated + '" has been deprecated. ' + insteadApproach);
      deprecatedLogs[key] = true;
    }
  }
}
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
};
var LEGACY_TRANSFORM_PROPS = keys2(LEGACY_TRANSFORM_PROPS_MAP);
var TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key) {
  obj[key] = 1;
  return obj;
}, {});
var transformPropNamesStr = TRANSFORMABLE_PROPS.join(", ");
var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
var transitionInnerStore = makeInner();
function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
  var animationProp = animationType + "Animation";
  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
  var userDuring = transitionInnerStore(el).userDuring;
  if (config.duration > 0) {
    config.during = userDuring ? bind$1(duringCall, {
      el,
      userDuring
    }) : null;
    config.setToFinal = true;
    config.scope = animationType;
  }
  extend2(config, elOption[animationProp]);
  return config;
}
function applyUpdateTransition(el, elOption, animatableModel, opts) {
  opts = opts || {};
  var dataIndex = opts.dataIndex, isInit = opts.isInit, clearStyle = opts.clearStyle;
  var hasAnimation = animatableModel.isAnimationEnabled();
  var store = transitionInnerStore(el);
  var styleOpt = elOption.style;
  store.userDuring = elOption.during;
  var transFromProps = {};
  var propsToSet = {};
  prepareTransformAllPropsFinal(el, elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
  if (!isInit && hasAnimation) {
    prepareTransformTransitionFrom(el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
  }
  propsToSet.style = styleOpt;
  applyPropsDirectly(el, propsToSet, clearStyle);
  applyMiscProps(el, elOption);
  if (hasAnimation) {
    if (isInit) {
      var enterFromProps_1 = {};
      each$f(ELEMENT_ANIMATABLE_PROPS, function(propName) {
        var prop = propName ? elOption[propName] : elOption;
        if (prop && prop.enterFrom) {
          if (propName) {
            enterFromProps_1[propName] = enterFromProps_1[propName] || {};
          }
          extend2(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
        }
      });
      var config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(enterFromProps_1, config);
      }
    } else {
      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
    }
  }
  updateLeaveTo(el, elOption);
  styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
  var leaveToProps = transitionInnerStore(el).leaveToProps;
  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
    var propName = ELEMENT_ANIMATABLE_PROPS[i];
    var prop = propName ? elOption[propName] : elOption;
    if (prop && prop.leaveTo) {
      if (!leaveToProps) {
        leaveToProps = transitionInnerStore(el).leaveToProps = {};
      }
      if (propName) {
        leaveToProps[propName] = leaveToProps[propName] || {};
      }
      extend2(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
    }
  }
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
  if (el) {
    var parent_1 = el.parent;
    var leaveToProps = transitionInnerStore(el).leaveToProps;
    if (leaveToProps) {
      var config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
      config.done = function() {
        parent_1.remove(el);
        onRemove && onRemove();
      };
      el.animateTo(leaveToProps, config);
    } else {
      parent_1.remove(el);
      onRemove && onRemove();
    }
  }
}
function isTransitionAll(transition) {
  return transition === "all";
}
function applyPropsDirectly(el, allPropsFinal, clearStyle) {
  var styleOpt = allPropsFinal.style;
  if (!el.isGroup && styleOpt) {
    if (clearStyle) {
      el.useStyle({});
      var animators = el.animators;
      for (var i = 0; i < animators.length; i++) {
        var animator = animators[i];
        if (animator.targetName === "style") {
          animator.changeTarget(el.style);
        }
      }
    }
    el.setStyle(styleOpt);
  }
  if (allPropsFinal) {
    allPropsFinal.style = null;
    allPropsFinal && el.attr(allPropsFinal);
    allPropsFinal.style = styleOpt;
  }
}
function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
  if (transFromProps) {
    var config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
    if (config.duration > 0) {
      el.animateFrom(transFromProps, config);
    }
  }
}
function applyMiscProps(el, elOption) {
  hasOwn(elOption, "silent") && (el.silent = elOption.silent);
  hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
  if (el instanceof Displayable$1) {
    hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
  }
  if (el instanceof Path$1) {
    hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
  }
}
var tmpDuringScope = {};
var transitionDuringAPI = {
  setTransform: function(key, val) {
    {
      assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `setTransform`.");
    }
    tmpDuringScope.el[key] = val;
    return this;
  },
  getTransform: function(key) {
    {
      assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `getTransform`.");
    }
    return tmpDuringScope.el[key];
  },
  setShape: function(key, val) {
    {
      assertNotReserved(key);
    }
    var el = tmpDuringScope.el;
    var shape = el.shape || (el.shape = {});
    shape[key] = val;
    el.dirtyShape && el.dirtyShape();
    return this;
  },
  getShape: function(key) {
    {
      assertNotReserved(key);
    }
    var shape = tmpDuringScope.el.shape;
    if (shape) {
      return shape[key];
    }
  },
  setStyle: function(key, val) {
    {
      assertNotReserved(key);
    }
    var el = tmpDuringScope.el;
    var style = el.style;
    if (style) {
      {
        if (eqNaN(val)) {
          warn("style." + key + " must not be assigned with NaN.");
        }
      }
      style[key] = val;
      el.dirtyStyle && el.dirtyStyle();
    }
    return this;
  },
  getStyle: function(key) {
    {
      assertNotReserved(key);
    }
    var style = tmpDuringScope.el.style;
    if (style) {
      return style[key];
    }
  },
  setExtra: function(key, val) {
    {
      assertNotReserved(key);
    }
    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key] = val;
    return this;
  },
  getExtra: function(key) {
    {
      assertNotReserved(key);
    }
    var extra = tmpDuringScope.el.extra;
    if (extra) {
      return extra[key];
    }
  }
};
function assertNotReserved(key) {
  {
    if (key === "transition" || key === "enterFrom" || key === "leaveTo") {
      throw new Error('key must not be "' + key + '"');
    }
  }
}
function duringCall() {
  var scope = this;
  var el = scope.el;
  if (!el) {
    return;
  }
  var latestUserDuring = transitionInnerStore(el).userDuring;
  var scopeUserDuring = scope.userDuring;
  if (latestUserDuring !== scopeUserDuring) {
    scope.el = scope.userDuring = null;
    return;
  }
  tmpDuringScope.el = el;
  scopeUserDuring(transitionDuringAPI);
}
function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
  var attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  var elPropsInAttr = fromEl[mainAttr];
  var transFromPropsInAttr;
  if (elPropsInAttr) {
    var transition = elOption.transition;
    var attrTransition = attrOpt.transition;
    if (attrTransition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      if (isTransitionAll(attrTransition)) {
        extend2(transFromPropsInAttr, elPropsInAttr);
      } else {
        var transitionKeys = normalizeToArray(attrTransition);
        for (var i = 0; i < transitionKeys.length; i++) {
          var key = transitionKeys[i];
          var elVal = elPropsInAttr[key];
          transFromPropsInAttr[key] = elVal;
        }
      }
    } else if (isTransitionAll(transition) || indexOf2(transition, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      var elPropsInAttrKeys = keys2(elPropsInAttr);
      for (var i = 0; i < elPropsInAttrKeys.length; i++) {
        var key = elPropsInAttrKeys[i];
        var elVal = elPropsInAttr[key];
        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
          transFromPropsInAttr[key] = elVal;
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  var attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  var allPropsInAttr = allProps[mainAttr] = {};
  var keysInAttr = keys2(attrOpt);
  for (var i = 0; i < keysInAttr.length; i++) {
    var key = keysInAttr[i];
    allPropsInAttr[key] = cloneValue(attrOpt[key]);
  }
}
function prepareTransformTransitionFrom(el, elOption, transFromProps) {
  var transition = elOption.transition;
  var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
  for (var i = 0; i < transitionKeys.length; i++) {
    var key = transitionKeys[i];
    if (key === "style" || key === "shape" || key === "extra") {
      continue;
    }
    var elVal = el[key];
    {
      checkTransformPropRefer(key, "el.transition");
    }
    transFromProps[key] = elVal;
  }
}
function prepareTransformAllPropsFinal(el, elOption, allProps) {
  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
    var legacyName = LEGACY_TRANSFORM_PROPS[i];
    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
    var legacyArr = elOption[legacyName];
    if (legacyArr) {
      allProps[xyName[0]] = legacyArr[0];
      allProps[xyName[1]] = legacyArr[1];
    }
  }
  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    var key = TRANSFORMABLE_PROPS[i];
    if (elOption[key] != null) {
      allProps[key] = elOption[key];
    }
  }
}
function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
  if (!styleOpt) {
    return;
  }
  var fromElStyle = fromEl.style;
  var transFromStyleProps;
  if (fromElStyle) {
    var styleTransition = styleOpt.transition;
    var elTransition = elOption.transition;
    if (styleTransition && !isTransitionAll(styleTransition)) {
      var transitionKeys = normalizeToArray(styleTransition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
      for (var i = 0; i < transitionKeys.length; i++) {
        var key = transitionKeys[i];
        var elVal = fromElStyle[key];
        transFromStyleProps[key] = elVal;
      }
    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf2(elTransition, "style") >= 0)) {
      var animationProps = fromEl.getAnimationStyleProps();
      var animationStyleProps = animationProps ? animationProps.style : null;
      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        var styleKeys = keys2(styleOpt);
        for (var i = 0; i < styleKeys.length; i++) {
          var key = styleKeys[i];
          if (animationStyleProps[key]) {
            var elVal = fromElStyle[key];
            transFromStyleProps[key] = elVal;
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(optVal, elVal) {
  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}
var checkTransformPropRefer;
{
  checkTransformPropRefer = function(key, usedIn) {
    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {
      warn("Prop `" + key + "` is not a permitted in `" + usedIn + "`. Only `" + keys2(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
    }
  };
}
var getStateToRestore = makeInner();
var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(el) {
  el.stopAnimation("keyframe");
  el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
  if (!animatableModel.isAnimationEnabled() || !animationOpts) {
    return;
  }
  if (isArray$1(animationOpts)) {
    each$f(animationOpts, function(singleAnimationOpts) {
      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
    });
    return;
  }
  var keyframes = animationOpts.keyframes;
  var duration = animationOpts.duration;
  if (animatableModel && duration == null) {
    var config = getAnimationConfig("enter", animatableModel, 0);
    duration = config && config.duration;
  }
  if (!keyframes || !duration) {
    return;
  }
  var stateToRestore = getStateToRestore(el);
  each$f(ELEMENT_ANIMATABLE_PROPS, function(targetPropName) {
    if (targetPropName && !el[targetPropName]) {
      return;
    }
    var animator;
    var endFrameIsSet = false;
    keyframes.sort(function(a, b) {
      return a.percent - b.percent;
    });
    each$f(keyframes, function(kf) {
      var animators = el.animators;
      var kfValues = targetPropName ? kf[targetPropName] : kf;
      {
        if (kf.percent >= 1) {
          endFrameIsSet = true;
        }
      }
      if (!kfValues) {
        return;
      }
      var propKeys = keys2(kfValues);
      if (!targetPropName) {
        propKeys = filter17(propKeys, function(key) {
          return indexOf2(KEYFRAME_EXCLUDE_KEYS, key) < 0;
        });
      }
      if (!propKeys.length) {
        return;
      }
      if (!animator) {
        animator = el.animate(targetPropName, animationOpts.loop, true);
        animator.scope = "keyframe";
      }
      for (var i = 0; i < animators.length; i++) {
        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
          animators[i].stopTracks(propKeys);
        }
      }
      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
      var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
      each$f(propKeys, function(key) {
        savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];
      });
      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
    });
    if (!animator) {
      return;
    }
    {
      if (!endFrameIsSet) {
        warn("End frame with percent: 1 is missing in the keyframeAnimation.", true);
      }
    }
    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
  });
}
var EMPHASIS = "emphasis";
var NORMAL = "normal";
var BLUR = "blur";
var SELECT = "select";
var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
var PATH_ITEM_STYLE = {
  normal: ["itemStyle"],
  emphasis: [EMPHASIS, "itemStyle"],
  blur: [BLUR, "itemStyle"],
  select: [SELECT, "itemStyle"]
};
var PATH_LABEL = {
  normal: ["label"],
  emphasis: [EMPHASIS, "label"],
  blur: [BLUR, "label"],
  select: [SELECT, "label"]
};
var DEFAULT_TRANSITION = ["x", "y"];
var GROUP_DIFF_PREFIX = "e\0\0";
var attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
};
var prepareCustoms = {
  cartesian2d: cartesianPrepareCustom,
  geo: geoPrepareCustom,
  single: singlePrepareCustom,
  polar: polarPrepareCustom,
  calendar: calendarPrepareCustom
};
function isPath(el) {
  return el instanceof Path$1;
}
function isDisplayable(el) {
  return el instanceof Displayable$1;
}
function copyElement(sourceEl, targetEl) {
  targetEl.copyTransform(sourceEl);
  if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
    targetEl.setStyle(sourceEl.style);
    targetEl.z = sourceEl.z;
    targetEl.z2 = sourceEl.z2;
    targetEl.zlevel = sourceEl.zlevel;
    targetEl.invisible = sourceEl.invisible;
    targetEl.ignore = sourceEl.ignore;
    if (isPath(targetEl) && isPath(sourceEl)) {
      targetEl.setShape(sourceEl.shape);
    }
  }
}
var CustomChartView = function(_super) {
  __extends$1(CustomChartView2, _super);
  function CustomChartView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CustomChartView2.type;
    return _this;
  }
  CustomChartView2.prototype.render = function(customSeries, ecModel, api, payload) {
    this._progressiveEls = null;
    var oldData = this._data;
    var data = customSeries.getData();
    var group = this.group;
    var renderItem = makeRenderItem(customSeries, data, ecModel, api);
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && applyLeaveTransition(el, customInnerStore(el).option, customSeries);
    }).update(function(newIdx, oldIdx) {
      var oldEl = oldData.getItemGraphicEl(oldIdx);
      createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).execute();
    var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
    this._data = data;
  };
  CustomChartView2.prototype.incrementalPrepareRender = function(customSeries, ecModel, api) {
    this.group.removeAll();
    this._data = null;
  };
  CustomChartView2.prototype.incrementalRender = function(params, customSeries, ecModel, api, payload) {
    var data = customSeries.getData();
    var renderItem = makeRenderItem(customSeries, data, ecModel, api);
    var progressiveEls = this._progressiveEls = [];
    function setIncrementalAndHoverLayer(el2) {
      if (!el2.isGroup) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = params.start; idx < params.end; idx++) {
      var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
      if (el) {
        el.traverse(setIncrementalAndHoverLayer);
        progressiveEls.push(el);
      }
    }
  };
  CustomChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  CustomChartView2.prototype.filterForExposedEvent = function(eventType, query5, targetEl, packedEvent) {
    var elementName = query5.element;
    if (elementName == null || targetEl.name === elementName) {
      return true;
    }
    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
      if (targetEl.name === elementName) {
        return true;
      }
    }
    return false;
  };
  CustomChartView2.type = "custom";
  return CustomChartView2;
}(ChartView$1);
var CustomChartView$1 = CustomChartView;
function createEl$1(elOption) {
  var graphicType = elOption.type;
  var el;
  if (graphicType === "path") {
    var shape = elOption.shape;
    var pathRect = shape.width != null && shape.height != null ? {
      x: shape.x || 0,
      y: shape.y || 0,
      width: shape.width,
      height: shape.height
    } : null;
    var pathData = getPathData(shape);
    el = makePath(pathData, null, pathRect, shape.layout || "center");
    customInnerStore(el).customPathData = pathData;
  } else if (graphicType === "image") {
    el = new ZRImage$1({});
    customInnerStore(el).customImagePath = elOption.style.image;
  } else if (graphicType === "text") {
    el = new ZRText$1({});
  } else if (graphicType === "group") {
    el = new Group$4();
  } else if (graphicType === "compoundPath") {
    throw new Error('"compoundPath" is not supported yet.');
  } else {
    var Clz = getShapeClass(graphicType);
    if (!Clz) {
      var errMsg = "";
      {
        errMsg = 'graphic type "' + graphicType + '" can not be found.';
      }
      throwError(errMsg);
    }
    el = new Clz();
  }
  customInnerStore(el).customGraphicType = graphicType;
  el.name = elOption.name;
  el.z2EmphasisLift = 1;
  el.z2SelectLift = 1;
  return el;
}
function updateElNormal(api, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
  stopPreviousKeyframeAnimationAndRestore(el);
  var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
  if (txCfgOpt) {
    el.setTextConfig(txCfgOpt);
  }
  if (elOption && elOption.transition == null) {
    elOption.transition = DEFAULT_TRANSITION;
  }
  var styleOpt = elOption && elOption.style;
  if (styleOpt) {
    if (el.type === "text") {
      var textOptionStyle = styleOpt;
      hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
      hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
    }
    var decalPattern = void 0;
    var decalObj = isPath(el) ? styleOpt.decal : null;
    if (api && decalObj) {
      decalObj.dirty = true;
      decalPattern = createOrUpdatePatternFromDecal(decalObj, api);
    }
    styleOpt.__decalPattern = decalPattern;
  }
  if (isDisplayable(el)) {
    if (styleOpt) {
      var decalPattern = styleOpt.__decalPattern;
      if (decalPattern) {
        styleOpt.decal = decalPattern;
      }
    }
  }
  applyUpdateTransition(el, elOption, seriesModel, {
    dataIndex,
    isInit,
    clearStyle: true
  });
  applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
}
function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
  var elDisplayable = el.isGroup ? null : el;
  var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
  if (elDisplayable) {
    var stateObj = elDisplayable.ensureState(state);
    if (styleOpt === false) {
      var existingEmphasisState = elDisplayable.getState(state);
      if (existingEmphasisState) {
        existingEmphasisState.style = null;
      }
    } else {
      stateObj.style = styleOpt || null;
    }
    if (txCfgOpt) {
      stateObj.textConfig = txCfgOpt;
    }
    setDefaultStateProxy(elDisplayable);
  }
}
function updateZ(el, elOption, seriesModel) {
  if (el.isGroup) {
    return;
  }
  var elDisplayable = el;
  var currentZ = seriesModel.currentZ;
  var currentZLevel = seriesModel.currentZLevel;
  elDisplayable.z = currentZ;
  elDisplayable.zlevel = currentZLevel;
  var optZ2 = elOption.z2;
  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
  for (var i = 0; i < STATES.length; i++) {
    updateZForEachState(elDisplayable, elOption, STATES[i]);
  }
}
function updateZForEachState(elDisplayable, elOption, state) {
  var isNormal = state === NORMAL;
  var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
  var optZ2 = elStateOpt ? elStateOpt.z2 : null;
  var stateObj;
  if (optZ2 != null) {
    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
    stateObj.z2 = optZ2 || 0;
  }
}
function makeRenderItem(customSeries, data, ecModel, api) {
  var renderItem = customSeries.get("renderItem");
  var coordSys = customSeries.coordinateSystem;
  var prepareResult3 = {};
  if (coordSys) {
    {
      assert(renderItem, "series.render is required.");
      assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], "This coordSys does not support custom series.");
    }
    prepareResult3 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
  }
  var userAPI = defaults({
    getWidth: api.getWidth,
    getHeight: api.getHeight,
    getZr: api.getZr,
    getDevicePixelRatio: api.getDevicePixelRatio,
    value,
    style,
    ordinalRawValue,
    styleEmphasis,
    visual,
    barLayout,
    currentSeriesIndices,
    font
  }, prepareResult3.api || {});
  var userParams = {
    context: {},
    seriesId: customSeries.id,
    seriesName: customSeries.name,
    seriesIndex: customSeries.seriesIndex,
    coordSys: prepareResult3.coordSys,
    dataInsideLength: data.count(),
    encode: wrapEncodeDef(customSeries.getData())
  };
  var currDataIndexInside;
  var currItemModel;
  var currItemStyleModels = {};
  var currLabelModels = {};
  var seriesItemStyleModels = {};
  var seriesLabelModels = {};
  for (var i = 0; i < STATES.length; i++) {
    var stateName = STATES[i];
    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
  }
  function getItemModel2(dataIndexInside) {
    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
  }
  function getItemStyleModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
  }
  function getLabelModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel2(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel2(dataIndexInside).getModel(PATH_LABEL[state]);
  }
  return function(dataIndexInside, payload) {
    currDataIndexInside = dataIndexInside;
    currItemModel = null;
    currItemStyleModels = {};
    currLabelModels = {};
    return renderItem && renderItem(defaults({
      dataIndexInside,
      dataIndex: data.getRawIndex(dataIndexInside),
      actionType: payload ? payload.type : null
    }, userParams), userAPI);
  };
  function value(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
  }
  function ordinalRawValue(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    dim = dim || 0;
    var dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo) {
      var dimIndex = data.getDimensionIndex(dim);
      return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
    }
    var val = data.get(dimInfo.name, dataIndexInside);
    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.categories[val] : val;
  }
  function style(userProps, dataIndexInside) {
    {
      warnDeprecated("api.style", "Please write literal style directly instead.");
    }
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var style2 = data.getItemVisual(dataIndexInside, "style");
    var visualColor = style2 && style2.fill;
    var opacity = style2 && style2.opacity;
    var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
    visualColor != null && (itemStyle.fill = visualColor);
    opacity != null && (itemStyle.opacity = opacity);
    var opt = {
      inheritColor: isString(visualColor) ? visualColor : "#000"
    };
    var labelModel = getLabelModel(dataIndexInside, NORMAL);
    var textStyle = createTextStyle(labelModel, null, opt, false, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    var textConfig = createTextConfig(labelModel, opt, false);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function styleEmphasis(userProps, dataIndexInside) {
    {
      warnDeprecated("api.styleEmphasis", "Please write literal style directly instead.");
    }
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
    var labelModel = getLabelModel(dataIndexInside, EMPHASIS);
    var textStyle = createTextStyle(labelModel, null, null, true, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    var textConfig = createTextConfig(labelModel, null, true);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function applyUserPropsAfter(itemStyle, extra) {
    for (var key in extra) {
      if (hasOwn(extra, key)) {
        itemStyle[key] = extra[key];
      }
    }
  }
  function preFetchFromExtra(extra, itemStyle) {
    if (extra) {
      extra.textFill && (itemStyle.textFill = extra.textFill);
      extra.textPosition && (itemStyle.textPosition = extra.textPosition);
    }
  }
  function visual(visualType, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
      var style_1 = data.getItemVisual(dataIndexInside, "style");
      return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;
    }
    if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
      return data.getItemVisual(dataIndexInside, visualType);
    }
  }
  function barLayout(opt) {
    if (coordSys.type === "cartesian2d") {
      var baseAxis = coordSys.getBaseAxis();
      return getLayoutOnAxis(defaults({
        axis: baseAxis
      }, opt));
    }
  }
  function currentSeriesIndices() {
    return ecModel.getCurrentSeriesIndices();
  }
  function font(opt) {
    return getFont(opt, ecModel);
  }
}
function wrapEncodeDef(data) {
  var encodeDef = {};
  each$f(data.dimensions, function(dimName) {
    var dimInfo = data.getDimensionInfo(dimName);
    if (!dimInfo.isExtraCoord) {
      var coordDim = dimInfo.coordDim;
      var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
      dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
    }
  });
  return encodeDef;
}
function createOrUpdateItem(api, existsEl, dataIndex, elOption, seriesModel, group, data) {
  if (!elOption) {
    group.remove(existsEl);
    return;
  }
  var el = doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group);
  el && data.setItemGraphicEl(dataIndex, el);
  el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
  return el;
}
function doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group) {
  {
    assert(elOption, "should not have an null/undefined element setting");
  }
  var toBeReplacedIdx = -1;
  var oldEl = existsEl;
  if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
    toBeReplacedIdx = indexOf2(group.childrenRef(), existsEl);
    existsEl = null;
  }
  var isInit = !existsEl;
  var el = existsEl;
  if (!el) {
    el = createEl$1(elOption);
    if (oldEl) {
      copyElement(oldEl, el);
    }
  } else {
    el.clearStates();
  }
  if (elOption.morph === false) {
    el.disableMorphing = true;
  } else if (el.disableMorphing) {
    el.disableMorphing = false;
  }
  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
  attachedTxInfoTmp.isLegacy = false;
  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
  updateElNormal(api, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
  hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
  for (var i = 0; i < STATES.length; i++) {
    var stateName = STATES[i];
    if (stateName !== NORMAL) {
      var otherStateOpt = retrieveStateOption(elOption, stateName);
      var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
    }
  }
  updateZ(el, elOption, seriesModel);
  if (elOption.type === "group") {
    mergeChildren(api, el, dataIndex, elOption, seriesModel);
  }
  if (toBeReplacedIdx >= 0) {
    group.replaceAt(el, toBeReplacedIdx);
  } else {
    group.add(el);
  }
  return el;
}
function doesElNeedRecreate(el, elOption, seriesModel) {
  var elInner = customInnerStore(el);
  var elOptionType = elOption.type;
  var elOptionShape = elOption.shape;
  var elOptionStyle = elOption.style;
  return seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath;
}
function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
  var clipPathOpt = elOption.clipPath;
  if (clipPathOpt === false) {
    if (el && el.getClipPath()) {
      el.removeClipPath();
    }
  } else if (clipPathOpt) {
    var clipPath = el.getClipPath();
    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
      clipPath = null;
    }
    if (!clipPath) {
      clipPath = createEl$1(clipPathOpt);
      {
        assert(isPath(clipPath), "Only any type of `path` can be used in `clipPath`, rather than " + clipPath.type + ".");
      }
      el.setClipPath(clipPath);
    }
    updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
  }
}
function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
  if (el.isGroup) {
    return;
  }
  processTxInfo(elOption, null, attachedTxInfo);
  processTxInfo(elOption, EMPHASIS, attachedTxInfo);
  var txConOptNormal = attachedTxInfo.normal.conOpt;
  var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
  var txConOptBlur = attachedTxInfo.blur.conOpt;
  var txConOptSelect = attachedTxInfo.select.conOpt;
  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
    var textContent = el.getTextContent();
    if (txConOptNormal === false) {
      textContent && el.removeTextContent();
    } else {
      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {
        type: "text"
      };
      if (!textContent) {
        textContent = createEl$1(txConOptNormal);
        el.setTextContent(textContent);
      } else {
        textContent.clearStates();
      }
      updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
      var txConStlOptNormal = txConOptNormal && txConOptNormal.style;
      for (var i = 0; i < STATES.length; i++) {
        var stateName = STATES[i];
        if (stateName !== NORMAL) {
          var txConOptOtherState = attachedTxInfo[stateName].conOpt;
          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
        }
      }
      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
    }
  }
}
function processTxInfo(elOption, state, attachedTxInfo) {
  var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
  var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
  var elType = elOption.type;
  var txCfg = stateOpt ? stateOpt.textConfig : null;
  var txConOptNormal = elOption.textContent;
  var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
  if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
    attachedTxInfo.isLegacy = true;
    var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
    if (!txCfg && convertResult.textConfig) {
      txCfg = convertResult.textConfig;
    }
    if (!txConOpt && convertResult.textContent) {
      txConOpt = convertResult.textContent;
    }
  }
  if (!state && txConOpt) {
    var txConOptNormal_1 = txConOpt;
    !txConOptNormal_1.type && (txConOptNormal_1.type = "text");
    {
      assert(txConOptNormal_1.type === "text", 'textContent.type must be "text"');
    }
  }
  var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
  info.cfg = txCfg;
  info.conOpt = txConOpt;
}
function retrieveStateOption(elOption, state) {
  return !state ? elOption : elOption ? elOption[state] : null;
}
function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
  var style = stateOption && stateOption.style;
  if (style == null && state === EMPHASIS && stateOptionNormal) {
    style = stateOptionNormal.styleEmphasis;
  }
  return style;
}
function mergeChildren(api, el, dataIndex, elOption, seriesModel) {
  var newChildren = elOption.children;
  var newLen = newChildren ? newChildren.length : 0;
  var mergeChildren2 = elOption.$mergeChildren;
  var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
  var notMerge = mergeChildren2 === false;
  if (!newLen && !byName && !notMerge) {
    return;
  }
  if (byName) {
    diffGroupChildren({
      api,
      oldChildren: el.children() || [],
      newChildren: newChildren || [],
      dataIndex,
      seriesModel,
      group: el
    });
    return;
  }
  notMerge && el.removeAll();
  var index2 = 0;
  for (; index2 < newLen; index2++) {
    var newChild = newChildren[index2];
    var oldChild = el.childAt(index2);
    if (newChild) {
      if (newChild.ignore == null) {
        newChild.ignore = false;
      }
      doCreateOrUpdateEl(api, oldChild, dataIndex, newChild, seriesModel, el);
    } else {
      {
        assert(oldChild, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before.");
      }
      oldChild.ignore = true;
    }
  }
  for (var i = el.childCount() - 1; i >= index2; i--) {
    var child = el.childAt(i);
    removeChildFromGroup(el, child, seriesModel);
  }
}
function removeChildFromGroup(group, child, seriesModel) {
  child && applyLeaveTransition(child, customInnerStore(group).option, seriesModel);
}
function diffGroupChildren(context) {
  new DataDiffer$1(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(item, idx) {
  var name2 = item && item.name;
  return name2 != null ? name2 : GROUP_DIFF_PREFIX + idx;
}
function processAddUpdate(newIndex, oldIndex) {
  var context = this.context;
  var childOption = newIndex != null ? context.newChildren[newIndex] : null;
  var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
}
function processRemove(oldIndex) {
  var context = this.context;
  var child = context.oldChildren[oldIndex];
  child && applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
}
function getPathData(shape) {
  return shape && (shape.pathData || shape.d);
}
function hasOwnPathData(shape) {
  return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
}
function install$r(registers) {
  registers.registerChartView(CustomChartView$1);
  registers.registerSeriesModel(CustomSeriesModel$1);
}
var inner$b = makeInner();
var clone$1 = clone$4;
var bind3 = bind$1;
var BaseAxisPointer = function() {
  function BaseAxisPointer2() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get("value");
    var status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api;
    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }
    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
    var graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }
    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group$4();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = curry$1(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value);
  };
  BaseAxisPointer2.prototype.remove = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.dispose = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
    var animation = axisPointerModel.get("animation");
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === "category";
    var useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      var animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        var seriesDataCount = getAxisInfo$1(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  };
  BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
  };
  BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;
    if (pointerOption) {
      var pointerEl = inner$b(group).pointerEl = new graphic[pointerOption.type](clone$1(elOption.pointer));
      group.add(pointerEl);
    }
  };
  BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner$b(group).labelEl = new ZRText$1(clone$1(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
    var pointerEl = inner$b(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps2(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
    var labelEl = inner$b(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps2(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype._renderHandle = function(value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    var axisPointerModel = this._axisPointerModel;
    var zr = this._api.getZr();
    var handle = this._handle;
    var handleModel = axisPointerModel.getModel("handle");
    var status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }
    var isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove: function(e2) {
          stop(e2.event);
        },
        onmousedown: bind3(this._onHandleDragMove, this, 0, 0),
        drift: bind3(this._onHandleDragMove, this),
        ondragend: bind3(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
    var handleSize = handleModel.get("size");
    if (!isArray$1(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value, isInit);
  };
  BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  };
  BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner$b(handle).lastProp = null;
    this._doDispatchAxisPointer();
  };
  BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };
  BaseAxisPointer2.prototype._onHandleDragEnd = function() {
    this._dragging = false;
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var value = this._axisPointerModel.get("value");
    this._moveHandleToValue(value);
    this._api.dispatchAction({
      type: "hideTip"
    });
  };
  BaseAxisPointer2.prototype.clear = function(api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;
    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear$1(this, "_doDispatchAxisPointer");
  };
  BaseAxisPointer2.prototype.doClear = function() {
  };
  BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  };
  return BaseAxisPointer2;
}();
function updateProps(animationModel, moveAnimation, el, props) {
  if (!propsEqual(inner$b(el).lastProp, props)) {
    inner$b(el).lastProp = props;
    moveAnimation ? updateProps$1(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject$3(lastProps) && isObject$3(newProps)) {
    var equals_1 = true;
    each$f(newProps, function(item, key) {
      equals_1 = equals_1 && propsEqual(lastProps[key], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get("z");
  var zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el) {
    if (el.type !== "group") {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}
var BaseAxisPointer$1 = BaseAxisPointer;
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get("type");
  var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  var style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get("value");
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  var labelModel = axisPointerModel.getModel("label");
  var paddings = normalizeCssArray(labelModel.get("padding") || 0);
  var font = labelModel.getFont();
  var textRect = getBoundingRect(text, font);
  var position2 = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2];
  var align = labelPos.align;
  align === "right" && (position2[0] -= width);
  align === "center" && (position2[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position2[1] -= height);
  verticalAlign === "middle" && (position2[1] -= height / 2);
  confineInContainer(position2, width, height, api);
  var bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position2[0],
    y: position2[1],
    style: createTextStyle(labelModel, {
      text,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position2, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position2[0] = Math.min(position2[0] + width, viewWidth) - width;
  position2[1] = Math.min(position2[1] + height, viewHeight) - height;
  position2[0] = Math.max(position2[0], 0);
  position2[1] = Math.max(position2[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text = axis.scale.getLabel({
    value
  }, {
    precision: opt.precision
  });
  var formatter = opt.formatter;
  if (formatter) {
    var params_1 = {
      value: getAxisRawValue(axis, {
        value
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each$f(seriesDataIndices, function(idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });
    if (isString(formatter)) {
      text = formatter.replace("{value}", text);
    } else if (isFunction(formatter)) {
      text = formatter(params_1);
    }
  }
  return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
  var transform4 = create$1();
  rotate(transform4, transform4, layoutInfo.rotation);
  translate2(transform4, transform4, layoutInfo.position);
  return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform4);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder$1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx,
    cy,
    r0,
    r,
    startAngle,
    endAngle,
    clockwise: true
  };
}
var CartesianAxisPointer = function(_super) {
  __extends$1(CartesianAxisPointer2, _super);
  function CartesianAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get("type");
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder$2[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout$2(grid.model, axisModel);
    buildCartesianSingleLabelElOption(
      value,
      elOption,
      layoutInfo,
      axisModel,
      axisPointerModel,
      api
    );
  };
  CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
    var layoutInfo = layout$2(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  CartesianAxisPointer2.prototype.updateHandleTransform = function(transform4, delta2, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === "x" ? 0 : 1;
    var currPosition = [transform4.x, transform4.y];
    currPosition[dimIndex] += delta2[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    var tooltipOptions = [{
      verticalAlign: "middle"
    }, {
      align: "center"
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform4.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };
  return CartesianAxisPointer2;
}(BaseAxisPointer$1);
function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid.getCartesian(opt);
}
var pointerShapeBuilder$2 = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer$1 = CartesianAxisPointer;
var AxisPointerModel = function(_super) {
  __extends$1(AxisPointerModel2, _super);
  function AxisPointerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerModel2.type;
    return _this;
  }
  AxisPointerModel2.type = "axisPointer";
  AxisPointerModel2.defaultOption = {
    show: "auto",
    z: 50,
    type: "line",
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    link: [],
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: "#B9BEC9",
      width: 1,
      type: "dashed"
    },
    shadowStyle: {
      color: "rgba(210,219,238,0.2)"
    },
    label: {
      show: true,
      formatter: null,
      precision: "auto",
      margin: 3,
      color: "#fff",
      padding: [5, 7, 5, 7],
      backgroundColor: "auto",
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
      size: 45,
      margin: 50,
      color: "#333",
      shadowBlur: 3,
      shadowColor: "#aaa",
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      throttle: 40
    }
  };
  return AxisPointerModel2;
}(ComponentModel$1);
var AxisPointerModel$1 = AxisPointerModel;
var inner$a = makeInner();
var each$8 = each$f;
function register(key, api, handler) {
  if (env$1.node) {
    return;
  }
  var zr = api.getZr();
  inner$a(zr).records || (inner$a(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner$a(zr).records[key] || (inner$a(zr).records[key] = {});
  record.handler = handler;
}
function initGlobalListeners(zr, api) {
  if (inner$a(zr).initialized) {
    return;
  }
  inner$a(zr).initialized = true;
  useHandler("click", curry$1(doEnter, "click"));
  useHandler("mousemove", curry$1(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr.on(eventType, function(e2) {
      var dis = makeDispatchAction$1(api);
      each$8(inner$a(zr).records, function(record) {
        record && cb(record, e2, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}
function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e2, dispatchAction2) {
  record.handler("leave", null, dispatchAction2);
}
function doEnter(currTrigger, record, e2, dispatchAction2) {
  record.handler(currTrigger, e2, dispatchAction2);
}
function makeDispatchAction$1(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  };
  var dispatchAction2 = function(payload) {
    var pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction2;
      api.dispatchAction(payload);
    }
  };
  return {
    dispatchAction: dispatchAction2,
    pendings
  };
}
function unregister(key, api) {
  if (env$1.node) {
    return;
  }
  var zr = api.getZr();
  var record = (inner$a(zr).records || {})[key];
  if (record) {
    inner$a(zr).records[key] = null;
  }
}
var AxisPointerView = function(_super) {
  __extends$1(AxisPointerView2, _super);
  function AxisPointerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerView2.type;
    return _this;
  }
  AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
    register("axisPointer", api, function(currTrigger, e2, dispatchAction2) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction2({
          type: "updateAxisPointer",
          currTrigger,
          x: e2 && e2.offsetX,
          y: e2 && e2.offsetY
        });
      }
    });
  };
  AxisPointerView2.prototype.remove = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.prototype.dispose = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.type = "axisPointer";
  return AxisPointerView2;
}(ComponentView$1);
var AxisPointerView$1 = AxisPointerView;
function findPointFromSeries(finder, ecModel) {
  var point4 = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  var data = seriesModel.getData();
  var dataIndex = queryDataIndex(data, finder);
  if (dataIndex == null || dataIndex < 0 || isArray$1(dataIndex)) {
    return {
      point: []
    };
  }
  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point4 = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis2 = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis2.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var baseDim = data.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
      point4 = coordSys.dataToPoint(stackedData) || [];
    } else {
      point4 = coordSys.dataToPoint(data.getValues(map$1(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point4 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
  return {
    point: point4,
    el
  };
}
var inner$9 = makeInner();
function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point4 = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction2 = payload.dispatchAction || bind$1(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point4)) {
    point4 = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  var isIllegalPoint = illegalPoint(point4);
  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === "leave" || illegalPoint(point4);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry$1(showPointer, showValueMap),
    showTooltip: curry$1(showTooltip, dataByCoordSys)
  };
  each$f(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point4);
    each$f(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;
        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point4);
        }
        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  });
  var linkTriggers = {};
  each$f(axesInfo, function(tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each$f(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each$f(linkTriggers, function(val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point4, payload, dispatchAction2);
  dispatchHighDownActually(axesInfo, dispatchAction2, api);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend2(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each$f(axisInfo.seriesModels, function(series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;
    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(
        dataDim[0],
        value,
        axis.type === "category" ? 0.5 : null
      );
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    var diff2 = value - seriesNestestValue;
    var dist3 = Math.abs(diff2);
    if (dist3 <= minDist) {
      if (dist3 < minDist || diff2 >= 0 && minDiff < 0) {
        minDist = dist3;
        minDiff = diff2;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each$f(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = [];
  each$f(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point4, payload, dispatchAction2) {
  if (illegalPoint(point4) || !dataByCoordSys.list.length) {
    dispatchAction2({
      type: "hideTip"
    });
    return;
  }
  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction2({
    type: "showTip",
    escapeConnect: true,
    x: point4[0],
    y: point4[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction2, api) {
  var zr = api.getZr();
  var highDownKey = "axisPointerLastHighlights";
  var lastHighlights = inner$9(zr)[highDownKey] || {};
  var newHighlights = inner$9(zr)[highDownKey] = {};
  each$f(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === "show" && each$f(option.seriesDataIndices, function(batchItem) {
      var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key2] = batchItem;
    });
  });
  var toHighlight = [];
  var toDownplay = [];
  each$f(lastHighlights, function(batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each$f(newHighlights, function(batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point4) {
  return !point4 || point4[0] == null || isNaN(point4[0]) || point4[1] == null || isNaN(point4[1]);
}
function install$q(registers) {
  AxisView$1.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer$1);
  registers.registerComponentModel(AxisPointerModel$1);
  registers.registerComponentView(AxisPointerView$1);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link2 = option.axisPointer.link;
      if (link2 && !isArray$1(link2)) {
        option.axisPointer.link = [link2];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}
function install$p(registers) {
  use2(install$N);
  use2(install$q);
}
var PolarAxisPointer = function(_super) {
  __extends$1(PolarAxisPointer2, _super);
  function PolarAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    if (axis.dim === "angle") {
      this.animationThreshold = Math.PI / 18;
    }
    var polar = axis.polar;
    var otherAxis = polar.getOtherAxis(axis);
    var otherExtent = otherAxis.getExtent();
    var coordValue = axis.dataToCoord(value);
    var axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder$1[axisPointerType](axis, polar, coordValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var labelMargin = axisPointerModel.get(["label", "margin"]);
    var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
  };
  return PolarAxisPointer2;
}(BaseAxisPointer$1);
function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
  var axis = axisModel.axis;
  var coord = axis.dataToCoord(value);
  var axisAngle = polar.getAngleAxis().getExtent()[0];
  axisAngle = axisAngle / 180 * Math.PI;
  var radiusExtent = polar.getRadiusAxis().getExtent();
  var position2;
  var align;
  var verticalAlign;
  if (axis.dim === "radius") {
    var transform4 = create$1();
    rotate(transform4, transform4, axisAngle);
    translate2(transform4, transform4, [polar.cx, polar.cy]);
    position2 = applyTransform([coord, -labelMargin], transform4);
    var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
    var labelLayout2 = AxisBuilder$1.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
    align = labelLayout2.textAlign;
    verticalAlign = labelLayout2.textVerticalAlign;
  } else {
    var r = radiusExtent[1];
    position2 = polar.coordToPoint([r + labelMargin, coord]);
    var cx = polar.cx;
    var cy = polar.cy;
    align = Math.abs(position2[0] - cx) / r < 0.3 ? "center" : position2[0] > cx ? "left" : "right";
    verticalAlign = Math.abs(position2[1] - cy) / r < 0.3 ? "middle" : position2[1] > cy ? "top" : "bottom";
  }
  return {
    position: position2,
    align,
    verticalAlign
  };
}
var pointerShapeBuilder$1 = {
  line: function(axis, polar, coordValue, otherExtent) {
    return axis.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
    } : {
      type: "Circle",
      shape: {
        cx: polar.cx,
        cy: polar.cy,
        r: coordValue
      }
    };
  },
  shadow: function(axis, polar, coordValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var radian = Math.PI / 180;
    return axis.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(
        polar.cx,
        polar.cy,
        otherExtent[0],
        otherExtent[1],
        (-coordValue - bandWidth / 2) * radian,
        (-coordValue + bandWidth / 2) * radian
      )
    } : {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
    };
  }
};
var PolarAxisPointer$1 = PolarAxisPointer;
var PolarModel = function(_super) {
  __extends$1(PolarModel2, _super);
  function PolarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PolarModel2.type;
    return _this;
  }
  PolarModel2.prototype.findAxisModel = function(axisType) {
    var foundAxisModel;
    var ecModel = this.ecModel;
    ecModel.eachComponent(axisType, function(axisModel) {
      if (axisModel.getCoordSysModel() === this) {
        foundAxisModel = axisModel;
      }
    }, this);
    return foundAxisModel;
  };
  PolarModel2.type = "polar";
  PolarModel2.dependencies = ["radiusAxis", "angleAxis"];
  PolarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "80%"
  };
  return PolarModel2;
}(ComponentModel$1);
var PolarModel$1 = PolarModel;
var PolarAxisModel = function(_super) {
  __extends$1(PolarAxisModel2, _super);
  function PolarAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
  };
  PolarAxisModel2.type = "polarAxis";
  return PolarAxisModel2;
}(ComponentModel$1);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = function(_super) {
  __extends$1(AngleAxisModel2, _super);
  function AngleAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AngleAxisModel2.type;
    return _this;
  }
  AngleAxisModel2.type = "angleAxis";
  return AngleAxisModel2;
}(PolarAxisModel);
var RadiusAxisModel = function(_super) {
  __extends$1(RadiusAxisModel2, _super);
  function RadiusAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadiusAxisModel2.type;
    return _this;
  }
  RadiusAxisModel2.type = "radiusAxis";
  return RadiusAxisModel2;
}(PolarAxisModel);
var RadiusAxis = function(_super) {
  __extends$1(RadiusAxis2, _super);
  function RadiusAxis2(scale4, radiusExtent) {
    return _super.call(this, "radius", scale4, radiusExtent) || this;
  }
  RadiusAxis2.prototype.pointToData = function(point4, clamp3) {
    return this.polar.pointToData(point4, clamp3)[this.dim === "radius" ? 0 : 1];
  };
  return RadiusAxis2;
}(Axis$1);
RadiusAxis.prototype.dataToRadius = Axis$1.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis$1.prototype.coordToData;
var RadiusAxis$1 = RadiusAxis;
var inner$8 = makeInner();
var AngleAxis = function(_super) {
  __extends$1(AngleAxis2, _super);
  function AngleAxis2(scale4, angleExtent) {
    return _super.call(this, "angle", scale4, angleExtent || [0, 360]) || this;
  }
  AngleAxis2.prototype.pointToData = function(point4, clamp3) {
    return this.polar.pointToData(point4, clamp3)[this.dim === "radius" ? 0 : 1];
  };
  AngleAxis2.prototype.calculateCategoryInterval = function() {
    var axis = this;
    var labelModel = axis.getLabelModel();
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitH = Math.abs(unitSpan);
    var rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
    var maxH = Math.max(rect.height, 7);
    var dh = maxH / unitH;
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(dh));
    var cache = inner$8(axis.model);
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
      interval = lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
    }
    return interval;
  };
  return AngleAxis2;
}(Axis$1);
AngleAxis.prototype.dataToAngle = Axis$1.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis$1.prototype.coordToData;
var AngleAxis$1 = AngleAxis;
var polarDimensions = ["radius", "angle"];
var Polar = function() {
  function Polar2(name2) {
    this.dimensions = polarDimensions;
    this.type = "polar";
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis$1();
    this._angleAxis = new AngleAxis$1();
    this.axisPointerEnabled = true;
    this.name = name2 || "";
    this._radiusAxis.polar = this._angleAxis.polar = this;
  }
  Polar2.prototype.containPoint = function(point4) {
    var coord = this.pointToCoord(point4);
    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
  };
  Polar2.prototype.containData = function(data) {
    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
  };
  Polar2.prototype.getAxis = function(dim) {
    var key = "_" + dim + "Axis";
    return this[key];
  };
  Polar2.prototype.getAxes = function() {
    return [this._radiusAxis, this._angleAxis];
  };
  Polar2.prototype.getAxesByScale = function(scaleType) {
    var axes = [];
    var angleAxis = this._angleAxis;
    var radiusAxis = this._radiusAxis;
    angleAxis.scale.type === scaleType && axes.push(angleAxis);
    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
    return axes;
  };
  Polar2.prototype.getAngleAxis = function() {
    return this._angleAxis;
  };
  Polar2.prototype.getRadiusAxis = function() {
    return this._radiusAxis;
  };
  Polar2.prototype.getOtherAxis = function(axis) {
    var angleAxis = this._angleAxis;
    return axis === angleAxis ? this._radiusAxis : angleAxis;
  };
  Polar2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
  };
  Polar2.prototype.getTooltipAxes = function(dim) {
    var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
    return {
      baseAxes: [baseAxis],
      otherAxes: [this.getOtherAxis(baseAxis)]
    };
  };
  Polar2.prototype.dataToPoint = function(data, clamp3) {
    return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp3), this._angleAxis.dataToAngle(data[1], clamp3)]);
  };
  Polar2.prototype.pointToData = function(point4, clamp3) {
    var coord = this.pointToCoord(point4);
    return [this._radiusAxis.radiusToData(coord[0], clamp3), this._angleAxis.angleToData(coord[1], clamp3)];
  };
  Polar2.prototype.pointToCoord = function(point4) {
    var dx = point4[0] - this.cx;
    var dy = point4[1] - this.cy;
    var angleAxis = this.getAngleAxis();
    var extent3 = angleAxis.getExtent();
    var minAngle = Math.min(extent3[0], extent3[1]);
    var maxAngle = Math.max(extent3[0], extent3[1]);
    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx) / Math.PI * 180;
    var dir3 = radian < minAngle ? 1 : -1;
    while (radian < minAngle || radian > maxAngle) {
      radian += dir3 * 360;
    }
    return [radius, radian];
  };
  Polar2.prototype.coordToPoint = function(coord) {
    var radius = coord[0];
    var radian = coord[1] / 180 * Math.PI;
    var x2 = Math.cos(radian) * radius + this.cx;
    var y2 = -Math.sin(radian) * radius + this.cy;
    return [x2, y2];
  };
  Polar2.prototype.getArea = function() {
    var angleAxis = this.getAngleAxis();
    var radiusAxis = this.getRadiusAxis();
    var radiusExtent = radiusAxis.getExtent().slice();
    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
    var angleExtent = angleAxis.getExtent();
    var RADIAN2 = Math.PI / 180;
    return {
      cx: this.cx,
      cy: this.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN2,
      endAngle: -angleExtent[1] * RADIAN2,
      clockwise: angleAxis.inverse,
      contain: function(x2, y2) {
        var dx = x2 - this.cx;
        var dy = y2 - this.cy;
        var d2 = dx * dx + dy * dy - 1e-4;
        var r = this.r;
        var r0 = this.r0;
        return d2 <= r * r && d2 >= r0 * r0;
      }
    };
  };
  Polar2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$2(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };
  Polar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$2(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };
  return Polar2;
}();
function getCoordSys$2(finder) {
  var seriesModel = finder.seriesModel;
  var polarModel = finder.polarModel;
  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Polar$1 = Polar;
function resizePolar(polar, polarModel, api) {
  var center2 = polarModel.get("center");
  var width = api.getWidth();
  var height = api.getHeight();
  polar.cx = parsePercent(center2[0], width);
  polar.cy = parsePercent(center2[1], height);
  var radiusAxis = polar.getRadiusAxis();
  var size11 = Math.min(width, height) / 2;
  var radius = polarModel.get("radius");
  if (radius == null) {
    radius = [0, "100%"];
  } else if (!isArray$1(radius)) {
    radius = [0, radius];
  }
  var parsedRadius = [parsePercent(radius[0], size11), parsePercent(radius[1], size11)];
  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
function updatePolarScale(ecModel, api) {
  var polar = this;
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis();
  angleAxis.scale.setExtent(Infinity, -Infinity);
  radiusAxis.scale.setExtent(Infinity, -Infinity);
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem === polar) {
      var data_1 = seriesModel.getData();
      each$f(getDataDimensionsOnAxis(data_1, "radius"), function(dim) {
        radiusAxis.scale.unionExtentFromData(data_1, dim);
      });
      each$f(getDataDimensionsOnAxis(data_1, "angle"), function(dim) {
        angleAxis.scale.unionExtentFromData(data_1, dim);
      });
    }
  });
  niceScaleExtent(angleAxis.scale, angleAxis.model);
  niceScaleExtent(radiusAxis.scale, radiusAxis.model);
  if (angleAxis.type === "category" && !angleAxis.onBand) {
    var extent3 = angleAxis.getExtent();
    var diff2 = 360 / angleAxis.scale.count();
    angleAxis.inverse ? extent3[1] += diff2 : extent3[1] -= diff2;
    angleAxis.setExtent(extent3[0], extent3[1]);
  }
}
function isAngleAxisModel(axisModel) {
  return axisModel.mainType === "angleAxis";
}
function setAxis(axis, axisModel) {
  axis.type = axisModel.get("type");
  axis.scale = createScaleByModel$1(axisModel);
  axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
  axis.inverse = axisModel.get("inverse");
  if (isAngleAxisModel(axisModel)) {
    axis.inverse = axis.inverse !== axisModel.get("clockwise");
    var startAngle = axisModel.get("startAngle");
    axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
  }
  axisModel.axis = axis;
  axis.model = axisModel;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(ecModel, api) {
    var polarList = [];
    ecModel.eachComponent("polar", function(polarModel, idx) {
      var polar = new Polar$1(idx + "");
      polar.update = updatePolarScale;
      var radiusAxis = polar.getRadiusAxis();
      var angleAxis = polar.getAngleAxis();
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      setAxis(radiusAxis, radiusAxisModel);
      setAxis(angleAxis, angleAxisModel);
      resizePolar(polar, polarModel, api);
      polarList.push(polar);
      polarModel.coordinateSystem = polar;
      polar.model = polarModel;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "polar") {
        var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        {
          if (!polarModel) {
            throw new Error('Polar "' + retrieve(seriesModel.get("polarIndex"), seriesModel.get("polarId"), 0) + '" not found');
          }
        }
        seriesModel.coordinateSystem = polarModel.coordinateSystem;
      }
    });
    return polarList;
  }
};
var polarCreator$1 = polarCreator;
var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function getAxisLineShape(polar, rExtent, angle4) {
  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
  var start2 = polar.coordToPoint([rExtent[0], angle4]);
  var end2 = polar.coordToPoint([rExtent[1], angle4]);
  return {
    x1: start2[0],
    y1: start2[1],
    x2: end2[0],
    y2: end2[1]
  };
}
function getRadiusIdx(polar) {
  var radiusAxis = polar.getRadiusAxis();
  return radiusAxis.inverse ? 0 : 1;
}
function fixAngleOverlap(list) {
  var firstItem = list[0];
  var lastItem = list[list.length - 1];
  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
    list.pop();
  }
}
var AngleAxisView = function(_super) {
  __extends$1(AngleAxisView2, _super);
  function AngleAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AngleAxisView2.type;
    _this.axisPointerClass = "PolarAxisPointer";
    return _this;
  }
  AngleAxisView2.prototype.render = function(angleAxisModel, ecModel) {
    this.group.removeAll();
    if (!angleAxisModel.get("show")) {
      return;
    }
    var angleAxis = angleAxisModel.axis;
    var polar = angleAxis.polar;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var ticksAngles = angleAxis.getTicksCoords();
    var minorTickAngles = angleAxis.getMinorTicksCoords();
    var labels = map$1(angleAxis.getViewLabels(), function(labelItem) {
      labelItem = clone$4(labelItem);
      var scale4 = angleAxis.scale;
      var tickValue = scale4.type === "ordinal" ? scale4.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      labelItem.coord = angleAxis.dataToCoord(tickValue);
      return labelItem;
    });
    fixAngleOverlap(labels);
    fixAngleOverlap(ticksAngles);
    each$f(elementList, function(name2) {
      if (angleAxisModel.get([name2, "show"]) && (!angleAxis.scale.isBlank() || name2 === "axisLine")) {
        angelAxisElementsBuilders[name2](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
      }
    }, this);
  };
  AngleAxisView2.type = "angleAxis";
  return AngleAxisView2;
}(AxisView$1);
var angelAxisElementsBuilders = {
  axisLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
    var rId = getRadiusIdx(polar);
    var r0Id = rId ? 0 : 1;
    var shape;
    if (radiusExtent[r0Id] === 0) {
      shape = new Circle$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    } else {
      shape = new Ring$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          r0: radiusExtent[r0Id]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    }
    shape.style.fill = null;
    group.add(shape);
  },
  axisTick: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var tickModel = angleAxisModel.getModel("axisTick");
    var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = map$1(ticksAngles, function(tickAngleItem) {
      return new Line$3({
        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
      });
    });
    group.add(mergePath(lines, {
      style: defaults(tickModel.getModel("lineStyle").getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    var tickModel = angleAxisModel.getModel("axisTick");
    var minorTickModel = angleAxisModel.getModel("minorTick");
    var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = [];
    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line$3({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath(lines, {
      style: defaults(minorTickModel.getModel("lineStyle").getLineStyle(), defaults(tickModel.getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      }))
    }));
  },
  axisLabel: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
    var rawCategoryData = angleAxisModel.getCategories(true);
    var commonLabelModel = angleAxisModel.getModel("axisLabel");
    var labelMargin = commonLabelModel.get("margin");
    var triggerEvent = angleAxisModel.get("triggerEvent");
    each$f(labels, function(labelItem, idx) {
      var labelModel = commonLabelModel;
      var tickValue = labelItem.tickValue;
      var r = radiusExtent[getRadiusIdx(polar)];
      var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
      var cx = polar.cx;
      var cy = polar.cy;
      var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
      var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];
        if (isObject$3(rawCategoryItem) && rawCategoryItem.textStyle) {
          labelModel = new Model$1(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
      }
      var textEl = new ZRText$1({
        silent: AxisBuilder$1.isLabelSilent(angleAxisModel),
        style: createTextStyle(labelModel, {
          x: p[0],
          y: p[1],
          fill: labelModel.getTextColor() || angleAxisModel.get(["axisLine", "lineStyle", "color"]),
          text: labelItem.formattedLabel,
          align: labelTextAlign,
          verticalAlign: labelTextVerticalAlign
        })
      });
      group.add(textEl);
      if (triggerEvent) {
        var eventData = AxisBuilder$1.makeAxisEventDataBase(angleAxisModel);
        eventData.targetType = "axisLabel";
        eventData.value = labelItem.rawLabel;
        getECData(textEl).eventData = eventData;
      }
    }, this);
  },
  splitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var splitLineModel = angleAxisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];
    for (var i = 0; i < ticksAngles.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Line$3({
        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
      }));
    }
    for (var i = 0; i < splitLines.length; i++) {
      group.add(mergePath(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyleModel.getLineStyle()),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    }
  },
  minorSplitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var lines = [];
    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line$3({
          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath(lines, {
      style: lineStyleModel.getLineStyle(),
      silent: true,
      z: angleAxisModel.get("z")
    }));
  },
  splitArea: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!ticksAngles.length) {
      return;
    }
    var splitAreaModel = angleAxisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var RADIAN2 = Math.PI / 180;
    var prevAngle = -ticksAngles[0].coord * RADIAN2;
    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
    var clockwise = angleAxisModel.get("clockwise");
    for (var i = 1, len2 = ticksAngles.length; i <= len2; i++) {
      var coord = i === len2 ? ticksAngles[0].coord : ticksAngles[i].coord;
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0,
          r: r1,
          startAngle: prevAngle,
          endAngle: -coord * RADIAN2,
          clockwise
        },
        silent: true
      }));
      prevAngle = -coord * RADIAN2;
    }
    for (var i = 0; i < splitAreas.length; i++) {
      group.add(mergePath(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
var AngleAxisView$1 = AngleAxisView;
var axisBuilderAttrs$1 = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs$1 = ["splitLine", "splitArea", "minorSplitLine"];
var RadiusAxisView = function(_super) {
  __extends$1(RadiusAxisView2, _super);
  function RadiusAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadiusAxisView2.type;
    _this.axisPointerClass = "PolarAxisPointer";
    return _this;
  }
  RadiusAxisView2.prototype.render = function(radiusAxisModel, ecModel) {
    this.group.removeAll();
    if (!radiusAxisModel.get("show")) {
      return;
    }
    var oldAxisGroup = this._axisGroup;
    var newAxisGroup = this._axisGroup = new Group$4();
    this.group.add(newAxisGroup);
    var radiusAxis = radiusAxisModel.axis;
    var polar = radiusAxis.polar;
    var angleAxis = polar.getAngleAxis();
    var ticksCoords = radiusAxis.getTicksCoords();
    var minorTicksCoords = radiusAxis.getMinorTicksCoords();
    var axisAngle = angleAxis.getExtent()[0];
    var radiusExtent = radiusAxis.getExtent();
    var layout2 = layoutAxis(polar, radiusAxisModel, axisAngle);
    var axisBuilder = new AxisBuilder$1(radiusAxisModel, layout2);
    each$f(axisBuilderAttrs$1, axisBuilder.add, axisBuilder);
    newAxisGroup.add(axisBuilder.getGroup());
    groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
    each$f(selfBuilderAttrs$1, function(name2) {
      if (radiusAxisModel.get([name2, "show"]) && !radiusAxis.scale.isBlank()) {
        axisElementBuilders$1[name2](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
      }
    }, this);
  };
  RadiusAxisView2.type = "radiusAxis";
  return RadiusAxisView2;
}(AxisView$1);
var axisElementBuilders$1 = {
  splitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    var splitLineModel = radiusAxisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];
    for (var i = 0; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Circle$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: Math.max(ticksCoords[i].coord, 0)
        }
      }));
    }
    for (var i = 0; i < splitLines.length; i++) {
      group.add(mergePath(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length],
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    }
  },
  minorSplitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
    if (!minorTicksCoords.length) {
      return;
    }
    var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var lines = [];
    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        lines.push(new Circle$1({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: minorTicksCoords[i][k].coord
          }
        }));
      }
    }
    group.add(mergePath(lines, {
      style: defaults({
        fill: null
      }, lineStyleModel.getLineStyle()),
      silent: true
    }));
  },
  splitArea: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    if (!ticksCoords.length) {
      return;
    }
    var splitAreaModel = radiusAxisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var prevRadius = ticksCoords[0].coord;
    for (var i = 1; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: prevRadius,
          r: ticksCoords[i].coord,
          startAngle: 0,
          endAngle: Math.PI * 2
        },
        silent: true
      }));
      prevRadius = ticksCoords[i].coord;
    }
    for (var i = 0; i < splitAreas.length; i++) {
      group.add(mergePath(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
function layoutAxis(polar, radiusAxisModel, axisAngle) {
  return {
    position: [polar.cx, polar.cy],
    rotation: axisAngle / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
    z2: 1
  };
}
var RadiusAxisView$1 = RadiusAxisView;
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
}
function getAxisKey(polar, axis) {
  return axis.dim + polar.model.componentIndex;
}
function barLayoutPolar(seriesType2, ecModel, api) {
  var lastStackCoords = {};
  var barWidthAndOffset = calRadialBar(filter17(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
  }));
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (seriesModel.coordinateSystem.type !== "polar") {
      return;
    }
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis2 = polar.getOtherAxis(baseAxis);
    var cx = seriesModel.coordinateSystem.cx;
    var cy = seriesModel.coordinateSystem.cy;
    var barMinHeight = seriesModel.get("barMinHeight") || 0;
    var barMinAngle = seriesModel.get("barMinAngle") || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    var valueDim = data.mapDimension(valueAxis2.dim);
    var baseDim = data.mapDimension(baseAxis.dim);
    var stacked = isDimensionStacked(
      data,
      valueDim
    );
    var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
    var valueAxisStart = valueAxis2.dataToCoord(0);
    for (var idx = 0, len2 = data.count(); idx < len2; idx++) {
      var value = data.get(valueDim, idx);
      var baseValue = data.get(baseDim, idx);
      var sign2 = value >= 0 ? "p" : "n";
      var baseCoord = valueAxisStart;
      if (stacked) {
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            n: valueAxisStart
          };
        }
        baseCoord = lastStackCoords[stackId][baseValue][sign2];
      }
      var r0 = void 0;
      var r = void 0;
      var startAngle = void 0;
      var endAngle = void 0;
      if (valueAxis2.dim === "radius") {
        var radiusSpan = valueAxis2.dataToCoord(value) - valueAxisStart;
        var angle4 = baseAxis.dataToCoord(baseValue);
        if (Math.abs(radiusSpan) < barMinHeight) {
          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
        }
        r0 = baseCoord;
        r = baseCoord + radiusSpan;
        startAngle = angle4 - columnOffset;
        endAngle = startAngle - columnWidth;
        stacked && (lastStackCoords[stackId][baseValue][sign2] = r);
      } else {
        var angleSpan = valueAxis2.dataToCoord(value, clampLayout) - valueAxisStart;
        var radius = baseAxis.dataToCoord(baseValue);
        if (Math.abs(angleSpan) < barMinAngle) {
          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
        }
        r0 = radius + columnOffset;
        r = r0 + columnWidth;
        startAngle = baseCoord;
        endAngle = baseCoord + angleSpan;
        stacked && (lastStackCoords[stackId][baseValue][sign2] = endAngle);
      }
      data.setItemLayout(idx, {
        cx,
        cy,
        r0,
        r,
        startAngle: -startAngle * Math.PI / 180,
        endAngle: -endAngle * Math.PI / 180,
        clockwise: startAngle >= endAngle
      });
    }
  });
}
function calRadialBar(barSeries) {
  var columnsMap = {};
  each$f(barSeries, function(seriesModel, idx) {
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = getSeriesStackId(seriesModel);
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    if (barWidth && !stacks[stackId].width) {
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      stacks[stackId].width = barWidth;
      columnsOnAxis.remainedWidth -= barWidth;
    }
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    barGap != null && (columnsOnAxis.gap = barGap);
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$f(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$f(stacks, function(column, stack) {
      var maxWidth = column.maxWidth;
      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);
        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }
        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$f(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset = -widthSum / 2;
    each$f(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: true,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
};
var radiusAxisExtraOption = {
  splitNumber: 5
};
var PolarView = function(_super) {
  __extends$1(PolarView2, _super);
  function PolarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PolarView2.type;
    return _this;
  }
  PolarView2.type = "polar";
  return PolarView2;
}(ComponentView$1);
function install$o(registers) {
  use2(install$q);
  AxisView$1.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer$1);
  registers.registerCoordinateSystem("polar", polarCreator$1);
  registers.registerComponentModel(PolarModel$1);
  registers.registerComponentView(PolarView);
  axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
  axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
  registers.registerComponentView(AngleAxisView$1);
  registers.registerComponentView(RadiusAxisView$1);
  registers.registerLayout(curry$1(barLayoutPolar, "bar"));
}
function layout$1(axisModel, opt) {
  opt = opt || {};
  var single = axisModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout2 = {};
  var axisPosition = axis.position;
  var orient2 = axis.orient;
  var rect = single.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var positionMap = {
    horizontal: {
      top: rectBound[2],
      bottom: rectBound[3]
    },
    vertical: {
      left: rectBound[0],
      right: rectBound[1]
    }
  };
  layout2.position = [orient2 === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient2 === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
  var r = {
    horizontal: 0,
    vertical: 1
  };
  layout2.rotation = Math.PI / 2 * r[orient2];
  var directionMap = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = directionMap[axisPosition];
  if (axisModel.get(["axisTick", "inside"])) {
    layout2.tickDirection = -layout2.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout2.labelDirection = -layout2.labelDirection;
  }
  var labelRotation = opt.rotate;
  labelRotation == null && (labelRotation = axisModel.get(["axisLabel", "rotate"]));
  layout2.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
  layout2.z2 = 1;
  return layout2;
}
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs = ["splitArea", "splitLine"];
var SingleAxisView = function(_super) {
  __extends$1(SingleAxisView2, _super);
  function SingleAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SingleAxisView2.type;
    _this.axisPointerClass = "SingleAxisPointer";
    return _this;
  }
  SingleAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$4();
    var layout2 = layout$1(axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, layout2);
    each$f(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    group.add(this._axisGroup);
    group.add(axisBuilder.getGroup());
    each$f(selfBuilderAttrs, function(name2) {
      if (axisModel.get([name2, "show"])) {
        axisElementBuilders[name2](this, this.group, this._axisGroup, axisModel);
      }
    }, this);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  SingleAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  SingleAxisView2.type = "singleAxis";
  return SingleAxisView2;
}(AxisView$1);
var axisElementBuilders = {
  splitLine: function(axisView, group, axisGroup, axisModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var lineWidth = lineStyleModel.get("width");
    var gridRect = axisModel.coordinateSystem.getRect();
    var isHorizontal2 = axis.isHorizontal();
    var splitLines = [];
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];
    for (var i = 0; i < ticksCoords.length; ++i) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal2) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      var line = new Line$3({
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        silent: true
      });
      subPixelOptimizeLine(line.shape, lineWidth);
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(line);
    }
    var lineStyle = lineStyleModel.getLineStyle(["color"]);
    for (var i = 0; i < splitLines.length; ++i) {
      group.add(mergePath(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyle),
        silent: true
      }));
    }
  },
  splitArea: function(axisView, group, axisGroup, axisModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);
  }
};
var SingleAxisView$1 = SingleAxisView;
var SingleAxisModel = function(_super) {
  __extends$1(SingleAxisModel2, _super);
  function SingleAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SingleAxisModel2.type;
    return _this;
  }
  SingleAxisModel2.prototype.getCoordSysModel = function() {
    return this;
  };
  SingleAxisModel2.type = "singleAxis";
  SingleAxisModel2.layoutMode = "box";
  SingleAxisModel2.defaultOption = {
    left: "5%",
    top: "5%",
    right: "5%",
    bottom: "5%",
    type: "value",
    position: "bottom",
    orient: "horizontal",
    axisLine: {
      show: true,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    tooltip: {
      show: true
    },
    axisTick: {
      show: true,
      length: 6,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      interval: "auto"
    },
    splitLine: {
      show: true,
      lineStyle: {
        type: "dashed",
        opacity: 0.2
      }
    }
  };
  return SingleAxisModel2;
}(ComponentModel$1);
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
var SingleAxisModel$1 = SingleAxisModel;
var SingleAxis = function(_super) {
  __extends$1(SingleAxis2, _super);
  function SingleAxis2(dim, scale4, coordExtent, axisType, position2) {
    var _this = _super.call(this, dim, scale4, coordExtent) || this;
    _this.type = axisType || "value";
    _this.position = position2 || "bottom";
    return _this;
  }
  SingleAxis2.prototype.isHorizontal = function() {
    var position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  };
  SingleAxis2.prototype.pointToData = function(point4, clamp3) {
    return this.coordinateSystem.pointToData(point4)[0];
  };
  return SingleAxis2;
}(Axis$1);
var SingleAxis$1 = SingleAxis;
var singleDimensions = ["single"];
var Single = function() {
  function Single2(axisModel, ecModel, api) {
    this.type = "single";
    this.dimension = "single";
    this.dimensions = singleDimensions;
    this.axisPointerEnabled = true;
    this.model = axisModel;
    this._init(axisModel, ecModel, api);
  }
  Single2.prototype._init = function(axisModel, ecModel, api) {
    var dim = this.dimension;
    var axis = new SingleAxis$1(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
    var isCategory2 = axis.type === "category";
    axis.onBand = isCategory2 && axisModel.get("boundaryGap");
    axis.inverse = axisModel.get("inverse");
    axis.orient = axisModel.get("orient");
    axisModel.axis = axis;
    axis.model = axisModel;
    axis.coordinateSystem = this;
    this._axis = axis;
  };
  Single2.prototype.update = function(ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === this) {
        var data_1 = seriesModel.getData();
        each$f(data_1.mapDimensionsAll(this.dimension), function(dim) {
          this._axis.scale.unionExtentFromData(data_1, dim);
        }, this);
        niceScaleExtent(this._axis.scale, this._axis.model);
      }
    }, this);
  };
  Single2.prototype.resize = function(axisModel, api) {
    this._rect = getLayoutRect({
      left: axisModel.get("left"),
      top: axisModel.get("top"),
      right: axisModel.get("right"),
      bottom: axisModel.get("bottom"),
      width: axisModel.get("width"),
      height: axisModel.get("height")
    }, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._adjustAxis();
  };
  Single2.prototype.getRect = function() {
    return this._rect;
  };
  Single2.prototype._adjustAxis = function() {
    var rect = this._rect;
    var axis = this._axis;
    var isHorizontal2 = axis.isHorizontal();
    var extent3 = isHorizontal2 ? [0, rect.width] : [0, rect.height];
    var idx = axis.inverse ? 1 : 0;
    axis.setExtent(extent3[idx], extent3[1 - idx]);
    this._updateAxisTransform(axis, isHorizontal2 ? rect.x : rect.y);
  };
  Single2.prototype._updateAxisTransform = function(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var extentSum = axisExtent[0] + axisExtent[1];
    var isHorizontal2 = axis.isHorizontal();
    axis.toGlobalCoord = isHorizontal2 ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
    axis.toLocalCoord = isHorizontal2 ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
  };
  Single2.prototype.getAxis = function() {
    return this._axis;
  };
  Single2.prototype.getBaseAxis = function() {
    return this._axis;
  };
  Single2.prototype.getAxes = function() {
    return [this._axis];
  };
  Single2.prototype.getTooltipAxes = function() {
    return {
      baseAxes: [this.getAxis()],
      otherAxes: []
    };
  };
  Single2.prototype.containPoint = function(point4) {
    var rect = this.getRect();
    var axis = this.getAxis();
    var orient2 = axis.orient;
    if (orient2 === "horizontal") {
      return axis.contain(axis.toLocalCoord(point4[0])) && point4[1] >= rect.y && point4[1] <= rect.y + rect.height;
    } else {
      return axis.contain(axis.toLocalCoord(point4[1])) && point4[0] >= rect.y && point4[0] <= rect.y + rect.height;
    }
  };
  Single2.prototype.pointToData = function(point4) {
    var axis = this.getAxis();
    return [axis.coordToData(axis.toLocalCoord(point4[axis.orient === "horizontal" ? 0 : 1]))];
  };
  Single2.prototype.dataToPoint = function(val) {
    var axis = this.getAxis();
    var rect = this.getRect();
    var pt = [];
    var idx = axis.orient === "horizontal" ? 0 : 1;
    if (val instanceof Array) {
      val = val[0];
    }
    pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
    pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
    return pt;
  };
  Single2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };
  Single2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };
  return Single2;
}();
function getCoordSys$1(finder) {
  var seriesModel = finder.seriesModel;
  var singleModel = finder.singleAxisModel;
  return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
function create5(ecModel, api) {
  var singles = [];
  ecModel.eachComponent("singleAxis", function(axisModel, idx) {
    var single = new Single(axisModel, ecModel, api);
    single.name = "single_" + idx;
    single.resize(axisModel, api);
    axisModel.coordinateSystem = single;
    singles.push(single);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "singleAxis") {
      var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
    }
  });
  return singles;
}
var singleCreator = {
  create: create5,
  dimensions: singleDimensions
};
var singleCreator$1 = singleCreator;
var XY$1 = ["x", "y"];
var WH$1 = ["width", "height"];
var SingleAxisPointer = function(_super) {
  __extends$1(SingleAxisPointer2, _super);
  function SingleAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SingleAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var coordSys = axis.coordinateSystem;
    var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
    var pixelValue = coordSys.dataToPoint(value)[0];
    var axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout$1(axisModel);
    buildCartesianSingleLabelElOption(
      value,
      elOption,
      layoutInfo,
      axisModel,
      axisPointerModel,
      api
    );
  };
  SingleAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
    var layoutInfo = layout$1(axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var position2 = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: position2[0],
      y: position2[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  SingleAxisPointer2.prototype.updateHandleTransform = function(transform4, delta2, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var coordSys = axis.coordinateSystem;
    var dimIndex = getPointDimIndex(axis);
    var axisExtent = getGlobalExtent(coordSys, dimIndex);
    var currPosition = [transform4.x, transform4.y];
    currPosition[dimIndex] += delta2[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform4.rotation,
      cursorPoint,
      tooltipOption: {
        verticalAlign: "middle"
      }
    };
  };
  return SingleAxisPointer2;
}(BaseAxisPointer$1);
var pointerShapeBuilder = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = axis.getBandWidth();
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
    };
  }
};
function getPointDimIndex(axis) {
  return axis.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(coordSys, dimIndex) {
  var rect = coordSys.getRect();
  return [rect[XY$1[dimIndex]], rect[XY$1[dimIndex]] + rect[WH$1[dimIndex]]];
}
var SingleAxisPointer$1 = SingleAxisPointer;
var SingleView = function(_super) {
  __extends$1(SingleView2, _super);
  function SingleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SingleView2.type;
    return _this;
  }
  SingleView2.type = "single";
  return SingleView2;
}(ComponentView$1);
function install$n(registers) {
  use2(install$q);
  AxisView$1.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer$1);
  registers.registerComponentView(SingleView);
  registers.registerComponentView(SingleAxisView$1);
  registers.registerComponentModel(SingleAxisModel$1);
  axisModelCreator(registers, "single", SingleAxisModel$1, SingleAxisModel$1.defaultOption);
  registers.registerCoordinateSystem("single", singleCreator$1);
}
var CalendarModel = function(_super) {
  __extends$1(CalendarModel2, _super);
  function CalendarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CalendarModel2.type;
    return _this;
  }
  CalendarModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.apply(this, arguments);
    mergeAndNormalizeLayoutParams$1(option, inputPositionParams);
  };
  CalendarModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    mergeAndNormalizeLayoutParams$1(this.option, option);
  };
  CalendarModel2.prototype.getCellSize = function() {
    return this.option.cellSize;
  };
  CalendarModel2.type = "calendar";
  CalendarModel2.defaultOption = {
    z: 2,
    left: 80,
    top: 60,
    cellSize: 20,
    orient: "horizontal",
    splitLine: {
      show: true,
      lineStyle: {
        color: "#000",
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      color: "#fff",
      borderWidth: 1,
      borderColor: "#ccc"
    },
    dayLabel: {
      show: true,
      firstDay: 0,
      position: "start",
      margin: "50%",
      color: "#000"
    },
    monthLabel: {
      show: true,
      position: "start",
      margin: 5,
      align: "center",
      formatter: null,
      color: "#000"
    },
    yearLabel: {
      show: true,
      position: null,
      margin: 30,
      formatter: null,
      color: "#ccc",
      fontFamily: "sans-serif",
      fontWeight: "bolder",
      fontSize: 20
    }
  };
  return CalendarModel2;
}(ComponentModel$1);
function mergeAndNormalizeLayoutParams$1(target, raw) {
  var cellSize = target.cellSize;
  var cellSizeArr;
  if (!isArray$1(cellSize)) {
    cellSizeArr = target.cellSize = [cellSize, cellSize];
  } else {
    cellSizeArr = cellSize;
  }
  if (cellSizeArr.length === 1) {
    cellSizeArr[1] = cellSizeArr[0];
  }
  var ignoreSize = map$1([0, 1], function(hvIdx) {
    if (sizeCalculable(raw, hvIdx)) {
      cellSizeArr[hvIdx] = "auto";
    }
    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
  });
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize
  });
}
var CalendarModel$1 = CalendarModel;
var CalendarView = function(_super) {
  __extends$1(CalendarView2, _super);
  function CalendarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CalendarView2.type;
    return _this;
  }
  CalendarView2.prototype.render = function(calendarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    var coordSys = calendarModel.coordinateSystem;
    var rangeData = coordSys.getRangeInfo();
    var orient2 = coordSys.getOrient();
    var localeModel = ecModel.getLocaleModel();
    this._renderDayRect(calendarModel, rangeData, group);
    this._renderLines(calendarModel, rangeData, orient2, group);
    this._renderYearText(calendarModel, rangeData, orient2, group);
    this._renderMonthText(calendarModel, localeModel, orient2, group);
    this._renderWeekText(calendarModel, localeModel, rangeData, orient2, group);
  };
  CalendarView2.prototype._renderDayRect = function(calendarModel, rangeData, group) {
    var coordSys = calendarModel.coordinateSystem;
    var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
    var sw = coordSys.getCellWidth();
    var sh = coordSys.getCellHeight();
    for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
      var point4 = coordSys.dataToRect([i], false).tl;
      var rect = new Rect$3({
        shape: {
          x: point4[0],
          y: point4[1],
          width: sw,
          height: sh
        },
        cursor: "default",
        style: itemRectStyleModel
      });
      group.add(rect);
    }
  };
  CalendarView2.prototype._renderLines = function(calendarModel, rangeData, orient2, group) {
    var self2 = this;
    var coordSys = calendarModel.coordinateSystem;
    var lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
    var show = calendarModel.get(["splitLine", "show"]);
    var lineWidth = lineStyleModel.lineWidth;
    this._tlpoints = [];
    this._blpoints = [];
    this._firstDayOfMonth = [];
    this._firstDayPoints = [];
    var firstDay = rangeData.start;
    for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
      addPoints2(firstDay.formatedDate);
      if (i === 0) {
        firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
      }
      var date = firstDay.date;
      date.setMonth(date.getMonth() + 1);
      firstDay = coordSys.getDateInfo(date);
    }
    addPoints2(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
    function addPoints2(date2) {
      self2._firstDayOfMonth.push(coordSys.getDateInfo(date2));
      self2._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
      var points2 = self2._getLinePointsOfOneWeek(calendarModel, date2, orient2);
      self2._tlpoints.push(points2[0]);
      self2._blpoints.push(points2[points2.length - 1]);
      show && self2._drawSplitline(points2, lineStyleModel, group);
    }
    show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient2), lineStyleModel, group);
    show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient2), lineStyleModel, group);
  };
  CalendarView2.prototype._getEdgesPoints = function(points2, lineWidth, orient2) {
    var rs = [points2[0].slice(), points2[points2.length - 1].slice()];
    var idx = orient2 === "horizontal" ? 0 : 1;
    rs[0][idx] = rs[0][idx] - lineWidth / 2;
    rs[1][idx] = rs[1][idx] + lineWidth / 2;
    return rs;
  };
  CalendarView2.prototype._drawSplitline = function(points2, lineStyle, group) {
    var poyline = new Polyline$3({
      z2: 20,
      shape: {
        points: points2
      },
      style: lineStyle
    });
    group.add(poyline);
  };
  CalendarView2.prototype._getLinePointsOfOneWeek = function(calendarModel, date, orient2) {
    var coordSys = calendarModel.coordinateSystem;
    var parsedDate = coordSys.getDateInfo(date);
    var points2 = [];
    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(parsedDate.time, i);
      var point4 = coordSys.dataToRect([tmpD.time], false);
      points2[2 * tmpD.day] = point4.tl;
      points2[2 * tmpD.day + 1] = point4[orient2 === "horizontal" ? "bl" : "tr"];
    }
    return points2;
  };
  CalendarView2.prototype._formatterLabel = function(formatter, params) {
    if (isString(formatter) && formatter) {
      return formatTplSimple(formatter, params);
    }
    if (isFunction(formatter)) {
      return formatter(params);
    }
    return params.nameMap;
  };
  CalendarView2.prototype._yearTextPositionControl = function(textEl, point4, orient2, position2, margin) {
    var x2 = point4[0];
    var y2 = point4[1];
    var aligns = ["center", "bottom"];
    if (position2 === "bottom") {
      y2 += margin;
      aligns = ["center", "top"];
    } else if (position2 === "left") {
      x2 -= margin;
    } else if (position2 === "right") {
      x2 += margin;
      aligns = ["center", "top"];
    } else {
      y2 -= margin;
    }
    var rotate2 = 0;
    if (position2 === "left" || position2 === "right") {
      rotate2 = Math.PI / 2;
    }
    return {
      rotation: rotate2,
      x: x2,
      y: y2,
      style: {
        align: aligns[0],
        verticalAlign: aligns[1]
      }
    };
  };
  CalendarView2.prototype._renderYearText = function(calendarModel, rangeData, orient2, group) {
    var yearLabel = calendarModel.getModel("yearLabel");
    if (!yearLabel.get("show")) {
      return;
    }
    var margin = yearLabel.get("margin");
    var pos = yearLabel.get("position");
    if (!pos) {
      pos = orient2 !== "horizontal" ? "top" : "left";
    }
    var points2 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
    var xc = (points2[0][0] + points2[1][0]) / 2;
    var yc = (points2[0][1] + points2[1][1]) / 2;
    var idx = orient2 === "horizontal" ? 0 : 1;
    var posPoints = {
      top: [xc, points2[idx][1]],
      bottom: [xc, points2[1 - idx][1]],
      left: [points2[1 - idx][0], yc],
      right: [points2[idx][0], yc]
    };
    var name2 = rangeData.start.y;
    if (+rangeData.end.y > +rangeData.start.y) {
      name2 = name2 + "-" + rangeData.end.y;
    }
    var formatter = yearLabel.get("formatter");
    var params = {
      start: rangeData.start.y,
      end: rangeData.end.y,
      nameMap: name2
    };
    var content = this._formatterLabel(formatter, params);
    var yearText = new ZRText$1({
      z2: 30,
      style: createTextStyle(yearLabel, {
        text: content
      })
    });
    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient2, pos, margin));
    group.add(yearText);
  };
  CalendarView2.prototype._monthTextPositionControl = function(point4, isCenter, orient2, position2, margin) {
    var align = "left";
    var vAlign = "top";
    var x2 = point4[0];
    var y2 = point4[1];
    if (orient2 === "horizontal") {
      y2 = y2 + margin;
      if (isCenter) {
        align = "center";
      }
      if (position2 === "start") {
        vAlign = "bottom";
      }
    } else {
      x2 = x2 + margin;
      if (isCenter) {
        vAlign = "middle";
      }
      if (position2 === "start") {
        align = "right";
      }
    }
    return {
      x: x2,
      y: y2,
      align,
      verticalAlign: vAlign
    };
  };
  CalendarView2.prototype._renderMonthText = function(calendarModel, localeModel, orient2, group) {
    var monthLabel = calendarModel.getModel("monthLabel");
    if (!monthLabel.get("show")) {
      return;
    }
    var nameMap = monthLabel.get("nameMap");
    var margin = monthLabel.get("margin");
    var pos = monthLabel.get("position");
    var align = monthLabel.get("align");
    var termPoints = [this._tlpoints, this._blpoints];
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      nameMap = localeModel.get(["time", "monthAbbr"]) || [];
    }
    var idx = pos === "start" ? 0 : 1;
    var axis = orient2 === "horizontal" ? 0 : 1;
    margin = pos === "start" ? -margin : margin;
    var isCenter = align === "center";
    for (var i = 0; i < termPoints[idx].length - 1; i++) {
      var tmp = termPoints[idx][i].slice();
      var firstDay = this._firstDayOfMonth[i];
      if (isCenter) {
        var firstDayPoints = this._firstDayPoints[i];
        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
      }
      var formatter = monthLabel.get("formatter");
      var name_1 = nameMap[+firstDay.m - 1];
      var params = {
        yyyy: firstDay.y,
        yy: (firstDay.y + "").slice(2),
        MM: firstDay.m,
        M: +firstDay.m,
        nameMap: name_1
      };
      var content = this._formatterLabel(formatter, params);
      var monthText = new ZRText$1({
        z2: 30,
        style: extend2(createTextStyle(monthLabel, {
          text: content
        }), this._monthTextPositionControl(tmp, isCenter, orient2, pos, margin))
      });
      group.add(monthText);
    }
  };
  CalendarView2.prototype._weekTextPositionControl = function(point4, orient2, position2, margin, cellSize) {
    var align = "center";
    var vAlign = "middle";
    var x2 = point4[0];
    var y2 = point4[1];
    var isStart = position2 === "start";
    if (orient2 === "horizontal") {
      x2 = x2 + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
      align = isStart ? "right" : "left";
    } else {
      y2 = y2 + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
      vAlign = isStart ? "bottom" : "top";
    }
    return {
      x: x2,
      y: y2,
      align,
      verticalAlign: vAlign
    };
  };
  CalendarView2.prototype._renderWeekText = function(calendarModel, localeModel, rangeData, orient2, group) {
    var dayLabel = calendarModel.getModel("dayLabel");
    if (!dayLabel.get("show")) {
      return;
    }
    var coordSys = calendarModel.coordinateSystem;
    var pos = dayLabel.get("position");
    var nameMap = dayLabel.get("nameMap");
    var margin = dayLabel.get("margin");
    var firstDayOfWeek = coordSys.getFirstDayOfWeek();
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      var dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
      nameMap = dayOfWeekShort || map$1(localeModel.get(["time", "dayOfWeekAbbr"]), function(val) {
        return val[0];
      });
    }
    var start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
    var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
    margin = parsePercent(margin, Math.min(cellSize[1], cellSize[0]));
    if (pos === "start") {
      start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
      margin = -margin;
    }
    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(start2, i);
      var point4 = coordSys.dataToRect([tmpD.time], false).center;
      var day = i;
      day = Math.abs((i + firstDayOfWeek) % 7);
      var weekText = new ZRText$1({
        z2: 30,
        style: extend2(createTextStyle(dayLabel, {
          text: nameMap[day]
        }), this._weekTextPositionControl(point4, orient2, pos, margin, cellSize))
      });
      group.add(weekText);
    }
  };
  CalendarView2.type = "calendar";
  return CalendarView2;
}(ComponentView$1);
var CalendarView$1 = CalendarView;
var PROXIMATE_ONE_DAY = 864e5;
var Calendar = function() {
  function Calendar2(calendarModel, ecModel, api) {
    this.type = "calendar";
    this.dimensions = Calendar2.dimensions;
    this.getDimensionsInfo = Calendar2.getDimensionsInfo;
    this._model = calendarModel;
  }
  Calendar2.getDimensionsInfo = function() {
    return [{
      name: "time",
      type: "time"
    }, "value"];
  };
  Calendar2.prototype.getRangeInfo = function() {
    return this._rangeInfo;
  };
  Calendar2.prototype.getModel = function() {
    return this._model;
  };
  Calendar2.prototype.getRect = function() {
    return this._rect;
  };
  Calendar2.prototype.getCellWidth = function() {
    return this._sw;
  };
  Calendar2.prototype.getCellHeight = function() {
    return this._sh;
  };
  Calendar2.prototype.getOrient = function() {
    return this._orient;
  };
  Calendar2.prototype.getFirstDayOfWeek = function() {
    return this._firstDayOfWeek;
  };
  Calendar2.prototype.getDateInfo = function(date) {
    date = parseDate(date);
    var y2 = date.getFullYear();
    var m2 = date.getMonth() + 1;
    var mStr = m2 < 10 ? "0" + m2 : "" + m2;
    var d = date.getDate();
    var dStr = d < 10 ? "0" + d : "" + d;
    var day = date.getDay();
    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
    return {
      y: y2 + "",
      m: mStr,
      d: dStr,
      day,
      time: date.getTime(),
      formatedDate: y2 + "-" + mStr + "-" + dStr,
      date
    };
  };
  Calendar2.prototype.getNextNDay = function(date, n) {
    n = n || 0;
    if (n === 0) {
      return this.getDateInfo(date);
    }
    date = new Date(this.getDateInfo(date).time);
    date.setDate(date.getDate() + n);
    return this.getDateInfo(date);
  };
  Calendar2.prototype.update = function(ecModel, api) {
    this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
    this._orient = this._model.get("orient");
    this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
    this._rangeInfo = this._getRangeInfo(this._initRangeOption());
    var weeks = this._rangeInfo.weeks || 1;
    var whNames = ["width", "height"];
    var cellSize = this._model.getCellSize().slice();
    var layoutParams = this._model.getBoxLayoutParams();
    var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
    each$f([0, 1], function(idx) {
      if (cellSizeSpecified(cellSize, idx)) {
        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
      }
    });
    var whGlobal = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
    each$f([0, 1], function(idx) {
      if (!cellSizeSpecified(cellSize, idx)) {
        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
      }
    });
    function cellSizeSpecified(cellSize2, idx) {
      return cellSize2[idx] != null && cellSize2[idx] !== "auto";
    }
    this._sw = cellSize[0];
    this._sh = cellSize[1];
  };
  Calendar2.prototype.dataToPoint = function(data, clamp3) {
    isArray$1(data) && (data = data[0]);
    clamp3 == null && (clamp3 = true);
    var dayInfo = this.getDateInfo(data);
    var range = this._rangeInfo;
    var date = dayInfo.formatedDate;
    if (clamp3 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
      return [NaN, NaN];
    }
    var week = dayInfo.day;
    var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
    if (this._orient === "vertical") {
      return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
    }
    return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
  };
  Calendar2.prototype.pointToData = function(point4) {
    var date = this.pointToDate(point4);
    return date && date.time;
  };
  Calendar2.prototype.dataToRect = function(data, clamp3) {
    var point4 = this.dataToPoint(data, clamp3);
    return {
      contentShape: {
        x: point4[0] - (this._sw - this._lineWidth) / 2,
        y: point4[1] - (this._sh - this._lineWidth) / 2,
        width: this._sw - this._lineWidth,
        height: this._sh - this._lineWidth
      },
      center: point4,
      tl: [point4[0] - this._sw / 2, point4[1] - this._sh / 2],
      tr: [point4[0] + this._sw / 2, point4[1] - this._sh / 2],
      br: [point4[0] + this._sw / 2, point4[1] + this._sh / 2],
      bl: [point4[0] - this._sw / 2, point4[1] + this._sh / 2]
    };
  };
  Calendar2.prototype.pointToDate = function(point4) {
    var nthX = Math.floor((point4[0] - this._rect.x) / this._sw) + 1;
    var nthY = Math.floor((point4[1] - this._rect.y) / this._sh) + 1;
    var range = this._rangeInfo.range;
    if (this._orient === "vertical") {
      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
    }
    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
  };
  Calendar2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  Calendar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  Calendar2.prototype.containPoint = function(point4) {
    console.warn("Not implemented.");
    return false;
  };
  Calendar2.prototype._initRangeOption = function() {
    var range = this._model.get("range");
    var normalizedRange;
    if (isArray$1(range) && range.length === 1) {
      range = range[0];
    }
    if (!isArray$1(range)) {
      var rangeStr = range.toString();
      if (/^\d{4}$/.test(rangeStr)) {
        normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
      }
      if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
        var start2 = this.getDateInfo(rangeStr);
        var firstDay = start2.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        var end2 = this.getNextNDay(firstDay, -1);
        normalizedRange = [start2.formatedDate, end2.formatedDate];
      }
      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
        normalizedRange = [rangeStr, rangeStr];
      }
    } else {
      normalizedRange = range;
    }
    if (!normalizedRange) {
      {
        logError("Invalid date range.");
      }
      return range;
    }
    var tmp = this._getRangeInfo(normalizedRange);
    if (tmp.start.time > tmp.end.time) {
      normalizedRange.reverse();
    }
    return normalizedRange;
  };
  Calendar2.prototype._getRangeInfo = function(range) {
    var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
    var reversed;
    if (parsedRange[0].time > parsedRange[1].time) {
      reversed = true;
      parsedRange.reverse();
    }
    var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
    var date = new Date(parsedRange[0].time);
    var startDateNum = date.getDate();
    var endDateNum = parsedRange[1].date.getDate();
    date.setDate(startDateNum + allDay - 1);
    var dateNum = date.getDate();
    if (dateNum !== endDateNum) {
      var sign2 = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign2 > 0) {
        allDay -= sign2;
        date.setDate(dateNum - sign2);
      }
    }
    var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
    var nthWeek = reversed ? -weeks + 1 : weeks - 1;
    reversed && parsedRange.reverse();
    return {
      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
      start: parsedRange[0],
      end: parsedRange[1],
      allDay,
      weeks,
      nthWeek,
      fweek: parsedRange[0].day,
      lweek: parsedRange[1].day
    };
  };
  Calendar2.prototype._getDateByWeeksAndDay = function(nthWeek, day, range) {
    var rangeInfo = this._getRangeInfo(range);
    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
      return null;
    }
    var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
    var date = new Date(rangeInfo.start.time);
    date.setDate(+rangeInfo.start.d + nthDay);
    return this.getDateInfo(date);
  };
  Calendar2.create = function(ecModel, api) {
    var calendarList = [];
    ecModel.eachComponent("calendar", function(calendarModel) {
      var calendar = new Calendar2(calendarModel);
      calendarList.push(calendar);
      calendarModel.coordinateSystem = calendar;
    });
    ecModel.eachSeries(function(calendarSeries) {
      if (calendarSeries.get("coordinateSystem") === "calendar") {
        calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
      }
    });
    return calendarList;
  };
  Calendar2.dimensions = ["time", "value"];
  return Calendar2;
}();
function getCoordSys(finder) {
  var calendarModel = finder.calendarModel;
  var seriesModel = finder.seriesModel;
  var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}
var Calendar$1 = Calendar;
function install$m(registers) {
  registers.registerComponentModel(CalendarModel$1);
  registers.registerComponentView(CalendarView$1);
  registers.registerCoordinateSystem("calendar", Calendar$1);
}
function setKeyInfoToNewElOption(resultItem, newElOption) {
  var existElOption = resultItem.existing;
  newElOption.id = resultItem.keyInfo.id;
  !newElOption.type && existElOption && (newElOption.type = existElOption.type);
  if (newElOption.parentId == null) {
    var newElParentOption = newElOption.parentOption;
    if (newElParentOption) {
      newElOption.parentId = newElParentOption.id;
    } else if (existElOption) {
      newElOption.parentId = existElOption.parentId;
    }
  }
  newElOption.parentOption = null;
}
function isSetLoc(obj, props) {
  var isSet;
  each$f(props, function(prop) {
    obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
  });
  return isSet;
}
function mergeNewElOptionToExist(existList, index2, newElOption) {
  var newElOptCopy = extend2({}, newElOption);
  var existElOption = existList[index2];
  var $action = newElOption.$action || "merge";
  if ($action === "merge") {
    if (existElOption) {
      {
        var newType = newElOption.type;
        assert(!newType || existElOption.type === newType, 'Please set $action: "replace" to change `type`');
      }
      merge3(existElOption, newElOptCopy, true);
      mergeLayoutParam(existElOption, newElOptCopy, {
        ignoreSize: true
      });
      copyLayoutParams(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption, "shape");
      copyTransitionInfo(newElOption, existElOption, "style");
      copyTransitionInfo(newElOption, existElOption, "extra");
      newElOption.clipPath = existElOption.clipPath;
    } else {
      existList[index2] = newElOptCopy;
    }
  } else if ($action === "replace") {
    existList[index2] = newElOptCopy;
  } else if ($action === "remove") {
    existElOption && (existList[index2] = null);
  }
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"];
var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(target, source2, targetProp) {
  if (targetProp) {
    if (!target[targetProp] && source2[targetProp]) {
      target[targetProp] = {};
    }
    target = target[targetProp];
    source2 = source2[targetProp];
  }
  if (!target || !source2) {
    return;
  }
  var props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    if (target[prop] == null && source2[prop] != null) {
      target[prop] = source2[prop];
    }
  }
}
function setLayoutInfoToExist(existItem, newElOption) {
  if (!existItem) {
    return;
  }
  existItem.hv = newElOption.hv = [
    isSetLoc(newElOption, ["left", "right"]),
    isSetLoc(newElOption, ["top", "bottom"])
  ];
  if (existItem.type === "group") {
    var existingGroupOpt = existItem;
    var newGroupOpt = newElOption;
    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
  }
}
var GraphicComponentModel = function(_super) {
  __extends$1(GraphicComponentModel2, _super);
  function GraphicComponentModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphicComponentModel2.type;
    _this.preventAutoZ = true;
    return _this;
  }
  GraphicComponentModel2.prototype.mergeOption = function(option, ecModel) {
    var elements = this.option.elements;
    this.option.elements = null;
    _super.prototype.mergeOption.call(this, option, ecModel);
    this.option.elements = elements;
  };
  GraphicComponentModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    var newList = (isInit ? thisOption : newOption).elements;
    var existList = thisOption.elements = isInit ? [] : thisOption.elements;
    var flattenedList = [];
    this._flatten(newList, flattenedList, null);
    var mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
    var elOptionsToUpdate = this._elOptionsToUpdate = [];
    each$f(mappingResult, function(resultItem, index2) {
      var newElOption = resultItem.newOption;
      {
        assert(isObject$3(newElOption) || resultItem.existing, "Empty graphic option definition");
      }
      if (!newElOption) {
        return;
      }
      elOptionsToUpdate.push(newElOption);
      setKeyInfoToNewElOption(resultItem, newElOption);
      mergeNewElOptionToExist(existList, index2, newElOption);
      setLayoutInfoToExist(existList[index2], newElOption);
    }, this);
    thisOption.elements = filter17(existList, function(item) {
      item && delete item.$action;
      return item != null;
    });
  };
  GraphicComponentModel2.prototype._flatten = function(optionList, result, parentOption) {
    each$f(optionList, function(option) {
      if (!option) {
        return;
      }
      if (parentOption) {
        option.parentOption = parentOption;
      }
      result.push(option);
      var children = option.children;
      if (children && children.length) {
        this._flatten(children, result, option);
      }
      delete option.children;
    }, this);
  };
  GraphicComponentModel2.prototype.useElOptionsToUpdate = function() {
    var els = this._elOptionsToUpdate;
    this._elOptionsToUpdate = null;
    return els;
  };
  GraphicComponentModel2.type = "graphic";
  GraphicComponentModel2.defaultOption = {
    elements: []
  };
  return GraphicComponentModel2;
}(ComponentModel$1);
var nonShapeGraphicElements = {
  path: null,
  compoundPath: null,
  group: Group$4,
  image: ZRImage$1,
  text: ZRText$1
};
var inner$7 = makeInner();
var GraphicComponentView = function(_super) {
  __extends$1(GraphicComponentView2, _super);
  function GraphicComponentView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphicComponentView2.type;
    return _this;
  }
  GraphicComponentView2.prototype.init = function() {
    this._elMap = createHashMap();
  };
  GraphicComponentView2.prototype.render = function(graphicModel, ecModel, api) {
    if (graphicModel !== this._lastGraphicModel) {
      this._clear();
    }
    this._lastGraphicModel = graphicModel;
    this._updateElements(graphicModel);
    this._relocate(graphicModel, api);
  };
  GraphicComponentView2.prototype._updateElements = function(graphicModel) {
    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
    if (!elOptionsToUpdate) {
      return;
    }
    var elMap = this._elMap;
    var rootGroup = this.group;
    var globalZ = graphicModel.get("z");
    var globalZLevel = graphicModel.get("zlevel");
    each$f(elOptionsToUpdate, function(elOption) {
      var id = convertOptionIdName(elOption.id, null);
      var elExisting = id != null ? elMap.get(id) : null;
      var parentId = convertOptionIdName(elOption.parentId, null);
      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
      var elType = elOption.type;
      var elOptionStyle = elOption.style;
      if (elType === "text" && elOptionStyle) {
        if (elOption.hv && elOption.hv[1]) {
          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
        }
      }
      var textContentOption = elOption.textContent;
      var textConfig = elOption.textConfig;
      if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
        var convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
        if (!textConfig && convertResult.textConfig) {
          textConfig = elOption.textConfig = convertResult.textConfig;
        }
        if (!textContentOption && convertResult.textContent) {
          textContentOption = convertResult.textContent;
        }
      }
      var elOptionCleaned = getCleanedElOption(elOption);
      {
        elExisting && assert(targetElParent === elExisting.parent, "Changing parent is not supported.");
      }
      var $action = elOption.$action || "merge";
      var isMerge = $action === "merge";
      var isReplace = $action === "replace";
      if (isMerge) {
        var isInit = !elExisting;
        var el_1 = elExisting;
        if (isInit) {
          el_1 = createEl(id, targetElParent, elOption.type, elMap);
        } else {
          el_1 && (inner$7(el_1).isNew = false);
          stopPreviousKeyframeAnimationAndRestore(el_1);
        }
        if (el_1) {
          applyUpdateTransition(el_1, elOptionCleaned, graphicModel, {
            isInit
          });
          updateCommonAttrs(el_1, elOption, globalZ, globalZLevel);
        }
      } else if (isReplace) {
        removeEl$1(elExisting, elOption, elMap, graphicModel);
        var el_2 = createEl(id, targetElParent, elOption.type, elMap);
        if (el_2) {
          applyUpdateTransition(el_2, elOptionCleaned, graphicModel, {
            isInit: true
          });
          updateCommonAttrs(el_2, elOption, globalZ, globalZLevel);
        }
      } else if ($action === "remove") {
        updateLeaveTo(elExisting, elOption);
        removeEl$1(elExisting, elOption, elMap, graphicModel);
      }
      var el = elMap.get(id);
      if (el && textContentOption) {
        if (isMerge) {
          var textContentExisting = el.getTextContent();
          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new ZRText$1(textContentOption));
        } else if (isReplace) {
          el.setTextContent(new ZRText$1(textContentOption));
        }
      }
      if (el) {
        var clipPathOption = elOption.clipPath;
        if (clipPathOption) {
          var clipPathType = clipPathOption.type;
          var clipPath = void 0;
          var isInit = false;
          if (isMerge) {
            var oldClipPath = el.getClipPath();
            isInit = !oldClipPath || inner$7(oldClipPath).type !== clipPathType;
            clipPath = isInit ? newEl(clipPathType) : oldClipPath;
          } else if (isReplace) {
            isInit = true;
            clipPath = newEl(clipPathType);
          }
          el.setClipPath(clipPath);
          applyUpdateTransition(clipPath, clipPathOption, graphicModel, {
            isInit
          });
          applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
        }
        var elInner = inner$7(el);
        el.setTextConfig(textConfig);
        elInner.option = elOption;
        setEventData(el, graphicModel, elOption);
        setTooltipConfig({
          el,
          componentModel: graphicModel,
          itemName: el.name,
          itemTooltipOption: elOption.tooltip
        });
        applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
      }
    });
  };
  GraphicComponentView2.prototype._relocate = function(graphicModel, api) {
    var elOptions = graphicModel.option.elements;
    var rootGroup = this.group;
    var elMap = this._elMap;
    var apiWidth = api.getWidth();
    var apiHeight = api.getHeight();
    var xy = ["x", "y"];
    for (var i = 0; i < elOptions.length; i++) {
      var elOption = elOptions[i];
      var id = convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;
      if (!el || !el.isGroup) {
        continue;
      }
      var parentEl = el.parent;
      var isParentRoot = parentEl === rootGroup;
      var elInner = inner$7(el);
      var parentElInner = inner$7(parentEl);
      elInner.width = parsePercent(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
      elInner.height = parsePercent(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
    }
    for (var i = elOptions.length - 1; i >= 0; i--) {
      var elOption = elOptions[i];
      var id = convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;
      if (!el) {
        continue;
      }
      var parentEl = el.parent;
      var parentElInner = inner$7(parentEl);
      var containerInfo = parentEl === rootGroup ? {
        width: apiWidth,
        height: apiHeight
      } : {
        width: parentElInner.width,
        height: parentElInner.height
      };
      var layoutPos = {};
      var layouted = positionElement(el, elOption, containerInfo, null, {
        hv: elOption.hv,
        boundingMode: elOption.bounding
      }, layoutPos);
      if (!inner$7(el).isNew && layouted) {
        var transition = elOption.transition;
        var animatePos = {};
        for (var k = 0; k < xy.length; k++) {
          var key = xy[k];
          var val = layoutPos[key];
          if (transition && (isTransitionAll(transition) || indexOf2(transition, key) >= 0)) {
            animatePos[key] = val;
          } else {
            el[key] = val;
          }
        }
        updateProps$1(el, animatePos, graphicModel, 0);
      } else {
        el.attr(layoutPos);
      }
    }
  };
  GraphicComponentView2.prototype._clear = function() {
    var _this = this;
    var elMap = this._elMap;
    elMap.each(function(el) {
      removeEl$1(el, inner$7(el).option, elMap, _this._lastGraphicModel);
    });
    this._elMap = createHashMap();
  };
  GraphicComponentView2.prototype.dispose = function() {
    this._clear();
  };
  GraphicComponentView2.type = "graphic";
  return GraphicComponentView2;
}(ComponentView$1);
function newEl(graphicType) {
  {
    assert(graphicType, "graphic type MUST be set");
  }
  var Clz = hasOwn(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
  {
    assert(Clz, "graphic type " + graphicType + " can not be found");
  }
  var el = new Clz({});
  inner$7(el).type = graphicType;
  return el;
}
function createEl(id, targetElParent, graphicType, elMap) {
  var el = newEl(graphicType);
  targetElParent.add(el);
  elMap.set(id, el);
  inner$7(el).id = id;
  inner$7(el).isNew = true;
  return el;
}
function removeEl$1(elExisting, elOption, elMap, graphicModel) {
  var existElParent = elExisting && elExisting.parent;
  if (existElParent) {
    elExisting.type === "group" && elExisting.traverse(function(el) {
      removeEl$1(el, elOption, elMap, graphicModel);
    });
    applyLeaveTransition(elExisting, elOption, graphicModel);
    elMap.removeKey(inner$7(elExisting).id);
  }
}
function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
  if (!el.isGroup) {
    each$f([
      ["cursor", Displayable$1.prototype.cursor],
      ["zlevel", defaultZlevel || 0],
      ["z", defaultZ || 0],
      ["z2", 0]
    ], function(item) {
      var prop = item[0];
      if (hasOwn(elOption, prop)) {
        el[prop] = retrieve2(elOption[prop], item[1]);
      } else if (el[prop] == null) {
        el[prop] = item[1];
      }
    });
  }
  each$f(keys2(elOption), function(key) {
    if (key.indexOf("on") === 0) {
      var val = elOption[key];
      el[key] = isFunction(val) ? val : null;
    }
  });
  if (hasOwn(elOption, "draggable")) {
    el.draggable = elOption.draggable;
  }
  elOption.name != null && (el.name = elOption.name);
  elOption.id != null && (el.id = elOption.id);
}
function getCleanedElOption(elOption) {
  elOption = extend2({}, elOption);
  each$f(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(name2) {
    delete elOption[name2];
  });
  return elOption;
}
function setEventData(el, graphicModel, elOption) {
  var eventData = getECData(el).eventData;
  if (!el.silent && !el.ignore && !eventData) {
    eventData = getECData(el).eventData = {
      componentType: "graphic",
      componentIndex: graphicModel.componentIndex,
      name: el.name
    };
  }
  if (eventData) {
    eventData.info = elOption.info;
  }
}
function install$l(registers) {
  registers.registerComponentModel(GraphicComponentModel);
  registers.registerComponentView(GraphicComponentView);
  registers.registerPreprocessor(function(option) {
    var graphicOption = option.graphic;
    if (isArray$1(graphicOption)) {
      if (!graphicOption[0] || !graphicOption[0].elements) {
        option.graphic = [{
          elements: graphicOption
        }];
      } else {
        option.graphic = [option.graphic[0]];
      }
    } else if (graphicOption && !graphicOption.elements) {
      option.graphic = [{
        elements: [graphicOption]
      }];
    }
  });
}
var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"];
var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(seriesModel) {
  var coordType = seriesModel.get("coordinateSystem");
  return indexOf2(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  {
    assert(axisDim);
  }
  return axisDim + "Axis";
}
function findEffectedDataZooms(ecModel, payload) {
  var axisRecords = createHashMap();
  var effectedModels = [];
  var effectedModelMap = createHashMap();
  ecModel.eachComponent({
    mainType: "dataZoom",
    query: payload
  }, function(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  });
  var foundNewLink;
  do {
    foundNewLink = false;
    ecModel.eachComponent("dataZoom", processSingle);
  } while (foundNewLink);
  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }
  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }
  function isLinked(dataZoomModel) {
    var isLink = false;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var axisIdxArr = axisRecords.get(axisDim);
      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }
  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }
  return effectedModels;
}
function collectReferCoordSysModelInfo(dataZoomModel) {
  var ecModel = dataZoomModel.ecModel;
  var coordSysInfoWrap = {
    infoList: [],
    infoMap: createHashMap()
  };
  dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    if (!axisModel) {
      return;
    }
    var coordSysModel = axisModel.getCoordSysModel();
    if (!coordSysModel) {
      return;
    }
    var coordSysUid = coordSysModel.uid;
    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
    if (!coordSysInfo) {
      coordSysInfo = {
        model: coordSysModel,
        axisModels: []
      };
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }
    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}
var DataZoomAxisInfo = function() {
  function DataZoomAxisInfo2() {
    this.indexList = [];
    this.indexMap = [];
  }
  DataZoomAxisInfo2.prototype.add = function(axisCmptIdx) {
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  };
  return DataZoomAxisInfo2;
}();
var DataZoomModel = function(_super) {
  __extends$1(DataZoomModel2, _super);
  function DataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomModel2.type;
    _this._autoThrottle = true;
    _this._noTarget = true;
    _this._rangePropMode = ["percent", "percent"];
    return _this;
  }
  DataZoomModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputRawOption = retrieveRawOption(option);
    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype.mergeOption = function(newOption) {
    var inputRawOption = retrieveRawOption(newOption);
    merge3(this.option, newOption, true);
    merge3(this.settledOption, inputRawOption, true);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype._doInit = function(inputRawOption) {
    var thisOption = this.option;
    this._setDefaultThrottle(inputRawOption);
    this._updateRangeUse(inputRawOption);
    var settledOption = this.settledOption;
    each$f([["start", "startValue"], ["end", "endValue"]], function(names, index2) {
      if (this._rangePropMode[index2] === "value") {
        thisOption[names[0]] = settledOption[names[0]] = null;
      }
    }, this);
    this._resetTarget();
  };
  DataZoomModel2.prototype._resetTarget = function() {
    var optionOrient = this.get("orient", true);
    var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || "horizontal";
      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }
    this._noTarget = true;
    targetAxisIndexMap.each(function(axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  };
  DataZoomModel2.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
    var hasAxisSpecified = false;
    each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
      var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
      if (!refering.specified) {
        return;
      }
      hasAxisSpecified = true;
      var axisInfo = new DataZoomAxisInfo();
      each$f(refering.models, function(axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  };
  DataZoomModel2.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient2) {
    var ecModel = this.ecModel;
    var needAuto = true;
    if (needAuto) {
      var axisDim = orient2 === "vertical" ? "y" : "x";
      var axisModels = ecModel.findComponents({
        mainType: axisDim + "Axis"
      });
      setParallelAxis(axisModels, axisDim);
    }
    if (needAuto) {
      var axisModels = ecModel.findComponents({
        mainType: "singleAxis",
        filter: function(axisModel) {
          return axisModel.get("orient", true) === orient2;
        }
      });
      setParallelAxis(axisModels, "single");
    }
    function setParallelAxis(axisModels2, axisDim2) {
      var axisModel = axisModels2[0];
      if (!axisModel) {
        return;
      }
      var axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim2, axisInfo);
      needAuto = false;
      if (axisDim2 === "x" || axisDim2 === "y") {
        var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
        gridModel_1 && each$f(axisModels2, function(axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }
    if (needAuto) {
      each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim2) {
        if (!needAuto) {
          return;
        }
        var axisModels2 = ecModel.findComponents({
          mainType: getAxisMainType(axisDim2),
          filter: function(axisModel) {
            return axisModel.get("type", true) === "category";
          }
        });
        if (axisModels2[0]) {
          var axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels2[0].componentIndex);
          targetAxisIndexMap.set(axisDim2, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  };
  DataZoomModel2.prototype._makeAutoOrientByTargetAxis = function() {
    var dim;
    this.eachTargetAxis(function(axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === "y" ? "vertical" : "horizontal";
  };
  DataZoomModel2.prototype._setDefaultThrottle = function(inputRawOption) {
    if (inputRawOption.hasOwnProperty("throttle")) {
      this._autoThrottle = false;
    }
    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  };
  DataZoomModel2.prototype._updateRangeUse = function(inputRawOption) {
    var rangePropMode = this._rangePropMode;
    var rangeModeInOption = this.get("rangeMode");
    each$f([["start", "startValue"], ["end", "endValue"]], function(names, index2) {
      var percentSpecified = inputRawOption[names[0]] != null;
      var valueSpecified = inputRawOption[names[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index2] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index2] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index2] = rangeModeInOption[index2];
      } else if (percentSpecified) {
        rangePropMode[index2] = "percent";
      }
    });
  };
  DataZoomModel2.prototype.noTarget = function() {
    return this._noTarget;
  };
  DataZoomModel2.prototype.getFirstTargetAxisModel = function() {
    var firstAxisModel;
    this.eachTargetAxis(function(axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  };
  DataZoomModel2.prototype.eachTargetAxis = function(callback, context) {
    this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
      each$f(axisInfo.indexList, function(axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  };
  DataZoomModel2.prototype.getAxisProxy = function(axisDim, axisIndex) {
    var axisModel = this.getAxisModel(axisDim, axisIndex);
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  };
  DataZoomModel2.prototype.getAxisModel = function(axisDim, axisIndex) {
    {
      assert(axisDim && axisIndex != null);
    }
    var axisInfo = this._targetAxisInfoMap.get(axisDim);
    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    }
  };
  DataZoomModel2.prototype.setRawRange = function(opt) {
    var thisOption = this.option;
    var settledOption = this.settledOption;
    each$f([["start", "startValue"], ["end", "endValue"]], function(names) {
      if (opt[names[0]] != null || opt[names[1]] != null) {
        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
      }
    }, this);
    this._updateRangeUse(opt);
  };
  DataZoomModel2.prototype.setCalculatedRange = function(opt) {
    var option = this.option;
    each$f(["start", "startValue", "end", "endValue"], function(name2) {
      option[name2] = opt[name2];
    });
  };
  DataZoomModel2.prototype.getPercentRange = function() {
    var axisProxy = this.findRepresentativeAxisProxy();
    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  };
  DataZoomModel2.prototype.getValueRange = function(axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  };
  DataZoomModel2.prototype.findRepresentativeAxisProxy = function(axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
    var firstProxy;
    var axisDimList = this._targetAxisInfoMap.keys();
    for (var i = 0; i < axisDimList.length; i++) {
      var axisDim = axisDimList[i];
      var axisInfo = this._targetAxisInfoMap.get(axisDim);
      for (var j = 0; j < axisInfo.indexList.length; j++) {
        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
        if (proxy.hostedBy(this)) {
          return proxy;
        }
        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    }
    return firstProxy;
  };
  DataZoomModel2.prototype.getRangePropMode = function() {
    return this._rangePropMode.slice();
  };
  DataZoomModel2.prototype.getOrient = function() {
    {
      assert(this._orient);
    }
    return this._orient;
  };
  DataZoomModel2.type = "dataZoom";
  DataZoomModel2.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"];
  DataZoomModel2.defaultOption = {
    z: 4,
    filterMode: "filter",
    start: 0,
    end: 100
  };
  return DataZoomModel2;
}(ComponentModel$1);
function retrieveRawOption(option) {
  var ret = {};
  each$f(["start", "end", "startValue", "endValue", "throttle"], function(name2) {
    option.hasOwnProperty(name2) && (ret[name2] = option[name2]);
  });
  return ret;
}
var DataZoomModel$1 = DataZoomModel;
var SelectDataZoomModel = function(_super) {
  __extends$1(SelectDataZoomModel2, _super);
  function SelectDataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SelectDataZoomModel2.type;
    return _this;
  }
  SelectDataZoomModel2.type = "dataZoom.select";
  return SelectDataZoomModel2;
}(DataZoomModel$1);
var SelectZoomModel = SelectDataZoomModel;
var DataZoomView = function(_super) {
  __extends$1(DataZoomView2, _super);
  function DataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomView2.type;
    return _this;
  }
  DataZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  };
  DataZoomView2.type = "dataZoom";
  return DataZoomView2;
}(ComponentView$1);
var DataZoomView$1 = DataZoomView;
var SelectDataZoomView = function(_super) {
  __extends$1(SelectDataZoomView2, _super);
  function SelectDataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SelectDataZoomView2.type;
    return _this;
  }
  SelectDataZoomView2.type = "dataZoom.select";
  return SelectDataZoomView2;
}(DataZoomView$1);
var SelectZoomView = SelectDataZoomView;
var each$7 = each$f;
var asc$1 = asc$2;
var AxisProxy = function() {
  function AxisProxy2(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  }
  AxisProxy2.prototype.hostedBy = function(dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  };
  AxisProxy2.prototype.getDataValueWindow = function() {
    return this._valueWindow.slice();
  };
  AxisProxy2.prototype.getDataPercentWindow = function() {
    return this._percentWindow.slice();
  };
  AxisProxy2.prototype.getTargetSeriesModels = function() {
    var seriesModels = [];
    this.ecModel.eachSeries(function(seriesModel) {
      if (isCoordSupported(seriesModel)) {
        var axisMainType = getAxisMainType(this._dimName);
        var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  };
  AxisProxy2.prototype.getAxisModel = function() {
    return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
  };
  AxisProxy2.prototype.getMinMaxSpan = function() {
    return clone$4(this._minMaxSpan);
  };
  AxisProxy2.prototype.calculateDataWindow = function(opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale4 = axisModel.axis.scale;
    var rangePropMode = this._dataZoomModel.getRangePropMode();
    var percentExtent = [0, 100];
    var percentWindow = [];
    var valueWindow = [];
    var hasPropModeValue;
    each$7(["start", "end"], function(prop, idx) {
      var boundPercent = opt[prop];
      var boundValue = opt[prop + "Value"];
      if (rangePropMode[idx] === "percent") {
        boundPercent == null && (boundPercent = percentExtent[idx]);
        boundValue = scale4.parse(linearMap$2(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale4.parse(boundValue);
        boundPercent = linearMap$2(boundValue, dataExtent, percentExtent);
      }
      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    asc$1(valueWindow);
    asc$1(percentWindow);
    var spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
      var suffix = toValue ? "Span" : "ValueSpan";
      sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
      for (var i = 0; i < 2; i++) {
        toWindow[i] = linearMap$2(fromWindow[i], fromExtent, toExtent, true);
        toValue && (toWindow[i] = scale4.parse(toWindow[i]));
      }
    }
    return {
      valueWindow,
      percentWindow
    };
  };
  AxisProxy2.prototype.reset = function(dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var targetSeries = this.getTargetSeriesModels();
    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
    this._updateMinMaxSpan();
    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    this._setAxisModel();
  };
  AxisProxy2.prototype.filterData = function(dataZoomModel, api) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get("filterMode");
    var valueWindow = this._valueWindow;
    if (filterMode === "none") {
      return;
    }
    each$7(seriesModels, function(seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesData.mapDimensionsAll(axisDim);
      if (!dataDims.length) {
        return;
      }
      if (filterMode === "weakFilter") {
        var store_1 = seriesData.getStore();
        var dataDimIndices_1 = map$1(dataDims, function(dim) {
          return seriesData.getDimensionIndex(dim);
        }, seriesData);
        seriesData.filterSelf(function(dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;
          for (var i = 0; i < dataDims.length; i++) {
            var value = store_1.get(dataDimIndices_1[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];
            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }
            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          }
          return hasValue && leftOut && rightOut;
        });
      } else {
        each$7(dataDims, function(dim) {
          if (filterMode === "empty") {
            seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            var range = {};
            range[dim] = valueWindow;
            seriesData.selectRange(range);
          }
        });
      }
      each$7(dataDims, function(dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });
    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  };
  AxisProxy2.prototype._updateMinMaxSpan = function() {
    var minMaxSpan = this._minMaxSpan = {};
    var dataZoomModel = this._dataZoomModel;
    var dataExtent = this._dataExtent;
    each$7(["min", "max"], function(minMax) {
      var percentSpan = dataZoomModel.get(minMax + "Span");
      var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = linearMap$2(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = linearMap$2(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    }, this);
  };
  AxisProxy2.prototype._setAxisModel = function() {
    var axisModel = this.getAxisModel();
    var percentWindow = this._percentWindow;
    var valueWindow = this._valueWindow;
    if (!percentWindow) {
      return;
    }
    var precision = getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
    }
    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
    }
    rawExtentInfo.freeze();
  };
  return AxisProxy2;
}();
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each$7(seriesModels, function(seriesModel) {
    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
  });
  var axisModel = axisProxy.getAxisModel();
  var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy$1 = AxisProxy;
var dataZoomProcessor = {
  getTargetSeries: function(ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    }
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      axisModel.__dzAxisProxy = null;
    });
    var proxyList = [];
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      if (!axisModel.__dzAxisProxy) {
        axisModel.__dzAxisProxy = new AxisProxy$1(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    var seriesModelMap = createHashMap();
    each$f(proxyList, function(axisProxy) {
      each$f(axisProxy.getTargetSeriesModels(), function(seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  overallReset: function(ecModel, api) {
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      });
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
      });
    });
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
var dataZoomProcessor$1 = dataZoomProcessor;
function installDataZoomAction(registers) {
  registers.registerAction("dataZoom", function(payload, ecModel) {
    var effectedModels = findEffectedDataZooms(ecModel, payload);
    each$f(effectedModels, function(dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}
var installed$1 = false;
function installCommon$1(registers) {
  if (installed$1) {
    return;
  }
  installed$1 = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor$1);
  installDataZoomAction(registers);
  registers.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
}
function install$k(registers) {
  registers.registerComponentModel(SelectZoomModel);
  registers.registerComponentView(SelectZoomView);
  installCommon$1(registers);
}
var ToolboxFeature = function() {
  function ToolboxFeature2() {
  }
  return ToolboxFeature2;
}();
var features = {};
function registerFeature(name2, ctor) {
  features[name2] = ctor;
}
function getFeature(name2) {
  return features[name2];
}
var ToolboxModel = function(_super) {
  __extends$1(ToolboxModel2, _super);
  function ToolboxModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ToolboxModel2.type;
    return _this;
  }
  ToolboxModel2.prototype.optionUpdated = function() {
    _super.prototype.optionUpdated.apply(this, arguments);
    var ecModel = this.ecModel;
    each$f(this.option.feature, function(featureOpt, featureName) {
      var Feature = getFeature(featureName);
      if (Feature) {
        if (Feature.getDefaultOption) {
          Feature.defaultOption = Feature.getDefaultOption(ecModel);
        }
        merge3(featureOpt, Feature.defaultOption);
      }
    });
  };
  ToolboxModel2.type = "toolbox";
  ToolboxModel2.layoutMode = {
    type: "box",
    ignoreSize: true
  };
  ToolboxModel2.defaultOption = {
    show: true,
    z: 6,
    orient: "horizontal",
    left: "right",
    top: "top",
    backgroundColor: "transparent",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      borderColor: "#666",
      color: "none"
    },
    emphasis: {
      iconStyle: {
        borderColor: "#3E98C5"
      }
    },
    tooltip: {
      show: false,
      position: "bottom"
    }
  };
  return ToolboxModel2;
}(ComponentModel$1);
var ToolboxModel$1 = ToolboxModel;
function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get("padding");
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
  box(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}
function makeBackground(rect, componentModel) {
  var padding = normalizeCssArray(componentModel.get("padding"));
  var style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  rect = new Rect$3({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return rect;
}
var ToolboxView = function(_super) {
  __extends$1(ToolboxView2, _super);
  function ToolboxView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ToolboxView2.prototype.render = function(toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();
    if (!toolboxModel.get("show")) {
      return;
    }
    var itemSize = +toolboxModel.get("itemSize");
    var isVertical2 = toolboxModel.get("orient") === "vertical";
    var featureOpts = toolboxModel.get("feature") || {};
    var features2 = this._features || (this._features = {});
    var featureNames = [];
    each$f(featureOpts, function(opt, name2) {
      featureNames.push(name2);
    });
    new DataDiffer$1(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry$1(processFeature, null)).execute();
    this._featureNames = featureNames;
    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new Model$1(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature2;
      if (payload && payload.newTitle != null && payload.featureName === featureName) {
        featureOpt.title = payload.newTitle;
      }
      if (featureName && !oldName) {
        if (isUserFeatureName(featureName)) {
          feature2 = {
            onclick: featureModel.option.onclick,
            featureName
          };
        } else {
          var Feature = getFeature(featureName);
          if (!Feature) {
            return;
          }
          feature2 = new Feature();
        }
        features2[featureName] = feature2;
      } else {
        feature2 = features2[oldName];
        if (!feature2) {
          return;
        }
      }
      feature2.uid = getUID("toolbox-feature");
      feature2.model = featureModel;
      feature2.ecModel = ecModel;
      feature2.api = api;
      var isToolboxFeature = feature2 instanceof ToolboxFeature;
      if (!featureName && oldName) {
        isToolboxFeature && feature2.dispose && feature2.dispose(ecModel, api);
        return;
      }
      if (!featureModel.get("show") || isToolboxFeature && feature2.unusable) {
        isToolboxFeature && feature2.remove && feature2.remove(ecModel, api);
        return;
      }
      createIconPaths(featureModel, feature2, featureName);
      featureModel.setIconStatus = function(iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status;
        if (iconPaths[iconName]) {
          (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
        }
      };
      if (feature2 instanceof ToolboxFeature) {
        if (feature2.render) {
          feature2.render(featureModel, ecModel, api, payload);
        }
      }
    }
    function createIconPaths(featureModel, feature2, featureName) {
      var iconStyleModel = featureModel.getModel("iconStyle");
      var iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
      var icons = feature2 instanceof ToolboxFeature && feature2.getIcons ? feature2.getIcons() : featureModel.get("icon");
      var titles = featureModel.get("title") || {};
      var iconsMap;
      var titlesMap;
      if (isString(icons)) {
        iconsMap = {};
        iconsMap[featureName] = icons;
      } else {
        iconsMap = icons;
      }
      if (isString(titles)) {
        titlesMap = {};
        titlesMap[featureName] = titles;
      } else {
        titlesMap = titles;
      }
      var iconPaths = featureModel.iconPaths = {};
      each$f(iconsMap, function(iconStr, iconName) {
        var path = createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getItemStyle());
        var pathEmphasisState = path.ensureState("emphasis");
        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
        var textContent = new ZRText$1({
          style: {
            text: titlesMap[iconName],
            align: iconStyleEmphasisModel.get("textAlign"),
            borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
            padding: iconStyleEmphasisModel.get("textPadding"),
            fill: null
          },
          ignore: true
        });
        path.setTextContent(textContent);
        setTooltipConfig({
          el: path,
          componentModel: toolboxModel,
          itemName: iconName,
          formatterParamsExtra: {
            title: titlesMap[iconName]
          }
        });
        path.__title = titlesMap[iconName];
        path.on("mouseover", function() {
          var hoverStyle = iconStyleEmphasisModel.getItemStyle();
          var defaultTextPosition = isVertical2 ? toolboxModel.get("right") == null && toolboxModel.get("left") !== "right" ? "right" : "left" : toolboxModel.get("bottom") == null && toolboxModel.get("top") !== "bottom" ? "bottom" : "top";
          textContent.setStyle({
            fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
            backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
          });
          path.setTextConfig({
            position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
          });
          textContent.ignore = !toolboxModel.get("showTitle");
          api.enterEmphasis(this);
        }).on("mouseout", function() {
          if (featureModel.get(["iconStatus", iconName]) !== "emphasis") {
            api.leaveEmphasis(this);
          }
          textContent.hide();
        });
        (featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
        group.add(path);
        path.on("click", bind$1(feature2.onclick, feature2, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }
    layout(group, toolboxModel, api);
    group.add(makeBackground(group.getBoundingRect(), toolboxModel));
    isVertical2 || group.eachChild(function(icon) {
      var titleText = icon.__title;
      var emphasisState = icon.ensureState("emphasis");
      var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
      var textContent = icon.getTextContent();
      var emphasisTextState = textContent && textContent.ensureState("emphasis");
      if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {
        var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
        var rect = getBoundingRect(titleText, ZRText$1.makeFont(emphasisTextStyle));
        var offsetX = icon.x + group.x;
        var offsetY = icon.y + group.y + itemSize;
        var needPutOnTop = false;
        if (offsetY + rect.height > api.getHeight()) {
          emphasisTextConfig.position = "top";
          needPutOnTop = true;
        }
        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;
        if (offsetX + rect.width / 2 > api.getWidth()) {
          emphasisTextConfig.position = ["100%", topOffset];
          emphasisTextStyle.align = "right";
        } else if (offsetX - rect.width / 2 < 0) {
          emphasisTextConfig.position = [0, topOffset];
          emphasisTextStyle.align = "left";
        }
      }
    });
  };
  ToolboxView2.prototype.updateView = function(toolboxModel, ecModel, api, payload) {
    each$f(this._features, function(feature2) {
      feature2 instanceof ToolboxFeature && feature2.updateView && feature2.updateView(feature2.model, ecModel, api, payload);
    });
  };
  ToolboxView2.prototype.remove = function(ecModel, api) {
    each$f(this._features, function(feature2) {
      feature2 instanceof ToolboxFeature && feature2.remove && feature2.remove(ecModel, api);
    });
    this.group.removeAll();
  };
  ToolboxView2.prototype.dispose = function(ecModel, api) {
    each$f(this._features, function(feature2) {
      feature2 instanceof ToolboxFeature && feature2.dispose && feature2.dispose(ecModel, api);
    });
  };
  ToolboxView2.type = "toolbox";
  return ToolboxView2;
}(ComponentView$1);
function isUserFeatureName(featureName) {
  return featureName.indexOf("my") === 0;
}
var ToolboxView$1 = ToolboxView;
var SaveAsImage = function(_super) {
  __extends$1(SaveAsImage2, _super);
  function SaveAsImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SaveAsImage2.prototype.onclick = function(ecModel, api) {
    var model = this.model;
    var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
    var isSvg = api.getZr().painter.getType() === "svg";
    var type = isSvg ? "svg" : model.get("type", true) || "png";
    var url = api.getConnectedDataURL({
      type,
      backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
      connectedBackgroundColor: model.get("connectedBackgroundColor"),
      excludeComponents: model.get("excludeComponents"),
      pixelRatio: model.get("pixelRatio")
    });
    var browser2 = env$1.browser;
    if (isFunction(MouseEvent) && (browser2.newEdge || !browser2.ie && !browser2.edge)) {
      var $a = document.createElement("a");
      $a.download = title + "." + type;
      $a.target = "_blank";
      $a.href = url;
      var evt = new MouseEvent("click", {
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      if (window.navigator.msSaveOrOpenBlob || isSvg) {
        var parts = url.split(",");
        var base64Encoded = parts[0].indexOf("base64") > -1;
        var bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
        base64Encoded && (bstr = window.atob(bstr));
        var filename = title + "." + type;
        if (window.navigator.msSaveOrOpenBlob) {
          var n = bstr.length;
          var u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          var blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          var frame = document.createElement("iframe");
          document.body.appendChild(frame);
          var cw = frame.contentWindow;
          var doc = cw.document;
          doc.open("image/svg+xml", "replace");
          doc.write(bstr);
          doc.close();
          cw.focus();
          doc.execCommand("SaveAs", true, filename);
          document.body.removeChild(frame);
        }
      } else {
        var lang = model.get("lang");
        var html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || "") + '" /></body>';
        var tab = window.open();
        tab.document.write(html);
        tab.document.title = title;
      }
    }
  };
  SaveAsImage2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
      type: "png",
      connectedBackgroundColor: "#fff",
      name: "",
      excludeComponents: ["toolbox"],
      lang: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
    };
    return defaultOption2;
  };
  return SaveAsImage2;
}(ToolboxFeature);
var SaveAsImage$1 = SaveAsImage;
var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
var radioTypes = [["line", "bar"], ["stack"]];
var MagicType = function(_super) {
  __extends$1(MagicType2, _super);
  function MagicType2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MagicType2.prototype.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get("icon");
    var icons = {};
    each$f(model.get("type"), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  MagicType2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      type: [],
      icon: {
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "magicType", "title"]),
      option: {},
      seriesIndex: {}
    };
    return defaultOption2;
  };
  MagicType2.prototype.onclick = function(ecModel, api, type) {
    var model = this.model;
    var seriesIndex = model.get(["seriesIndex", type]);
    if (!seriesOptGenreator[type]) {
      return;
    }
    var newOption = {
      series: []
    };
    var generateNewSeriesTypes = function(seriesModel) {
      var seriesType2 = seriesModel.subType;
      var seriesId = seriesModel.id;
      var newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model);
      if (newSeriesOpt) {
        defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
        var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
        if (categoryAxis2) {
          var axisDim = categoryAxis2.dim;
          var axisType = axisDim + "Axis";
          var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
          var axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];
          for (var i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }
          newOption[axisType][axisIndex].boundaryGap = type === "bar";
        }
      }
    };
    each$f(radioTypes, function(radio) {
      if (indexOf2(radio, type) >= 0) {
        each$f(radio, function(item) {
          model.setIconStatus(item, "normal");
        });
      }
    });
    model.setIconStatus(type, "emphasis");
    ecModel.eachComponent({
      mainType: "series",
      query: seriesIndex == null ? null : {
        seriesIndex
      }
    }, generateNewSeriesTypes);
    var newTitle;
    var currentType = type;
    if (type === "stack") {
      newTitle = merge3({
        stack: model.option.title.tiled,
        tiled: model.option.title.stack
      }, model.option.title);
      if (model.get(["iconStatus", type]) !== "emphasis") {
        currentType = "tiled";
      }
    }
    api.dispatchAction({
      type: "changeMagicType",
      currentType,
      newOption,
      newTitle,
      featureName: "magicType"
    });
  };
  return MagicType2;
}(ToolboxFeature);
var seriesOptGenreator = {
  "line": function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "bar") {
      return merge3({
        id: seriesId,
        type: "line",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "line"]) || {}, true);
    }
  },
  "bar": function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "line") {
      return merge3({
        id: seriesId,
        type: "bar",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "bar"]) || {}, true);
    }
  },
  "stack": function(seriesType2, seriesId, seriesModel, model) {
    var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
    if (seriesType2 === "line" || seriesType2 === "bar") {
      model.setIconStatus("stack", isStack ? "normal" : "emphasis");
      return merge3({
        id: seriesId,
        stack: isStack ? "" : INNER_STACK_KEYWORD
      }, model.get(["option", "stack"]) || {}, true);
    }
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
var MagicType$1 = MagicType;
var BLOCK_SPLITER = new Array(60).join("-");
var ITEM_SPLITER = "	";
function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta2 = [];
  ecModel.eachRawSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
      var baseAxis = coordSys.getBaseAxis();
      if (baseAxis.type === "category") {
        var key = baseAxis.dim + "_" + baseAxis.index;
        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta2.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }
        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis,
    other: otherSeries,
    meta: meta2
  };
}
function assembleSeriesWithCategoryAxis(groups) {
  var tables = [];
  each$f(groups, function(group, key) {
    var categoryAxis2 = group.categoryAxis;
    var valueAxis2 = group.valueAxis;
    var valueAxisDim = valueAxis2.dim;
    var headers2 = [" "].concat(map$1(group.series, function(series) {
      return series.name;
    }));
    var columns = [categoryAxis2.model.getCategories()];
    each$f(group.series, function(series) {
      var rawData = series.getRawData();
      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
        return val;
      }));
    });
    var lines = [headers2.join(ITEM_SPLITER)];
    for (var i = 0; i < columns[0].length; i++) {
      var items = [];
      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }
      lines.push(items.join(ITEM_SPLITER));
    }
    tables.push(lines.join("\n"));
  });
  return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function assembleOtherSeries(series) {
  return map$1(series, function(series2) {
    var data = series2.getRawData();
    var lines = [series2.name];
    var vals = [];
    data.each(data.dimensions, function() {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name2 = data.getName(dataIndex);
      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }
      lines.push((name2 ? name2 + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
    });
    return lines.join("\n");
  }).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: filter17([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
      return !!str.replace(/[\n\t\s]/g, "");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
    meta: result.meta
  };
}
function trim(str) {
  return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(block) {
  var firstLine = block.slice(0, block.indexOf("\n"));
  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers2 = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = map$1(headers2, function(header) {
    return {
      name: header,
      data: []
    };
  });
  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());
    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }
  return {
    series,
    categories
  };
}
function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];
  for (var i = 0; i < lines.length; i++) {
    var line = trim(lines[i]);
    if (!line) {
      continue;
    }
    var items = line.split(itemSplitRegex);
    var name_1 = "";
    var value = void 0;
    var hasName = false;
    if (isNaN(items[0])) {
      hasName = true;
      name_1 = items[0];
      items = items.slice(1);
      data[i] = {
        name: name_1,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }
    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }
    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }
  return {
    name: seriesName,
    data
  };
}
function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
  var newOption = {
    series: []
  };
  each$f(blocks, function(block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + "Axis";
      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
var DataView$1 = function(_super) {
  __extends$1(DataView2, _super);
  function DataView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataView2.prototype.onclick = function(ecModel, api) {
    setTimeout(function() {
      api.dispatchAction({
        type: "hideTip"
      });
    });
    var container = api.getDom();
    var model = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    var root = document.createElement("div");
    root.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px";
    root.style.backgroundColor = model.get("backgroundColor") || "#fff";
    var header = document.createElement("h4");
    var lang = model.get("lang") || [];
    header.innerHTML = lang[0] || model.get("title");
    header.style.cssText = "margin:10px 20px";
    header.style.color = model.get("textColor");
    var viewMain = document.createElement("div");
    var textarea = document.createElement("textarea");
    viewMain.style.cssText = "overflow:auto";
    var optionToContent = model.get("optionToContent");
    var contentToOption = model.get("contentToOption");
    var result = getContentFromModel(ecModel);
    if (isFunction(optionToContent)) {
      var htmlOrDom = optionToContent(api.getOption());
      if (isString(htmlOrDom)) {
        viewMain.innerHTML = htmlOrDom;
      } else if (isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      textarea.readOnly = model.get("readOnly");
      var style = textarea.style;
      style.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none";
      style.color = model.get("textColor");
      style.borderColor = model.get("textareaBorderColor");
      style.backgroundColor = model.get("textareaColor");
      textarea.value = result.value;
      viewMain.appendChild(textarea);
    }
    var blockMetaList = result.meta;
    var buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
    var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    var closeButton = document.createElement("div");
    var refreshButton = document.createElement("div");
    buttonStyle += ";background-color:" + model.get("buttonColor");
    buttonStyle += ";color:" + model.get("buttonTextColor");
    var self2 = this;
    function close() {
      container.removeChild(root);
      self2._dom = null;
    }
    addEventListener(closeButton, "click", close);
    addEventListener(refreshButton, "click", function() {
      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
        {
          warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.");
        }
        close();
        return;
      }
      var newOption;
      try {
        if (isFunction(contentToOption)) {
          newOption = contentToOption(viewMain, api.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e2) {
        close();
        throw new Error("Data view format error " + e2);
      }
      if (newOption) {
        api.dispatchAction({
          type: "changeDataView",
          newOption
        });
      }
      close();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;
    !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + "px";
    container.appendChild(root);
    this._dom = root;
  };
  DataView2.prototype.remove = function(ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
  };
  DataView2.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  DataView2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: ecModel.getLocaleModel().get(["toolbox", "dataView", "title"]),
      lang: ecModel.getLocaleModel().get(["toolbox", "dataView", "lang"]),
      backgroundColor: "#fff",
      textColor: "#000",
      textareaColor: "#fff",
      textareaBorderColor: "#333",
      buttonColor: "#c23531",
      buttonTextColor: "#fff"
    };
    return defaultOption2;
  };
  return DataView2;
}(ToolboxFeature);
function tryMergeDataOption(newData, originalData) {
  return map$1(newData, function(newVal, idx) {
    var original = originalData && originalData[idx];
    if (isObject$3(original) && !isArray$1(original)) {
      var newValIsObject = isObject$3(newVal) && !isArray$1(newVal);
      if (!newValIsObject) {
        newVal = {
          value: newVal
        };
      }
      var shouldDeleteName = original.name != null && newVal.name == null;
      newVal = defaults(newVal, original);
      shouldDeleteName && delete newVal.name;
      return newVal;
    } else {
      return newVal;
    }
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  var newSeriesOptList = [];
  each$f(payload.newOption.series, function(seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
    if (!seriesModel) {
      newSeriesOptList.push(extend2({
        type: "scatter"
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get("data");
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var DataView$2 = DataView$1;
var each$6 = each$f;
var inner$6 = makeInner();
function push(ecModel, newSnapshot) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  each$6(newSnapshot, function(batchItem, dataZoomId) {
    var i = storedSnapshots.length - 1;
    for (; i >= 0; i--) {
      var snapshot = storedSnapshots[i];
      if (snapshot[dataZoomId]) {
        break;
      }
    }
    if (i < 0) {
      var dataZoomModel = ecModel.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: dataZoomId
      })[0];
      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        storedSnapshots[0][dataZoomId] = {
          dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  var head = storedSnapshots[storedSnapshots.length - 1];
  storedSnapshots.length > 1 && storedSnapshots.pop();
  var snapshot = {};
  each$6(head, function(batchItem, dataZoomId) {
    for (var i = storedSnapshots.length - 1; i >= 0; i--) {
      batchItem = storedSnapshots[i][dataZoomId];
      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
function clear2(ecModel) {
  inner$6(ecModel).snapshots = null;
}
function count2(ecModel) {
  return getStoreSnapshots(ecModel).length;
}
function getStoreSnapshots(ecModel) {
  var store = inner$6(ecModel);
  if (!store.snapshots) {
    store.snapshots = [{}];
  }
  return store.snapshots;
}
var RestoreOption = function(_super) {
  __extends$1(RestoreOption2, _super);
  function RestoreOption2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RestoreOption2.prototype.onclick = function(ecModel, api) {
    clear2(ecModel);
    api.dispatchAction({
      type: "restore",
      from: this.uid
    });
  };
  RestoreOption2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      title: ecModel.getLocaleModel().get(["toolbox", "restore", "title"])
    };
    return defaultOption2;
  };
  return RestoreOption2;
}(ToolboxFeature);
registerAction({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.resetOption("recreate");
});
var Restore = RestoreOption;
var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
var BrushTargetManager = function() {
  function BrushTargetManager2(finder, ecModel, opt) {
    var _this = this;
    this._targetInfoList = [];
    var foundCpts = parseFinder(ecModel, finder);
    each$f(targetInfoBuilders, function(builder, type) {
      if (!opt || !opt.include || indexOf2(opt.include, type) >= 0) {
        builder(foundCpts, _this._targetInfoList);
      }
    });
  }
  BrushTargetManager2.prototype.setOutputRanges = function(areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function(area5, coordRange, coordSys) {
      (area5.coordRanges || (area5.coordRanges = [])).push(coordRange);
      if (!area5.coordRange) {
        area5.coordRange = coordRange;
        var result = coordConvert[area5.brushType](0, coordSys, coordRange);
        area5.__rangeOffset = {
          offset: diffProcessor[area5.brushType](result.values, area5.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
    return areas;
  };
  BrushTargetManager2.prototype.matchOutputRanges = function(areas, ecModel, cb) {
    each$f(areas, function(area5) {
      var targetInfo = this.findTargetInfo(area5, ecModel);
      if (targetInfo && targetInfo !== true) {
        each$f(targetInfo.coordSyses, function(coordSys) {
          var result = coordConvert[area5.brushType](1, coordSys, area5.range, true);
          cb(area5, result.values, coordSys, ecModel);
        });
      }
    }, this);
  };
  BrushTargetManager2.prototype.setInputRanges = function(areas, ecModel) {
    each$f(areas, function(area5) {
      var targetInfo = this.findTargetInfo(area5, ecModel);
      {
        assert(!targetInfo || targetInfo === true || area5.coordRange, "coordRange must be specified when coord index specified.");
        assert(!targetInfo || targetInfo !== true || area5.range, "range must be specified in global brush.");
      }
      area5.range = area5.range || [];
      if (targetInfo && targetInfo !== true) {
        area5.panelId = targetInfo.panelId;
        var result = coordConvert[area5.brushType](0, targetInfo.coordSys, area5.coordRange);
        var rangeOffset = area5.__rangeOffset;
        area5.range = rangeOffset ? diffProcessor[area5.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  };
  BrushTargetManager2.prototype.makePanelOpts = function(api, getDefaultBrushType) {
    return map$1(this._targetInfoList, function(targetInfo) {
      var rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
        clipPath: makeRectPanelClipPath(rect),
        isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
      };
    });
  };
  BrushTargetManager2.prototype.controlSeries = function(area5, seriesModel, ecModel) {
    var targetInfo = this.findTargetInfo(area5, ecModel);
    return targetInfo === true || targetInfo && indexOf2(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  };
  BrushTargetManager2.prototype.findTargetInfo = function(area5, ecModel) {
    var targetInfoList = this._targetInfoList;
    var foundCpts = parseFinder(ecModel, area5);
    for (var i = 0; i < targetInfoList.length; i++) {
      var targetInfo = targetInfoList[i];
      var areaPanelId = area5.panelId;
      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (var j = 0; j < targetInfoMatchers.length; j++) {
          if (targetInfoMatchers[j](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }
    return true;
  };
  return BrushTargetManager2;
}();
function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}
function parseFinder(ecModel, finder) {
  return parseFinder$1(ecModel, finder, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}
var targetInfoBuilders = {
  grid: function(foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels;
    var gridModelMap = createHashMap();
    var xAxesHas = {};
    var yAxesHas = {};
    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }
    each$f(xAxisModels, function(axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each$f(yAxisModels, function(axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each$f(gridModels, function(gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function(gridModel) {
      var grid = gridModel.coordinateSystem;
      var cartesians = [];
      each$f(grid.getCartesians(), function(cartesian2, index2) {
        if (indexOf2(xAxisModels, cartesian2.getAxis("x").model) >= 0 || indexOf2(yAxisModels, cartesian2.getAxis("y").model) >= 0) {
          cartesians.push(cartesian2);
        }
      });
      targetInfoList.push({
        panelId: "grid--" + gridModel.id,
        gridModel,
        coordSysModel: gridModel,
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function(foundCpts, targetInfoList) {
    each$f(foundCpts.geoModels, function(geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: "geo--" + geoModel.id,
        geoModel,
        coordSysModel: geoModel,
        coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
};
var targetInfoMatchers = [
  function(foundCpts, targetInfo) {
    var xAxisModel = foundCpts.xAxisModel;
    var yAxisModel = foundCpts.yAxisModel;
    var gridModel = foundCpts.gridModel;
    !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
    !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
    return gridModel && gridModel === targetInfo.gridModel;
  },
  function(foundCpts, targetInfo) {
    var geoModel = foundCpts.geoModel;
    return geoModel && geoModel === targetInfo.geoModel;
  }
];
var panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone();
    rect.applyTransform(getTransform$1(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry$1(axisConvert, 0),
  lineY: curry$1(axisConvert, 1),
  rect: function(to, coordSys, rangeOrCoordRange, clamp3) {
    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp3) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp3);
    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp3) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp3);
    var values3 = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values: values3,
      xyMinMax: values3
    };
  },
  polygon: function(to, coordSys, rangeOrCoordRange, clamp3) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values3 = map$1(rangeOrCoordRange, function(item) {
      var p = to ? coordSys.pointToData(item, clamp3) : coordSys.dataToPoint(item, clamp3);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {
      values: values3,
      xyMinMax
    };
  }
};
function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  {
    assert(coordSys.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  }
  var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
  var values3 = formatMinMax(map$1([0, 1], function(i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values3;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values: values3,
    xyMinMax
  };
}
var diffProcessor = {
  lineX: curry$1(axisDiffProcessor, 0),
  lineY: curry$1(axisDiffProcessor, 1),
  rect: function(values3, refer, scales) {
    return [[values3[0][0] - scales[0] * refer[0][0], values3[0][1] - scales[0] * refer[0][1]], [values3[1][0] - scales[1] * refer[1][0], values3[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function(values3, refer, scales) {
    return map$1(values3, function(item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};
function axisDiffProcessor(axisNameIndex, values3, refer, scales) {
  return [values3[0] - scales[axisNameIndex] * refer[0], values3[1] - scales[axisNameIndex] * refer[1]];
}
function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}
function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}
var BrushTargetManager$1 = BrushTargetManager;
var each$5 = each$f;
var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
var DataZoomFeature = function(_super) {
  __extends$1(DataZoomFeature2, _super);
  function DataZoomFeature2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataZoomFeature2.prototype.render = function(featureModel, ecModel, api, payload) {
    if (!this._brushController) {
      this._brushController = new BrushController$1(api.getZr());
      this._brushController.on("brush", bind$1(this._onBrush, this)).mount();
    }
    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
    updateBackBtnStatus(featureModel, ecModel);
  };
  DataZoomFeature2.prototype.onclick = function(ecModel, api, type) {
    handlers[type].call(this);
  };
  DataZoomFeature2.prototype.remove = function(ecModel, api) {
    this._brushController && this._brushController.unmount();
  };
  DataZoomFeature2.prototype.dispose = function(ecModel, api) {
    this._brushController && this._brushController.dispose();
  };
  DataZoomFeature2.prototype._onBrush = function(eventParam) {
    var areas = eventParam.areas;
    if (!eventParam.isEnd || !areas.length) {
      return;
    }
    var snapshot = {};
    var ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    var brushTargetManager = new BrushTargetManager$1(makeAxisFinder(this.model), ecModel, {
      include: ["grid"]
    });
    brushTargetManager.matchOutputRanges(areas, ecModel, function(area5, coordRange, coordSys) {
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      var brushType = area5.brushType;
      if (brushType === "rect") {
        setBatch("x", coordSys, coordRange[0]);
        setBatch("y", coordSys, coordRange[1]);
      } else {
        setBatch({
          lineX: "x",
          lineY: "y"
        }[brushType], coordSys, coordRange);
      }
    });
    push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(dimName, coordSys, minMax) {
      var axis = coordSys.getAxis(dimName);
      var axisModel = axis.model;
      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }
      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }
    function findDataZoom(dimName, axisModel, ecModel2) {
      var found;
      ecModel2.eachComponent({
        mainType: "dataZoom",
        subType: "select"
      }, function(dzModel) {
        var has2 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has2 && (found = dzModel);
      });
      return found;
    }
  };
  DataZoomFeature2.prototype._dispatchZoomAction = function(snapshot) {
    var batch = [];
    each$5(snapshot, function(batchItem, dataZoomId) {
      batch.push(clone$4(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      batch
    });
  };
  DataZoomFeature2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      filterMode: "filter",
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
      brushStyle: {
        borderWidth: 0,
        color: "rgba(210,219,238,0.2)"
      }
    };
    return defaultOption2;
  };
  return DataZoomFeature2;
}(ToolboxFeature);
var handlers = {
  zoom: function() {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: nextActive
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(dzFeatureModel) {
  var setting = {
    xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
    yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
    xAxisId: dzFeatureModel.get("xAxisId", true),
    yAxisId: dzFeatureModel.get("yAxisId", true)
  };
  if (setting.xAxisIndex == null && setting.xAxisId == null) {
    setting.xAxisIndex = "all";
  }
  if (setting.yAxisIndex == null && setting.yAxisId == null) {
    setting.yAxisIndex = "all";
  }
  return setting;
}
function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus("back", count2(ecModel) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
  var zoomActive = view._isZoomActive;
  if (payload && payload.type === "takeGlobalCursor") {
    zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
  }
  view._isZoomActive = zoomActive;
  featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
  var brushTargetManager = new BrushTargetManager$1(makeAxisFinder(featureModel), ecModel, {
    include: ["grid"]
  });
  var panels = brushTargetManager.makePanelOpts(api, function(targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
  });
  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
    brushType: "auto",
    brushStyle: featureModel.getModel("brushStyle").getItemStyle()
  } : false);
}
registerInternalOptionCreator("dataZoom", function(ecModel) {
  var toolboxModel = ecModel.getComponent("toolbox", 0);
  var featureDataZoomPath = ["feature", "dataZoom"];
  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
    return;
  }
  var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
  var dzOptions = [];
  var finder = makeAxisFinder(dzFeatureModel);
  var finderResult = parseFinder$1(ecModel, finder);
  each$5(finderResult.xAxisModels, function(axisModel) {
    return buildInternalOptions(axisModel, "xAxis", "xAxisIndex");
  });
  each$5(finderResult.yAxisModels, function(axisModel) {
    return buildInternalOptions(axisModel, "yAxis", "yAxisIndex");
  });
  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
    var axisIndex = axisModel.componentIndex;
    var newOpt = {
      type: "select",
      $fromToolbox: true,
      filterMode: dzFeatureModel.get("filterMode", true) || "filter",
      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
    };
    newOpt[axisIndexPropName] = axisIndex;
    dzOptions.push(newOpt);
  }
  return dzOptions;
});
var DataZoom = DataZoomFeature;
function install$j(registers) {
  registers.registerComponentModel(ToolboxModel$1);
  registers.registerComponentView(ToolboxView$1);
  registerFeature("saveAsImage", SaveAsImage$1);
  registerFeature("magicType", MagicType$1);
  registerFeature("dataView", DataView$2);
  registerFeature("dataZoom", DataZoom);
  registerFeature("restore", Restore);
  use2(install$k);
}
var TooltipModel = function(_super) {
  __extends$1(TooltipModel2, _super);
  function TooltipModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipModel2.type;
    return _this;
  }
  TooltipModel2.type = "tooltip";
  TooltipModel2.dependencies = ["axisPointer"];
  TooltipModel2.defaultOption = {
    z: 60,
    show: true,
    showContent: true,
    trigger: "item",
    triggerOn: "mousemove|click",
    alwaysShowContent: false,
    displayMode: "single",
    renderMode: "auto",
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: "#fff",
    shadowBlur: 10,
    shadowColor: "rgba(0, 0, 0, .2)",
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    borderRadius: 4,
    borderWidth: 1,
    padding: null,
    extraCssText: "",
    axisPointer: {
      type: "line",
      axis: "auto",
      animation: "auto",
      animationDurationUpdate: 200,
      animationEasingUpdate: "exponentialOut",
      crossStyle: {
        color: "#999",
        width: 1,
        type: "dashed",
        textStyle: {}
      }
    },
    textStyle: {
      color: "#666",
      fontSize: 14
    }
  };
  return TooltipModel2;
}(ComponentModel$1);
var TooltipModel$1 = TooltipModel;
function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env$1.domSupported) {
    return;
  }
  var style = document.documentElement.style;
  for (var i = 0, len2 = styleProps.length; i < len2; i++) {
    if (styleProps[i] in style) {
      return styleProps[i];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase(styleProp, true);
  var idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
  return styleVendor.toLowerCase();
}
function getComputedStyle(el, style) {
  var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  var positionStyle = "";
  var transformStyle = CSS_TRANSFORM_VENDOR + ":";
  var rotateDeg;
  if (indexOf2(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
  } else {
    positionStyle += "left:50%";
    transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
  }
  var rotateRadian = rotateDeg * Math.PI / 180;
  var arrowWH = arrowSize + borderWidth;
  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
  var borderStyle = borderColor + " solid " + borderWidth + "px;";
  var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
  return '<div style="' + styleCss.join("") + '"></div>';
}
function assembleTransition(duration, onlyFade) {
  var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  var transitionOption = " " + duration / 2 + "s " + transitionCurve;
  var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
  if (!onlyFade) {
    transitionOption = " " + duration + "s " + transitionCurve;
    transitionText += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x2, y2, toString27) {
  var x02 = x2.toFixed(0) + "px";
  var y02 = y2.toFixed(0) + "px";
  if (!env$1.transformSupported) {
    return toString27 ? "top:" + y02 + ";left:" + x02 + ";" : [["top", y02], ["left", x02]];
  }
  var is3d = env$1.transform3dSupported;
  var translate3 = "translate" + (is3d ? "3d" : "") + "(" + x02 + "," + y02 + (is3d ? ",0" : "") + ")";
  return toString27 ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate3 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate3]];
}
function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get("fontSize");
  var color = textStyleModel.getTextColor();
  color && cssText.push("color:" + color);
  cssText.push("font:" + textStyleModel.getFont());
  fontSize && cssText.push("line-height:" + Math.round(fontSize * 3 / 2) + "px");
  var shadowColor = textStyleModel.get("textShadowColor");
  var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each$f(["decoration", "align"], function(name2) {
    var val = textStyleModel.get(name2);
    val && cssText.push("text-" + name2 + ":" + val);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get("transitionDuration");
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var shadowBlur = tooltipModel.get("shadowBlur");
  var shadowColor = tooltipModel.get("shadowColor");
  var shadowOffsetX = tooltipModel.get("shadowOffsetX");
  var shadowOffsetY = tooltipModel.get("shadowOffsetY");
  var textStyleModel = tooltipModel.getModel("textStyle");
  var padding = getPaddingFromTooltipModel(tooltipModel, "html");
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each$f(["width", "color", "radius"], function(name2) {
    var borderName = "border-" + name2;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ":" + val + (name2 === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord$1(out2, zr, appendToBody, zrX, zrY) {
  var zrPainter = zr && zr.painter;
  if (appendToBody) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, document.body, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipHTMLContent = function() {
  function TooltipHTMLContent2(container, api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._firstShow = true;
    this._longHide = true;
    if (env$1.wxa) {
      return null;
    }
    var el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    makeStyleCoord$1(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }
    this._container = container;
    var self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e2) {
      e2 = e2 || window.event;
      if (!self2._enterable) {
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e2, true);
        handler.dispatch("mousemove", e2);
      }
    };
    el.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  TooltipHTMLContent2.prototype.update = function(tooltipModel) {
    var container = this._container;
    var position2 = getComputedStyle(container, "position");
    var domStyle = container.style;
    if (domStyle.position !== "absolute" && position2 !== "absolute") {
      domStyle.position = "relative";
    }
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this.el.className = tooltipModel.get("className") || "";
  };
  TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el = this.el;
    var style = el.style;
    var styleCoord = this._styleCoord;
    if (!el.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };
  TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
    var el = this.el;
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    var arrow = "";
    if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString(content)) {
      el.innerHTML = content + arrow;
    } else if (content) {
      el.innerHTML = "";
      if (!isArray$1(content)) {
        content = [content];
      }
      for (var i = 0; i < content.length; i++) {
        if (isDom(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      }
      if (arrow && el.childNodes.length) {
        var arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow;
        el.appendChild(arrowEl);
      }
    }
  };
  TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipHTMLContent2.prototype.getSize = function() {
    var el = this.el;
    return [el.offsetWidth, el.offsetHeight];
  };
  TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
    var styleCoord = this._styleCoord;
    makeStyleCoord$1(styleCoord, this._zr, this._appendToBody, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style_1 = this.el.style;
      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each$f(transforms, function(transform4) {
        style_1[transform4[0]] = transform4[1];
      });
    }
  };
  TooltipHTMLContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipHTMLContent2.prototype.hide = function() {
    var _this = this;
    var style = this.el.style;
    style.visibility = "hidden";
    style.opacity = "0";
    env$1.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(function() {
      return _this._longHide = true;
    }, 500);
  };
  TooltipHTMLContent2.prototype.hideLater = function(time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };
  TooltipHTMLContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipHTMLContent2.prototype.dispose = function() {
    this.el.parentNode.removeChild(this.el);
  };
  return TooltipHTMLContent2;
}();
var TooltipHTMLContent$1 = TooltipHTMLContent;
var TooltipRichContent = function() {
  function TooltipRichContent2(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  TooltipRichContent2.prototype.update = function(tooltipModel) {
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
  };
  TooltipRichContent2.prototype.show = function() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  };
  TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    var _this = this;
    if (isObject$3(content)) {
      throwError("Passing DOM nodes as content is not supported in richText tooltip!");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    var textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new ZRText$1({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each$f(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
      _this.el.style[propName] = tooltipModel.get(propName);
    });
    each$f(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
      _this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    var self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  };
  TooltipRichContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipRichContent2.prototype.getSize = function() {
    var el = this.el;
    var bounding = this.el.getBoundingRect();
    var shadowOuterSize = calcShadowOuterSize(el.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };
  TooltipRichContent2.prototype.moveTo = function(x2, y2) {
    var el = this.el;
    if (el) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, x2, y2);
      x2 = styleCoord[0];
      y2 = styleCoord[1];
      var style = el.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style);
      el.x = x2 + borderWidth + shadowOuterSize.left;
      el.y = y2 + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  };
  TooltipRichContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipRichContent2.prototype.hide = function() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  };
  TooltipRichContent2.prototype.hideLater = function(time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };
  TooltipRichContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipRichContent2.prototype.dispose = function() {
    this._zr.remove(this.el);
  };
  return TooltipRichContent2;
}();
function mathMaxWith0(val) {
  return Math.max(0, val);
}
function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord(out2, zr, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipRichContent$1 = TooltipRichContent;
var proxyRect = new Rect$3({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});
var TooltipView = function(_super) {
  __extends$1(TooltipView2, _super);
  function TooltipView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipView2.type;
    return _this;
  }
  TooltipView2.prototype.init = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    var tooltipModel = ecModel.getComponent("tooltip");
    var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent$1(api) : new TooltipHTMLContent$1(api.getDom(), api, {
      appendToBody: tooltipModel.get("appendToBody", true)
    });
  };
  TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear$1(this, "_updatePosition");
    }
  };
  TooltipView2.prototype._initGlobalListener = function() {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get("triggerOn");
    register("itemTooltip", this._api, bind$1(function(currTrigger, e2, dispatchAction2) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e2, dispatchAction2);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction2);
        }
      }
    }, this));
  };
  TooltipView2.prototype._keepShow = function() {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api;
    var triggerOn = tooltipModel.get("triggerOn");
    if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env$1.node || !api.getDom()) {
      return;
    }
    var dispatchAction2 = makeDispatchAction(payload, api);
    this._ticket = "";
    var dataByCoordSys = payload.dataByCoordSys;
    var cmptRef = findComponentReference(payload, ecModel, api);
    if (cmptRef) {
      var rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction2);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction2);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction2);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }
      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction2);
      }
    } else if (payload.x != null && payload.y != null) {
      api.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction2);
    }
  };
  TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;
    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  };
  TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    var data = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  };
  TooltipView2.prototype._tryShow = function(e2, dispatchAction2) {
    var el = e2.target;
    var tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e2.offsetX;
    this._lastY = e2.offsetY;
    var dataByCoordSys = e2.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e2);
    } else if (el) {
      this._lastDataByCoordSys = null;
      var seriesDispatcher_1;
      var cmptDispatcher_1;
      findEventDispatcher(el, function(target) {
        if (getECData(target).dataIndex != null) {
          seriesDispatcher_1 = target;
          return true;
        }
        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher_1 = target;
          return true;
        }
      }, true);
      if (seriesDispatcher_1) {
        this._showSeriesItemTooltip(e2, seriesDispatcher_1, dispatchAction2);
      } else if (cmptDispatcher_1) {
        this._showComponentItemTooltip(e2, cmptDispatcher_1, dispatchAction2);
      } else {
        this._hide(dispatchAction2);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction2);
    }
  };
  TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
    var delay = tooltipModel.get("showDelay");
    cb = bind$1(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  };
  TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e2) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point4 = [e2.offsetX, e2.offsetY];
    var singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    var markupTextArrLegacy = [];
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    each$f(dataByCoordSys, function(itemCoordSys) {
      each$f(itemCoordSys.dataByAxis, function(axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        var axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim$1(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each$f(axisItem.seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          var frag = seriesTooltipResult.frag;
          if (frag) {
            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend2({
              valueFormatter
            }, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e2.position;
    var orderMode = singleTooltipModel.get("order");
    var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
    var allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point4[0], point4[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point4[0], point4[1], positionExpr, null, markupStyleCreator);
      }
    });
  };
  TooltipView2.prototype._showSeriesItemTooltip = function(e2, dispatcher, dispatchAction2) {
    var ecModel = this._ecModel;
    var ecData = getECData(dispatcher);
    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var positionDefault = e2.positionDefault;
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get("order");
    var valueFormatter = tooltipModel.get("valueFormatter");
    var frag = seriesTooltipResult.frag;
    var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend2({
      valueFormatter
    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  };
  TooltipView2.prototype._showComponentItemTooltip = function(e2, el, dispatchAction2) {
    var ecData = getECData(el);
    var tooltipConfig = ecData.tooltipConfig;
    var tooltipOpt = tooltipConfig.option || {};
    if (isString(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
    }
    var tooltipModelCascade = [tooltipOpt];
    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({
      formatter: tooltipOpt.content
    });
    var positionDefault = e2.positionDefault;
    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var defaultHtml = subTooltipModel.get("content");
    var asyncTicket = Math.random() + "";
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    this._showOrMove(subTooltipModel, function() {
      var formatterParams = clone$4(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      from: this.uid
    });
  };
  TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x2, y2, positionExpr, el, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    var tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    var formatter = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    var html = defaultHtml;
    var nearPoint = this._getNearestPoint([x2, y2], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
    var nearPointColor = nearPoint.color;
    if (formatter) {
      if (isString(formatter)) {
        var useUTC = tooltipModel.ecModel.get("useUTC");
        var params0 = isArray$1(params) ? params[0] : params;
        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html = formatter;
        if (isTimeAxis) {
          html = format(params0.axisValue, html, useUTC);
        }
        html = formatTpl(html, params, true);
      } else if (isFunction(formatter)) {
        var callback = bind$1(function(cbTicket, html2) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x2, y2, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      } else {
        html = formatter;
      }
    }
    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x2, y2, tooltipContent, params, el);
  };
  TooltipView2.prototype._getNearestPoint = function(point4, tooltipDataParams, trigger2, borderColor) {
    if (trigger2 === "axis" || isArray$1(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
      };
    }
    if (!isArray$1(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };
  TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x2, y2, content, params, el) {
    var viewWidth = this._api.getWidth();
    var viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    var contentSize = content.getSize();
    var align = tooltipModel.get("align");
    var vAlign = tooltipModel.get("verticalAlign");
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (isFunction(positionExpr)) {
      positionExpr = positionExpr([x2, y2], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray$1(positionExpr)) {
      x2 = parsePercent(positionExpr[0], viewWidth);
      y2 = parsePercent(positionExpr[1], viewHeight);
    } else if (isObject$3(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = getLayoutRect(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x2 = layoutRect.x;
      y2 = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString(positionExpr) && el) {
      var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x2 = pos[0];
      y2 = pos[1];
    } else {
      var pos = refixTooltipPosition(x2, y2, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x2 = pos[0];
      y2 = pos[1];
    }
    align && (x2 -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y2 -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      var pos = confineTooltipPosition(x2, y2, content, viewWidth, viewHeight);
      x2 = pos[0];
      y2 = pos[1];
    }
    content.moveTo(x2, y2);
  };
  TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
    var lastCoordSys = this._lastDataByCoordSys;
    var lastCbParamsList = this._cbParamsList;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each$f(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each$f(lastDataByAxis, function(lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each$f(lastIndices, function(lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each$f(lastItem.seriesDataIndices, function(idxItem) {
          var seriesIdx = idxItem.seriesIndex;
          var cbParams = cbParamsList[seriesIdx];
          var lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  };
  TooltipView2.prototype._hide = function(dispatchAction2) {
    this._lastDataByCoordSys = null;
    dispatchAction2({
      type: "hideTip",
      from: this.uid
    });
  };
  TooltipView2.prototype.dispose = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    clear$1(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api);
  };
  TooltipView2.type = "tooltip";
  return TooltipView2;
}(ComponentView$1);
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  var ecModel = globalTooltipModel.ecModel;
  var resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model$1(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model$1(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (var i = modelCascade.length - 1; i >= 0; i--) {
    var tooltipOpt = modelCascade[i];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model$1) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model$1(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction(payload, api) {
  return payload.dispatchAction || bind$1(api.dispatchAction, api);
}
function refixTooltipPosition(x2, y2, content, viewWidth, viewHeight, gapH, gapV) {
  var size11 = content.getSize();
  var width = size11[0];
  var height = size11[1];
  if (gapH != null) {
    if (x2 + width + gapH + 2 > viewWidth) {
      x2 -= width + gapH;
    } else {
      x2 += gapH;
    }
  }
  if (gapV != null) {
    if (y2 + height + gapV > viewHeight) {
      y2 -= height + gapV;
    } else {
      y2 += gapV;
    }
  }
  return [x2, y2];
}
function confineTooltipPosition(x2, y2, content, viewWidth, viewHeight) {
  var size11 = content.getSize();
  var width = size11[0];
  var height = size11[1];
  x2 = Math.min(x2 + width, viewWidth) - width;
  y2 = Math.min(y2 + height, viewHeight) - height;
  x2 = Math.max(x2, 0);
  y2 = Math.max(y2, 0);
  return [x2, y2];
}
function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  var x2 = 0;
  var y2 = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  switch (position2) {
    case "inside":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y2 = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y2 = rect.y - domHeight - offset;
      break;
    case "bottom":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y2 = rect.y + rectHeight + offset;
      break;
    case "left":
      x2 = rect.x - domWidth - offset;
      y2 = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x2 = rect.x + rectWidth + offset;
      y2 = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x2, y2];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api) {
  var queryOptionMap = preParseFinder(payload).queryOptionMap;
  var componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
    useDefault: false,
    enableAll: false,
    enableNone: false
  });
  var model = queryResult.models[0];
  if (!model) {
    return;
  }
  var view = api.getViewOfComponentModel(model);
  var el;
  view.group.traverse(function(subEl) {
    var tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true;
    }
  });
  if (el) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el
    };
  }
}
var TooltipView$1 = TooltipView;
function install$i(registers) {
  use2(install$q);
  registers.registerComponentModel(TooltipModel$1);
  registers.registerComponentView(TooltipView$1);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop);
}
var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
function brushPreprocessor(option, isNew) {
  var brushComponents = normalizeToArray(option ? option.brush : []);
  if (!brushComponents.length) {
    return;
  }
  var brushComponentSpecifiedBtns = [];
  each$f(brushComponents, function(brushOpt) {
    var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
    if (tbs instanceof Array) {
      brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
    }
  });
  var toolbox = option && option.toolbox;
  if (isArray$1(toolbox)) {
    toolbox = toolbox[0];
  }
  if (!toolbox) {
    toolbox = {
      feature: {}
    };
    option.toolbox = [toolbox];
  }
  var toolboxFeature = toolbox.feature || (toolbox.feature = {});
  var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
  var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
  brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
  removeDuplicate(brushTypes);
  if (isNew && !brushTypes.length) {
    brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
  }
}
function removeDuplicate(arr) {
  var map5 = {};
  each$f(arr, function(val) {
    map5[val] = 1;
  });
  arr.length = 0;
  each$f(map5, function(flag, val) {
    arr.push(val);
  });
}
var each$4 = each$f;
function hasKeys(obj) {
  if (obj) {
    for (var name_1 in obj) {
      if (obj.hasOwnProperty(name_1)) {
        return true;
      }
    }
  }
}
function createVisualMappings(option, stateList, supplementVisualOption) {
  var visualMappings = {};
  each$4(stateList, function(state) {
    var mappings = visualMappings[state] = createMappings();
    each$4(option[state], function(visualData, visualType) {
      if (!VisualMapping$1.isValidType(visualType)) {
        return;
      }
      var mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new VisualMapping$1(mappingOption);
      if (visualType === "opacity") {
        mappingOption = clone$4(mappingOption);
        mappingOption.type = "colorAlpha";
        mappings.__hidden.__alphaForOpacity = new VisualMapping$1(mappingOption);
      }
    });
  });
  return visualMappings;
  function createMappings() {
    var Creater = function() {
    };
    Creater.prototype.__hidden = Creater.prototype;
    var obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys3) {
  var has2;
  each$f(keys3, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      has2 = true;
    }
  });
  has2 && each$f(keys3, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      thisOption[key] = clone$4(newOption[key]);
    } else {
      delete thisOption[key];
    }
  });
}
function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
  var visualTypesMap = {};
  each$f(stateList, function(state) {
    var visualTypes = VisualMapping$1.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  var dataIndex;
  function getVisual(key) {
    return getItemVisualFromData(data, dataIndex, key);
  }
  function setVisual(key, value) {
    setItemVisualFromData(data, dataIndex, key, value);
  }
  if (dimension == null) {
    data.each(eachItem);
  } else {
    data.each([dimension], eachItem);
  }
  function eachItem(valueOrIndex, index2) {
    dataIndex = dimension == null ? valueOrIndex : index2;
    var rawDataItem = data.getRawDataItem(dataIndex);
    if (rawDataItem && rawDataItem.visualMap === false) {
      return;
    }
    var valueState = getValueState.call(scope, valueOrIndex);
    var mappings = visualMappings[valueState];
    var visualTypes = visualTypesMap[valueState];
    for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
      var type = visualTypes[i];
      mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
    }
  }
}
function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  var visualTypesMap = {};
  each$f(stateList, function(state) {
    var visualTypes = VisualMapping$1.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      var dimIndex;
      if (dim != null) {
        dimIndex = data.getDimensionIndex(dim);
      }
      function getVisual(key) {
        return getItemVisualFromData(data, dataIndex, key);
      }
      function setVisual(key, value2) {
        setItemVisualFromData(data, dataIndex, key, value2);
      }
      var dataIndex;
      var store = data.getStore();
      while ((dataIndex = params.next()) != null) {
        var rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }
        var value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
        var valueState = getValueState(value);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}
function makeBrushCommonSelectorForSeries(area5) {
  var brushType = area5.brushType;
  var selectors = {
    point: function(itemLayout) {
      return selector[brushType].point(itemLayout, selectors, area5);
    },
    rect: function(itemLayout) {
      return selector[brushType].rect(itemLayout, selectors, area5);
    }
  };
  return selectors;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function(itemLayout, selectors, area5) {
      return itemLayout && area5.boundingRect.contain(itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area5) {
      return itemLayout && area5.boundingRect.intersect(itemLayout);
    }
  },
  polygon: {
    point: function(itemLayout, selectors, area5) {
      return itemLayout && area5.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain(area5.range, itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area5) {
      var points2 = area5.range;
      if (!itemLayout || points2.length <= 1) {
        return false;
      }
      var x2 = itemLayout.x;
      var y2 = itemLayout.y;
      var width = itemLayout.width;
      var height = itemLayout.height;
      var p = points2[0];
      if (contain(points2, x2, y2) || contain(points2, x2 + width, y2) || contain(points2, x2, y2 + height) || contain(points2, x2 + width, y2 + height) || BoundingRect$1.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x2, y2, x2 + width, y2, points2) || linePolygonIntersect(x2, y2, x2, y2 + height, points2) || linePolygonIntersect(x2 + width, y2, x2 + width, y2 + height, points2) || linePolygonIntersect(x2, y2 + height, x2 + width, y2 + height, points2)) {
        return true;
      }
    }
  }
};
function getLineSelectors(xyIndex) {
  var xy = ["x", "y"];
  var wh = ["width", "height"];
  return {
    point: function(itemLayout, selectors, area5) {
      if (itemLayout) {
        var range = area5.range;
        var p = itemLayout[xyIndex];
        return inLineRange(p, range);
      }
    },
    rect: function(itemLayout, selectors, area5) {
      if (itemLayout) {
        var range = area5.range;
        var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
        layoutRange[1] < layoutRange[0] && layoutRange.reverse();
        return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
      }
    }
  };
}
function inLineRange(p, range) {
  return range[0] <= p && p <= range[1];
}
var STATE_LIST = ["inBrush", "outOfBrush"];
var DISPATCH_METHOD = "__ecBrushSelect";
var DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(ecModel) {
  ecModel.eachComponent({
    mainType: "brush"
  }, function(brushModel) {
    var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager$1(brushModel.option, ecModel);
    brushTargetManager.setInputRanges(brushModel.areas, ecModel);
  });
}
function brushVisual(ecModel, api, payload) {
  var brushSelected = [];
  var throttleType;
  var throttleDelay;
  ecModel.eachComponent({
    mainType: "brush"
  }, function(brushModel) {
    payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {
      brushType: false
    });
  });
  layoutCovers(ecModel);
  ecModel.eachComponent({
    mainType: "brush"
  }, function(brushModel, brushIndex) {
    var thisBrushSelected = {
      brushId: brushModel.id,
      brushIndex,
      brushName: brushModel.name,
      areas: clone$4(brushModel.areas),
      selected: []
    };
    brushSelected.push(thisBrushSelected);
    var brushOption = brushModel.option;
    var brushLink = brushOption.brushLink;
    var linkedSeriesMap = [];
    var selectedDataIndexForLink = [];
    var rangeInfoBySeries = [];
    var hasBrushExists = false;
    if (!brushIndex) {
      throttleType = brushOption.throttleType;
      throttleDelay = brushOption.throttleDelay;
    }
    var areas = map$1(brushModel.areas, function(area5) {
      var builder = boundingRectBuilders[area5.brushType];
      var selectableArea = defaults({
        boundingRect: builder ? builder(area5) : void 0
      }, area5);
      selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);
      return selectableArea;
    });
    var visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
      mappingOption.mappingMethod = "fixed";
    });
    isArray$1(brushLink) && each$f(brushLink, function(seriesIndex) {
      linkedSeriesMap[seriesIndex] = 1;
    });
    function linkOthers(seriesIndex) {
      return brushLink === "all" || !!linkedSeriesMap[seriesIndex];
    }
    function brushed(rangeInfoList) {
      return !!rangeInfoList.length;
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
      seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
    });
    function stepAParallel(seriesModel, seriesIndex) {
      var coordSys = seriesModel.coordinateSystem;
      hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
      linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
        activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
      });
    }
    function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
      if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
        return;
      }
      each$f(areas, function(area5) {
        if (brushModel.brushTargetManager.controlSeries(area5, seriesModel, ecModel)) {
          rangeInfoList.push(area5);
        }
        hasBrushExists = hasBrushExists || brushed(rangeInfoList);
      });
      if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
        var data_1 = seriesModel.getData();
        data_1.each(function(dataIndex) {
          if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {
            selectedDataIndexForLink[dataIndex] = 1;
          }
        });
      }
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      var seriesBrushSelected = {
        seriesId: seriesModel.id,
        seriesIndex,
        seriesName: seriesModel.name,
        dataIndex: []
      };
      thisBrushSelected.selected.push(seriesBrushSelected);
      var rangeInfoList = rangeInfoBySeries[seriesIndex];
      var data = seriesModel.getData();
      var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
        return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      } : function(dataIndex) {
        return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      };
      (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);
    });
  });
  dispatchAction$1(api, throttleType, throttleDelay, brushSelected, payload);
}
function dispatchAction$1(api, throttleType, throttleDelay, brushSelected, payload) {
  if (!payload) {
    return;
  }
  var zr = api.getZr();
  if (zr[DISPATCH_FLAG]) {
    return;
  }
  if (!zr[DISPATCH_METHOD]) {
    zr[DISPATCH_METHOD] = doDispatch;
  }
  var fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
  fn(api, brushSelected);
}
function doDispatch(api, brushSelected) {
  if (!api.isDisposed()) {
    var zr = api.getZr();
    zr[DISPATCH_FLAG] = true;
    api.dispatchAction({
      type: "brushSelect",
      batch: brushSelected
    });
    zr[DISPATCH_FLAG] = false;
  }
}
function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
  for (var i = 0, len2 = rangeInfoList.length; i < len2; i++) {
    var area5 = rangeInfoList[i];
    if (seriesModel.brushSelector(dataIndex, data, area5.selectors, area5)) {
      return true;
    }
  }
}
function brushModelNotControll(brushModel, seriesIndex) {
  var seriesIndices = brushModel.option.seriesIndex;
  return seriesIndices != null && seriesIndices !== "all" && (isArray$1(seriesIndices) ? indexOf2(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
}
var boundingRectBuilders = {
  rect: function(area5) {
    return getBoundingRectFromMinMax(area5.range);
  },
  polygon: function(area5) {
    var minMax;
    var range = area5.range;
    for (var i = 0, len2 = range.length; i < len2; i++) {
      minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
      var rg = range[i];
      rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
      rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
      rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
      rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
    }
    return minMax && getBoundingRectFromMinMax(minMax);
  }
};
function getBoundingRectFromMinMax(minMax) {
  return new BoundingRect$1(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
}
var BrushView = function(_super) {
  __extends$1(BrushView2, _super);
  function BrushView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BrushView2.type;
    return _this;
  }
  BrushView2.prototype.init = function(ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
    this.model;
    (this._brushController = new BrushController$1(api.getZr())).on("brush", bind$1(this._onBrush, this)).mount();
  };
  BrushView2.prototype.render = function(brushModel, ecModel, api, payload) {
    this.model = brushModel;
    this._updateController(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype.updateTransform = function(brushModel, ecModel, api, payload) {
    layoutCovers(ecModel);
    this._updateController(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype.updateVisual = function(brushModel, ecModel, api, payload) {
    this.updateTransform(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype.updateView = function(brushModel, ecModel, api, payload) {
    this._updateController(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype._updateController = function(brushModel, ecModel, api, payload) {
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  };
  BrushView2.prototype.dispose = function() {
    this._brushController.dispose();
  };
  BrushView2.prototype._onBrush = function(eventParam) {
    var modelId = this.model.id;
    var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);
    (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
      type: "brush",
      brushId: modelId,
      areas: clone$4(areas),
      $from: modelId
    });
    eventParam.isEnd && this.api.dispatchAction({
      type: "brushEnd",
      brushId: modelId,
      areas: clone$4(areas),
      $from: modelId
    });
  };
  BrushView2.type = "brush";
  return BrushView2;
}(ComponentView$1);
var BrushView$1 = BrushView;
var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd";
var BrushModel = function(_super) {
  __extends$1(BrushModel2, _super);
  function BrushModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BrushModel2.type;
    _this.areas = [];
    _this.brushOption = {};
    return _this;
  }
  BrushModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
    var inBrush = thisOption.inBrush = thisOption.inBrush || {};
    thisOption.outOfBrush = thisOption.outOfBrush || {
      color: DEFAULT_OUT_OF_BRUSH_COLOR
    };
    if (!inBrush.hasOwnProperty("liftZ")) {
      inBrush.liftZ = 5;
    }
  };
  BrushModel2.prototype.setAreas = function(areas) {
    {
      assert(isArray$1(areas));
      each$f(areas, function(area5) {
        assert(area5.brushType, "Illegal areas");
      });
    }
    if (!areas) {
      return;
    }
    this.areas = map$1(areas, function(area5) {
      return generateBrushOption(this.option, area5);
    }, this);
  };
  BrushModel2.prototype.setBrushOption = function(brushOption) {
    this.brushOption = generateBrushOption(this.option, brushOption);
    this.brushType = this.brushOption.brushType;
  };
  BrushModel2.type = "brush";
  BrushModel2.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"];
  BrushModel2.defaultOption = {
    seriesIndex: "all",
    brushType: "rect",
    brushMode: "single",
    transformable: true,
    brushStyle: {
      borderWidth: 1,
      color: "rgba(210,219,238,0.3)",
      borderColor: "#D2DBEE"
    },
    throttleType: "fixRate",
    throttleDelay: 0,
    removeOnClick: true,
    z: 1e4
  };
  return BrushModel2;
}(ComponentModel$1);
function generateBrushOption(option, brushOption) {
  return merge3({
    brushType: option.brushType,
    brushMode: option.brushMode,
    transformable: option.transformable,
    brushStyle: new Model$1(option.brushStyle).getItemStyle(),
    removeOnClick: option.removeOnClick,
    z: option.z
  }, brushOption, true);
}
var BrushModel$1 = BrushModel;
var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"];
var BrushFeature = function(_super) {
  __extends$1(BrushFeature2, _super);
  function BrushFeature2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BrushFeature2.prototype.render = function(featureModel, ecModel, api) {
    var brushType;
    var brushMode;
    var isBrushed;
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || "single";
      isBrushed = isBrushed || !!brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    each$f(featureModel.get("type", true), function(type) {
      featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
    });
  };
  BrushFeature2.prototype.updateView = function(featureModel, ecModel, api) {
    this.render(featureModel, ecModel, api);
  };
  BrushFeature2.prototype.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get("icon", true);
    var icons = {};
    each$f(model.get("type", true), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  BrushFeature2.prototype.onclick = function(ecModel, api, type) {
    var brushType = this._brushType;
    var brushMode = this._brushMode;
    if (type === "clear") {
      api.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      });
      api.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      });
    } else {
      api.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: type === "keep" ? brushType : brushType === type ? false : type,
          brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
        }
      });
    }
  };
  BrushFeature2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      type: ICON_TYPES.slice(),
      icon: {
        rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
        polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
        lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
        lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
        keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
        clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "brush", "title"])
    };
    return defaultOption2;
  };
  return BrushFeature2;
}(ToolboxFeature);
var BrushFeature$1 = BrushFeature;
function install$h(registers) {
  registers.registerComponentView(BrushView$1);
  registers.registerComponentModel(BrushModel$1);
  registers.registerPreprocessor(brushPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);
  registers.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "brush",
      query: payload
    }, function(brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  registers.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, noop);
  registers.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, noop);
  registerFeature("brush", BrushFeature$1);
}
var TitleModel = function(_super) {
  __extends$1(TitleModel2, _super);
  function TitleModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  TitleModel2.type = "title";
  TitleModel2.defaultOption = {
    z: 6,
    show: true,
    text: "",
    target: "blank",
    subtext: "",
    subtarget: "blank",
    left: 0,
    top: 0,
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: "bold",
      color: "#464646"
    },
    subtextStyle: {
      fontSize: 12,
      color: "#6E7079"
    }
  };
  return TitleModel2;
}(ComponentModel$1);
var TitleView = function(_super) {
  __extends$1(TitleView2, _super);
  function TitleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleView2.type;
    return _this;
  }
  TitleView2.prototype.render = function(titleModel, ecModel, api) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    var group = this.group;
    var textStyleModel = titleModel.getModel("textStyle");
    var subtextStyleModel = titleModel.getModel("subtextStyle");
    var textAlign = titleModel.get("textAlign");
    var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    var textEl = new ZRText$1({
      style: createTextStyle(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get("subtext");
    var subTextEl = new ZRText$1({
      style: createTextStyle(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link2 = titleModel.get("link");
    var sublink = titleModel.get("sublink");
    var triggerEvent = titleModel.get("triggerEvent", true);
    textEl.silent = !link2 && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;
    if (link2) {
      textEl.on("click", function() {
        windowOpen(link2, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    var rect = new Rect$3({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };
  TitleView2.type = "title";
  return TitleView2;
}(ComponentView$1);
function install$g(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}
var TimelineModel = function(_super) {
  __extends$1(TimelineModel2, _super);
  function TimelineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TimelineModel2.type;
    _this.layoutMode = "box";
    return _this;
  }
  TimelineModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    this._initData();
  };
  TimelineModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    this._initData();
  };
  TimelineModel2.prototype.setCurrentIndex = function(currentIndex) {
    if (currentIndex == null) {
      currentIndex = this.option.currentIndex;
    }
    var count3 = this._data.count();
    if (this.option.loop) {
      currentIndex = (currentIndex % count3 + count3) % count3;
    } else {
      currentIndex >= count3 && (currentIndex = count3 - 1);
      currentIndex < 0 && (currentIndex = 0);
    }
    this.option.currentIndex = currentIndex;
  };
  TimelineModel2.prototype.getCurrentIndex = function() {
    return this.option.currentIndex;
  };
  TimelineModel2.prototype.isIndexMax = function() {
    return this.getCurrentIndex() >= this._data.count() - 1;
  };
  TimelineModel2.prototype.setPlayState = function(state) {
    this.option.autoPlay = !!state;
  };
  TimelineModel2.prototype.getPlayState = function() {
    return !!this.option.autoPlay;
  };
  TimelineModel2.prototype._initData = function() {
    var thisOption = this.option;
    var dataArr = thisOption.data || [];
    var axisType = thisOption.axisType;
    var names = this._names = [];
    var processedDataArr;
    if (axisType === "category") {
      processedDataArr = [];
      each$f(dataArr, function(item, index2) {
        var value = convertOptionIdName(getDataItemValue(item), "");
        var newItem;
        if (isObject$3(item)) {
          newItem = clone$4(item);
          newItem.value = index2;
        } else {
          newItem = index2;
        }
        processedDataArr.push(newItem);
        names.push(value);
      });
    } else {
      processedDataArr = dataArr;
    }
    var dimType = {
      category: "ordinal",
      time: "time",
      value: "number"
    }[axisType] || "number";
    var data = this._data = new SeriesData$1([{
      name: "value",
      type: dimType
    }], this);
    data.initData(processedDataArr, names);
  };
  TimelineModel2.prototype.getData = function() {
    return this._data;
  };
  TimelineModel2.prototype.getCategories = function() {
    if (this.get("axisType") === "category") {
      return this._names.slice();
    }
  };
  TimelineModel2.type = "timeline";
  TimelineModel2.defaultOption = {
    z: 4,
    show: true,
    axisType: "time",
    realtime: true,
    left: "20%",
    top: null,
    right: "20%",
    bottom: 0,
    width: null,
    height: 40,
    padding: 5,
    controlPosition: "left",
    autoPlay: false,
    rewind: false,
    loop: true,
    playInterval: 2e3,
    currentIndex: 0,
    itemStyle: {},
    label: {
      color: "#000"
    },
    data: []
  };
  return TimelineModel2;
}(ComponentModel$1);
var TimelineModel$1 = TimelineModel;
var SliderTimelineModel = function(_super) {
  __extends$1(SliderTimelineModel2, _super);
  function SliderTimelineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderTimelineModel2.type;
    return _this;
  }
  SliderTimelineModel2.type = "timeline.slider";
  SliderTimelineModel2.defaultOption = inheritDefaultOption(TimelineModel$1.defaultOption, {
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    orient: "horizontal",
    inverse: false,
    tooltip: {
      trigger: "item"
    },
    symbol: "circle",
    symbolSize: 12,
    lineStyle: {
      show: true,
      width: 2,
      color: "#DAE1F5"
    },
    label: {
      position: "auto",
      show: true,
      interval: "auto",
      rotate: 0,
      color: "#A4B1D7"
    },
    itemStyle: {
      color: "#A4B1D7",
      borderWidth: 1
    },
    checkpointStyle: {
      symbol: "circle",
      symbolSize: 15,
      color: "#316bf3",
      borderColor: "#fff",
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0, 0, 0, 0.3)",
      animation: true,
      animationDuration: 300,
      animationEasing: "quinticInOut"
    },
    controlStyle: {
      show: true,
      showPlayBtn: true,
      showPrevBtn: true,
      showNextBtn: true,
      itemSize: 24,
      itemGap: 12,
      position: "left",
      playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
      stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
      nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
      prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
      prevBtnSize: 18,
      nextBtnSize: 18,
      color: "#A4B1D7",
      borderColor: "#A4B1D7",
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true,
        color: "#6f778d"
      },
      itemStyle: {
        color: "#316BF3"
      },
      controlStyle: {
        color: "#316BF3",
        borderColor: "#316BF3",
        borderWidth: 2
      }
    },
    progress: {
      lineStyle: {
        color: "#316BF3"
      },
      itemStyle: {
        color: "#316BF3"
      },
      label: {
        color: "#6f778d"
      }
    },
    data: []
  });
  return SliderTimelineModel2;
}(TimelineModel$1);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel$1 = SliderTimelineModel;
var TimelineView = function(_super) {
  __extends$1(TimelineView2, _super);
  function TimelineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TimelineView2.type;
    return _this;
  }
  TimelineView2.type = "timeline";
  return TimelineView2;
}(ComponentView$1);
var TimelineView$1 = TimelineView;
var TimelineAxis = function(_super) {
  __extends$1(TimelineAxis2, _super);
  function TimelineAxis2(dim, scale4, coordExtent, axisType) {
    var _this = _super.call(this, dim, scale4, coordExtent) || this;
    _this.type = axisType || "value";
    return _this;
  }
  TimelineAxis2.prototype.getLabelModel = function() {
    return this.model.getModel("label");
  };
  TimelineAxis2.prototype.isHorizontal = function() {
    return this.model.get("orient") === "horizontal";
  };
  return TimelineAxis2;
}(Axis$1);
var TimelineAxis$1 = TimelineAxis;
var PI = Math.PI;
var labelDataIndexStore = makeInner();
var SliderTimelineView = function(_super) {
  __extends$1(SliderTimelineView2, _super);
  function SliderTimelineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderTimelineView2.type;
    return _this;
  }
  SliderTimelineView2.prototype.init = function(ecModel, api) {
    this.api = api;
  };
  SliderTimelineView2.prototype.render = function(timelineModel, ecModel, api) {
    this.model = timelineModel;
    this.api = api;
    this.ecModel = ecModel;
    this.group.removeAll();
    if (timelineModel.get("show", true)) {
      var layoutInfo_1 = this._layout(timelineModel, api);
      var mainGroup_1 = this._createGroup("_mainGroup");
      var labelGroup = this._createGroup("_labelGroup");
      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);
      timelineModel.formatTooltip = function(dataIndex) {
        var name2 = axis_1.scale.getLabel({
          value: dataIndex
        });
        return createTooltipMarkup("nameValue", {
          noName: true,
          value: name2
        });
      };
      each$f(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name2) {
        this["_render" + name2](layoutInfo_1, mainGroup_1, axis_1, timelineModel);
      }, this);
      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);
      this._position(layoutInfo_1, timelineModel);
    }
    this._doPlayStop();
    this._updateTicksStatus();
  };
  SliderTimelineView2.prototype.remove = function() {
    this._clearTimer();
    this.group.removeAll();
  };
  SliderTimelineView2.prototype.dispose = function() {
    this._clearTimer();
  };
  SliderTimelineView2.prototype._layout = function(timelineModel, api) {
    var labelPosOpt = timelineModel.get(["label", "position"]);
    var orient2 = timelineModel.get("orient");
    var viewRect2 = getViewRect(timelineModel, api);
    var parsedLabelPos;
    if (labelPosOpt == null || labelPosOpt === "auto") {
      parsedLabelPos = orient2 === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api.getWidth() / 2 ? "+" : "-";
    } else if (isString(labelPosOpt)) {
      parsedLabelPos = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[orient2][labelPosOpt];
    } else {
      parsedLabelPos = labelPosOpt;
    }
    var labelAlignMap = {
      horizontal: "center",
      vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
    };
    var labelBaselineMap = {
      horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
      vertical: "middle"
    };
    var rotationMap = {
      horizontal: 0,
      vertical: PI / 2
    };
    var mainLength = orient2 === "vertical" ? viewRect2.height : viewRect2.width;
    var controlModel = timelineModel.getModel("controlStyle");
    var showControl = controlModel.get("show", true);
    var controlSize = showControl ? controlModel.get("itemSize") : 0;
    var controlGap = showControl ? controlModel.get("itemGap") : 0;
    var sizePlusGap = controlSize + controlGap;
    var labelRotation = timelineModel.get(["label", "rotate"]) || 0;
    labelRotation = labelRotation * PI / 180;
    var playPosition;
    var prevBtnPosition;
    var nextBtnPosition;
    var controlPosition = controlModel.get("position", true);
    var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
    var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
    var showNextBtn = showControl && controlModel.get("showNextBtn", true);
    var xLeft = 0;
    var xRight = mainLength;
    if (controlPosition === "left" || controlPosition === "bottom") {
      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    } else {
      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    }
    var axisExtent = [xLeft, xRight];
    if (timelineModel.get("inverse")) {
      axisExtent.reverse();
    }
    return {
      viewRect: viewRect2,
      mainLength,
      orient: orient2,
      rotation: rotationMap[orient2],
      labelRotation,
      labelPosOpt: parsedLabelPos,
      labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient2],
      labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient2],
      playPosition,
      prevBtnPosition,
      nextBtnPosition,
      axisExtent,
      controlSize,
      controlGap
    };
  };
  SliderTimelineView2.prototype._position = function(layoutInfo, timelineModel) {
    var mainGroup = this._mainGroup;
    var labelGroup = this._labelGroup;
    var viewRect2 = layoutInfo.viewRect;
    if (layoutInfo.orient === "vertical") {
      var m2 = create$1();
      var rotateOriginX = viewRect2.x;
      var rotateOriginY = viewRect2.y + viewRect2.height;
      translate2(m2, m2, [-rotateOriginX, -rotateOriginY]);
      rotate(m2, m2, -PI / 2);
      translate2(m2, m2, [rotateOriginX, rotateOriginY]);
      viewRect2 = viewRect2.clone();
      viewRect2.applyTransform(m2);
    }
    var viewBound = getBound(viewRect2);
    var mainBound = getBound(mainGroup.getBoundingRect());
    var labelBound = getBound(labelGroup.getBoundingRect());
    var mainPosition = [mainGroup.x, mainGroup.y];
    var labelsPosition = [labelGroup.x, labelGroup.y];
    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
    var labelPosOpt = layoutInfo.labelPosOpt;
    if (labelPosOpt == null || isString(labelPosOpt)) {
      var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
    } else {
      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      labelsPosition[1] = mainPosition[1] + labelPosOpt;
    }
    mainGroup.setPosition(mainPosition);
    labelGroup.setPosition(labelsPosition);
    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
    setOrigin(mainGroup);
    setOrigin(labelGroup);
    function setOrigin(targetGroup) {
      targetGroup.originX = viewBound[0][0] - targetGroup.x;
      targetGroup.originY = viewBound[1][0] - targetGroup.y;
    }
    function getBound(rect) {
      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
    }
    function toBound(fromPos, from, to, dimIdx, boundIdx) {
      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
    }
  };
  SliderTimelineView2.prototype._createAxis = function(layoutInfo, timelineModel) {
    var data = timelineModel.getData();
    var axisType = timelineModel.get("axisType");
    var scale4 = createScaleByModel(timelineModel, axisType);
    scale4.getTicks = function() {
      return data.mapArray(["value"], function(value) {
        return {
          value
        };
      });
    };
    var dataExtent = data.getDataExtent("value");
    scale4.setExtent(dataExtent[0], dataExtent[1]);
    scale4.calcNiceTicks();
    var axis = new TimelineAxis$1("value", scale4, layoutInfo.axisExtent, axisType);
    axis.model = timelineModel;
    return axis;
  };
  SliderTimelineView2.prototype._createGroup = function(key) {
    var newGroup = this[key] = new Group$4();
    this.group.add(newGroup);
    return newGroup;
  };
  SliderTimelineView2.prototype._renderAxisLine = function(layoutInfo, group, axis, timelineModel) {
    var axisExtent = axis.getExtent();
    if (!timelineModel.get(["lineStyle", "show"])) {
      return;
    }
    var line = new Line$3({
      shape: {
        x1: axisExtent[0],
        y1: 0,
        x2: axisExtent[1],
        y2: 0
      },
      style: extend2({
        lineCap: "round"
      }, timelineModel.getModel("lineStyle").getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(line);
    var progressLine = this._progressLine = new Line$3({
      shape: {
        x1: axisExtent[0],
        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
        y1: 0,
        y2: 0
      },
      style: defaults({
        lineCap: "round",
        lineWidth: line.style.lineWidth
      }, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(progressLine);
  };
  SliderTimelineView2.prototype._renderAxisTick = function(layoutInfo, group, axis, timelineModel) {
    var _this = this;
    var data = timelineModel.getData();
    var ticks = axis.scale.getTicks();
    this._tickSymbols = [];
    each$f(ticks, function(tick) {
      var tickCoord = axis.dataToCoord(tick.value);
      var itemModel = data.getItemModel(tick.value);
      var itemStyleModel = itemModel.getModel("itemStyle");
      var hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
      var progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
      var symbolOpt = {
        x: tickCoord,
        y: 0,
        onclick: bind$1(_this._changeTimeline, _this, tick.value)
      };
      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
      el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
      el.ensureState("progress").style = progressStyleModel.getItemStyle();
      enableHoverEmphasis(el);
      var ecData = getECData(el);
      if (itemModel.get("tooltip")) {
        ecData.dataIndex = tick.value;
        ecData.dataModel = timelineModel;
      } else {
        ecData.dataIndex = ecData.dataModel = null;
      }
      _this._tickSymbols.push(el);
    });
  };
  SliderTimelineView2.prototype._renderAxisLabel = function(layoutInfo, group, axis, timelineModel) {
    var _this = this;
    var labelModel = axis.getLabelModel();
    if (!labelModel.get("show")) {
      return;
    }
    var data = timelineModel.getData();
    var labels = axis.getViewLabels();
    this._tickLabels = [];
    each$f(labels, function(labelItem) {
      var dataIndex = labelItem.tickValue;
      var itemModel = data.getItemModel(dataIndex);
      var normalLabelModel = itemModel.getModel("label");
      var hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
      var progressLabelModel = itemModel.getModel(["progress", "label"]);
      var tickCoord = axis.dataToCoord(labelItem.tickValue);
      var textEl = new ZRText$1({
        x: tickCoord,
        y: 0,
        rotation: layoutInfo.labelRotation - layoutInfo.rotation,
        onclick: bind$1(_this._changeTimeline, _this, dataIndex),
        silent: false,
        style: createTextStyle(normalLabelModel, {
          text: labelItem.formattedLabel,
          align: layoutInfo.labelAlign,
          verticalAlign: layoutInfo.labelBaseline
        })
      });
      textEl.ensureState("emphasis").style = createTextStyle(hoverLabelModel);
      textEl.ensureState("progress").style = createTextStyle(progressLabelModel);
      group.add(textEl);
      enableHoverEmphasis(textEl);
      labelDataIndexStore(textEl).dataIndex = dataIndex;
      _this._tickLabels.push(textEl);
    });
  };
  SliderTimelineView2.prototype._renderControl = function(layoutInfo, group, axis, timelineModel) {
    var controlSize = layoutInfo.controlSize;
    var rotation = layoutInfo.rotation;
    var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
    var hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
    var playState = timelineModel.getPlayState();
    var inverse = timelineModel.get("inverse", true);
    makeBtn(layoutInfo.nextBtnPosition, "next", bind$1(this._changeTimeline, this, inverse ? "-" : "+"));
    makeBtn(layoutInfo.prevBtnPosition, "prev", bind$1(this._changeTimeline, this, inverse ? "+" : "-"));
    makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind$1(this._handlePlayClick, this, !playState), true);
    function makeBtn(position2, iconName, onclick, willRotate) {
      if (!position2) {
        return;
      }
      var iconSize = parsePercent$1(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
      var rect = [0, -iconSize / 2, iconSize, iconSize];
      var btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
        x: position2[0],
        y: position2[1],
        originX: controlSize / 2,
        originY: 0,
        rotation: willRotate ? -rotation : 0,
        rectHover: true,
        style: itemStyle,
        onclick
      });
      btn.ensureState("emphasis").style = hoverStyle;
      group.add(btn);
      enableHoverEmphasis(btn);
    }
  };
  SliderTimelineView2.prototype._renderCurrentPointer = function(layoutInfo, group, axis, timelineModel) {
    var data = timelineModel.getData();
    var currentIndex = timelineModel.getCurrentIndex();
    var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
    var me = this;
    var callback = {
      onCreate: function(pointer) {
        pointer.draggable = true;
        pointer.drift = bind$1(me._handlePointerDrag, me);
        pointer.ondragend = bind$1(me._handlePointerDragend, me);
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
      },
      onUpdate: function(pointer) {
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
      }
    };
    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
  };
  SliderTimelineView2.prototype._handlePlayClick = function(nextState) {
    this._clearTimer();
    this.api.dispatchAction({
      type: "timelinePlayChange",
      playState: nextState,
      from: this.uid
    });
  };
  SliderTimelineView2.prototype._handlePointerDrag = function(dx, dy, e2) {
    this._clearTimer();
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
  };
  SliderTimelineView2.prototype._handlePointerDragend = function(e2) {
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
  };
  SliderTimelineView2.prototype._pointerChangeTimeline = function(mousePos, trigger2) {
    var toCoord = this._toAxisCoord(mousePos)[0];
    var axis = this._axis;
    var axisExtent = asc$2(axis.getExtent().slice());
    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
    this._currentPointer.x = toCoord;
    this._currentPointer.markRedraw();
    this._progressLine.shape.x2 = toCoord;
    this._progressLine.dirty();
    var targetDataIndex = this._findNearestTick(toCoord);
    var timelineModel = this.model;
    if (trigger2 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
      this._changeTimeline(targetDataIndex);
    }
  };
  SliderTimelineView2.prototype._doPlayStop = function() {
    var _this = this;
    this._clearTimer();
    if (this.model.getPlayState()) {
      this._timer = setTimeout(function() {
        var timelineModel = _this.model;
        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval"));
    }
  };
  SliderTimelineView2.prototype._toAxisCoord = function(vertex) {
    var trans = this._mainGroup.getLocalTransform();
    return applyTransform(vertex, trans, true);
  };
  SliderTimelineView2.prototype._findNearestTick = function(axisCoord) {
    var data = this.model.getData();
    var dist3 = Infinity;
    var targetDataIndex;
    var axis = this._axis;
    data.each(["value"], function(value, dataIndex) {
      var coord = axis.dataToCoord(value);
      var d = Math.abs(coord - axisCoord);
      if (d < dist3) {
        dist3 = d;
        targetDataIndex = dataIndex;
      }
    });
    return targetDataIndex;
  };
  SliderTimelineView2.prototype._clearTimer = function() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  };
  SliderTimelineView2.prototype._changeTimeline = function(nextIndex) {
    var currentIndex = this.model.getCurrentIndex();
    if (nextIndex === "+") {
      nextIndex = currentIndex + 1;
    } else if (nextIndex === "-") {
      nextIndex = currentIndex - 1;
    }
    this.api.dispatchAction({
      type: "timelineChange",
      currentIndex: nextIndex,
      from: this.uid
    });
  };
  SliderTimelineView2.prototype._updateTicksStatus = function() {
    var currentIndex = this.model.getCurrentIndex();
    var tickSymbols = this._tickSymbols;
    var tickLabels = this._tickLabels;
    if (tickSymbols) {
      for (var i = 0; i < tickSymbols.length; i++) {
        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState("progress", i < currentIndex);
      }
    }
    if (tickLabels) {
      for (var i = 0; i < tickLabels.length; i++) {
        tickLabels && tickLabels[i] && tickLabels[i].toggleState("progress", labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
      }
    }
  };
  SliderTimelineView2.type = "timeline.slider";
  return SliderTimelineView2;
}(TimelineView$1);
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new IntervalScale$1();
    }
  }
}
function getViewRect(model, api) {
  return getLayoutRect(model.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  }, model.get("padding"));
}
function makeControlIcon(timelineModel, objPath, rect, opts) {
  var style = opts.style;
  var icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect$1(rect[0], rect[1], rect[2], rect[3]));
  if (style) {
    icon.setStyle(style);
  }
  return icon;
}
function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
  var color = itemStyleModel.get("color");
  if (!symbol) {
    var symbolType = hostModel.get("symbol");
    symbol = createSymbol$1(symbolType, -1, -1, 2, 2, color);
    symbol.setStyle("strokeNoScale", true);
    group.add(symbol);
    callback && callback.onCreate(symbol);
  } else {
    symbol.setColor(color);
    group.add(symbol);
    callback && callback.onUpdate(symbol);
  }
  var itemStyle = itemStyleModel.getItemStyle(["color"]);
  symbol.setStyle(itemStyle);
  opt = merge3({
    rectHover: true,
    z2: 100
  }, opt, true);
  var symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
  opt.scaleX = symbolSize[0] / 2;
  opt.scaleY = symbolSize[1] / 2;
  var symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
  if (symbolOffset) {
    opt.x = (opt.x || 0) + symbolOffset[0];
    opt.y = (opt.y || 0) + symbolOffset[1];
  }
  var symbolRotate = hostModel.get("symbolRotate");
  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  symbol.attr(opt);
  symbol.updateTransform();
  return symbol;
}
function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
  if (pointer.dragging) {
    return;
  }
  var pointerModel = timelineModel.getModel("checkpointStyle");
  var toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
  if (noAnimation || !pointerModel.get("animation", true)) {
    pointer.attr({
      x: toCoord,
      y: 0
    });
    progressLine && progressLine.attr({
      shape: {
        x2: toCoord
      }
    });
  } else {
    var animationCfg = {
      duration: pointerModel.get("animationDuration", true),
      easing: pointerModel.get("animationEasing", true)
    };
    pointer.stopAnimation(null, true);
    pointer.animateTo({
      x: toCoord,
      y: 0
    }, animationCfg);
    progressLine && progressLine.animateTo({
      shape: {
        x2: toCoord
      }
    }, animationCfg);
  }
}
var SliderTimelineView$1 = SliderTimelineView;
function installTimelineAction(registers) {
  registers.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel, api) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
        timelineModel.setPlayState(false);
        api.dispatchAction({
          type: "timelinePlayChange",
          playState: false,
          from: payload.from
        });
      }
    }
    ecModel.resetOption("timeline", {
      replaceMerge: timelineModel.get("replaceMerge", true)
    });
    return defaults({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  registers.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
}
function timelinePreprocessor(option) {
  var timelineOpt = option && option.timeline;
  if (!isArray$1(timelineOpt)) {
    timelineOpt = timelineOpt ? [timelineOpt] : [];
  }
  each$f(timelineOpt, function(opt) {
    if (!opt) {
      return;
    }
    compatibleEC2(opt);
  });
}
function compatibleEC2(opt) {
  var type = opt.type;
  var ec2Types = {
    "number": "value",
    "time": "time"
  };
  if (ec2Types[type]) {
    opt.axisType = ec2Types[type];
    delete opt.type;
  }
  transferItem(opt);
  if (has$1(opt, "controlPosition")) {
    var controlStyle = opt.controlStyle || (opt.controlStyle = {});
    if (!has$1(controlStyle, "position")) {
      controlStyle.position = opt.controlPosition;
    }
    if (controlStyle.position === "none" && !has$1(controlStyle, "show")) {
      controlStyle.show = false;
      delete controlStyle.position;
    }
    delete opt.controlPosition;
  }
  each$f(opt.data || [], function(dataItem) {
    if (isObject$3(dataItem) && !isArray$1(dataItem)) {
      if (!has$1(dataItem, "value") && has$1(dataItem, "name")) {
        dataItem.value = dataItem.name;
      }
      transferItem(dataItem);
    }
  });
}
function transferItem(opt) {
  var itemStyle = opt.itemStyle || (opt.itemStyle = {});
  var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
  var label = opt.label || opt.label || {};
  var labelNormal = label.normal || (label.normal = {});
  var excludeLabelAttr = {
    normal: 1,
    emphasis: 1
  };
  each$f(label, function(value, name2) {
    if (!excludeLabelAttr[name2] && !has$1(labelNormal, name2)) {
      labelNormal[name2] = value;
    }
  });
  if (itemStyleEmphasis.label && !has$1(label, "emphasis")) {
    label.emphasis = itemStyleEmphasis.label;
    delete itemStyleEmphasis.label;
  }
}
function has$1(obj, attr) {
  return obj.hasOwnProperty(attr);
}
function install$f(registers) {
  registers.registerComponentModel(SliderTimelineModel$1);
  registers.registerComponentView(SliderTimelineView$1);
  registers.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  });
  installTimelineAction(registers);
  registers.registerPreprocessor(timelinePreprocessor);
}
function checkMarkerInSeries(seriesOpts, markerType) {
  if (!seriesOpts) {
    return false;
  }
  var seriesOptArr = isArray$1(seriesOpts) ? seriesOpts : [seriesOpts];
  for (var idx = 0; idx < seriesOptArr.length; idx++) {
    if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {
      return true;
    }
  }
  return false;
}
function fillLabel(opt) {
  defaultEmphasis(opt, "label", ["show"]);
}
var inner$5 = makeInner();
var MarkerModel = function(_super) {
  __extends$1(MarkerModel2, _super);
  function MarkerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkerModel2.type;
    _this.createdBySelf = false;
    return _this;
  }
  MarkerModel2.prototype.init = function(option, parentModel, ecModel) {
    {
      if (this.type === "marker") {
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    this._mergeOption(option, ecModel, false, true);
  };
  MarkerModel2.prototype.isAnimationEnabled = function() {
    if (env$1.node) {
      return false;
    }
    var hostSeries = this.__hostSeries;
    return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
  };
  MarkerModel2.prototype.mergeOption = function(newOpt, ecModel) {
    this._mergeOption(newOpt, ecModel, false, false);
  };
  MarkerModel2.prototype._mergeOption = function(newOpt, ecModel, createdBySelf, isInit) {
    var componentType = this.mainType;
    if (!createdBySelf) {
      ecModel.eachSeries(function(seriesModel) {
        var markerOpt = seriesModel.get(this.mainType, true);
        var markerModel = inner$5(seriesModel)[componentType];
        if (!markerOpt || !markerOpt.data) {
          inner$5(seriesModel)[componentType] = null;
          return;
        }
        if (!markerModel) {
          if (isInit) {
            fillLabel(markerOpt);
          }
          each$f(markerOpt.data, function(item) {
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
          extend2(markerModel, {
            mainType: this.mainType,
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel._mergeOption(markerOpt, ecModel, true);
        }
        inner$5(seriesModel)[componentType] = markerModel;
      }, this);
    }
  };
  MarkerModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var itemName = data.getName(dataIndex);
    return createTooltipMarkup("section", {
      header: this.name,
      blocks: [createTooltipMarkup("nameValue", {
        name: itemName,
        value,
        noName: !itemName,
        noValue: value == null
      })]
    });
  };
  MarkerModel2.prototype.getData = function() {
    return this._data;
  };
  MarkerModel2.prototype.setData = function(data) {
    this._data = data;
  };
  MarkerModel2.getMarkerModelFromSeries = function(seriesModel, componentType) {
    return inner$5(seriesModel)[componentType];
  };
  MarkerModel2.type = "marker";
  MarkerModel2.dependencies = ["series", "grid", "polar", "geo"];
  return MarkerModel2;
}(ComponentModel$1);
mixin(MarkerModel, DataFormatMixin.prototype);
var MarkerModel$1 = MarkerModel;
var MarkPointModel = function(_super) {
  __extends$1(MarkPointModel2, _super);
  function MarkPointModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkPointModel2.type;
    return _this;
  }
  MarkPointModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
    return new MarkPointModel2(markerOpt, masterMarkerModel, ecModel);
  };
  MarkPointModel2.type = "markPoint";
  MarkPointModel2.defaultOption = {
    z: 5,
    symbol: "pin",
    symbolSize: 50,
    tooltip: {
      trigger: "item"
    },
    label: {
      show: true,
      position: "inside"
    },
    itemStyle: {
      borderWidth: 2
    },
    emphasis: {
      label: {
        show: true
      }
    }
  };
  return MarkPointModel2;
}(MarkerModel$1);
var MarkPointModel$1 = MarkPointModel;
function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}
function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}
function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  var coordArr = [];
  var stacked = isDimensionStacked(
    data,
    targetDataDim
  );
  var calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
  var value = numCalculate(data, calcDataDim, markerType);
  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
  var coordArrValue = data.get(targetDataDim, dataIndex);
  var precision = getPrecision(data.get(targetDataDim, dataIndex));
  precision = Math.min(precision, 20);
  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }
  return [coordArr, coordArrValue];
}
var markerTypeCalculator = {
  min: curry$1(markerTypeCalculatorWithExtent, "min"),
  max: curry$1(markerTypeCalculatorWithExtent, "max"),
  average: curry$1(markerTypeCalculatorWithExtent, "average"),
  median: curry$1(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(seriesModel, item) {
  var data = seriesModel.getData();
  var coordSys = seriesModel.coordinateSystem;
  if (item && !hasXAndY(item) && !isArray$1(item.coord) && coordSys) {
    var dims = coordSys.dimensions;
    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
    item = clone$4(item);
    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      var otherCoordIndex = indexOf2(dims, axisInfo.baseAxis.dim);
      var targetCoordIndex = indexOf2(dims, axisInfo.valueAxis.dim);
      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
      item.coord = coordInfo[0];
      item.value = coordInfo[1];
    } else {
      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
      for (var i = 0; i < 2; i++) {
        if (markerTypeCalculator[coord[i]]) {
          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
        }
      }
      item.coord = coord;
    }
  }
  return item;
}
function getAxisInfo(item, data, coordSys, seriesModel) {
  var ret = {};
  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
  }
  return ret;
}
function dataDimToCoordDim(seriesModel, dataDim) {
  var dimItem = seriesModel.getData().getDimensionInfo(dataDim);
  return dimItem && dimItem.coordDim;
}
function dataFilter(coordSys, item) {
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}
function zoneFilter(coordSys, item1, item2) {
  return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;
}
function createMarkerDimValueGetter(inCoordSys, dims) {
  return inCoordSys ? function(item, dimName, dataIndex, dimIndex) {
    var rawVal = dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value;
    return parseDataValue(rawVal, dims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dims[dimIndex]);
  };
}
function numCalculate(data, valueDataDim, type) {
  if (type === "average") {
    var sum_1 = 0;
    var count_1 = 0;
    data.each(valueDataDim, function(val, idx) {
      if (!isNaN(val)) {
        sum_1 += val;
        count_1++;
      }
    });
    return sum_1 / count_1;
  } else if (type === "median") {
    return data.getMedian(valueDataDim);
  } else {
    return data.getDataExtent(valueDataDim)[type === "max" ? 1 : 0];
  }
}
var inner$4 = makeInner();
var MarkerView = function(_super) {
  __extends$1(MarkerView2, _super);
  function MarkerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkerView2.type;
    return _this;
  }
  MarkerView2.prototype.init = function() {
    this.markerGroupMap = createHashMap();
  };
  MarkerView2.prototype.render = function(markerModel, ecModel, api) {
    var _this = this;
    var markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function(item) {
      inner$4(item).keep = false;
    });
    ecModel.eachSeries(function(seriesModel) {
      var markerModel2 = MarkerModel$1.getMarkerModelFromSeries(seriesModel, _this.type);
      markerModel2 && _this.renderSeries(seriesModel, markerModel2, ecModel, api);
    });
    markerGroupMap.each(function(item) {
      !inner$4(item).keep && _this.group.remove(item.group);
    });
  };
  MarkerView2.prototype.markKeep = function(drawGroup) {
    inner$4(drawGroup).keep = true;
  };
  MarkerView2.prototype.toggleBlurSeries = function(seriesModelList, isBlur) {
    var _this = this;
    each$f(seriesModelList, function(seriesModel) {
      var markerModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, _this.type);
      if (markerModel) {
        var data = markerModel.getData();
        data.eachItemGraphicEl(function(el) {
          if (el) {
            isBlur ? enterBlur(el) : leaveBlur(el);
          }
        });
      }
    });
  };
  MarkerView2.type = "marker";
  return MarkerView2;
}(ComponentView$1);
var MarkerView$1 = MarkerView;
function updateMarkerLayout(mpData, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  mpData.each(function(idx) {
    var itemModel = mpData.getItemModel(idx);
    var point4;
    var xPx = parsePercent(itemModel.get("x"), api.getWidth());
    var yPx = parsePercent(itemModel.get("y"), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point4 = [xPx, yPx];
    } else if (seriesModel.getMarkerPosition) {
      point4 = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
    } else if (coordSys) {
      var x2 = mpData.get(coordSys.dimensions[0], idx);
      var y2 = mpData.get(coordSys.dimensions[1], idx);
      point4 = coordSys.dataToPoint([x2, y2]);
    }
    if (!isNaN(xPx)) {
      point4[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point4[1] = yPx;
    }
    mpData.setItemLayout(idx, point4);
  });
}
var MarkPointView = function(_super) {
  __extends$1(MarkPointView2, _super);
  function MarkPointView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkPointView2.type;
    return _this;
  }
  MarkPointView2.prototype.updateTransform = function(markPointModel, ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      var mpModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, "markPoint");
      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  };
  MarkPointView2.prototype.renderSeries = function(seriesModel, mpModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var symbolDrawMap = this.markerGroupMap;
    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw$1());
    var mpData = createData(coordSys, seriesModel, mpModel);
    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api);
    mpData.each(function(idx) {
      var itemModel = mpData.getItemModel(idx);
      var symbol = itemModel.getShallow("symbol");
      var symbolSize = itemModel.getShallow("symbolSize");
      var symbolRotate = itemModel.getShallow("symbolRotate");
      var symbolOffset = itemModel.getShallow("symbolOffset");
      var symbolKeepAspect = itemModel.getShallow("symbolKeepAspect");
      if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {
        var rawIdx = mpModel.getRawValue(idx);
        var dataParams = mpModel.getDataParams(idx);
        if (isFunction(symbol)) {
          symbol = symbol(rawIdx, dataParams);
        }
        if (isFunction(symbolSize)) {
          symbolSize = symbolSize(rawIdx, dataParams);
        }
        if (isFunction(symbolRotate)) {
          symbolRotate = symbolRotate(rawIdx, dataParams);
        }
        if (isFunction(symbolOffset)) {
          symbolOffset = symbolOffset(rawIdx, dataParams);
        }
      }
      var style = itemModel.getModel("itemStyle").getItemStyle();
      var color = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color;
      }
      mpData.setItemVisual(idx, {
        symbol,
        symbolSize,
        symbolRotate,
        symbolOffset,
        symbolKeepAspect,
        style
      });
    });
    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group);
    mpData.eachItemGraphicEl(function(el) {
      el.traverse(function(child) {
        getECData(child).dataModel = mpModel;
      });
    });
    this.markKeep(symbolDraw);
    symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
  };
  MarkPointView2.type = "markPoint";
  return MarkPointView2;
}(MarkerView$1);
function createData(coordSys, seriesModel, mpModel) {
  var coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map$1(coordSys && coordSys.dimensions, function(coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend2(extend2({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  var mpData = new SeriesData$1(coordDimsInfos, mpModel);
  var dataOpt = map$1(mpModel.get("data"), curry$1(dataTransform, seriesModel));
  if (coordSys) {
    dataOpt = filter17(dataOpt, curry$1(dataFilter, coordSys));
  }
  var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  mpData.initData(dataOpt, null, dimValueGetter);
  return mpData;
}
var MarkPointView$1 = MarkPointView;
function install$e(registers) {
  registers.registerComponentModel(MarkPointModel$1);
  registers.registerComponentView(MarkPointView$1);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markPoint")) {
      opt.markPoint = opt.markPoint || {};
    }
  });
}
var MarkLineModel = function(_super) {
  __extends$1(MarkLineModel2, _super);
  function MarkLineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkLineModel2.type;
    return _this;
  }
  MarkLineModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
    return new MarkLineModel2(markerOpt, masterMarkerModel, ecModel);
  };
  MarkLineModel2.type = "markLine";
  MarkLineModel2.defaultOption = {
    z: 5,
    symbol: ["circle", "arrow"],
    symbolSize: [8, 16],
    symbolOffset: 0,
    precision: 2,
    tooltip: {
      trigger: "item"
    },
    label: {
      show: true,
      position: "end",
      distance: 5
    },
    lineStyle: {
      type: "dashed"
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        width: 3
      }
    },
    animationEasing: "linear"
  };
  return MarkLineModel2;
}(MarkerModel$1);
var MarkLineModel$1 = MarkLineModel;
var inner$3 = makeInner();
var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
  var data = seriesModel.getData();
  var itemArray;
  if (!isArray$1(item)) {
    var mlType = item.type;
    if (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null) {
      var valueAxis2 = void 0;
      var value = void 0;
      if (item.yAxis != null || item.xAxis != null) {
        valueAxis2 = coordSys.getAxis(item.yAxis != null ? "y" : "x");
        value = retrieve(item.yAxis, item.xAxis);
      } else {
        var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
        valueAxis2 = axisInfo.valueAxis;
        var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
        value = numCalculate(data, valueDataDim, mlType);
      }
      var valueIndex = valueAxis2.dim === "x" ? 0 : 1;
      var baseIndex = 1 - valueIndex;
      var mlFrom = clone$4(item);
      var mlTo = {
        coord: []
      };
      mlFrom.type = null;
      mlFrom.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      var precision = mlModel.get("precision");
      if (precision >= 0 && isNumber(value)) {
        value = +value.toFixed(Math.min(precision, 20));
      }
      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      itemArray = [mlFrom, mlTo, {
        type: mlType,
        valueIndex: item.valueIndex,
        value
      }];
    } else {
      {
        logError("Invalid markLine data.");
      }
      itemArray = [];
    }
  } else {
    itemArray = item;
  }
  var normalizedItem = [dataTransform(seriesModel, itemArray[0]), dataTransform(seriesModel, itemArray[1]), extend2({}, itemArray[2])];
  normalizedItem[2].type = normalizedItem[2].type || null;
  merge3(normalizedItem[2], normalizedItem[0]);
  merge3(normalizedItem[2], normalizedItem[1]);
  return normalizedItem;
};
function isInfinity$1(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  var dimName = coordSys.dimensions[dimIndex];
  return isInfinity$1(fromCoord[otherDimIndex]) && isInfinity$1(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}
function markLineFilter(coordSys, item) {
  if (coordSys.type === "cartesian2d") {
    var fromCoord = item[0].coord;
    var toCoord = item[1].coord;
    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }
  return dataFilter(coordSys, item[0]) && dataFilter(coordSys, item[1]);
}
function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point4;
  var xPx = parsePercent(itemModel.get("x"), api.getWidth());
  var yPx = parsePercent(itemModel.get("y"), api.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point4 = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      point4 = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      var dims = coordSys.dimensions;
      var x2 = data.get(dims[0], idx);
      var y2 = data.get(dims[1], idx);
      point4 = coordSys.dataToPoint([x2, y2]);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var xAxis = coordSys.getAxis("x");
      var yAxis = coordSys.getAxis("y");
      var dims = coordSys.dimensions;
      if (isInfinity$1(data.get(dims[0], idx))) {
        point4[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInfinity$1(data.get(dims[1], idx))) {
        point4[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point4[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point4[1] = yPx;
    }
  }
  data.setItemLayout(idx, point4);
}
var MarkLineView = function(_super) {
  __extends$1(MarkLineView2, _super);
  function MarkLineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkLineView2.type;
    return _this;
  }
  MarkLineView2.prototype.updateTransform = function(markLineModel, ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      var mlModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, "markLine");
      if (mlModel) {
        var mlData_1 = mlModel.getData();
        var fromData_1 = inner$3(mlModel).from;
        var toData_1 = inner$3(mlModel).to;
        fromData_1.each(function(idx) {
          updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);
          updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);
        });
        mlData_1.each(function(idx) {
          mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  };
  MarkLineView2.prototype.renderSeries = function(seriesModel, mlModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var lineDrawMap = this.markerGroupMap;
    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw$1());
    this.group.add(lineDraw.group);
    var mlData = createList$1(coordSys, seriesModel, mlModel);
    var fromData = mlData.from;
    var toData = mlData.to;
    var lineData = mlData.line;
    inner$3(mlModel).from = fromData;
    inner$3(mlModel).to = toData;
    mlModel.setData(lineData);
    var symbolType = mlModel.get("symbol");
    var symbolSize = mlModel.get("symbolSize");
    var symbolRotate = mlModel.get("symbolRotate");
    var symbolOffset = mlModel.get("symbolOffset");
    if (!isArray$1(symbolType)) {
      symbolType = [symbolType, symbolType];
    }
    if (!isArray$1(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }
    if (!isArray$1(symbolRotate)) {
      symbolRotate = [symbolRotate, symbolRotate];
    }
    if (!isArray$1(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    mlData.from.each(function(idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    });
    lineData.each(function(idx) {
      var lineStyle = lineData.getItemModel(idx).getModel("lineStyle").getLineStyle();
      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
      if (lineStyle.stroke == null) {
        lineStyle.stroke = fromData.getItemVisual(idx, "style").fill;
      }
      lineData.setItemVisual(idx, {
        fromSymbolKeepAspect: fromData.getItemVisual(idx, "symbolKeepAspect"),
        fromSymbolOffset: fromData.getItemVisual(idx, "symbolOffset"),
        fromSymbolRotate: fromData.getItemVisual(idx, "symbolRotate"),
        fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
        fromSymbol: fromData.getItemVisual(idx, "symbol"),
        toSymbolKeepAspect: toData.getItemVisual(idx, "symbolKeepAspect"),
        toSymbolOffset: toData.getItemVisual(idx, "symbolOffset"),
        toSymbolRotate: toData.getItemVisual(idx, "symbolRotate"),
        toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
        toSymbol: toData.getItemVisual(idx, "symbol"),
        style: lineStyle
      });
    });
    lineDraw.updateData(lineData);
    mlData.line.eachItemGraphicEl(function(el) {
      getECData(el).dataModel = mlModel;
      el.traverse(function(child) {
        getECData(child).dataModel = mlModel;
      });
    });
    function updateDataVisualAndLayout(data, idx, isFrom) {
      var itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
      var style = itemModel.getModel("itemStyle").getItemStyle();
      if (style.fill == null) {
        style.fill = getVisualFromData(seriesData, "color");
      }
      data.setItemVisual(idx, {
        symbolKeepAspect: itemModel.get("symbolKeepAspect"),
        symbolOffset: retrieve2(itemModel.get("symbolOffset", true), symbolOffset[isFrom ? 0 : 1]),
        symbolRotate: retrieve2(itemModel.get("symbolRotate", true), symbolRotate[isFrom ? 0 : 1]),
        symbolSize: retrieve2(itemModel.get("symbolSize"), symbolSize[isFrom ? 0 : 1]),
        symbol: retrieve2(itemModel.get("symbol", true), symbolType[isFrom ? 0 : 1]),
        style
      });
    }
    this.markKeep(lineDraw);
    lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
  };
  MarkLineView2.type = "markLine";
  return MarkLineView2;
}(MarkerView$1);
function createList$1(coordSys, seriesModel, mlModel) {
  var coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map$1(coordSys && coordSys.dimensions, function(coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend2(extend2({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  var fromData = new SeriesData$1(coordDimsInfos, mlModel);
  var toData = new SeriesData$1(coordDimsInfos, mlModel);
  var lineData = new SeriesData$1([], mlModel);
  var optData = map$1(mlModel.get("data"), curry$1(markLineTransform, seriesModel, coordSys, mlModel));
  if (coordSys) {
    optData = filter17(optData, curry$1(markLineFilter, coordSys));
  }
  var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  fromData.initData(map$1(optData, function(item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(map$1(optData, function(item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(map$1(optData, function(item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}
var MarkLineView$1 = MarkLineView;
function install$d(registers) {
  registers.registerComponentModel(MarkLineModel$1);
  registers.registerComponentView(MarkLineView$1);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markLine")) {
      opt.markLine = opt.markLine || {};
    }
  });
}
var MarkAreaModel = function(_super) {
  __extends$1(MarkAreaModel2, _super);
  function MarkAreaModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkAreaModel2.type;
    return _this;
  }
  MarkAreaModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
    return new MarkAreaModel2(markerOpt, masterMarkerModel, ecModel);
  };
  MarkAreaModel2.type = "markArea";
  MarkAreaModel2.defaultOption = {
    z: 1,
    tooltip: {
      trigger: "item"
    },
    animation: false,
    label: {
      show: true,
      position: "top"
    },
    itemStyle: {
      borderWidth: 0
    },
    emphasis: {
      label: {
        show: true,
        position: "top"
      }
    }
  };
  return MarkAreaModel2;
}(MarkerModel$1);
var MarkAreaModel$1 = MarkAreaModel;
var inner$2 = makeInner();
var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
  var lt3 = dataTransform(seriesModel, item[0]);
  var rb2 = dataTransform(seriesModel, item[1]);
  var ltCoord = lt3.coord;
  var rbCoord = rb2.coord;
  ltCoord[0] = retrieve(ltCoord[0], -Infinity);
  ltCoord[1] = retrieve(ltCoord[1], -Infinity);
  rbCoord[0] = retrieve(rbCoord[0], Infinity);
  rbCoord[1] = retrieve(rbCoord[1], Infinity);
  var result = mergeAll([{}, lt3, rb2]);
  result.coord = [lt3.coord, rb2.coord];
  result.x0 = lt3.x;
  result.y0 = lt3.y;
  result.x1 = rb2.x;
  result.y1 = rb2.y;
  return result;
};
function isInfinity(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]);
}
function markAreaFilter(coordSys, item) {
  var fromCoord = item.coord[0];
  var toCoord = item.coord[1];
  var item0 = {
    coord: fromCoord,
    x: item.x0,
    y: item.y0
  };
  var item1 = {
    coord: toCoord,
    x: item.x1,
    y: item.y1
  };
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord))) {
      return true;
    }
    return zoneFilter(coordSys, item0, item1);
  }
  return dataFilter(coordSys, item0) || dataFilter(coordSys, item1);
}
function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point4;
  var xPx = parsePercent(itemModel.get(dims[0]), api.getWidth());
  var yPx = parsePercent(itemModel.get(dims[1]), api.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point4 = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      point4 = seriesModel.getMarkerPosition(data.getValues(dims, idx));
    } else {
      var x2 = data.get(dims[0], idx);
      var y2 = data.get(dims[1], idx);
      var pt = [x2, y2];
      coordSys.clampData && coordSys.clampData(pt, pt);
      point4 = coordSys.dataToPoint(pt, true);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var xAxis = coordSys.getAxis("x");
      var yAxis = coordSys.getAxis("y");
      var x2 = data.get(dims[0], idx);
      var y2 = data.get(dims[1], idx);
      if (isInfinity(x2)) {
        point4[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
      } else if (isInfinity(y2)) {
        point4[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point4[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point4[1] = yPx;
    }
  }
  return point4;
}
var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
var MarkAreaView = function(_super) {
  __extends$1(MarkAreaView2, _super);
  function MarkAreaView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkAreaView2.type;
    return _this;
  }
  MarkAreaView2.prototype.updateTransform = function(markAreaModel, ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      var maModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, "markArea");
      if (maModel) {
        var areaData_1 = maModel.getData();
        areaData_1.each(function(idx) {
          var points2 = map$1(dimPermutations, function(dim) {
            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);
          });
          areaData_1.setItemLayout(idx, points2);
          var el = areaData_1.getItemGraphicEl(idx);
          el.setShape("points", points2);
        });
      }
    }, this);
  };
  MarkAreaView2.prototype.renderSeries = function(seriesModel, maModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var areaGroupMap = this.markerGroupMap;
    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
      group: new Group$4()
    });
    this.group.add(polygonGroup.group);
    this.markKeep(polygonGroup);
    var areaData = createList2(coordSys, seriesModel, maModel);
    maModel.setData(areaData);
    areaData.each(function(idx) {
      var points2 = map$1(dimPermutations, function(dim) {
        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
      });
      var xAxisScale = coordSys.getAxis("x").scale;
      var yAxisScale = coordSys.getAxis("y").scale;
      var xAxisExtent = xAxisScale.getExtent();
      var yAxisExtent = yAxisScale.getExtent();
      var xPointExtent = [xAxisScale.parse(areaData.get("x0", idx)), xAxisScale.parse(areaData.get("x1", idx))];
      var yPointExtent = [yAxisScale.parse(areaData.get("y0", idx)), yAxisScale.parse(areaData.get("y1", idx))];
      asc$2(xPointExtent);
      asc$2(yPointExtent);
      var overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);
      var allClipped = !overlapped;
      areaData.setItemLayout(idx, {
        points: points2,
        allClipped
      });
      var style = areaData.getItemModel(idx).getModel("itemStyle").getItemStyle();
      var color = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color;
        if (isString(style.fill)) {
          style.fill = modifyAlpha(style.fill, 0.4);
        }
      }
      if (!style.stroke) {
        style.stroke = color;
      }
      areaData.setItemVisual(idx, "style", style);
    });
    areaData.diff(inner$2(polygonGroup).data).add(function(idx) {
      var layout2 = areaData.getItemLayout(idx);
      if (!layout2.allClipped) {
        var polygon4 = new Polygon$1({
          shape: {
            points: layout2.points
          }
        });
        areaData.setItemGraphicEl(idx, polygon4);
        polygonGroup.group.add(polygon4);
      }
    }).update(function(newIdx, oldIdx) {
      var polygon4 = inner$2(polygonGroup).data.getItemGraphicEl(oldIdx);
      var layout2 = areaData.getItemLayout(newIdx);
      if (!layout2.allClipped) {
        if (polygon4) {
          updateProps$1(polygon4, {
            shape: {
              points: layout2.points
            }
          }, maModel, newIdx);
        } else {
          polygon4 = new Polygon$1({
            shape: {
              points: layout2.points
            }
          });
        }
        areaData.setItemGraphicEl(newIdx, polygon4);
        polygonGroup.group.add(polygon4);
      } else if (polygon4) {
        polygonGroup.group.remove(polygon4);
      }
    }).remove(function(idx) {
      var polygon4 = inner$2(polygonGroup).data.getItemGraphicEl(idx);
      polygonGroup.group.remove(polygon4);
    }).execute();
    areaData.eachItemGraphicEl(function(polygon4, idx) {
      var itemModel = areaData.getItemModel(idx);
      var style = areaData.getItemVisual(idx, "style");
      polygon4.useStyle(areaData.getItemVisual(idx, "style"));
      setLabelStyle(polygon4, getLabelStatesModels(itemModel), {
        labelFetcher: maModel,
        labelDataIndex: idx,
        defaultText: areaData.getName(idx) || "",
        inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : "#000"
      });
      setStatesStylesFromModel(polygon4, itemModel);
      toggleHoverEmphasis(polygon4, null, null, itemModel.get(["emphasis", "disabled"]));
      getECData(polygon4).dataModel = maModel;
    });
    inner$2(polygonGroup).data = areaData;
    polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
  };
  MarkAreaView2.type = "markArea";
  return MarkAreaView2;
}(MarkerView$1);
function createList2(coordSys, seriesModel, maModel) {
  var areaData;
  var dataDims;
  var dims = ["x0", "y0", "x1", "y1"];
  if (coordSys) {
    var coordDimsInfos_1 = map$1(coordSys && coordSys.dimensions, function(coordDim) {
      var data = seriesModel.getData();
      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
      return extend2(extend2({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
    dataDims = map$1(dims, function(dim, idx) {
      return {
        name: dim,
        type: coordDimsInfos_1[idx % 2].type
      };
    });
    areaData = new SeriesData$1(dataDims, maModel);
  } else {
    dataDims = [{
      name: "value",
      type: "float"
    }];
    areaData = new SeriesData$1(dataDims, maModel);
  }
  var optData = map$1(maModel.get("data"), curry$1(markAreaTransform, seriesModel, coordSys, maModel));
  if (coordSys) {
    optData = filter17(optData, curry$1(markAreaFilter, coordSys));
  }
  var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
    var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    return parseDataValue(rawVal, dataDims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dataDims[dimIndex]);
  };
  areaData.initData(optData, null, dimValueGetter);
  areaData.hasItemOption = true;
  return areaData;
}
var MarkAreaView$1 = MarkAreaView;
function install$c(registers) {
  registers.registerComponentModel(MarkAreaModel$1);
  registers.registerComponentView(MarkAreaView$1);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markArea")) {
      opt.markArea = opt.markArea || {};
    }
  });
}
var getDefaultSelectorOptions = function(ecModel, type) {
  if (type === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel = function(_super) {
  __extends$1(LegendModel2, _super);
  function LegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  LegendModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  };
  LegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    this._updateSelector(option);
  };
  LegendModel2.prototype._updateSelector = function(option) {
    var selector2 = option.selector;
    var ecModel = this.ecModel;
    if (selector2 === true) {
      selector2 = option.selector = ["all", "inverse"];
    }
    if (isArray$1(selector2)) {
      each$f(selector2, function(item, index2) {
        isString(item) && (item = {
          type: item
        });
        selector2[index2] = merge3(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };
  LegendModel2.prototype.optionUpdated = function() {
    this._updateData(this.ecModel);
    var legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      var hasSelected = false;
      for (var i = 0; i < legendData.length; i++) {
        var name_1 = legendData[i].get("name");
        if (this.isSelected(name_1)) {
          this.select(name_1);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  };
  LegendModel2.prototype._updateData = function(ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;
      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }
        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    var rawData = this.get("data") || potentialData;
    var legendData = map$1(rawData, function(dataItem) {
      if (isString(dataItem) || isNumber(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      return new Model$1(dataItem, this, this.ecModel);
    }, this);
    this._data = legendData;
  };
  LegendModel2.prototype.getData = function() {
    return this._data;
  };
  LegendModel2.prototype.select = function(name2) {
    var selected = this.option.selected;
    var selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      var data = this._data;
      each$f(data, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name2] = true;
  };
  LegendModel2.prototype.unSelect = function(name2) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name2] = false;
    }
  };
  LegendModel2.prototype.toggleSelected = function(name2) {
    var selected = this.option.selected;
    if (!selected.hasOwnProperty(name2)) {
      selected[name2] = true;
    }
    this[selected[name2] ? "unSelect" : "select"](name2);
  };
  LegendModel2.prototype.allSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each$f(data, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  };
  LegendModel2.prototype.inverseSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each$f(data, function(dataItem) {
      var name2 = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name2)) {
        selected[name2] = true;
      }
      selected[name2] = !selected[name2];
    });
  };
  LegendModel2.prototype.isSelected = function(name2) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name2) && !selected[name2]) && indexOf2(this._availableNames, name2) >= 0;
  };
  LegendModel2.prototype.getOrient = function() {
    return this.get("orient") === "vertical" ? {
      index: 1,
      name: "vertical"
    } : {
      index: 0,
      name: "horizontal"
    };
  };
  LegendModel2.type = "legend.plain";
  LegendModel2.dependencies = ["series"];
  LegendModel2.defaultOption = {
    z: 4,
    show: true,
    orient: "horizontal",
    left: "center",
    top: 0,
    align: "auto",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    symbolRotate: "inherit",
    symbolKeepAspect: true,
    inactiveColor: "#ccc",
    inactiveBorderColor: "#ccc",
    inactiveBorderWidth: "auto",
    itemStyle: {
      color: "inherit",
      opacity: "inherit",
      borderColor: "inherit",
      borderWidth: "auto",
      borderCap: "inherit",
      borderJoin: "inherit",
      borderDashOffset: "inherit",
      borderMiterLimit: "inherit"
    },
    lineStyle: {
      width: "auto",
      color: "inherit",
      inactiveColor: "#ccc",
      inactiveWidth: 2,
      opacity: "inherit",
      type: "inherit",
      cap: "inherit",
      join: "inherit",
      dashOffset: "inherit",
      miterLimit: "inherit"
    },
    textStyle: {
      color: "#333"
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: "sans-serif",
      color: "#666",
      borderWidth: 1,
      borderColor: "#666"
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: "#eee",
        backgroundColor: "#666"
      }
    },
    selectorPosition: "auto",
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel2;
}(ComponentModel$1);
var LegendModel$1 = LegendModel;
var curry = curry$1;
var each$3 = each$f;
var Group$1 = Group$4;
var LegendView = function(_super) {
  __extends$1(LegendView2, _super);
  function LegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendView2.type;
    _this.newlineDisabled = false;
    return _this;
  }
  LegendView2.prototype.init = function() {
    this.group.add(this._contentGroup = new Group$1());
    this.group.add(this._selectorGroup = new Group$1());
    this._isFirstRender = true;
  };
  LegendView2.prototype.getContentGroup = function() {
    return this._contentGroup;
  };
  LegendView2.prototype.getSelectorGroup = function() {
    return this._selectorGroup;
  };
  LegendView2.prototype.render = function(legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    var itemAlign = legendModel.get("align");
    var orient2 = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient2 === "vertical" ? "right" : "left";
    }
    var selector2 = legendModel.get("selector", true);
    var selectorPosition = legendModel.get("selectorPosition", true);
    if (selector2 && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient2 === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api, selector2, orient2, selectorPosition);
    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get("padding");
    var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition);
    var layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  };
  LegendView2.prototype.resetInner = function() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };
  LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector2, orient2, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = createHashMap();
    var selectMode = legendModel.get("selectedMode");
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each$3(legendModel.getData(), function(legendItemModel, dataIndex) {
      var name2 = legendItemModel.get("name");
      if (!this.newlineDisabled && (name2 === "" || name2 === "\n")) {
        var g = new Group$1();
        g.newline = true;
        contentGroup.add(g);
        return;
      }
      var seriesModel = ecModel.getSeriesByName(name2)[0];
      if (legendDrawnMap.get(name2)) {
        return;
      }
      if (seriesModel) {
        var data = seriesModel.getData();
        var lineVisualStyle = data.getVisual("legendLineStyle") || {};
        var legendIcon = data.getVisual("legendIcon");
        var style = data.getVisual("style");
        var itemGroup = this._createItem(seriesModel, name2, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);
        itemGroup.on("click", curry(dispatchSelectAction, name2, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        legendDrawnMap.set(name2, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name2)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            var provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name2)) {
              return;
            }
            var idx = provider.indexOfName(name2);
            var style2 = provider.getItemVisual(idx, "style");
            var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
            var colorArr = parse2(style2.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style2 = extend2(extend2({}, style2), {
                fill: stringify(colorArr, "rgba")
              });
            }
            var itemGroup2 = this._createItem(seriesModel2, name2, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode, api);
            itemGroup2.on("click", curry(dispatchSelectAction, null, name2, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name2, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name2, api, excludeSeriesId));
            legendDrawnMap.set(name2, true);
          }
        }, this);
      }
      {
        if (!legendDrawnMap.get(name2)) {
          console.warn(name2 + " series not exists. Legend data should be same with series name or data name.");
        }
      }
    }, this);
    if (selector2) {
      this._createSelector(selector2, legendModel, api, orient2, selectorPosition);
    }
  };
  LegendView2.prototype._createSelector = function(selector2, legendModel, api, orient2, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each$3(selector2, function createSelectorButton(selectorItem) {
      var type = selectorItem.type;
      var labelText = new ZRText$1({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick: function() {
          api.dispatchAction({
            type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel("selectorLabel");
      var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  };
  LegendView2.prototype._createItem = function(seriesModel, name2, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
    var drawType = seriesModel.visualDrawType;
    var itemWidth = legendModel.get("itemWidth");
    var itemHeight = legendModel.get("itemHeight");
    var isSelected = legendModel.isSelected(name2);
    var iconRotate = legendItemModel.get("symbolRotate");
    var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    var legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
    var itemGroup = new Group$1();
    var textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    var textX = itemAlign === "left" ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get("formatter");
    var content = name2;
    if (isString(formatter) && formatter) {
      content = formatter.replace("{name}", name2 != null ? name2 : "");
    } else if (isFunction(formatter)) {
      content = formatter(name2);
    }
    var inactiveColor = legendItemModel.get("inactiveColor");
    itemGroup.add(new ZRText$1({
      style: createTextStyle(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        align: textAlign,
        verticalAlign: "middle"
      })
    }));
    var hitRect = new Rect$3({
      shape: itemGroup.getBoundingRect(),
      invisible: true
    });
    var tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name2,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };
  LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup();
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector2) {
      box(
        "horizontal",
        selectorGroup,
        legendModel.get("selectorItemGap", true)
      );
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var orientIdx = legendModel.getOrient().index;
      var wh = orientIdx === 0 ? "width" : "height";
      var hw = orientIdx === 0 ? "height" : "width";
      var yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  LegendView2.prototype.remove = function() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };
  LegendView2.type = "legend.plain";
  return LegendView2;
}(ComponentView$1);
function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each$3(style, function(propVal, propName) {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  var itemStyleModel = legendItemModel.getModel("itemStyle");
  var itemStyle = itemStyleModel.getItemStyle();
  var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  var decalStyle = itemStyleModel.getShallow("decal");
  itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  var legendLineModel = legendItemModel.getModel("lineStyle");
  var lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    var borderWidth = legendItemModel.get("inactiveBorderWidth");
    var visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendItemModel.get("inactiveColor");
    itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {
    itemStyle,
    lineStyle
  };
}
function getDefaultLegendIcon(opt) {
  var symboType = opt.icon || "roundRect";
  var icon = createSymbol$1(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = "#fff";
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}
function isUseHoverLayer(api) {
  var list = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i = 0;
  var len2 = list.length;
  while (i < len2 && !(emphasisState = list[i].states.emphasis)) {
    i++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView$1 = LegendView;
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}
function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === "toggleSelected";
  var isSelected;
  ecModel.eachComponent("legend", function(legendModel) {
    if (isToggleSelect && isSelected != null) {
      legendModel[isSelected ? "select" : "unSelect"](payload.name);
    } else if (methodName === "allSelect" || methodName === "inverseSelect") {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }
    var legendData = legendModel.getData();
    each$f(legendData, function(model) {
      var name2 = model.get("name");
      if (name2 === "\n" || name2 === "") {
        return;
      }
      var isItemSelected = legendModel.isSelected(name2);
      if (selectedMap.hasOwnProperty(name2)) {
        selectedMap[name2] = selectedMap[name2] && isItemSelected;
      } else {
        selectedMap[name2] = isItemSelected;
      }
    });
  });
  return methodName === "allSelect" || methodName === "inverseSelect" ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
}
function install$b(registers) {
  registers.registerComponentModel(LegendModel$1);
  registers.registerComponentView(LegendView$1);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}
var ScrollableLegendModel = function(_super) {
  __extends$1(ScrollableLegendModel2, _super);
  function ScrollableLegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendModel2.type;
    return _this;
  }
  ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };
  ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.call(this, option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  };
  ScrollableLegendModel2.type = "legend.scroll";
  ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: "end",
    pageFormatter: "{current}/{total}",
    pageIcons: {
      horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
      vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
    },
    pageIconColor: "#2f4554",
    pageIconInactiveColor: "#aaa",
    pageIconSize: 15,
    pageTextStyle: {
      color: "#333"
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel2;
}(LegendModel$1);
function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient2 = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient2.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel$1 = ScrollableLegendModel;
var Group = Group$4;
var WH = ["width", "height"];
var XY = ["x", "y"];
var ScrollableLegendView = function(_super) {
  __extends$1(ScrollableLegendView2, _super);
  function ScrollableLegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendView2.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }
  ScrollableLegendView2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.group.add(this._containerGroup = new Group());
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group());
  };
  ScrollableLegendView2.prototype.resetInner = function() {
    _super.prototype.resetInner.call(this);
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  };
  ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector2, orient2, selectorPosition) {
    var self2 = this;
    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector2, orient2, selectorPosition);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get("pageIconSize", true);
    var pageIconSizeArr = isArray$1(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    var pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new ZRText$1({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name2, iconIdx) {
      var pageDataIndexName = name2 + "DataIndex";
      var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind$1(self2._pageGo, self2, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name2;
      controllerGroup.add(icon);
    }
  };
  ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector2 && box(
      "horizontal",
      selectorGroup,
      legendModel.get("selectorItemGap", true)
    );
    var selectorButtonGap = legendModel.get("selectorButtonGap", true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = clone$4(maxSize);
    selector2 && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
    if (selector2) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        var offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }
      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  };
  ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box(
      "horizontal",
      controllerGroup,
      legendModel.get("pageButtonItemGap", true)
    );
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      var pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } else {
        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    var mainRect = {
      x: 0,
      y: 0
    };
    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];
    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect$3({
        shape: clipShape
      }));
      containerGroup.__rectSize = clipShape[wh];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    var pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps$1(
      contentGroup,
      {
        x: pageInfo.contentPosition[0],
        y: pageInfo.contentPosition[1]
      },
      showController ? legendModel : null
    );
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  };
  ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];
    scrollDataIndex != null && api.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  };
  ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    each$f(["pagePrev", "pageNext"], function(name2) {
      var key = name2 + "DataIndex";
      var canJump = pageInfo[key] != null;
      var icon = controllerGroup.childOfName(name2);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    var pageText = controllerGroup.childOfName("pageText");
    var pageFormatter = legendModel.get("pageFormatter");
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
      current,
      total
    }));
  };
  ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
    var scrollDataIndex = legendModel.get("scrollDataIndex", true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    var children = contentGroup.children();
    var targetItem = children[targetItemIndex];
    var itemCount = children.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children[i]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children[i]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el) {
      if (el) {
        var itemRect = el.getBoundingRect();
        var start2 = itemRect[xy] + el[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };
  ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    var index2;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      var legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index2 = idx;
      }
    });
    return index2 != null ? index2 : defaultIndex;
  };
  ScrollableLegendView2.type = "legend.scroll";
  return ScrollableLegendView2;
}(LegendView$1);
var ScrollableLegendView$1 = ScrollableLegendView;
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: payload
    }, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}
function install$a(registers) {
  use2(install$b);
  registers.registerComponentModel(ScrollableLegendModel$1);
  registers.registerComponentView(ScrollableLegendView$1);
  installScrollableLegendAction(registers);
}
function install$9(registers) {
  use2(install$b);
  use2(install$a);
}
var InsideZoomModel = function(_super) {
  __extends$1(InsideZoomModel2, _super);
  function InsideZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = InsideZoomModel2.type;
    return _this;
  }
  InsideZoomModel2.type = "dataZoom.inside";
  InsideZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    disabled: false,
    zoomLock: false,
    zoomOnMouseWheel: true,
    moveOnMouseMove: true,
    moveOnMouseWheel: false,
    preventDefaultMouseMove: true
  });
  return InsideZoomModel2;
}(DataZoomModel$1);
var InsideZoomModel$1 = InsideZoomModel;
var inner$1 = makeInner();
function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
  inner$1(api).coordSysRecordMap.each(function(coordSysRecord) {
    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
  var coordSysRecordMap = inner$1(api).coordSysRecordMap;
  var coordSysKeyArr = coordSysRecordMap.keys();
  for (var i = 0; i < coordSysKeyArr.length; i++) {
    var coordSysKey = coordSysKeyArr[i];
    var coordSysRecord = coordSysRecordMap.get(coordSysKey);
    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
    if (dataZoomInfoMap) {
      var dzUid = dataZoomModel.uid;
      var dzInfo = dataZoomInfoMap.get(dzUid);
      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);
        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    var controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}
function createCoordSysRecord(api, coordSysModel) {
  var coordSysRecord = {
    model: coordSysModel,
    containsPoint: curry$1(containsPoint4, coordSysModel),
    dispatchAction: curry$1(dispatchAction, api),
    dataZoomInfoMap: null,
    controller: null
  };
  var controller = coordSysRecord.controller = new RoamController$1(api.getZr());
  each$f(["pan", "zoom", "scrollMove"], function(eventName) {
    controller.on(eventName, function(event) {
      var batch = [];
      coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }
        var method = (dzInfo.getRange || {})[eventName];
        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get("disabled", true) && range && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range[0],
          end: range[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
function dispatchAction(api, batch) {
  if (!api.isDisposed()) {
    api.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch
    });
  }
}
function containsPoint4(coordSysModel, e2, x2, y2) {
  return coordSysModel.coordinateSystem.containPoint([x2, y2]);
}
function mergeControllerParams(dataZoomInfoMap) {
  var controlType;
  var prefix = "type_";
  var typePriority = {
    "type_true": 2,
    "type_move": 1,
    "type_false": 0,
    "type_undefined": -1
  };
  var preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function(dataZoomInfo) {
    var dataZoomModel = dataZoomInfo.model;
    var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    }
    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
  });
  return {
    controlType,
    opt: {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove
    }
  };
}
function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
    var apiInner = inner$1(api);
    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
    coordSysRecordMap.each(function(coordSysRecord) {
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(dataZoomModel) {
      var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
      each$f(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
        var coordSysUid = dzCoordSysInfo.model.uid;
        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    });
    coordSysRecordMap.each(function(coordSysRecord) {
      var controller = coordSysRecord.controller;
      var firstDzInfo;
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        var firstDzKey = dataZoomInfoMap.keys()[0];
        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }
      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }
      var controllerParams = mergeControllerParams(dataZoomInfoMap);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      controller.setPointerChecker(coordSysRecord.containsPoint);
      createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
    });
  });
}
var InsideZoomView = function(_super) {
  __extends$1(InsideZoomView2, _super);
  function InsideZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataZoom.inside";
    return _this;
  }
  InsideZoomView2.prototype.render = function(dataZoomModel, ecModel, api) {
    _super.prototype.render.apply(this, arguments);
    if (dataZoomModel.noTarget()) {
      this._clear();
      return;
    }
    this.range = dataZoomModel.getPercentRange();
    setViewInfoToCoordSysRecord(api, dataZoomModel, {
      pan: bind$1(getRangeHandlers.pan, this),
      zoom: bind$1(getRangeHandlers.zoom, this),
      scrollMove: bind$1(getRangeHandlers.scrollMove, this)
    });
  };
  InsideZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  InsideZoomView2.prototype._clear = function() {
    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  };
  InsideZoomView2.type = "dataZoom.inside";
  return InsideZoomView2;
}(DataZoomView$1);
var getRangeHandlers = {
  zoom: function(coordSysInfo, coordSysMainType, controller, e2) {
    var lastRange = this.range;
    var range = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    var scale4 = Math.max(1 / e2.scale, 0);
    range[0] = (range[0] - percentPoint) * scale4 + percentPoint;
    range[1] = (range[1] - percentPoint) * scale4 + percentPoint;
    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },
  pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    var directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
  })
};
function makeMover(getPercentDelta) {
  return function(coordSysInfo, coordSysMainType, controller, e2) {
    var lastRange = this.range;
    var range = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
    sliderMove(percentDelta, range, [0, 100], "all");
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  };
}
var getDirectionInfo = {
  grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];
    if (axis.dim === "x") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordSysInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);
    if (axisModel.mainType === "radiusAxis") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];
    if (axis.orient === "horizontal") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  }
};
var InsideZoomView$1 = InsideZoomView;
function install$8(registers) {
  installCommon$1(registers);
  registers.registerComponentModel(InsideZoomModel$1);
  registers.registerComponentView(InsideZoomView$1);
  installDataZoomRoamProcessor(registers);
}
var SliderZoomModel = function(_super) {
  __extends$1(SliderZoomModel2, _super);
  function SliderZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomModel2.type;
    return _this;
  }
  SliderZoomModel2.type = "dataZoom.slider";
  SliderZoomModel2.layoutMode = "box";
  SliderZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    show: true,
    right: "ph",
    top: "ph",
    width: "ph",
    height: "ph",
    left: null,
    bottom: null,
    borderColor: "#d2dbee",
    borderRadius: 3,
    backgroundColor: "rgba(47,69,84,0)",
    dataBackground: {
      lineStyle: {
        color: "#d2dbee",
        width: 0.5
      },
      areaStyle: {
        color: "#d2dbee",
        opacity: 0.2
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#8fb0f7",
        width: 0.5
      },
      areaStyle: {
        color: "#8fb0f7",
        opacity: 0.2
      }
    },
    fillerColor: "rgba(135,175,274,0.2)",
    handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
    handleSize: "100%",
    handleStyle: {
      color: "#fff",
      borderColor: "#ACB8D1"
    },
    moveHandleSize: 7,
    moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
    moveHandleStyle: {
      color: "#D2DBEE",
      opacity: 0.7
    },
    showDetail: true,
    showDataShadow: "auto",
    realtime: true,
    zoomLock: false,
    textStyle: {
      color: "#6E7079"
    },
    brushSelect: true,
    brushStyle: {
      color: "rgba(135,175,274,0.15)"
    },
    emphasis: {
      handleStyle: {
        borderColor: "#8FB0F7"
      },
      moveHandleStyle: {
        color: "#8FB0F7"
      }
    }
  });
  return SliderZoomModel2;
}(DataZoomModel$1);
var SliderZoomModel$1 = SliderZoomModel;
var Rect = Rect$3;
var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
var REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
};
var SliderZoomView = function(_super) {
  __extends$1(SliderZoomView2, _super);
  function SliderZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomView2.type;
    _this._displayables = {};
    return _this;
  }
  SliderZoomView2.prototype.init = function(ecModel, api) {
    this.api = api;
    this._onBrush = bind$1(this._onBrush, this);
    this._onBrushEnd = bind$1(this._onBrushEnd, this);
  };
  SliderZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    _super.prototype.render.apply(this, arguments);
    createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
    this._orient = dataZoomModel.getOrient();
    if (dataZoomModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    if (dataZoomModel.noTarget()) {
      this._clear();
      this.group.removeAll();
      return;
    }
    if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
      this._buildView();
    }
    this._updateView();
  };
  SliderZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  SliderZoomView2.prototype._clear = function() {
    clear$1(this, "_dispatchZoomAction");
    var zr = this.api.getZr();
    zr.off("mousemove", this._onBrush);
    zr.off("mouseup", this._onBrushEnd);
  };
  SliderZoomView2.prototype._buildView = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;
    this._resetLocation();
    this._resetInterval();
    var barGroup = this._displayables.sliderGroup = new Group$4();
    this._renderBackground();
    this._renderHandle();
    this._renderDataShadow();
    thisGroup.add(barGroup);
    this._positionGroup();
  };
  SliderZoomView2.prototype._resetLocation = function() {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var showMoveHandle = dataZoomModel.get("brushSelect");
    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
    var coordRect = this._findCoordRect();
    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var positionInfo = this._orient === HORIZONTAL ? {
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    };
    var layoutParams = getLayoutParams(dataZoomModel.option);
    each$f(["right", "top", "width", "height"], function(name2) {
      if (layoutParams[name2] === "ph") {
        layoutParams[name2] = positionInfo[name2];
      }
    });
    var layoutRect = getLayoutRect(layoutParams, ecSize);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  };
  SliderZoomView2.prototype._positionGroup = function() {
    var thisGroup = this.group;
    var location = this._location;
    var orient2 = this._orient;
    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get("inverse");
    var sliderGroup = this._displayables.sliderGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
    sliderGroup.attr(orient2 === HORIZONTAL && !inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: 1
    } : orient2 === HORIZONTAL && inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: -1
    } : orient2 === VERTICAL && !inverse ? {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: 1,
      rotation: Math.PI / 2
    } : {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: -1,
      rotation: Math.PI / 2
    });
    var rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location.x - rect.x;
    thisGroup.y = location.y - rect.y;
    thisGroup.markRedraw();
  };
  SliderZoomView2.prototype._getViewExtent = function() {
    return [0, this._size[0]];
  };
  SliderZoomView2.prototype._renderBackground = function() {
    var dataZoomModel = this.dataZoomModel;
    var size11 = this._size;
    var barGroup = this._displayables.sliderGroup;
    var brushSelect = dataZoomModel.get("brushSelect");
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size11[0],
        height: size11[1]
      },
      style: {
        fill: dataZoomModel.get("backgroundColor")
      },
      z2: -40
    }));
    var clickPanel = new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size11[0],
        height: size11[1]
      },
      style: {
        fill: "transparent"
      },
      z2: 0,
      onclick: bind$1(this._onClickPanel, this)
    });
    var zr = this.api.getZr();
    if (brushSelect) {
      clickPanel.on("mousedown", this._onBrushStart, this);
      clickPanel.cursor = "crosshair";
      zr.on("mousemove", this._onBrush);
      zr.on("mouseup", this._onBrushEnd);
    } else {
      zr.off("mousemove", this._onBrush);
      zr.off("mouseup", this._onBrushEnd);
    }
    barGroup.add(clickPanel);
  };
  SliderZoomView2.prototype._renderDataShadow = function() {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();
    this._displayables.dataShadowSegs = [];
    if (!info) {
      return;
    }
    var size11 = this._size;
    var oldSize = this._shadowSize || [];
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var candlestickDim = seriesModel.getShadowDim && seriesModel.getShadowDim();
    var otherDim = candlestickDim && data.getDimensionInfo(candlestickDim) ? seriesModel.getShadowDim() : info.otherDim;
    if (otherDim == null) {
      return;
    }
    var polygonPts = this._shadowPolygonPts;
    var polylinePts = this._shadowPolylinePts;
    if (data !== this._shadowData || otherDim !== this._shadowDim || size11[0] !== oldSize[0] || size11[1] !== oldSize[1]) {
      var otherDataExtent_1 = data.getDataExtent(otherDim);
      var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;
      otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
      var otherShadowExtent_1 = [0, size11[1]];
      var thisShadowExtent = [0, size11[0]];
      var areaPoints_1 = [[size11[0], 0], [0, 0]];
      var linePoints_1 = [];
      var step_1 = thisShadowExtent[1] / (data.count() - 1);
      var thisCoord_1 = 0;
      var stride_1 = Math.round(data.count() / size11[0]);
      var lastIsEmpty_1;
      data.each([otherDim], function(value, index2) {
        if (stride_1 > 0 && index2 % stride_1) {
          thisCoord_1 += step_1;
          return;
        }
        var isEmpty6 = value == null || isNaN(value) || value === "";
        var otherCoord = isEmpty6 ? 0 : linearMap$2(value, otherDataExtent_1, otherShadowExtent_1, true);
        if (isEmpty6 && !lastIsEmpty_1 && index2) {
          areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
          linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
        } else if (!isEmpty6 && lastIsEmpty_1) {
          areaPoints_1.push([thisCoord_1, 0]);
          linePoints_1.push([thisCoord_1, 0]);
        }
        areaPoints_1.push([thisCoord_1, otherCoord]);
        linePoints_1.push([thisCoord_1, otherCoord]);
        thisCoord_1 += step_1;
        lastIsEmpty_1 = isEmpty6;
      });
      polygonPts = this._shadowPolygonPts = areaPoints_1;
      polylinePts = this._shadowPolylinePts = linePoints_1;
    }
    this._shadowData = data;
    this._shadowDim = otherDim;
    this._shadowSize = [size11[0], size11[1]];
    var dataZoomModel = this.dataZoomModel;
    function createDataShadowGroup(isSelectedArea) {
      var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
      var group2 = new Group$4();
      var polygon4 = new Polygon$1({
        shape: {
          points: polygonPts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("areaStyle").getAreaStyle(),
        silent: true,
        z2: -20
      });
      var polyline = new Polyline$3({
        shape: {
          points: polylinePts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      });
      group2.add(polygon4);
      group2.add(polyline);
      return group2;
    }
    for (var i = 0; i < 3; i++) {
      var group = createDataShadowGroup(i === 1);
      this._displayables.sliderGroup.add(group);
      this._displayables.dataShadowSegs.push(group);
    }
  };
  SliderZoomView2.prototype._prepareDataShadowInfo = function() {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get("showDataShadow");
    if (showDataShadow === false) {
      return;
    }
    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      each$f(seriesModels, function(seriesModel) {
        if (result) {
          return;
        }
        if (showDataShadow !== true && indexOf2(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
          return;
        }
        var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
        var otherDim = getOtherDim(axisDim);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;
        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }
        otherDim = seriesModel.getData().mapDimension(otherDim);
        result = {
          thisAxis,
          series: seriesModel,
          thisDim: axisDim,
          otherDim,
          otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  };
  SliderZoomView2.prototype._renderHandle = function() {
    var thisGroup = this.group;
    var displayables = this._displayables;
    var handles = displayables.handles = [null, null];
    var handleLabels = displayables.handleLabels = [null, null];
    var sliderGroup = this._displayables.sliderGroup;
    var size11 = this._size;
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var borderRadius = dataZoomModel.get("borderRadius") || 0;
    var brushSelect = dataZoomModel.get("brushSelect");
    var filler = displayables.filler = new Rect({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get("fillerColor")
      },
      textConfig: {
        position: "inside"
      }
    });
    sliderGroup.add(filler);
    sliderGroup.add(new Rect({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size11[0],
        height: size11[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: "rgba(0,0,0,0)"
      }
    }));
    each$f([0, 1], function(handleIndex) {
      var iconStr = dataZoomModel.get("handleIcon");
      if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
        iconStr = "path://" + iconStr;
        {
          deprecateLog("handleIcon now needs 'path://' prefix when using a path string");
        }
      }
      var path = createSymbol$1(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor$1(this._orient),
        draggable: true,
        drift: bind$1(this._onDragMove, this, handleIndex),
        ondragend: bind$1(this._onDragEnd, this),
        onmouseover: bind$1(this._showDataInfo, this, true),
        onmouseout: bind$1(this._showDataInfo, this, false),
        z2: 5
      });
      var bRect = path.getBoundingRect();
      var handleSize = dataZoomModel.get("handleSize");
      this._handleHeight = parsePercent(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      enableHoverEmphasis(path);
      var handleColor = dataZoomModel.get("handleColor");
      if (handleColor != null) {
        path.style.fill = handleColor;
      }
      sliderGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.getModel("textStyle");
      thisGroup.add(handleLabels[handleIndex] = new ZRText$1({
        silent: true,
        invisible: true,
        style: createTextStyle(textStyleModel, {
          x: 0,
          y: 0,
          text: "",
          verticalAlign: "middle",
          align: "center",
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        }),
        z2: 10
      }));
    }, this);
    var actualMoveZone = filler;
    if (brushSelect) {
      var moveHandleHeight = parsePercent(dataZoomModel.get("moveHandleSize"), size11[1]);
      var moveHandle_1 = displayables.moveHandle = new Rect$3({
        style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size11[1] - 0.5,
          height: moveHandleHeight
        }
      });
      var iconSize = moveHandleHeight * 0.8;
      var moveHandleIcon = displayables.moveHandleIcon = createSymbol$1(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, "#fff", true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size11[1] + moveHandleHeight / 2 - 0.5;
      moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
      var moveZoneExpandSize = Math.min(size11[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new Rect$3({
        invisible: true,
        shape: {
          y: size11[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on("mouseover", function() {
        api.enterEmphasis(moveHandle_1);
      }).on("mouseout", function() {
        api.leaveEmphasis(moveHandle_1);
      });
      sliderGroup.add(moveHandle_1);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }
    actualMoveZone.attr({
      draggable: true,
      cursor: getCursor$1(this._orient),
      drift: bind$1(this._onDragMove, this, "all"),
      ondragstart: bind$1(this._showDataInfo, this, true),
      ondragend: bind$1(this._onDragEnd, this),
      onmouseover: bind$1(this._showDataInfo, this, true),
      onmouseout: bind$1(this._showDataInfo, this, false)
    });
  };
  SliderZoomView2.prototype._resetInterval = function() {
    var range = this._range = this.dataZoomModel.getPercentRange();
    var viewExtent = this._getViewExtent();
    this._handleEnds = [linearMap$2(range[0], [0, 100], viewExtent, true), linearMap$2(range[1], [0, 100], viewExtent, true)];
  };
  SliderZoomView2.prototype._updateInterval = function(handleIndex, delta2) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;
    var viewExtend = this._getViewExtent();
    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta2, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap$2(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap$2(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    var lastRange = this._range;
    var range = this._range = asc$2([linearMap$2(handleEnds[0], viewExtend, percentExtent, true), linearMap$2(handleEnds[1], viewExtend, percentExtent, true)]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  };
  SliderZoomView2.prototype._updateView = function(nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc$2(handleEnds.slice());
    var size11 = this._size;
    each$f([0, 1], function(handleIndex) {
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size11[1] / 2 - handleHeight / 2
      });
    }, this);
    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size11[1]
    });
    var viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    };
    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent);
      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
    }
    var dataShadowSegs = displaybles.dataShadowSegs;
    var segIntervals = [0, handleInterval[0], handleInterval[1], size11[0]];
    for (var i = 0; i < dataShadowSegs.length; i++) {
      var segGroup = dataShadowSegs[i];
      var clipPath = segGroup.getClipPath();
      if (!clipPath) {
        clipPath = new Rect$3();
        segGroup.setClipPath(clipPath);
      }
      clipPath.setShape({
        x: segIntervals[i],
        y: 0,
        width: segIntervals[i + 1] - segIntervals[i],
        height: size11[1]
      });
    }
    this._updateDataInfo(nonRealtime);
  };
  SliderZoomView2.prototype._updateDataInfo = function(nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient2 = this._orient;
    var labelTexts = ["", ""];
    if (dataZoomModel.get("showDetail")) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }
    var orderedHandleEnds = asc$2(this._handleEnds.slice());
    setLabel2.call(this, 0);
    setLabel2.call(this, 1);
    function setLabel2(handleIndex) {
      var barTransform = getTransform$1(displaybles.handles[handleIndex].parent, this.group);
      var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
      var offset = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient2 === HORIZONTAL ? "middle" : direction,
        align: orient2 === HORIZONTAL ? direction : "center",
        text: labelTexts[handleIndex]
      });
    }
  };
  SliderZoomView2.prototype._formatLabel = function(value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get("labelFormatter");
    var labelPrecision = dataZoomModel.get("labelPrecision");
    if (labelPrecision == null || labelPrecision === "auto") {
      labelPrecision = axis.getPixelPrecision();
    }
    var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
      value: Math.round(value)
    }) : value.toFixed(Math.min(labelPrecision, 20));
    return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
  };
  SliderZoomView2.prototype._showDataInfo = function(showOrHide) {
    showOrHide = this._dragging || showOrHide;
    var displayables = this._displayables;
    var handleLabels = displayables.handleLabels;
    handleLabels[0].attr("invisible", !showOrHide);
    handleLabels[1].attr("invisible", !showOrHide);
    displayables.moveHandle && this.api[showOrHide ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
  };
  SliderZoomView2.prototype._onDragMove = function(handleIndex, dx, dy, event) {
    this._dragging = true;
    stop(event.event);
    var barTransform = this._displayables.sliderGroup.getLocalTransform();
    var vertex = applyTransform([dx, dy], barTransform, true);
    var changed = this._updateInterval(handleIndex, vertex[0]);
    var realtime = this.dataZoomModel.get("realtime");
    this._updateView(!realtime);
    changed && realtime && this._dispatchZoomAction(true);
  };
  SliderZoomView2.prototype._onDragEnd = function() {
    this._dragging = false;
    this._showDataInfo(false);
    var realtime = this.dataZoomModel.get("realtime");
    !realtime && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onClickPanel = function(e2) {
    var size11 = this._size;
    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
    if (localPoint[0] < 0 || localPoint[0] > size11[0] || localPoint[1] < 0 || localPoint[1] > size11[1]) {
      return;
    }
    var handleEnds = this._handleEnds;
    var center2 = (handleEnds[0] + handleEnds[1]) / 2;
    var changed = this._updateInterval("all", localPoint[0] - center2);
    this._updateView();
    changed && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrushStart = function(e2) {
    var x2 = e2.offsetX;
    var y2 = e2.offsetY;
    this._brushStart = new Point$1(x2, y2);
    this._brushing = true;
    this._brushStartTime = +new Date();
  };
  SliderZoomView2.prototype._onBrushEnd = function(e2) {
    if (!this._brushing) {
      return;
    }
    var brushRect = this._displayables.brushRect;
    this._brushing = false;
    if (!brushRect) {
      return;
    }
    brushRect.attr("ignore", true);
    var brushShape = brushRect.shape;
    var brushEndTime = +new Date();
    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      return;
    }
    var viewExtend = this._getViewExtent();
    var percentExtent = [0, 100];
    this._range = asc$2([linearMap$2(brushShape.x, viewExtend, percentExtent, true), linearMap$2(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
    this._updateView();
    this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrush = function(e2) {
    if (this._brushing) {
      stop(e2.event);
      this._updateBrushRect(e2.offsetX, e2.offsetY);
    }
  };
  SliderZoomView2.prototype._updateBrushRect = function(mouseX, mouseY) {
    var displayables = this._displayables;
    var dataZoomModel = this.dataZoomModel;
    var brushRect = displayables.brushRect;
    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect({
        silent: true,
        style: dataZoomModel.getModel("brushStyle").getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }
    brushRect.attr("ignore", false);
    var brushStart = this._brushStart;
    var sliderGroup = this._displayables.sliderGroup;
    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    var size11 = this._size;
    endPoint[0] = Math.max(Math.min(size11[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size11[1]
    });
  };
  SliderZoomView2.prototype._dispatchZoomAction = function(realtime) {
    var range = this._range;
    this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range[0],
      end: range[1]
    });
  };
  SliderZoomView2.prototype._findCoordRect = function() {
    var rect;
    var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
    if (!rect && coordSysInfoList.length) {
      var coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }
    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }
    return rect;
  };
  SliderZoomView2.type = "dataZoom.slider";
  return SliderZoomView2;
}(DataZoomView$1);
function getOtherDim(thisDim) {
  var map5 = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return map5[thisDim];
}
function getCursor$1(orient2) {
  return orient2 === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView$1 = SliderZoomView;
function install$7(registers) {
  registers.registerComponentModel(SliderZoomModel$1);
  registers.registerComponentView(SliderZoomView$1);
  installCommon$1(registers);
}
function install$6(registers) {
  use2(install$8);
  use2(install$7);
}
var visualDefault = {
  get: function(visualType, key, isCategory2) {
    var value = clone$4((defaultOption[visualType] || {})[key]);
    return isCategory2 ? isArray$1(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
var visualDefault$1 = visualDefault;
var mapVisual = VisualMapping$1.mapVisual;
var eachVisual = VisualMapping$1.eachVisual;
var isArray = isArray$1;
var each$2 = each$f;
var asc = asc$2;
var linearMap$1 = linearMap$2;
var VisualMapModel = function(_super) {
  __extends$1(VisualMapModel2, _super);
  function VisualMapModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = VisualMapModel2.type;
    _this.stateList = ["inRange", "outOfRange"];
    _this.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"];
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    _this.dataBound = [-Infinity, Infinity];
    _this.targetVisuals = {};
    _this.controllerVisuals = {};
    return _this;
  }
  VisualMapModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  VisualMapModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel("textStyle");
    this.resetItemSize();
    this.completeVisualOption();
  };
  VisualMapModel2.prototype.resetVisual = function(supplementVisualOption) {
    var stateList = this.stateList;
    supplementVisualOption = bind$1(supplementVisualOption, this);
    this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
  };
  VisualMapModel2.prototype.getItemSymbol = function() {
    return null;
  };
  VisualMapModel2.prototype.getTargetSeriesIndices = function() {
    var optionSeriesIndex = this.option.seriesIndex;
    var seriesIndices = [];
    if (optionSeriesIndex == null || optionSeriesIndex === "all") {
      this.ecModel.eachSeries(function(seriesModel, index2) {
        seriesIndices.push(index2);
      });
    } else {
      seriesIndices = normalizeToArray(optionSeriesIndex);
    }
    return seriesIndices;
  };
  VisualMapModel2.prototype.eachTargetSeries = function(callback, context) {
    each$f(this.getTargetSeriesIndices(), function(seriesIndex) {
      var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  };
  VisualMapModel2.prototype.isTargetSeries = function(seriesModel) {
    var is3 = false;
    this.eachTargetSeries(function(model) {
      model === seriesModel && (is3 = true);
    });
    return is3;
  };
  VisualMapModel2.prototype.formatValueText = function(value, isCategory2, edgeSymbols) {
    var option = this.option;
    var precision = option.precision;
    var dataBound = this.dataBound;
    var formatter = option.formatter;
    var isMinMax;
    edgeSymbols = edgeSymbols || ["<", ">"];
    if (isArray$1(value)) {
      value = value.slice();
      isMinMax = true;
    }
    var textValue = isCategory2 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
    if (isString(formatter)) {
      return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
    } else if (isFunction(formatter)) {
      return isMinMax ? formatter(value[0], value[1]) : formatter(value);
    }
    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + " " + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + " " + textValue[0];
      } else {
        return textValue[0] + " - " + textValue[1];
      }
    } else {
      return textValue;
    }
    function toFixed(val) {
      return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
    }
  };
  VisualMapModel2.prototype.resetExtent = function() {
    var thisOption = this.option;
    var extent3 = asc([thisOption.min, thisOption.max]);
    this._dataExtent = extent3;
  };
  VisualMapModel2.prototype.getDataDimensionIndex = function(data) {
    var optDim = this.option.dimension;
    if (optDim != null) {
      return data.getDimensionIndex(optDim);
    }
    var dimNames = data.dimensions;
    for (var i = dimNames.length - 1; i >= 0; i--) {
      var dimName = dimNames[i];
      var dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isCalculationCoord) {
        return dimInfo.storeDimIndex;
      }
    }
  };
  VisualMapModel2.prototype.getExtent = function() {
    return this._dataExtent.slice();
  };
  VisualMapModel2.prototype.completeVisualOption = function() {
    var ecModel = this.ecModel;
    var thisOption = this.option;
    var base2 = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    var target = thisOption.target || (thisOption.target = {});
    var controller = thisOption.controller || (thisOption.controller = {});
    merge3(target, base2);
    merge3(controller, base2);
    var isCategory2 = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, "inRange", "outOfRange");
    completeController.call(this, controller);
    function completeSingle(base3) {
      if (isArray(thisOption.color) && !base3.inRange) {
        base3.inRange = {
          color: thisOption.color.slice().reverse()
        };
      }
      base3.inRange = base3.inRange || {
        color: ecModel.get("gradientColor")
      };
    }
    function completeInactive(base3, stateExist, stateAbsent) {
      var optExist = base3[stateExist];
      var optAbsent = base3[stateAbsent];
      if (optExist && !optAbsent) {
        optAbsent = base3[stateAbsent] = {};
        each$2(optExist, function(visualData, visualType) {
          if (!VisualMapping$1.isValidType(visualType)) {
            return;
          }
          var defa = visualDefault$1.get(visualType, "inactive", isCategory2);
          if (defa != null) {
            optAbsent[visualType] = defa;
            if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }
    function completeController(controller2) {
      var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
      var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
      var inactiveColor = this.get("inactiveColor");
      var itemSymbol = this.getItemSymbol();
      var defaultSymbol = itemSymbol || "roundRect";
      each$2(this.stateList, function(state) {
        var itemSize = this.itemSize;
        var visuals = controller2[state];
        if (!visuals) {
          visuals = controller2[state] = {
            color: isCategory2 ? inactiveColor : [inactiveColor]
          };
        }
        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && clone$4(symbolExists) || (isCategory2 ? defaultSymbol : [defaultSymbol]);
        }
        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && clone$4(symbolSizeExists) || (isCategory2 ? itemSize[0] : [itemSize[0], itemSize[0]]);
        }
        visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
          return symbol === "none" ? defaultSymbol : symbol;
        });
        var symbolSize = visuals.symbolSize;
        if (symbolSize != null) {
          var max_1 = -Infinity;
          eachVisual(symbolSize, function(value) {
            value > max_1 && (max_1 = value);
          });
          visuals.symbolSize = mapVisual(symbolSize, function(value) {
            return linearMap$1(value, [0, max_1], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  };
  VisualMapModel2.prototype.resetItemSize = function() {
    this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
  };
  VisualMapModel2.prototype.isCategory = function() {
    return !!this.option.categories;
  };
  VisualMapModel2.prototype.setSelected = function(selected) {
  };
  VisualMapModel2.prototype.getSelected = function() {
    return null;
  };
  VisualMapModel2.prototype.getValueState = function(value) {
    return null;
  };
  VisualMapModel2.prototype.getVisualMeta = function(getColorVisual2) {
    return null;
  };
  VisualMapModel2.type = "visualMap";
  VisualMapModel2.dependencies = ["series"];
  VisualMapModel2.defaultOption = {
    show: true,
    z: 4,
    seriesIndex: "all",
    min: 0,
    max: 200,
    left: 0,
    right: null,
    top: null,
    bottom: 0,
    itemWidth: null,
    itemHeight: null,
    inverse: false,
    orient: "vertical",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    contentColor: "#5793f3",
    inactiveColor: "#aaa",
    borderWidth: 0,
    padding: 5,
    textGap: 10,
    precision: 0,
    textStyle: {
      color: "#333"
    }
  };
  return VisualMapModel2;
}(ComponentModel$1);
var VisualMapModel$1 = VisualMapModel;
var DEFAULT_BAR_BOUND = [20, 140];
var ContinuousModel = function(_super) {
  __extends$1(ContinuousModel2, _super);
  function ContinuousModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ContinuousModel2.type;
    return _this;
  }
  ContinuousModel2.prototype.optionUpdated = function(newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);
    this.resetExtent();
    this.resetVisual(function(mappingOption) {
      mappingOption.mappingMethod = "linear";
      mappingOption.dataExtent = this.getExtent();
    });
    this._resetRange();
  };
  ContinuousModel2.prototype.resetItemSize = function() {
    _super.prototype.resetItemSize.apply(this, arguments);
    var itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  };
  ContinuousModel2.prototype._resetRange = function() {
    var dataExtent = this.getExtent();
    var range = this.option.range;
    if (!range || range.auto) {
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (isArray$1(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }
      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  };
  ContinuousModel2.prototype.completeVisualOption = function() {
    _super.prototype.completeVisualOption.apply(this, arguments);
    each$f(this.stateList, function(state) {
      var symbolSize = this.option.controller[state].symbolSize;
      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3;
      }
    }, this);
  };
  ContinuousModel2.prototype.setSelected = function(selected) {
    this.option.range = selected.slice();
    this._resetRange();
  };
  ContinuousModel2.prototype.getSelected = function() {
    var dataExtent = this.getExtent();
    var dataInterval = asc$2((this.get("range") || []).slice());
    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  };
  ContinuousModel2.prototype.getValueState = function(value) {
    var range = this.option.range;
    var dataExtent = this.getExtent();
    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
  };
  ContinuousModel2.prototype.findTargetDataIndices = function(range) {
    var result = [];
    this.eachTargetSeries(function(seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  ContinuousModel2.prototype.getVisualMeta = function(getColorVisual2) {
    var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
    var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
    var stops = [];
    function setStop(value, valueState) {
      stops.push({
        value,
        color: getColorVisual2(value, valueState)
      });
    }
    var iIdx = 0;
    var oIdx = 0;
    var iLen = iVals.length;
    var oLen = oVals.length;
    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
      first && stops.length && setStop(iVals[iIdx], "outOfRange");
      setStop(iVals[iIdx], "inRange");
    }
    for (var first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
          first = 0;
        }
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    var stopsLen = stops.length;
    return {
      stops,
      outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
    };
  };
  ContinuousModel2.type = "visualMap.continuous";
  ContinuousModel2.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    align: "auto",
    calculable: false,
    hoverLink: true,
    realtime: true,
    handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
    handleSize: "120%",
    handleStyle: {
      borderColor: "#fff",
      borderWidth: 1
    },
    indicatorIcon: "circle",
    indicatorSize: "50%",
    indicatorStyle: {
      borderColor: "#fff",
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0,0,0,0.2)"
    }
  });
  return ContinuousModel2;
}(VisualMapModel$1);
function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  }
  var count3 = 200;
  var step = (dataExtent[1] - dataExtent[0]) / count3;
  var value = dataExtent[0];
  var stopValues = [];
  for (var i = 0; i <= count3 && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }
  stopValues.push(dataExtent[1]);
  return stopValues;
}
var ContinuousModel$1 = ContinuousModel;
var VisualMapView = function(_super) {
  __extends$1(VisualMapView2, _super);
  function VisualMapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = VisualMapView2.type;
    _this.autoPositionValues = {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    };
    return _this;
  }
  VisualMapView2.prototype.init = function(ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
  };
  VisualMapView2.prototype.render = function(visualMapModel, ecModel, api, payload) {
    this.visualMapModel = visualMapModel;
    if (visualMapModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    this.doRender(visualMapModel, ecModel, api, payload);
  };
  VisualMapView2.prototype.renderBackground = function(group) {
    var visualMapModel = this.visualMapModel;
    var padding = normalizeCssArray(visualMapModel.get("padding") || 0);
    var rect = group.getBoundingRect();
    group.add(new Rect$3({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get("backgroundColor"),
        stroke: visualMapModel.get("borderColor"),
        lineWidth: visualMapModel.get("borderWidth")
      }
    }));
  };
  VisualMapView2.prototype.getControllerVisual = function(targetValue, visualCluster, opts) {
    opts = opts || {};
    var forceState = opts.forceState;
    var visualMapModel = this.visualMapModel;
    var visualObj = {};
    if (visualCluster === "color") {
      var defaultColor = visualMapModel.get("contentColor");
      visualObj.color = defaultColor;
    }
    function getter(key) {
      return visualObj[key];
    }
    function setter(key, value) {
      visualObj[key] = value;
    }
    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
    each$f(visualTypes, function(type) {
      var visualMapping = mappings[type];
      if (opts.convertOpacityToAlpha && type === "opacity") {
        type = "colorAlpha";
        visualMapping = mappings.__alphaForOpacity;
      }
      if (VisualMapping$1.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  };
  VisualMapView2.prototype.positionGroup = function(group) {
    var model = this.visualMapModel;
    var api = this.api;
    positionElement(group, model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  VisualMapView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
  };
  VisualMapView2.type = "visualMap";
  return VisualMapView2;
}(ComponentView$1);
var VisualMapView$1 = VisualMapView;
var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
function getItemAlign(visualMapModel, api, itemSize) {
  var modelOption = visualMapModel.option;
  var itemAlign = modelOption.align;
  if (itemAlign != null && itemAlign !== "auto") {
    return itemAlign;
  }
  var ecSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
  var reals = paramsSet[realIndex];
  var fakeValue = [0, null, 10];
  var layoutInput = {};
  for (var i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }
  var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
  var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(batch, visualMapModel) {
  each$f(batch || [], function(batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }
    batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
  });
  return batch;
}
var linearMap = linearMap$2;
var each$1 = each$f;
var mathMin = Math.min;
var mathMax = Math.max;
var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6;
var ContinuousView = function(_super) {
  __extends$1(ContinuousView2, _super);
  function ContinuousView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ContinuousView2.type;
    _this._shapes = {};
    _this._dataInterval = [];
    _this._handleEnds = [];
    _this._hoverLinkDataIndices = [];
    return _this;
  }
  ContinuousView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
    this._api = api;
    if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
      this._buildView();
    }
  };
  ContinuousView2.prototype._buildView = function() {
    this.group.removeAll();
    var visualMapModel = this.visualMapModel;
    var thisGroup = this.group;
    this._orient = visualMapModel.get("orient");
    this._useHandle = visualMapModel.get("calculable");
    this._resetInterval();
    this._renderBar(thisGroup);
    var dataRangeText = visualMapModel.get("text");
    this._renderEndsText(thisGroup, dataRangeText, 0);
    this._renderEndsText(thisGroup, dataRangeText, 1);
    this._updateView(true);
    this.renderBackground(thisGroup);
    this._updateView();
    this._enableHoverLinkToSeries();
    this._enableHoverLinkFromSeries();
    this.positionGroup(thisGroup);
  };
  ContinuousView2.prototype._renderEndsText = function(group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    }
    var text = dataRangeText[1 - endsIndex];
    text = text != null ? text + "" : "";
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get("textGap");
    var itemSize = visualMapModel.itemSize;
    var barGroup = this._shapes.mainGroup;
    var position2 = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
    var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
    var orient2 = this._orient;
    var textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new ZRText$1({
      style: createTextStyle(textStyleModel, {
        x: position2[0],
        y: position2[1],
        verticalAlign: orient2 === "horizontal" ? "middle" : align,
        align: orient2 === "horizontal" ? align : "center",
        text
      })
    }));
  };
  ContinuousView2.prototype._renderBar = function(targetGroup) {
    var visualMapModel = this.visualMapModel;
    var shapes = this._shapes;
    var itemSize = visualMapModel.itemSize;
    var orient2 = this._orient;
    var useHandle = this._useHandle;
    var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
    var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
    var gradientBarGroup = new Group$4();
    mainGroup.add(gradientBarGroup);
    gradientBarGroup.add(shapes.outOfRange = createPolygon2());
    gradientBarGroup.add(shapes.inRange = createPolygon2(null, useHandle ? getCursor(this._orient) : null, bind$1(this._dragHandle, this, "all", false), bind$1(this._dragHandle, this, "all", true)));
    gradientBarGroup.setClipPath(new Rect$3({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    var textRect = visualMapModel.textStyleModel.getTextRect("\u56FD");
    var textSize = mathMax(textRect.width, textRect.height);
    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];
      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient2);
      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient2);
    }
    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient2);
    targetGroup.add(mainGroup);
  };
  ContinuousView2.prototype._createHandle = function(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient2) {
    var onDrift = bind$1(this._dragHandle, this, handleIndex, false);
    var onDragEnd = bind$1(this._dragHandle, this, handleIndex, true);
    var handleSize = parsePercent$1(visualMapModel.get("handleSize"), itemSize[0]);
    var handleThumb = createSymbol$1(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    var cursor = getCursor(this._orient);
    handleThumb.attr({
      cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove: function(e2) {
        stop(e2.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
    setAsHighDownDispatcher(handleThumb, true);
    mainGroup.add(handleThumb);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var handleLabel = new ZRText$1({
      cursor,
      draggable: true,
      drift: onDrift,
      onmousemove: function(e2) {
        stop(e2.event);
      },
      ondragend: onDragEnd,
      style: createTextStyle(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    handleLabel.ensureState("blur").style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {
      duration: 200
    };
    this.group.add(handleLabel);
    var handleLabelPoint = [handleSize, 0];
    var shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  };
  ContinuousView2.prototype._createIndicator = function(visualMapModel, mainGroup, itemSize, textSize, orient2) {
    var scale4 = parsePercent$1(visualMapModel.get("indicatorSize"), itemSize[0]);
    var indicator = createSymbol$1(visualMapModel.get("indicatorIcon"), -scale4 / 2, -scale4 / 2, scale4, scale4, null, true);
    indicator.attr({
      cursor: "move",
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    var indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
    if (indicator instanceof ZRImage$1) {
      var pathStyle = indicator.style;
      indicator.useStyle(extend2({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }
    mainGroup.add(indicator);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var indicatorLabel = new ZRText$1({
      silent: true,
      invisible: true,
      style: createTextStyle(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    this.group.add(indicatorLabel);
    var indicatorLabelPoint = [(orient2 === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
    var shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  };
  ContinuousView2.prototype._dragHandle = function(handleIndex, isEnd, dx, dy) {
    if (!this._useHandle) {
      return;
    }
    this._dragging = !isEnd;
    if (!isEnd) {
      var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
      this._updateInterval(handleIndex, vertex[1]);
      this._hideIndicator();
      this._updateView();
    }
    if (isEnd === !this.visualMapModel.get("realtime")) {
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }
    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  };
  ContinuousView2.prototype._resetInterval = function() {
    var visualMapModel = this.visualMapModel;
    var dataInterval = this._dataInterval = visualMapModel.getSelected();
    var dataExtent = visualMapModel.getExtent();
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
  };
  ContinuousView2.prototype._updateInterval = function(handleIndex, delta2) {
    delta2 = delta2 || 0;
    var visualMapModel = this.visualMapModel;
    var handleEnds = this._handleEnds;
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    sliderMove(
      delta2,
      handleEnds,
      sizeExtent,
      handleIndex,
      0
    );
    var dataExtent = visualMapModel.getExtent();
    this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
  };
  ContinuousView2.prototype._updateView = function(forSketch) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var shapes = this._shapes;
    var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
    var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
    shapes.inRange.setStyle({
      fill: visualInRange.barColor
    }).setShape("points", visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor
    }).setShape("points", visualOutOfRange.barPoints);
    this._updateHandle(inRangeHandleEnds, visualInRange);
  };
  ContinuousView2.prototype._createBarVisual = function(dataInterval, dataExtent, handleEnds, forceState) {
    var opts = {
      forceState,
      convertOpacityToAlpha: true
    };
    var colorStops = this._makeColorGradient(dataInterval, opts);
    var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
    var barPoints = this._createBarPoints(handleEnds, symbolSizes);
    return {
      barColor: new LinearGradient$1(0, 0, 0, 1, colorStops),
      barPoints,
      handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
    };
  };
  ContinuousView2.prototype._makeColorGradient = function(dataInterval, opts) {
    var sampleNumber = 100;
    var colorStops = [];
    var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], "color", opts),
      offset: 0
    });
    for (var i = 1; i < sampleNumber; i++) {
      var currValue = dataInterval[0] + step * i;
      if (currValue > dataInterval[1]) {
        break;
      }
      colorStops.push({
        color: this.getControllerVisual(currValue, "color", opts),
        offset: i / sampleNumber
      });
    }
    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], "color", opts),
      offset: 1
    });
    return colorStops;
  };
  ContinuousView2.prototype._createBarPoints = function(handleEnds, symbolSizes) {
    var itemSize = this.visualMapModel.itemSize;
    return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
  };
  ContinuousView2.prototype._createBarGroup = function(itemAlign) {
    var orient2 = this._orient;
    var inverse = this.visualMapModel.get("inverse");
    return new Group$4(orient2 === "horizontal" && !inverse ? {
      scaleX: itemAlign === "bottom" ? 1 : -1,
      rotation: Math.PI / 2
    } : orient2 === "horizontal" && inverse ? {
      scaleX: itemAlign === "bottom" ? -1 : 1,
      rotation: -Math.PI / 2
    } : orient2 === "vertical" && !inverse ? {
      scaleX: itemAlign === "left" ? 1 : -1,
      scaleY: -1
    } : {
      scaleX: itemAlign === "left" ? 1 : -1
    });
  };
  ContinuousView2.prototype._updateHandle = function(handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }
    var shapes = this._shapes;
    var visualMapModel = this.visualMapModel;
    var handleThumbs = shapes.handleThumbs;
    var handleLabels = shapes.handleLabels;
    var itemSize = visualMapModel.itemSize;
    var dataExtent = visualMapModel.getExtent();
    each$1([0, 1], function(handleIndex) {
      var handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      var symbolSize = this.getControllerVisual(val, "symbolSize");
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2;
      var textPoint = applyTransform(shapes.handleLabelPoints[handleIndex], getTransform$1(handleThumb, this.group));
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: "middle",
        align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
      });
    }, this);
  };
  ContinuousView2.prototype._showIndicator = function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var itemSize = visualMapModel.itemSize;
    var sizeExtent = [0, itemSize[1]];
    var shapes = this._shapes;
    var indicator = shapes.indicator;
    if (!indicator) {
      return;
    }
    indicator.attr("invisible", false);
    var opts = {
      convertOpacityToAlpha: true
    };
    var color = this.getControllerVisual(cursorValue, "color", opts);
    var symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
    var y2 = linearMap(cursorValue, dataExtent, sizeExtent, true);
    var x2 = itemSize[0] - symbolSize / 2;
    var oldIndicatorPos = {
      x: indicator.x,
      y: indicator.y
    };
    indicator.y = y2;
    indicator.x = x2;
    var textPoint = applyTransform(shapes.indicatorLabelPoint, getTransform$1(indicator, this.group));
    var indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr("invisible", false);
    var align = this._applyTransform("left", shapes.mainGroup);
    var orient2 = this._orient;
    var isHorizontal2 = orient2 === "horizontal";
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal2 ? align : "middle",
      align: isHorizontal2 ? "center" : align
    });
    var indicatorNewProps = {
      x: x2,
      y: y2,
      style: {
        fill: color
      }
    };
    var labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };
    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      var animationCfg = {
        duration: 100,
        easing: "cubicInOut",
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }
    this._firstShowIndicator = false;
    var handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        this._api.enterBlur(handleLabels[i]);
      }
    }
  };
  ContinuousView2.prototype._enableHoverLinkToSeries = function() {
    var self2 = this;
    this._shapes.mainGroup.on("mousemove", function(e2) {
      self2._hovering = true;
      if (!self2._dragging) {
        var itemSize = self2.visualMapModel.itemSize;
        var pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.mainGroup, true, true);
        pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);
        self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on("mouseout", function() {
      self2._hovering = false;
      !self2._dragging && self2._clearHoverLinkToSeries();
    });
  };
  ContinuousView2.prototype._enableHoverLinkFromSeries = function() {
    var zr = this.api.getZr();
    if (this.visualMapModel.option.hoverLink) {
      zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
      zr.on("mouseout", this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  };
  ContinuousView2.prototype._doHoverLinkToSeries = function(cursorPos, hoverOnBar) {
    var visualMapModel = this.visualMapModel;
    var itemSize = visualMapModel.itemSize;
    if (!visualMapModel.option.hoverLink) {
      return;
    }
    var sizeExtent = [0, itemSize[1]];
    var dataExtent = visualMapModel.getExtent();
    cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
    var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
    var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, "\u2248 ", halfHoverLinkSize);
      }
    }
    var oldBatch = this._hoverLinkDataIndices;
    var newBatch = [];
    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }
    var resultBatches = compressBatches(oldBatch, newBatch);
    this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
    this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
  };
  ContinuousView2.prototype._hoverLinkFromSeriesMouseOver = function(e2) {
    var ecData;
    findEventDispatcher(e2.target, function(target) {
      var currECData = getECData(target);
      if (currECData.dataIndex != null) {
        ecData = currECData;
        return true;
      }
    }, true);
    if (!ecData) {
      return;
    }
    var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
    var visualMapModel = this.visualMapModel;
    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }
    var data = dataModel.getData(ecData.dataType);
    var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  };
  ContinuousView2.prototype._hideIndicator = function() {
    var shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr("invisible", true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
    var handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        this._api.leaveBlur(handleLabels[i]);
      }
    }
  };
  ContinuousView2.prototype._clearHoverLinkToSeries = function() {
    this._hideIndicator();
    var indices = this._hoverLinkDataIndices;
    this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
    indices.length = 0;
  };
  ContinuousView2.prototype._clearHoverLinkFromSeries = function() {
    this._hideIndicator();
    var zr = this.api.getZr();
    zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
    zr.off("mouseout", this._hideIndicator);
  };
  ContinuousView2.prototype._applyTransform = function(vertex, element, inverse, global2) {
    var transform4 = getTransform$1(element, global2 ? null : this.group);
    return isArray$1(vertex) ? applyTransform(vertex, transform4, inverse) : transformDirection(vertex, transform4, inverse);
  };
  ContinuousView2.prototype._dispatchHighDown = function(type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type,
      batch
    });
  };
  ContinuousView2.prototype.dispose = function() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  };
  ContinuousView2.prototype.remove = function() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  };
  ContinuousView2.type = "visualMap.continuous";
  return ContinuousView2;
}(VisualMapView$1);
function createPolygon2(points2, cursor, onDrift, onDragEnd) {
  return new Polygon$1({
    shape: {
      points: points2
    },
    draggable: !!onDrift,
    cursor,
    drift: onDrift,
    onmousemove: function(e2) {
      stop(e2.event);
    },
    ondragend: onDragEnd
  });
}
function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }
  return halfHoverLinkSize;
}
function useHoverLinkOnHandle(visualMapModel) {
  var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
  return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
}
function getCursor(orient2) {
  return orient2 === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView$1 = ContinuousView;
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  update: "update"
};
var visualMapActionHander = function(payload, ecModel) {
  ecModel.eachComponent({
    mainType: "visualMap",
    query: payload
  }, function(model) {
    model.setSelected(payload.selected);
  });
};
var visualMapEncodingHandlers = [
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var resetDefines = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        var pipelineContext = seriesModel.pipelineContext;
        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return;
        }
        resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind$1(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
      });
      return resetDefines;
    }
  },
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var visualMetaList = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          var visualMeta = visualMapModel.getVisualMeta(bind$1(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          };
          var dimIdx = visualMapModel.getDataDimensionIndex(data);
          if (dimIdx >= 0) {
            visualMeta.dimension = dimIdx;
            visualMetaList.push(visualMeta);
          }
        }
      });
      seriesModel.getData().setVisual("visualMeta", visualMetaList);
    }
  }
];
function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  var mappings = visualMapModel.targetVisuals[valueState];
  var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
  var resultVisual = {
    color: getVisualFromData(seriesModel.getData(), "color")
  };
  for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
    var type = visualTypes[i];
    var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }
  return resultVisual.color;
  function getVisual(key) {
    return resultVisual[key];
  }
  function setVisual(key, value2) {
    resultVisual[key] = value2;
  }
}
var each = each$f;
function visualMapPreprocessor(option) {
  var visualMap = option && option.visualMap;
  if (!isArray$1(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }
  each(visualMap, function(opt) {
    if (!opt) {
      return;
    }
    if (has(opt, "splitList") && !has(opt, "pieces")) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }
    var pieces = opt.pieces;
    if (pieces && isArray$1(pieces)) {
      each(pieces, function(piece) {
        if (isObject$3(piece)) {
          if (has(piece, "start") && !has(piece, "min")) {
            piece.min = piece.start;
          }
          if (has(piece, "end") && !has(piece, "max")) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}
function has(obj, name2) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name2);
}
var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }
  installed = true;
  registers.registerSubTypeDefaulter("visualMap", function(option) {
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
  });
  registers.registerAction(visualMapActionInfo, visualMapActionHander);
  each$f(visualMapEncodingHandlers, function(handler) {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(visualMapPreprocessor);
}
function install$5(registers) {
  registers.registerComponentModel(ContinuousModel$1);
  registers.registerComponentView(ContinuousView$1);
  installCommon(registers);
}
var PiecewiseModel = function(_super) {
  __extends$1(PiecewiseModel2, _super);
  function PiecewiseModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PiecewiseModel2.type;
    _this._pieceList = [];
    return _this;
  }
  PiecewiseModel2.prototype.optionUpdated = function(newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);
    this.resetExtent();
    var mode = this._mode = this._determineMode();
    this._pieceList = [];
    resetMethods[this._mode].call(this, this._pieceList);
    this._resetSelected(newOption, isInit);
    var categories = this.option.categories;
    this.resetVisual(function(mappingOption, state) {
      if (mode === "categories") {
        mappingOption.mappingMethod = "category";
        mappingOption.categories = clone$4(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = "piecewise";
        mappingOption.pieceList = map$1(this._pieceList, function(piece) {
          piece = clone$4(piece);
          if (state !== "inRange") {
            piece.visual = null;
          }
          return piece;
        });
      }
    });
  };
  PiecewiseModel2.prototype.completeVisualOption = function() {
    var option = this.option;
    var visualTypesInPieces = {};
    var visualTypes = VisualMapping$1.listVisualTypes();
    var isCategory2 = this.isCategory();
    each$f(option.pieces, function(piece) {
      each$f(visualTypes, function(visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    each$f(visualTypesInPieces, function(v, visualType) {
      var exists = false;
      each$f(this.stateList, function(state) {
        exists = exists || has2(option, state, visualType) || has2(option.target, state, visualType);
      }, this);
      !exists && each$f(this.stateList, function(state) {
        (option[state] || (option[state] = {}))[visualType] = visualDefault$1.get(visualType, state === "inRange" ? "active" : "inactive", isCategory2);
      });
    }, this);
    function has2(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }
    _super.prototype.completeVisualOption.apply(this, arguments);
  };
  PiecewiseModel2.prototype._resetSelected = function(newOption, isInit) {
    var thisOption = this.option;
    var pieceList = this._pieceList;
    var selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected;
    each$f(pieceList, function(piece, index2) {
      var key = this.getSelectedMapKey(piece);
      if (!selected.hasOwnProperty(key)) {
        selected[key] = true;
      }
    }, this);
    if (thisOption.selectedMode === "single") {
      var hasSel_1 = false;
      each$f(pieceList, function(piece, index2) {
        var key = this.getSelectedMapKey(piece);
        if (selected[key]) {
          hasSel_1 ? selected[key] = false : hasSel_1 = true;
        }
      }, this);
    }
  };
  PiecewiseModel2.prototype.getItemSymbol = function() {
    return this.get("itemSymbol");
  };
  PiecewiseModel2.prototype.getSelectedMapKey = function(piece) {
    return this._mode === "categories" ? piece.value + "" : piece.index + "";
  };
  PiecewiseModel2.prototype.getPieceList = function() {
    return this._pieceList;
  };
  PiecewiseModel2.prototype._determineMode = function() {
    var option = this.option;
    return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
  };
  PiecewiseModel2.prototype.setSelected = function(selected) {
    this.option.selected = clone$4(selected);
  };
  PiecewiseModel2.prototype.getValueState = function(value) {
    var index2 = VisualMapping$1.findPieceIndex(value, this._pieceList);
    return index2 != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index2])] ? "inRange" : "outOfRange" : "outOfRange";
  };
  PiecewiseModel2.prototype.findTargetDataIndices = function(pieceIndex) {
    var result = [];
    var pieceList = this._pieceList;
    this.eachTargetSeries(function(seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        var pIdx = VisualMapping$1.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  PiecewiseModel2.prototype.getRepresentValue = function(piece) {
    var representValue;
    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        var pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }
    return representValue;
  };
  PiecewiseModel2.prototype.getVisualMeta = function(getColorVisual2) {
    if (this.isCategory()) {
      return;
    }
    var stops = [];
    var outerColors = ["", ""];
    var visualMapModel = this;
    function setStop(interval, valueState) {
      var representValue = visualMapModel.getRepresentValue({
        interval
      });
      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }
      var color = getColorVisual2(representValue, valueState);
      if (interval[0] === -Infinity) {
        outerColors[0] = color;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color;
      } else {
        stops.push({
          value: interval[0],
          color
        }, {
          value: interval[1],
          color
        });
      }
    }
    var pieceList = this._pieceList.slice();
    if (!pieceList.length) {
      pieceList.push({
        interval: [-Infinity, Infinity]
      });
    } else {
      var edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({
        interval: [-Infinity, edge]
      });
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({
        interval: [edge, Infinity]
      });
    }
    var curr = -Infinity;
    each$f(pieceList, function(piece) {
      var interval = piece.interval;
      if (interval) {
        interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {
      stops,
      outerColors
    };
  };
  PiecewiseModel2.type = "visualMap.piecewise";
  PiecewiseModel2.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    selected: null,
    minOpen: false,
    maxOpen: false,
    align: "auto",
    itemWidth: 20,
    itemHeight: 14,
    itemSymbol: "roundRect",
    pieces: null,
    categories: null,
    splitNumber: 5,
    selectedMode: "multiple",
    itemGap: 10,
    hoverLink: true
  });
  return PiecewiseModel2;
}(VisualMapModel$1);
var resetMethods = {
  splitNumber: function(outPieceList) {
    var thisOption = this.option;
    var precision = Math.min(thisOption.precision, 20);
    var dataExtent = this.getExtent();
    var splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }
    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);
    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }
    for (var index2 = 0, curr = dataExtent[0]; index2 < splitNumber; curr += splitStep, index2++) {
      var max4 = index2 === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max4],
        close: [1, 1]
      });
    }
    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }
    reformIntervals(outPieceList);
    each$f(outPieceList, function(piece, index3) {
      piece.index = index3;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories: function(outPieceList) {
    var thisOption = this.option;
    each$f(thisOption.categories, function(cate) {
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this);
    normalizeReverse(thisOption, outPieceList);
  },
  pieces: function(outPieceList) {
    var thisOption = this.option;
    each$f(thisOption.pieces, function(pieceListItem, index2) {
      if (!isObject$3(pieceListItem)) {
        pieceListItem = {
          value: pieceListItem
        };
      }
      var item = {
        text: "",
        index: index2
      };
      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }
      if (pieceListItem.hasOwnProperty("value")) {
        var value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        var interval = item.interval = [];
        var close_1 = item.close = [0, 0];
        var closeList = [1, 0, 1];
        var infinityList = [-Infinity, Infinity];
        var useMinMax = [];
        for (var lg = 0; lg < 2; lg++) {
          var names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
          for (var i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names[i]];
            close_1[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }
          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }
        useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);
        {
          if (interval[0] > interval[1]) {
            console.warn("Piece " + index2 + "is illegal: " + interval + " lower bound should not greater then uppper bound.");
          }
        }
        if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
          item.value = interval[0];
        }
      }
      item.visual = VisualMapping$1.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this);
    normalizeReverse(thisOption, outPieceList);
    reformIntervals(outPieceList);
    each$f(outPieceList, function(piece) {
      var close = piece.close;
      var edgeSymbols = [["<", "\u2264"][close[1]], [">", "\u2265"][close[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};
function normalizeReverse(thisOption, pieceList) {
  var inverse = thisOption.inverse;
  if (thisOption.orient === "vertical" ? !inverse : inverse) {
    pieceList.reverse();
  }
}
var PiecewiseModel$1 = PiecewiseModel;
var PiecewiseVisualMapView = function(_super) {
  __extends$1(PiecewiseVisualMapView2, _super);
  function PiecewiseVisualMapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PiecewiseVisualMapView2.type;
    return _this;
  }
  PiecewiseVisualMapView2.prototype.doRender = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get("textGap");
    var textStyleModel = visualMapModel.textStyleModel;
    var textFont = textStyleModel.getFont();
    var textFill = textStyleModel.getTextColor();
    var itemAlign = this._getItemAlign();
    var itemSize = visualMapModel.itemSize;
    var viewData = this._getViewData();
    var endsText = viewData.endsText;
    var showLabel = retrieve(visualMapModel.get("showLabel", true), !endsText);
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    each$f(viewData.viewPieceList, function(item) {
      var piece = item.piece;
      var itemGroup = new Group$4();
      itemGroup.onclick = bind$1(this._onItemClick, this, piece);
      this._enableHoverLink(itemGroup, item.indexInModelPieceList);
      var representValue = visualMapModel.getRepresentValue(piece);
      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
      if (showLabel) {
        var visualState = this.visualMapModel.getValueState(representValue);
        itemGroup.add(new ZRText$1({
          style: {
            x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: "middle",
            align: itemAlign,
            font: textFont,
            fill: textFill,
            opacity: visualState === "outOfRange" ? 0.5 : 1
          }
        }));
      }
      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  };
  PiecewiseVisualMapView2.prototype._enableHoverLink = function(itemGroup, pieceIndex) {
    var _this = this;
    itemGroup.on("mouseover", function() {
      return onHoverLink("highlight");
    }).on("mouseout", function() {
      return onHoverLink("downplay");
    });
    var onHoverLink = function(method) {
      var visualMapModel = _this.visualMapModel;
      visualMapModel.option.hoverLink && _this.api.dispatchAction({
        type: method,
        batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  };
  PiecewiseVisualMapView2.prototype._getItemAlign = function() {
    var visualMapModel = this.visualMapModel;
    var modelOption = visualMapModel.option;
    if (modelOption.orient === "vertical") {
      return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      var align = modelOption.align;
      if (!align || align === "auto") {
        align = "left";
      }
      return align;
    }
  };
  PiecewiseVisualMapView2.prototype._renderEndsText = function(group, text, itemSize, showLabel, itemAlign) {
    if (!text) {
      return;
    }
    var itemGroup = new Group$4();
    var textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new ZRText$1({
      style: createTextStyle(textStyleModel, {
        x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: "middle",
        align: showLabel ? itemAlign : "center",
        text
      })
    }));
    group.add(itemGroup);
  };
  PiecewiseVisualMapView2.prototype._getViewData = function() {
    var visualMapModel = this.visualMapModel;
    var viewPieceList = map$1(visualMapModel.getPieceList(), function(piece, index2) {
      return {
        piece,
        indexInModelPieceList: index2
      };
    });
    var endsText = visualMapModel.get("text");
    var orient2 = visualMapModel.get("orient");
    var inverse = visualMapModel.get("inverse");
    if (orient2 === "horizontal" ? inverse : !inverse) {
      viewPieceList.reverse();
    } else if (endsText) {
      endsText = endsText.slice().reverse();
    }
    return {
      viewPieceList,
      endsText
    };
  };
  PiecewiseVisualMapView2.prototype._createItemSymbol = function(group, representValue, shapeParam) {
    group.add(createSymbol$1(
      this.getControllerVisual(representValue, "symbol"),
      shapeParam[0],
      shapeParam[1],
      shapeParam[2],
      shapeParam[3],
      this.getControllerVisual(representValue, "color")
    ));
  };
  PiecewiseVisualMapView2.prototype._onItemClick = function(piece) {
    var visualMapModel = this.visualMapModel;
    var option = visualMapModel.option;
    var selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    var selected = clone$4(option.selected);
    var newKey = visualMapModel.getSelectedMapKey(piece);
    if (selectedMode === "single" || selectedMode === true) {
      selected[newKey] = true;
      each$f(selected, function(o, key) {
        selected[key] = key === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }
    this.api.dispatchAction({
      type: "selectDataRange",
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected
    });
  };
  PiecewiseVisualMapView2.type = "visualMap.piecewise";
  return PiecewiseVisualMapView2;
}(VisualMapView$1);
var PiecewiseView = PiecewiseVisualMapView;
function install$4(registers) {
  registers.registerComponentModel(PiecewiseModel$1);
  registers.registerComponentView(PiecewiseView);
  installCommon(registers);
}
function install$3(registers) {
  use2(install$5);
  use2(install$4);
}
var DEFAULT_OPTION = {
  label: {
    enabled: true
  },
  decal: {
    show: false
  }
};
var inner = makeInner();
var decalPaletteScope = {};
function ariaVisual(ecModel, api) {
  var ariaModel = ecModel.getModel("aria");
  if (!ariaModel.get("enabled")) {
    return;
  }
  var defaultOption2 = clone$4(DEFAULT_OPTION);
  merge3(defaultOption2.label, ecModel.getLocaleModel().get("aria"), false);
  merge3(ariaModel.option, defaultOption2, false);
  setDecal();
  setLabel2();
  function setDecal() {
    var decalModel = ariaModel.getModel("decal");
    var useDecal = decalModel.get("show");
    if (useDecal) {
      var paletteScopeGroupByType_1 = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.isColorBySeries()) {
          return;
        }
        var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);
        if (!decalScope) {
          decalScope = {};
          paletteScopeGroupByType_1.set(seriesModel.type, decalScope);
        }
        inner(seriesModel).scope = decalScope;
      });
      ecModel.eachRawSeries(function(seriesModel) {
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        if (isFunction(seriesModel.enableAriaDecal)) {
          seriesModel.enableAriaDecal();
          return;
        }
        var data = seriesModel.getData();
        if (!seriesModel.isColorBySeries()) {
          var dataAll_1 = seriesModel.getRawData();
          var idxMap_1 = {};
          var decalScope_1 = inner(seriesModel).scope;
          data.each(function(idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap_1[rawIdx] = idx;
          });
          var dataCount_1 = dataAll_1.count();
          dataAll_1.each(function(rawIdx) {
            var idx = idxMap_1[rawIdx];
            var name2 = dataAll_1.getName(rawIdx) || rawIdx + "";
            var paletteDecal2 = getDecalFromPalette(seriesModel.ecModel, name2, decalScope_1, dataCount_1);
            var specifiedDecal2 = data.getItemVisual(idx, "decal");
            data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal2, paletteDecal2));
          });
        } else {
          var paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
          var specifiedDecal = data.getVisual("decal");
          data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
        }
        function mergeDecal(specifiedDecal2, paletteDecal2) {
          var resultDecal = specifiedDecal2 ? extend2(extend2({}, paletteDecal2), specifiedDecal2) : paletteDecal2;
          resultDecal.dirty = true;
          return resultDecal;
        }
      });
    }
  }
  function setLabel2() {
    var labelLocale = ecModel.getLocaleModel().get("aria");
    var labelModel = ariaModel.getModel("label");
    labelModel.option = defaults(labelModel.option, labelLocale);
    if (!labelModel.get("enabled")) {
      return;
    }
    var dom = api.getZr().dom;
    if (labelModel.get("description")) {
      dom.setAttribute("aria-label", labelModel.get("description"));
      return;
    }
    var seriesCnt = ecModel.getSeriesCount();
    var maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
    var maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
    var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    var ariaLabel;
    if (seriesCnt < 1) {
      return;
    } else {
      var title = getTitle();
      if (title) {
        var withTitle = labelModel.get(["general", "withTitle"]);
        ariaLabel = replace(withTitle, {
          title
        });
      } else {
        ariaLabel = labelModel.get(["general", "withoutTitle"]);
      }
      var seriesLabels_1 = [];
      var prefix = seriesCnt > 1 ? labelModel.get(["series", "multiple", "prefix"]) : labelModel.get(["series", "single", "prefix"]);
      ariaLabel += replace(prefix, {
        seriesCount: seriesCnt
      });
      ecModel.eachSeries(function(seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          var seriesLabel = void 0;
          var seriesName = seriesModel.get("name");
          var withName = seriesName ? "withName" : "withoutName";
          seriesLabel = seriesCnt > 1 ? labelModel.get(["series", "multiple", withName]) : labelModel.get(["series", "single", withName]);
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get("name"),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          var data = seriesModel.getData();
          if (data.count() > maxDataCnt) {
            var partialLabel = labelModel.get(["data", "partialData"]);
            seriesLabel += replace(partialLabel, {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += labelModel.get(["data", "allData"]);
          }
          var middleSeparator_1 = labelModel.get(["data", "separator", "middle"]);
          var endSeparator_1 = labelModel.get(["data", "separator", "end"]);
          var dataLabels = [];
          for (var i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              var name_1 = data.getName(i);
              var value = data.getValues(i);
              var dataLabel = labelModel.get(["data", name_1 ? "withName" : "withoutName"]);
              dataLabels.push(replace(dataLabel, {
                name: name_1,
                value: value.join(middleSeparator_1)
              }));
            }
          }
          seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;
          seriesLabels_1.push(seriesLabel);
        }
      });
      var separatorModel = labelModel.getModel(["series", "multiple", "separator"]);
      var middleSeparator = separatorModel.get("middle");
      var endSeparator = separatorModel.get("end");
      ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;
      dom.setAttribute("aria-label", ariaLabel);
    }
  }
  function replace(str, keyValues) {
    if (!isString(str)) {
      return str;
    }
    var result = str;
    each$f(keyValues, function(value, key) {
      result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
    });
    return result;
  }
  function getTitle() {
    var title = ecModel.get("title");
    if (title && title.length) {
      title = title[0];
    }
    return title && title.text;
  }
  function getSeriesTypeName(type) {
    return ecModel.getLocaleModel().get(["series", "typeNames"])[type] || "\u81EA\u5B9A\u4E49\u56FE";
  }
}
function ariaPreprocessor(option) {
  if (!option || !option.aria) {
    return;
  }
  var aria = option.aria;
  if (aria.show != null) {
    aria.enabled = aria.show;
  }
  aria.label = aria.label || {};
  each$f(["description", "general", "series", "data"], function(name2) {
    if (aria[name2] != null) {
      aria.label[name2] = aria[name2];
    }
  });
}
function install$2(registers) {
  registers.registerPreprocessor(ariaPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
}
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: "eq",
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
};
var RegExpEvaluator = function() {
  function RegExpEvaluator2(rVal) {
    var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;
    if (condValue == null) {
      var errMsg = "";
      {
        errMsg = makePrintable("Illegal regexp", rVal, "in");
      }
      throwError(errMsg);
    }
  }
  RegExpEvaluator2.prototype.evaluate = function(lVal) {
    var type = typeof lVal;
    return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + "") : false;
  };
  return RegExpEvaluator2;
}();
var ConstConditionInternal = function() {
  function ConstConditionInternal2() {
  }
  ConstConditionInternal2.prototype.evaluate = function() {
    return this.value;
  };
  return ConstConditionInternal2;
}();
var AndConditionInternal = function() {
  function AndConditionInternal2() {
  }
  AndConditionInternal2.prototype.evaluate = function() {
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      if (!children[i].evaluate()) {
        return false;
      }
    }
    return true;
  };
  return AndConditionInternal2;
}();
var OrConditionInternal = function() {
  function OrConditionInternal2() {
  }
  OrConditionInternal2.prototype.evaluate = function() {
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].evaluate()) {
        return true;
      }
    }
    return false;
  };
  return OrConditionInternal2;
}();
var NotConditionInternal = function() {
  function NotConditionInternal2() {
  }
  NotConditionInternal2.prototype.evaluate = function() {
    return !this.child.evaluate();
  };
  return NotConditionInternal2;
}();
var RelationalConditionInternal = function() {
  function RelationalConditionInternal2() {
  }
  RelationalConditionInternal2.prototype.evaluate = function() {
    var needParse = !!this.valueParser;
    var getValue = this.getValue;
    var tarValRaw = getValue(this.valueGetterParam);
    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
    for (var i = 0; i < this.subCondList.length; i++) {
      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
        return false;
      }
    }
    return true;
  };
  return RelationalConditionInternal2;
}();
function parseOption(exprOption, getters) {
  if (exprOption === true || exprOption === false) {
    var cond = new ConstConditionInternal();
    cond.value = exprOption;
    return cond;
  }
  var errMsg = "";
  if (!isObjectNotArray(exprOption)) {
    {
      errMsg = makePrintable("Illegal config. Expect a plain object but actually", exprOption);
    }
    throwError(errMsg);
  }
  if (exprOption.and) {
    return parseAndOrOption("and", exprOption, getters);
  } else if (exprOption.or) {
    return parseAndOrOption("or", exprOption, getters);
  } else if (exprOption.not) {
    return parseNotOption(exprOption, getters);
  }
  return parseRelationalOption(exprOption, getters);
}
function parseAndOrOption(op, exprOption, getters) {
  var subOptionArr = exprOption[op];
  var errMsg = "";
  {
    errMsg = makePrintable('"and"/"or" condition should only be `' + op + ": [...]` and must not be empty array.", "Illegal condition:", exprOption);
  }
  if (!isArray$1(subOptionArr)) {
    throwError(errMsg);
  }
  if (!subOptionArr.length) {
    throwError(errMsg);
  }
  var cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
  cond.children = map$1(subOptionArr, function(subOption) {
    return parseOption(subOption, getters);
  });
  if (!cond.children.length) {
    throwError(errMsg);
  }
  return cond;
}
function parseNotOption(exprOption, getters) {
  var subOption = exprOption.not;
  var errMsg = "";
  {
    errMsg = makePrintable('"not" condition should only be `not: {}`.', "Illegal condition:", exprOption);
  }
  if (!isObjectNotArray(subOption)) {
    throwError(errMsg);
  }
  var cond = new NotConditionInternal();
  cond.child = parseOption(subOption, getters);
  if (!cond.child) {
    throwError(errMsg);
  }
  return cond;
}
function parseRelationalOption(exprOption, getters) {
  var errMsg = "";
  var valueGetterParam = getters.prepareGetValue(exprOption);
  var subCondList = [];
  var exprKeys = keys2(exprOption);
  var parserName = exprOption.parser;
  var valueParser = parserName ? getRawValueParser(parserName) : null;
  for (var i = 0; i < exprKeys.length; i++) {
    var keyRaw = exprKeys[i];
    if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) {
      continue;
    }
    var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
    var condValueRaw = exprOption[keyRaw];
    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
    var evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
    if (!evaluator) {
      {
        errMsg = makePrintable('Illegal relational operation: "' + keyRaw + '" in condition:', exprOption);
      }
      throwError(errMsg);
    }
    subCondList.push(evaluator);
  }
  if (!subCondList.length) {
    {
      errMsg = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", exprOption);
    }
    throwError(errMsg);
  }
  var cond = new RelationalConditionInternal();
  cond.valueGetterParam = valueGetterParam;
  cond.valueParser = valueParser;
  cond.getValue = getters.getValue;
  cond.subCondList = subCondList;
  return cond;
}
function isObjectNotArray(val) {
  return isObject$3(val) && !isArrayLike(val);
}
var ConditionalExpressionParsed = function() {
  function ConditionalExpressionParsed2(exprOption, getters) {
    this._cond = parseOption(exprOption, getters);
  }
  ConditionalExpressionParsed2.prototype.evaluate = function() {
    return this._cond.evaluate();
  };
  return ConditionalExpressionParsed2;
}();
function parseConditionalExpression(exprOption, getters) {
  return new ConditionalExpressionParsed(exprOption, getters);
}
var filterTransform = {
  type: "echarts:filter",
  transform: function(params) {
    var upstream = params.upstream;
    var rawItem;
    var condition = parseConditionalExpression(params.config, {
      valueGetterAttrMap: createHashMap({
        dimension: true
      }),
      prepareGetValue: function(exprOption) {
        var errMsg = "";
        var dimLoose = exprOption.dimension;
        if (!hasOwn(exprOption, "dimension")) {
          {
            errMsg = makePrintable('Relation condition must has prop "dimension" specified.', "Illegal condition:", exprOption);
          }
          throwError(errMsg);
        }
        var dimInfo = upstream.getDimensionInfo(dimLoose);
        if (!dimInfo) {
          {
            errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal condition:", exprOption, ".\n");
          }
          throwError(errMsg);
        }
        return {
          dimIdx: dimInfo.index
        };
      },
      getValue: function(param) {
        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
      }
    });
    var resultData = [];
    for (var i = 0, len2 = upstream.count(); i < len2; i++) {
      rawItem = upstream.getRawDataItem(i);
      if (condition.evaluate()) {
        resultData.push(rawItem);
      }
    }
    return {
      data: resultData
    };
  }
};
var sampleLog = "";
{
  sampleLog = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" ");
}
var sortTransform = {
  type: "echarts:sort",
  transform: function(params) {
    var upstream = params.upstream;
    var config = params.config;
    var errMsg = "";
    var orderExprList = normalizeToArray(config);
    if (!orderExprList.length) {
      {
        errMsg = "Empty `config` in sort transform.";
      }
      throwError(errMsg);
    }
    var orderDefList = [];
    each$f(orderExprList, function(orderExpr) {
      var dimLoose = orderExpr.dimension;
      var order = orderExpr.order;
      var parserName = orderExpr.parser;
      var incomparable = orderExpr.incomparable;
      if (dimLoose == null) {
        {
          errMsg = 'Sort transform config must has "dimension" specified.' + sampleLog;
        }
        throwError(errMsg);
      }
      if (order !== "asc" && order !== "desc") {
        {
          errMsg = 'Sort transform config must has "order" specified.' + sampleLog;
        }
        throwError(errMsg);
      }
      if (incomparable && incomparable !== "min" && incomparable !== "max") {
        var errMsg_1 = "";
        {
          errMsg_1 = 'incomparable must be "min" or "max" rather than "' + incomparable + '".';
        }
        throwError(errMsg_1);
      }
      if (order !== "asc" && order !== "desc") {
        var errMsg_2 = "";
        {
          errMsg_2 = 'order must be "asc" or "desc" rather than "' + order + '".';
        }
        throwError(errMsg_2);
      }
      var dimInfo = upstream.getDimensionInfo(dimLoose);
      if (!dimInfo) {
        {
          errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal config:", orderExpr, ".\n");
        }
        throwError(errMsg);
      }
      var parser = parserName ? getRawValueParser(parserName) : null;
      if (parserName && !parser) {
        {
          errMsg = makePrintable("Invalid parser name " + parserName + ".\n", "Illegal config:", orderExpr, ".\n");
        }
        throwError(errMsg);
      }
      orderDefList.push({
        dimIdx: dimInfo.index,
        parser,
        comparator: new SortOrderComparator(order, incomparable)
      });
    });
    var sourceFormat = upstream.sourceFormat;
    if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
      {
        errMsg = 'sourceFormat "' + sourceFormat + '" is not supported yet';
      }
      throwError(errMsg);
    }
    var resultData = [];
    for (var i = 0, len2 = upstream.count(); i < len2; i++) {
      resultData.push(upstream.getRawDataItem(i));
    }
    resultData.sort(function(item0, item1) {
      for (var i2 = 0; i2 < orderDefList.length; i2++) {
        var orderDef = orderDefList[i2];
        var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
        var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
        if (orderDef.parser) {
          val0 = orderDef.parser(val0);
          val1 = orderDef.parser(val1);
        }
        var result = orderDef.comparator.evaluate(val0, val1);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
    return {
      data: resultData
    };
  }
};
function install$1(registers) {
  registers.registerTransform(filterTransform);
  registers.registerTransform(sortTransform);
}
var DatasetModel = function(_super) {
  __extends$1(DatasetModel2, _super);
  function DatasetModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataset";
    return _this;
  }
  DatasetModel2.prototype.init = function(option, parentModel, ecModel) {
    _super.prototype.init.call(this, option, parentModel, ecModel);
    this._sourceManager = new SourceManager(this);
    disableTransformOptionMerge(this);
  };
  DatasetModel2.prototype.mergeOption = function(newOption, ecModel) {
    _super.prototype.mergeOption.call(this, newOption, ecModel);
    disableTransformOptionMerge(this);
  };
  DatasetModel2.prototype.optionUpdated = function() {
    this._sourceManager.dirty();
  };
  DatasetModel2.prototype.getSourceManager = function() {
    return this._sourceManager;
  };
  DatasetModel2.type = "dataset";
  DatasetModel2.defaultOption = {
    seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
  };
  return DatasetModel2;
}(ComponentModel$1);
var DatasetView = function(_super) {
  __extends$1(DatasetView2, _super);
  function DatasetView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataset";
    return _this;
  }
  DatasetView2.type = "dataset";
  return DatasetView2;
}(ComponentView$1);
function install(registers) {
  registers.registerComponentModel(DatasetModel);
  registers.registerComponentView(DatasetView);
}
var CMD = PathProxy.CMD;
function aroundEqual(a, b) {
  return Math.abs(a - b) < 1e-5;
}
function pathToBezierCurves(path) {
  var data = path.data;
  var len2 = path.len();
  var bezierArrayGroups = [];
  var currentSubpath;
  var xi = 0;
  var yi = 0;
  var x02 = 0;
  var y02 = 0;
  function createNewSubpath(x3, y3) {
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    currentSubpath = [x3, y3];
  }
  function addLine2(x03, y03, x13, y13) {
    if (!(aroundEqual(x03, x13) && aroundEqual(y03, y13))) {
      currentSubpath.push(x03, y03, x13, y13, x13, y13);
    }
  }
  function addArc(startAngle2, endAngle2, cx2, cy2, rx2, ry2) {
    var delta2 = Math.abs(endAngle2 - startAngle2);
    var len3 = Math.tan(delta2 / 4) * 4 / 3;
    var dir3 = endAngle2 < startAngle2 ? -1 : 1;
    var c1 = Math.cos(startAngle2);
    var s1 = Math.sin(startAngle2);
    var c2 = Math.cos(endAngle2);
    var s2 = Math.sin(endAngle2);
    var x13 = c1 * rx2 + cx2;
    var y13 = s1 * ry2 + cy2;
    var x4 = c2 * rx2 + cx2;
    var y4 = s2 * ry2 + cy2;
    var hx = rx2 * len3 * dir3;
    var hy = ry2 * len3 * dir3;
    currentSubpath.push(x13 - hx * s1, y13 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
  var x12;
  var y12;
  var x2;
  var y2;
  for (var i = 0; i < len2; ) {
    var cmd = data[i++];
    var isFirst = i === 1;
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x02 = xi;
      y02 = yi;
      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {
        currentSubpath = [x02, y02];
      }
    }
    switch (cmd) {
      case CMD.M:
        xi = x02 = data[i++];
        yi = y02 = data[i++];
        createNewSubpath(x02, y02);
        break;
      case CMD.L:
        x12 = data[i++];
        y12 = data[i++];
        addLine2(xi, yi, x12, y12);
        xi = x12;
        yi = y12;
        break;
      case CMD.C:
        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
        break;
      case CMD.Q:
        x12 = data[i++];
        y12 = data[i++];
        x2 = data[i++];
        y2 = data[i++];
        currentSubpath.push(xi + 2 / 3 * (x12 - xi), yi + 2 / 3 * (y12 - yi), x2 + 2 / 3 * (x12 - x2), y2 + 2 / 3 * (y12 - y2), x2, y2);
        xi = x2;
        yi = y2;
        break;
      case CMD.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var startAngle = data[i++];
        var endAngle = data[i++] + startAngle;
        i += 1;
        var anticlockwise = !data[i++];
        x12 = Math.cos(startAngle) * rx + cx;
        y12 = Math.sin(startAngle) * ry + cy;
        if (isFirst) {
          x02 = x12;
          y02 = y12;
          createNewSubpath(x02, y02);
        } else {
          addLine2(xi, yi, x12, y12);
        }
        xi = Math.cos(endAngle) * rx + cx;
        yi = Math.sin(endAngle) * ry + cy;
        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (var angle4 = startAngle; anticlockwise ? angle4 > endAngle : angle4 < endAngle; angle4 += step) {
          var nextAngle = anticlockwise ? Math.max(angle4 + step, endAngle) : Math.min(angle4 + step, endAngle);
          addArc(angle4, nextAngle, cx, cy, rx, ry);
        }
        break;
      case CMD.R:
        x02 = xi = data[i++];
        y02 = yi = data[i++];
        x12 = x02 + data[i++];
        y12 = y02 + data[i++];
        createNewSubpath(x12, y02);
        addLine2(x12, y02, x12, y12);
        addLine2(x12, y12, x02, y12);
        addLine2(x02, y12, x02, y02);
        addLine2(x02, y02, x12, y02);
        break;
      case CMD.Z:
        currentSubpath && addLine2(xi, yi, x02, y02);
        xi = x02;
        yi = y02;
        break;
    }
  }
  if (currentSubpath && currentSubpath.length > 2) {
    bezierArrayGroups.push(currentSubpath);
  }
  return bezierArrayGroups;
}
function adpativeBezier(x02, y02, x12, y12, x2, y2, x3, y3, out2, scale4) {
  if (aroundEqual(x02, x12) && aroundEqual(y02, y12) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
    out2.push(x3, y3);
    return;
  }
  var PIXEL_DISTANCE = 2 / scale4;
  var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
  var dx = x3 - x02;
  var dy = y3 - y02;
  var d = Math.sqrt(dx * dx + dy * dy);
  dx /= d;
  dy /= d;
  var dx1 = x12 - x02;
  var dy1 = y12 - y02;
  var dx2 = x2 - x3;
  var dy2 = y2 - y3;
  var cp1LenSqr = dx1 * dx1 + dy1 * dy1;
  var cp2LenSqr = dx2 * dx2 + dy2 * dy2;
  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
    out2.push(x3, y3);
    return;
  }
  var projLen1 = dx * dx1 + dy * dy1;
  var projLen2 = -dx * dx2 - dy * dy2;
  var d1Sqr = cp1LenSqr - projLen1 * projLen1;
  var d2Sqr = cp2LenSqr - projLen2 * projLen2;
  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
    out2.push(x3, y3);
    return;
  }
  var tmpSegX = [];
  var tmpSegY = [];
  cubicSubdivide(x02, x12, x2, x3, 0.5, tmpSegX);
  cubicSubdivide(y02, y12, y2, y3, 0.5, tmpSegY);
  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale4);
  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale4);
}
function pathToPolygons(path, scale4) {
  var bezierArrayGroups = pathToBezierCurves(path);
  var polygons2 = [];
  scale4 = scale4 || 1;
  for (var i = 0; i < bezierArrayGroups.length; i++) {
    var beziers = bezierArrayGroups[i];
    var polygon4 = [];
    var x02 = beziers[0];
    var y02 = beziers[1];
    polygon4.push(x02, y02);
    for (var k = 2; k < beziers.length; ) {
      var x12 = beziers[k++];
      var y12 = beziers[k++];
      var x2 = beziers[k++];
      var y2 = beziers[k++];
      var x3 = beziers[k++];
      var y3 = beziers[k++];
      adpativeBezier(x02, y02, x12, y12, x2, y2, x3, y3, polygon4, scale4);
      x02 = x3;
      y02 = y3;
    }
    polygons2.push(polygon4);
  }
  return polygons2;
}
function getDividingGrids(dimSize, rowDim, count3) {
  var rowSize = dimSize[rowDim];
  var columnSize = dimSize[1 - rowDim];
  var ratio = Math.abs(rowSize / columnSize);
  var rowCount = Math.ceil(Math.sqrt(ratio * count3));
  var columnCount = Math.floor(count3 / rowCount);
  if (columnCount === 0) {
    columnCount = 1;
    rowCount = count3;
  }
  var grids = [];
  for (var i = 0; i < rowCount; i++) {
    grids.push(columnCount);
  }
  var currentCount = rowCount * columnCount;
  var remained = count3 - currentCount;
  if (remained > 0) {
    for (var i = 0; i < remained; i++) {
      grids[i % rowCount] += 1;
    }
  }
  return grids;
}
function divideSector(sectorShape, count3, outShapes) {
  var r0 = sectorShape.r0;
  var r = sectorShape.r;
  var startAngle = sectorShape.startAngle;
  var endAngle = sectorShape.endAngle;
  var angle4 = Math.abs(endAngle - startAngle);
  var arcLen = angle4 * r;
  var deltaR = r - r0;
  var isAngleRow = arcLen > Math.abs(deltaR);
  var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count3);
  var rowSize = (isAngleRow ? angle4 : deltaR) / grids.length;
  for (var row = 0; row < grids.length; row++) {
    var columnSize = (isAngleRow ? deltaR : angle4) / grids[row];
    for (var column = 0; column < grids[row]; column++) {
      var newShape = {};
      if (isAngleRow) {
        newShape.startAngle = startAngle + rowSize * row;
        newShape.endAngle = startAngle + rowSize * (row + 1);
        newShape.r0 = r0 + columnSize * column;
        newShape.r = r0 + columnSize * (column + 1);
      } else {
        newShape.startAngle = startAngle + columnSize * column;
        newShape.endAngle = startAngle + columnSize * (column + 1);
        newShape.r0 = r0 + rowSize * row;
        newShape.r = r0 + rowSize * (row + 1);
      }
      newShape.clockwise = sectorShape.clockwise;
      newShape.cx = sectorShape.cx;
      newShape.cy = sectorShape.cy;
      outShapes.push(newShape);
    }
  }
}
function divideRect(rectShape, count3, outShapes) {
  var width = rectShape.width;
  var height = rectShape.height;
  var isHorizontalRow = width > height;
  var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count3);
  var rowSizeDim = isHorizontalRow ? "width" : "height";
  var columnSizeDim = isHorizontalRow ? "height" : "width";
  var rowDim = isHorizontalRow ? "x" : "y";
  var columnDim = isHorizontalRow ? "y" : "x";
  var rowSize = rectShape[rowSizeDim] / grids.length;
  for (var row = 0; row < grids.length; row++) {
    var columnSize = rectShape[columnSizeDim] / grids[row];
    for (var column = 0; column < grids[row]; column++) {
      var newShape = {};
      newShape[rowDim] = row * rowSize;
      newShape[columnDim] = column * columnSize;
      newShape[rowSizeDim] = rowSize;
      newShape[columnSizeDim] = columnSize;
      newShape.x += rectShape.x;
      newShape.y += rectShape.y;
      outShapes.push(newShape);
    }
  }
}
function crossProduct2d(x12, y12, x2, y2) {
  return x12 * y2 - x2 * y12;
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (Math.abs(nmCrossProduct) < 1e-6) {
    return null;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return null;
  }
  return new Point$1(p * mx + a1x, p * my + a1y);
}
function projPtOnLine(pt, lineA, lineB) {
  var dir3 = new Point$1();
  Point$1.sub(dir3, lineB, lineA);
  dir3.normalize();
  var dir22 = new Point$1();
  Point$1.sub(dir22, pt, lineA);
  var len2 = dir22.dot(dir3);
  return len2;
}
function addToPoly(poly, pt) {
  var last = poly[poly.length - 1];
  if (last && last[0] === pt[0] && last[1] === pt[1]) {
    return;
  }
  poly.push(pt);
}
function splitPolygonByLine(points2, lineA, lineB) {
  var len2 = points2.length;
  var intersections = [];
  for (var i = 0; i < len2; i++) {
    var p0 = points2[i];
    var p1 = points2[(i + 1) % len2];
    var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
    if (intersectionPt) {
      intersections.push({
        projPt: projPtOnLine(intersectionPt, lineA, lineB),
        pt: intersectionPt,
        idx: i
      });
    }
  }
  if (intersections.length < 2) {
    return [{ points: points2 }, { points: points2 }];
  }
  intersections.sort(function(a, b) {
    return a.projPt - b.projPt;
  });
  var splitPt0 = intersections[0];
  var splitPt1 = intersections[intersections.length - 1];
  if (splitPt1.idx < splitPt0.idx) {
    var tmp = splitPt0;
    splitPt0 = splitPt1;
    splitPt1 = tmp;
  }
  var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
  var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
  var newPolyA = [splitPt0Arr];
  var newPolyB = [splitPt1Arr];
  for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {
    addToPoly(newPolyA, points2[i].slice());
  }
  addToPoly(newPolyA, splitPt1Arr);
  addToPoly(newPolyA, splitPt0Arr);
  for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len2; i++) {
    addToPoly(newPolyB, points2[i % len2].slice());
  }
  addToPoly(newPolyB, splitPt0Arr);
  addToPoly(newPolyB, splitPt1Arr);
  return [{
    points: newPolyA
  }, {
    points: newPolyB
  }];
}
function binaryDividePolygon(polygonShape) {
  var points2 = polygonShape.points;
  var min5 = [];
  var max4 = [];
  fromPoints(points2, min5, max4);
  var boundingRect = new BoundingRect$1(min5[0], min5[1], max4[0] - min5[0], max4[1] - min5[1]);
  var width = boundingRect.width;
  var height = boundingRect.height;
  var x2 = boundingRect.x;
  var y2 = boundingRect.y;
  var pt02 = new Point$1();
  var pt12 = new Point$1();
  if (width > height) {
    pt02.x = pt12.x = x2 + width / 2;
    pt02.y = y2;
    pt12.y = y2 + height;
  } else {
    pt02.y = pt12.y = y2 + height / 2;
    pt02.x = x2;
    pt12.x = x2 + width;
  }
  return splitPolygonByLine(points2, pt02, pt12);
}
function binaryDivideRecursive(divider, shape, count3, out2) {
  if (count3 === 1) {
    out2.push(shape);
  } else {
    var mid = Math.floor(count3 / 2);
    var sub2 = divider(shape);
    binaryDivideRecursive(divider, sub2[0], mid, out2);
    binaryDivideRecursive(divider, sub2[1], count3 - mid, out2);
  }
  return out2;
}
function clone5(path, count3) {
  var paths = [];
  for (var i = 0; i < count3; i++) {
    paths.push(clonePath(path));
  }
  return paths;
}
function copyPathProps(source2, target) {
  target.setStyle(source2.style);
  target.z = source2.z;
  target.z2 = source2.z2;
  target.zlevel = source2.zlevel;
}
function polygonConvert(points2) {
  var out2 = [];
  for (var i = 0; i < points2.length; ) {
    out2.push([points2[i++], points2[i++]]);
  }
  return out2;
}
function split2(path, count3) {
  var outShapes = [];
  var shape = path.shape;
  var OutShapeCtor;
  switch (path.type) {
    case "rect":
      divideRect(shape, count3, outShapes);
      OutShapeCtor = Rect$3;
      break;
    case "sector":
      divideSector(shape, count3, outShapes);
      OutShapeCtor = Sector$1;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: shape.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: shape.cx,
        cy: shape.cy
      }, count3, outShapes);
      OutShapeCtor = Sector$1;
      break;
    default:
      var m2 = path.getComputedTransform();
      var scale4 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
      var polygons2 = map$1(pathToPolygons(path.getUpdatedPathProxy(), scale4), function(poly) {
        return polygonConvert(poly);
      });
      var polygonCount = polygons2.length;
      if (polygonCount === 0) {
        binaryDivideRecursive(binaryDividePolygon, {
          points: polygons2[0]
        }, count3, outShapes);
      } else if (polygonCount === count3) {
        for (var i = 0; i < polygonCount; i++) {
          outShapes.push({
            points: polygons2[i]
          });
        }
      } else {
        var totalArea_1 = 0;
        var items = map$1(polygons2, function(poly) {
          var min5 = [];
          var max4 = [];
          fromPoints(poly, min5, max4);
          var area5 = (max4[1] - min5[1]) * (max4[0] - min5[0]);
          totalArea_1 += area5;
          return { poly, area: area5 };
        });
        items.sort(function(a, b) {
          return b.area - a.area;
        });
        var left = count3;
        for (var i = 0; i < polygonCount; i++) {
          var item = items[i];
          if (left <= 0) {
            break;
          }
          var selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count3);
          if (selfCount < 0) {
            continue;
          }
          binaryDivideRecursive(binaryDividePolygon, {
            points: item.poly
          }, selfCount, outShapes);
          left -= selfCount;
        }
      }
      OutShapeCtor = Polygon$1;
      break;
  }
  if (!OutShapeCtor) {
    return clone5(path, count3);
  }
  var out2 = [];
  for (var i = 0; i < outShapes.length; i++) {
    var subPath = new OutShapeCtor();
    subPath.setShape(outShapes[i]);
    copyPathProps(path, subPath);
    out2.push(subPath);
  }
  return out2;
}
function alignSubpath(subpath1, subpath2) {
  var len1 = subpath1.length;
  var len2 = subpath2.length;
  if (len1 === len2) {
    return [subpath1, subpath2];
  }
  var tmpSegX = [];
  var tmpSegY = [];
  var shorterPath = len1 < len2 ? subpath1 : subpath2;
  var shorterLen = Math.min(len1, len2);
  var diff2 = Math.abs(len2 - len1) / 6;
  var shorterBezierCount = (shorterLen - 2) / 6;
  var eachCurveSubDivCount = Math.ceil(diff2 / shorterBezierCount) + 1;
  var newSubpath = [shorterPath[0], shorterPath[1]];
  var remained = diff2;
  for (var i = 2; i < shorterLen; ) {
    var x02 = shorterPath[i - 2];
    var y02 = shorterPath[i - 1];
    var x12 = shorterPath[i++];
    var y12 = shorterPath[i++];
    var x2 = shorterPath[i++];
    var y2 = shorterPath[i++];
    var x3 = shorterPath[i++];
    var y3 = shorterPath[i++];
    if (remained <= 0) {
      newSubpath.push(x12, y12, x2, y2, x3, y3);
      continue;
    }
    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
    for (var k = 1; k <= actualSubDivCount; k++) {
      var p = k / actualSubDivCount;
      cubicSubdivide(x02, x12, x2, x3, p, tmpSegX);
      cubicSubdivide(y02, y12, y2, y3, p, tmpSegY);
      x02 = tmpSegX[3];
      y02 = tmpSegY[3];
      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x02, y02);
      x12 = tmpSegX[5];
      y12 = tmpSegY[5];
      x2 = tmpSegX[6];
      y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
  var len2 = lastSubpathSubpath.length;
  var lastX = lastSubpathSubpath[len2 - 2];
  var lastY = lastSubpathSubpath[len2 - 1];
  var newSubpath = [];
  for (var i = 0; i < otherSubpath.length; ) {
    newSubpath[i++] = lastX;
    newSubpath[i++] = lastY;
  }
  return newSubpath;
}
function alignBezierCurves(array1, array2) {
  var _a2;
  var lastSubpath1;
  var lastSubpath2;
  var newArray1 = [];
  var newArray2 = [];
  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {
    var subpath1 = array1[i];
    var subpath2 = array2[i];
    var newSubpath1 = void 0;
    var newSubpath2 = void 0;
    if (!subpath1) {
      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
      newSubpath2 = subpath2;
    } else if (!subpath2) {
      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
      newSubpath1 = subpath1;
    } else {
      _a2 = alignSubpath(subpath1, subpath2), newSubpath1 = _a2[0], newSubpath2 = _a2[1];
      lastSubpath1 = newSubpath1;
      lastSubpath2 = newSubpath2;
    }
    newArray1.push(newSubpath1);
    newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
function centroid3(array) {
  var signedArea5 = 0;
  var cx = 0;
  var cy = 0;
  var len2 = array.length;
  for (var i = 0, j = len2 - 2; i < len2; j = i, i += 2) {
    var x02 = array[j];
    var y02 = array[j + 1];
    var x12 = array[i];
    var y12 = array[i + 1];
    var a = x02 * y12 - x12 * y02;
    signedArea5 += a;
    cx += (x02 + x12) * a;
    cy += (y02 + y12) * a;
  }
  if (signedArea5 === 0) {
    return [array[0] || 0, array[1] || 0];
  }
  return [cx / signedArea5 / 3, cy / signedArea5 / 3, signedArea5];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  var bezierCount = (fromSubBeziers.length - 2) / 6;
  var bestScore = Infinity;
  var bestOffset = 0;
  var len2 = fromSubBeziers.length;
  var len22 = len2 - 2;
  for (var offset = 0; offset < bezierCount; offset++) {
    var cursorOffset = offset * 6;
    var score = 0;
    for (var k = 0; k < len2; k += 2) {
      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len22 + 2;
      var x02 = fromSubBeziers[idx] - fromCp[0];
      var y02 = fromSubBeziers[idx + 1] - fromCp[1];
      var x12 = toSubBeziers[k] - toCp[0];
      var y12 = toSubBeziers[k + 1] - toCp[1];
      var dx = x12 - x02;
      var dy = y12 - y02;
      score += dx * dx + dy * dy;
    }
    if (score < bestScore) {
      bestScore = score;
      bestOffset = offset;
    }
  }
  return bestOffset;
}
function reverse4(array) {
  var newArr = [];
  var len2 = array.length;
  for (var i = 0; i < len2; i += 2) {
    newArr[i] = array[len2 - i - 2];
    newArr[i + 1] = array[len2 - i - 1];
  }
  return newArr;
}
function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
  var result = [];
  var fromNeedsReverse;
  for (var i = 0; i < fromArr.length; i++) {
    var fromSubpathBezier = fromArr[i];
    var toSubpathBezier = toArr2[i];
    var fromCp = centroid3(fromSubpathBezier);
    var toCp = centroid3(toSubpathBezier);
    if (fromNeedsReverse == null) {
      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
    }
    var newFromSubpathBezier = [];
    var newToSubpathBezier = [];
    var bestAngle = 0;
    var bestScore = Infinity;
    var tmpArr2 = [];
    var len2 = fromSubpathBezier.length;
    if (fromNeedsReverse) {
      fromSubpathBezier = reverse4(fromSubpathBezier);
    }
    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
    var len22 = len2 - 2;
    for (var k = 0; k < len22; k += 2) {
      var idx = (offset + k) % len22 + 2;
      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
    if (searchAngleIteration > 0) {
      var step = searchAngleRange / searchAngleIteration;
      for (var angle4 = -searchAngleRange / 2; angle4 <= searchAngleRange / 2; angle4 += step) {
        var sa = Math.sin(angle4);
        var ca = Math.cos(angle4);
        var score = 0;
        for (var k = 0; k < fromSubpathBezier.length; k += 2) {
          var x02 = newFromSubpathBezier[k];
          var y02 = newFromSubpathBezier[k + 1];
          var x12 = toSubpathBezier[k] - toCp[0];
          var y12 = toSubpathBezier[k + 1] - toCp[1];
          var newX1 = x12 * ca - y12 * sa;
          var newY1 = x12 * sa + y12 * ca;
          tmpArr2[k] = newX1;
          tmpArr2[k + 1] = newY1;
          var dx = newX1 - x02;
          var dy = newY1 - y02;
          score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
          bestScore = score;
          bestAngle = angle4;
          for (var m2 = 0; m2 < tmpArr2.length; m2++) {
            newToSubpathBezier[m2] = tmpArr2[m2];
          }
        }
      }
    } else {
      for (var i_1 = 0; i_1 < len2; i_1 += 2) {
        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
      }
    }
    result.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result;
}
function isCombineMorphing(path) {
  return path.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(obj, methodName, modifiers) {
  var savedMethodName = SAVED_METHOD_PREFIX + methodName;
  var originalMethod = obj[savedMethodName] || obj[methodName];
  if (!obj[savedMethodName]) {
    obj[savedMethodName] = obj[methodName];
  }
  var replace = modifiers.replace;
  var after = modifiers.after;
  var before = modifiers.before;
  obj[methodName] = function() {
    var args = arguments;
    var res;
    before && before.apply(this, args);
    if (replace) {
      res = replace.apply(this, args);
    } else {
      res = originalMethod.apply(this, args);
    }
    after && after.apply(this, args);
    return res;
  };
}
function restoreMethod(obj, methodName) {
  var savedMethodName = SAVED_METHOD_PREFIX + methodName;
  if (obj[savedMethodName]) {
    obj[methodName] = obj[savedMethodName];
    obj[savedMethodName] = null;
  }
}
function applyTransformOnBeziers(bezierCurves, mm) {
  for (var i = 0; i < bezierCurves.length; i++) {
    var subBeziers = bezierCurves[i];
    for (var k = 0; k < subBeziers.length; ) {
      var x2 = subBeziers[k];
      var y2 = subBeziers[k + 1];
      subBeziers[k++] = mm[0] * x2 + mm[2] * y2 + mm[4];
      subBeziers[k++] = mm[1] * x2 + mm[3] * y2 + mm[5];
    }
  }
}
function prepareMorphPath(fromPath, toPath) {
  var fromPathProxy = fromPath.getUpdatedPathProxy();
  var toPathProxy = toPath.getUpdatedPathProxy();
  var _a2 = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a2[0], toBezierCurves = _a2[1];
  var fromPathTransform = fromPath.getComputedTransform();
  var toPathTransform = toPath.getComputedTransform();
  function updateIdentityTransform() {
    this.transform = null;
  }
  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
  saveAndModifyMethod(toPath, "updateTransform", { replace: updateIdentityTransform });
  toPath.transform = null;
  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
  var tmpArr2 = [];
  saveAndModifyMethod(toPath, "buildPath", { replace: function(path) {
    var t = toPath.__morphT;
    var onet = 1 - t;
    var newCp = [];
    for (var i = 0; i < morphingData.length; i++) {
      var item = morphingData[i];
      var from = item.from;
      var to = item.to;
      var angle4 = item.rotation * t;
      var fromCp = item.fromCp;
      var toCp = item.toCp;
      var sa = Math.sin(angle4);
      var ca = Math.cos(angle4);
      lerp$1(newCp, fromCp, toCp, t);
      for (var m2 = 0; m2 < from.length; m2 += 2) {
        var x0_1 = from[m2];
        var y0_1 = from[m2 + 1];
        var x12 = to[m2];
        var y12 = to[m2 + 1];
        var x2 = x0_1 * onet + x12 * t;
        var y2 = y0_1 * onet + y12 * t;
        tmpArr2[m2] = x2 * ca - y2 * sa + newCp[0];
        tmpArr2[m2 + 1] = x2 * sa + y2 * ca + newCp[1];
      }
      var x02 = tmpArr2[0];
      var y02 = tmpArr2[1];
      path.moveTo(x02, y02);
      for (var m2 = 2; m2 < from.length; ) {
        var x12 = tmpArr2[m2++];
        var y12 = tmpArr2[m2++];
        var x22 = tmpArr2[m2++];
        var y22 = tmpArr2[m2++];
        var x3 = tmpArr2[m2++];
        var y3 = tmpArr2[m2++];
        if (x02 === x12 && y02 === y12 && x22 === x3 && y22 === y3) {
          path.lineTo(x3, y3);
        } else {
          path.bezierCurveTo(x12, y12, x22, y22, x3, y3);
        }
        x02 = x3;
        y02 = y3;
      }
    }
  } });
}
function morphPath(fromPath, toPath, animationOpts) {
  if (!fromPath || !toPath) {
    return toPath;
  }
  var oldDone = animationOpts.done;
  var oldDuring = animationOpts.during;
  prepareMorphPath(fromPath, toPath);
  toPath.__morphT = 0;
  function restoreToPath() {
    restoreMethod(toPath, "buildPath");
    restoreMethod(toPath, "updateTransform");
    toPath.__morphT = -1;
    toPath.createPathProxy();
    toPath.dirtyShape();
  }
  toPath.animateTo({
    __morphT: 1
  }, defaults({
    during: function(p) {
      toPath.dirtyShape();
      oldDuring && oldDuring(p);
    },
    done: function() {
      restoreToPath();
      oldDone && oldDone();
    }
  }, animationOpts));
  return toPath;
}
function hilbert(x2, y2, minX2, minY2, maxX2, maxY2) {
  var bits = 16;
  x2 = maxX2 === minX2 ? 0 : Math.round(32767 * (x2 - minX2) / (maxX2 - minX2));
  y2 = maxY2 === minY2 ? 0 : Math.round(32767 * (y2 - minY2) / (maxY2 - minY2));
  var d = 0;
  var tmp;
  for (var s = (1 << bits) / 2; s > 0; s /= 2) {
    var rx = 0;
    var ry = 0;
    if ((x2 & s) > 0) {
      rx = 1;
    }
    if ((y2 & s) > 0) {
      ry = 1;
    }
    d += s * s * (3 * rx ^ ry);
    if (ry === 0) {
      if (rx === 1) {
        x2 = s - 1 - x2;
        y2 = s - 1 - y2;
      }
      tmp = x2;
      x2 = y2;
      y2 = tmp;
    }
  }
  return d;
}
function sortPaths(pathList) {
  var xMin = Infinity;
  var yMin = Infinity;
  var xMax = -Infinity;
  var yMax = -Infinity;
  var cps = map$1(pathList, function(path) {
    var rect = path.getBoundingRect();
    var m2 = path.getComputedTransform();
    var x2 = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
    var y2 = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
    xMin = Math.min(x2, xMin);
    yMin = Math.min(y2, yMin);
    xMax = Math.max(x2, xMax);
    yMax = Math.max(y2, yMax);
    return [x2, y2];
  });
  var items = map$1(cps, function(cp, idx) {
    return {
      cp,
      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
      path: pathList[idx]
    };
  });
  return items.sort(function(a, b) {
    return a.z - b.z;
  }).map(function(item) {
    return item.path;
  });
}
function defaultDividePath(param) {
  return split2(param.path, param.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(fromList, toPath, animationOpts) {
  var fromPathList = [];
  function addFromPath(fromList2) {
    for (var i2 = 0; i2 < fromList2.length; i2++) {
      var from2 = fromList2[i2];
      if (isCombineMorphing(from2)) {
        addFromPath(from2.childrenRef());
      } else if (from2 instanceof Path$1) {
        fromPathList.push(from2);
      }
    }
  }
  addFromPath(fromList);
  var separateCount = fromPathList.length;
  if (!separateCount) {
    return createEmptyReturn();
  }
  var dividePath = animationOpts.dividePath || defaultDividePath;
  var toSubPathList = dividePath({
    path: toPath,
    count: separateCount
  });
  if (toSubPathList.length !== separateCount) {
    console.error("Invalid morphing: unmatched splitted path");
    return createEmptyReturn();
  }
  fromPathList = sortPaths(fromPathList);
  toSubPathList = sortPaths(toSubPathList);
  var oldDone = animationOpts.done;
  var oldDuring = animationOpts.during;
  var individualDelay = animationOpts.individualDelay;
  var identityTransform = new Transformable$1();
  for (var i = 0; i < separateCount; i++) {
    var from = fromPathList[i];
    var to = toSubPathList[i];
    to.parent = toPath;
    to.copyTransform(identityTransform);
    if (!individualDelay) {
      prepareMorphPath(from, to);
    }
  }
  toPath.__isCombineMorphing = true;
  toPath.childrenRef = function() {
    return toSubPathList;
  };
  function addToSubPathListToZr(zr) {
    for (var i2 = 0; i2 < toSubPathList.length; i2++) {
      toSubPathList[i2].addSelfToZr(zr);
    }
  }
  saveAndModifyMethod(toPath, "addSelfToZr", {
    after: function(zr) {
      addToSubPathListToZr(zr);
    }
  });
  saveAndModifyMethod(toPath, "removeSelfFromZr", {
    after: function(zr) {
      for (var i2 = 0; i2 < toSubPathList.length; i2++) {
        toSubPathList[i2].removeSelfFromZr(zr);
      }
    }
  });
  function restoreToPath() {
    toPath.__isCombineMorphing = false;
    toPath.__morphT = -1;
    toPath.childrenRef = null;
    restoreMethod(toPath, "addSelfToZr");
    restoreMethod(toPath, "removeSelfFromZr");
  }
  var toLen = toSubPathList.length;
  if (individualDelay) {
    var animating_1 = toLen;
    var eachDone = function() {
      animating_1--;
      if (animating_1 === 0) {
        restoreToPath();
        oldDone && oldDone();
      }
    };
    for (var i = 0; i < toLen; i++) {
      var indivdualAnimationOpts = individualDelay ? defaults({
        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),
        done: eachDone
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);
    }
  } else {
    toPath.__morphT = 0;
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during: function(p) {
        for (var i2 = 0; i2 < toLen; i2++) {
          var child = toSubPathList[i2];
          child.__morphT = toPath.__morphT;
          child.dirtyShape();
        }
        oldDuring && oldDuring(p);
      },
      done: function() {
        restoreToPath();
        for (var i2 = 0; i2 < fromList.length; i2++) {
          restoreMethod(fromList[i2], "updateTransform");
        }
        oldDone && oldDone();
      }
    }, animationOpts));
  }
  if (toPath.__zr) {
    addToSubPathListToZr(toPath.__zr);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toSubPathList,
    count: toLen
  };
}
function separateMorph(fromPath, toPathList, animationOpts) {
  var toLen = toPathList.length;
  var fromPathList = [];
  var dividePath = animationOpts.dividePath || defaultDividePath;
  function addFromPath(fromList) {
    for (var i2 = 0; i2 < fromList.length; i2++) {
      var from = fromList[i2];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path$1) {
        fromPathList.push(from);
      }
    }
  }
  if (isCombineMorphing(fromPath)) {
    addFromPath(fromPath.childrenRef());
    var fromLen = fromPathList.length;
    if (fromLen < toLen) {
      var k = 0;
      for (var i = fromLen; i < toLen; i++) {
        fromPathList.push(clonePath(fromPathList[k++ % fromLen]));
      }
    }
    fromPathList.length = toLen;
  } else {
    fromPathList = dividePath({ path: fromPath, count: toLen });
    var fromPathTransform = fromPath.getComputedTransform();
    for (var i = 0; i < fromPathList.length; i++) {
      fromPathList[i].setLocalTransform(fromPathTransform);
    }
    if (fromPathList.length !== toLen) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
  }
  fromPathList = sortPaths(fromPathList);
  toPathList = sortPaths(toPathList);
  var individualDelay = animationOpts.individualDelay;
  for (var i = 0; i < toLen; i++) {
    var indivdualAnimationOpts = individualDelay ? defaults({
      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])
    }, animationOpts) : animationOpts;
    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toPathList,
    count: toPathList.length
  };
}
function isMultiple(elements) {
  return isArray$1(elements[0]);
}
function prepareMorphBatches(one, many) {
  var batches = [];
  var batchCount = one.length;
  for (var i = 0; i < batchCount; i++) {
    batches.push({
      one: one[i],
      many: []
    });
  }
  for (var i = 0; i < many.length; i++) {
    var len2 = many[i].length;
    var k = void 0;
    for (k = 0; k < len2; k++) {
      batches[k % batchCount].many.push(many[i][k]);
    }
  }
  var off = 0;
  for (var i = batchCount - 1; i >= 0; i--) {
    if (!batches[i].many.length) {
      var moveFrom = batches[off].many;
      if (moveFrom.length <= 1) {
        if (off) {
          off = 0;
        } else {
          return batches;
        }
      }
      var len2 = moveFrom.length;
      var mid = Math.ceil(len2 / 2);
      batches[i].many = moveFrom.slice(mid, len2);
      batches[off].many = moveFrom.slice(0, mid);
      off++;
    }
  }
  return batches;
}
var pathDividers = {
  clone: function(params) {
    var ret = [];
    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
    for (var i = 0; i < params.count; i++) {
      var cloned = clonePath(params.path);
      cloned.setStyle("opacity", approxOpacity);
      ret.push(cloned);
    }
    return ret;
  },
  split: null
};
function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
  if (!from.length || !to.length) {
    return;
  }
  var updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
    return;
  }
  var animationDelay = seriesModel.getModel("universalTransition").get("delay");
  var animationCfg = Object.assign({
    setToFinal: true
  }, updateAnimationCfg);
  var many;
  var one;
  if (isMultiple(from)) {
    many = from;
    one = to;
  }
  if (isMultiple(to)) {
    many = to;
    one = from;
  }
  function morphOneBatch(batch, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
    var batchMany = batch.many;
    var batchOne = batch.one;
    if (batchMany.length === 1 && !forceManyOne) {
      var batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
      var batchTo = fromIsMany2 ? batchOne : batchMany[0];
      if (isCombineMorphing(batchFrom)) {
        morphOneBatch({
          many: [batchFrom],
          one: batchTo
        }, true, animateIndex2, animateCount2, true);
      } else {
        var individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(animateIndex2, animateCount2)
        }, animationCfg) : animationCfg;
        morphPath(batchFrom, batchTo, individualAnimationCfg);
        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
      }
    } else {
      var separateAnimationCfg = defaults({
        dividePath: pathDividers[divideShape],
        individualDelay: animationDelay && function(idx, count4, fromPath, toPath) {
          return animationDelay(idx + animateIndex2, animateCount2);
        }
      }, animationCfg);
      var _a2 = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg), fromIndividuals = _a2.fromIndividuals, toIndividuals = _a2.toIndividuals;
      var count3 = fromIndividuals.length;
      for (var k = 0; k < count3; k++) {
        var individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(k, count3)
        }, animationCfg) : animationCfg;
        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany2 ? batchMany[k] : batch.one, fromIsMany2 ? batch.one : batchMany[k], individualAnimationCfg);
      }
    }
  }
  var fromIsMany = many ? many === from : from.length > to.length;
  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
  var animateCount = 0;
  for (var i = 0; i < morphBatches.length; i++) {
    animateCount += morphBatches[i].many.length;
  }
  var animateIndex = 0;
  for (var i = 0; i < morphBatches.length; i++) {
    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);
    animateIndex += morphBatches[i].many.length;
  }
}
function getPathList(elements) {
  if (!elements) {
    return [];
  }
  if (isArray$1(elements)) {
    var pathList_1 = [];
    for (var i = 0; i < elements.length; i++) {
      pathList_1.push(getPathList(elements[i]));
    }
    return pathList_1;
  }
  var pathList = [];
  elements.traverse(function(el) {
    if (el instanceof Path$1 && !el.disableMorphing && !el.invisible && !el.ignore) {
      pathList.push(el);
    }
  });
  return pathList;
}
var DATA_COUNT_THRESHOLD = 1e4;
var getUniversalTransitionGlobalStore = makeInner();
function getGroupIdDimension(data) {
  var dimensions = data.dimensions;
  for (var i = 0; i < dimensions.length; i++) {
    var dimInfo = data.getDimensionInfo(dimensions[i]);
    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {
      return dimensions[i];
    }
  }
}
function flattenDataDiffItems(list) {
  var items = [];
  each$f(list, function(seriesInfo) {
    var data = seriesInfo.data;
    if (data.count() > DATA_COUNT_THRESHOLD) {
      {
        warn("Universal transition is disabled on large data > 10k.");
      }
      return;
    }
    var indices = data.getIndices();
    var groupDim = getGroupIdDimension(data);
    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {
      items.push({
        data,
        dim: seriesInfo.dim || groupDim,
        divide: seriesInfo.divide,
        dataIndex
      });
    }
  });
  return items;
}
function fadeInElement(newEl2, newSeries, newIndex) {
  newEl2.traverse(function(el) {
    if (el instanceof Path$1) {
      initProps(el, {
        style: {
          opacity: 0
        }
      }, newSeries, {
        dataIndex: newIndex,
        isFrom: true
      });
    }
  });
}
function removeEl(el) {
  if (el.parent) {
    var computedTransform = el.getComputedTransform();
    el.setLocalTransform(computedTransform);
    el.parent.remove(el);
  }
}
function stopAnimation(el) {
  el.stopAnimation();
  if (el.isGroup) {
    el.traverse(function(child) {
      child.stopAnimation();
    });
  }
}
function animateElementStyles(el, dataIndex, seriesModel) {
  var animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
  animationConfig && el.traverse(function(child) {
    if (child instanceof Displayable$1) {
      var oldStyle = getOldStyle(child);
      if (oldStyle) {
        child.animateFrom({
          style: oldStyle
        }, animationConfig);
      }
    }
  });
}
function isAllIdSame(oldDiffItems, newDiffItems) {
  var len2 = oldDiffItems.length;
  if (len2 !== newDiffItems.length) {
    return false;
  }
  for (var i = 0; i < len2; i++) {
    var oldItem = oldDiffItems[i];
    var newItem = newDiffItems[i];
    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
      return false;
    }
  }
  return true;
}
function transitionBetween(oldList, newList, api) {
  var oldDiffItems = flattenDataDiffItems(oldList);
  var newDiffItems = flattenDataDiffItems(newList);
  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
    if (rawFrom || from) {
      to.animateFrom({
        style: rawFrom && rawFrom !== from ? extend2(extend2({}, rawFrom.style), from.style) : from.style
      }, animationCfg);
    }
  }
  function findKeyDim(items) {
    for (var i2 = 0; i2 < items.length; i2++) {
      if (items[i2].dim) {
        return items[i2].dim;
      }
    }
  }
  var oldKeyDim = findKeyDim(oldDiffItems);
  var newKeyDim = findKeyDim(newDiffItems);
  var hasMorphAnimation = false;
  function createKeyGetter(isOld, onlyGetId) {
    return function(diffItem) {
      var data = diffItem.data;
      var dataIndex = diffItem.dataIndex;
      if (onlyGetId) {
        return data.getId(dataIndex);
      }
      var dataGroupId = data.hostModel && data.hostModel.get("dataGroupId");
      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;
      var dimInfo = keyDim && data.getDimensionInfo(keyDim);
      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
      if (dimInfo) {
        var key = data.get(dimInfo.name, dataIndex);
        if (dimOrdinalMeta) {
          return dimOrdinalMeta.categories[key] || key + "";
        }
        return key + "";
      }
      var itemVal = data.getRawDataItem(dataIndex);
      if (itemVal && itemVal.groupId) {
        return itemVal.groupId + "";
      }
      return dataGroupId || data.getId(dataIndex);
    };
  }
  var useId = isAllIdSame(oldDiffItems, newDiffItems);
  var isElementStillInChart = {};
  if (!useId) {
    for (var i = 0; i < newDiffItems.length; i++) {
      var newItem = newDiffItems[i];
      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);
      if (el) {
        isElementStillInChart[el.id] = true;
      }
    }
  }
  function updateOneToOne(newIndex, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var newItem2 = newDiffItems[newIndex];
    var newSeries = newItem2.data.hostModel;
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    var newEl2 = newItem2.data.getItemGraphicEl(newItem2.dataIndex);
    if (oldEl === newEl2) {
      newEl2 && animateElementStyles(newEl2, newItem2.dataIndex, newSeries);
      return;
    }
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newEl2), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newIndex);
      }
    }
  }
  new DataDiffer$1(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
    var newItem2 = newDiffItems[newIndex];
    var newData = newItem2.data;
    var newSeries = newData.hostModel;
    var newEl2 = newData.getItemGraphicEl(newItem2.dataIndex);
    var oldElsList = filter17(map$1(oldIndices, function(idx) {
      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
    }), function(oldEl) {
      return oldEl && oldEl !== newEl2 && !isElementStillInChart[oldEl.id];
    });
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldElsList.length) {
        each$f(oldElsList, function(oldEl) {
          stopAnimation(oldEl);
          removeEl(oldEl);
        });
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl2), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newItem2.dataIndex);
      }
    }
  }).updateOneToMany(function(newIndices, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    var newElsList = filter17(map$1(newIndices, function(idx) {
      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
    }), function(el2) {
      return el2 && el2 !== oldEl;
    });
    var newSeris = newDiffItems[newIndices[0]].data.hostModel;
    if (newElsList.length) {
      each$f(newElsList, function(newEl2) {
        return stopAnimation(newEl2);
      });
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(
          getPathList(oldEl),
          getPathList(newElsList),
          oldItem.divide,
          newSeris,
          newIndices[0],
          updateMorphingPathProps
        );
      } else {
        each$f(newElsList, function(newEl2) {
          return fadeInElement(newEl2, newSeris, newIndices[0]);
        });
      }
    }
  }).updateManyToMany(function(newIndices, oldIndices) {
    new DataDiffer$1(oldIndices, newIndices, function(rawIdx) {
      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
    }, function(rawIdx) {
      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
    }).update(function(newIndex, oldIndex) {
      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
    }).execute();
  }).execute();
  if (hasMorphAnimation) {
    each$f(newList, function(_a2) {
      var data = _a2.data;
      var seriesModel = data.hostModel;
      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);
      var animationCfg = getAnimationConfig("update", seriesModel, 0);
      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
        view.group.traverse(function(el2) {
          if (el2 instanceof Path$1 && !el2.animators.length) {
            el2.animateFrom({
              style: {
                opacity: 0
              }
            }, animationCfg);
          }
        });
      }
    });
  }
}
function getSeriesTransitionKey(series) {
  var seriesKey = series.getModel("universalTransition").get("seriesKey");
  if (!seriesKey) {
    return series.id;
  }
  return seriesKey;
}
function convertArraySeriesKeyToString(seriesKey) {
  if (isArray$1(seriesKey)) {
    return seriesKey.sort().join(",");
  }
  return seriesKey;
}
function getDivideShapeFromData(data) {
  if (data.hostModel) {
    return data.hostModel.getModel("universalTransition").get("divideShape");
  }
}
function findTransitionSeriesBatches(globalStore, params) {
  var updateBatches = createHashMap();
  var oldDataMap = createHashMap();
  var oldDataMapForSplit = createHashMap();
  each$f(globalStore.oldSeries, function(series, idx) {
    var oldData = globalStore.oldData[idx];
    var transitionKey = getSeriesTransitionKey(series);
    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
    oldDataMap.set(transitionKeyStr, oldData);
    if (isArray$1(transitionKey)) {
      each$f(transitionKey, function(key) {
        oldDataMapForSplit.set(key, {
          data: oldData,
          key: transitionKeyStr
        });
      });
    }
  });
  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {
    if (updateBatches.get(transitionKeyStr)) {
      warn("Duplicated seriesKey in universalTransition " + transitionKeyStr);
    }
  }
  each$f(params.updatedSeries, function(series) {
    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
      var newData = series.getData();
      var transitionKey = getSeriesTransitionKey(series);
      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      var oldData = oldDataMap.get(transitionKeyStr);
      if (oldData) {
        {
          checkTransitionSeriesKeyDuplicated(transitionKeyStr);
        }
        updateBatches.set(transitionKeyStr, {
          oldSeries: [{
            divide: getDivideShapeFromData(oldData),
            data: oldData
          }],
          newSeries: [{
            divide: getDivideShapeFromData(newData),
            data: newData
          }]
        });
      } else {
        if (isArray$1(transitionKey)) {
          {
            checkTransitionSeriesKeyDuplicated(transitionKeyStr);
          }
          var oldSeries_1 = [];
          each$f(transitionKey, function(key) {
            var oldData2 = oldDataMap.get(key);
            if (oldData2) {
              oldSeries_1.push({
                divide: getDivideShapeFromData(oldData2),
                data: oldData2
              });
            }
          });
          if (oldSeries_1.length) {
            updateBatches.set(transitionKeyStr, {
              oldSeries: oldSeries_1,
              newSeries: [{
                data: newData,
                divide: getDivideShapeFromData(newData)
              }]
            });
          }
        } else {
          var oldData_1 = oldDataMapForSplit.get(transitionKey);
          if (oldData_1) {
            var batch = updateBatches.get(oldData_1.key);
            if (!batch) {
              batch = {
                oldSeries: [{
                  data: oldData_1.data,
                  divide: getDivideShapeFromData(oldData_1.data)
                }],
                newSeries: []
              };
              updateBatches.set(oldData_1.key, batch);
            }
            batch.newSeries.push({
              data: newData,
              divide: getDivideShapeFromData(newData)
            });
          }
        }
      }
    }
  });
  return updateBatches;
}
function querySeries(series, finder) {
  for (var i = 0; i < series.length; i++) {
    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;
    if (found) {
      return i;
    }
  }
}
function transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {
  var from = [];
  var to = [];
  each$f(normalizeToArray(transitionOpt.from), function(finder) {
    var idx = querySeries(globalStore.oldSeries, finder);
    if (idx >= 0) {
      from.push({
        data: globalStore.oldData[idx],
        divide: getDivideShapeFromData(globalStore.oldData[idx]),
        dim: finder.dimension
      });
    }
  });
  each$f(normalizeToArray(transitionOpt.to), function(finder) {
    var idx = querySeries(params.updatedSeries, finder);
    if (idx >= 0) {
      var data = params.updatedSeries[idx].getData();
      to.push({
        data,
        divide: getDivideShapeFromData(data),
        dim: finder.dimension
      });
    }
  });
  if (from.length > 0 && to.length > 0) {
    transitionBetween(from, to, api);
  }
}
function installUniversalTransition(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", function(ecMOdel, api, params) {
    each$f(normalizeToArray(params.seriesTransition), function(transOpt) {
      each$f(normalizeToArray(transOpt.to), function(finder) {
        var series = params.updatedSeries;
        for (var i = 0; i < series.length; i++) {
          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
          }
        }
      });
    });
  });
  registers.registerUpdateLifecycle("series:transition", function(ecModel, api, params) {
    var globalStore = getUniversalTransitionGlobalStore(api);
    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
      var transitionOpt = params.seriesTransition;
      if (transitionOpt) {
        each$f(normalizeToArray(transitionOpt), function(opt) {
          transitionSeriesFromOpt(opt, globalStore, params, api);
        });
      } else {
        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);
        each$f(updateBatches_1.keys(), function(key) {
          var batch = updateBatches_1.get(key);
          transitionBetween(batch.oldSeries, batch.newSeries, api);
        });
      }
      each$f(params.updatedSeries, function(series) {
        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
        }
      });
    }
    var allSeries = ecModel.getSeries();
    var savedSeries = globalStore.oldSeries = [];
    var savedData = globalStore.oldData = [];
    for (var i = 0; i < allSeries.length; i++) {
      var data = allSeries[i].getData();
      if (data.count() < DATA_COUNT_THRESHOLD) {
        savedSeries.push(allSeries[i]);
        savedData.push(data);
      }
    }
  });
}
use2([install$R]);
use2([install$S]);
use2([install$Q, install$P, install$O, install$M, install$K, install$I, install$H, install$G, install$F, install$E, install$D, install$B, install$A, install$z, install$y, install$x, install$w, install$v, install$u, install$t, install$s, install$r]);
use2(install$p);
use2(install$o);
use2(install$J);
use2(install$n);
use2(install$C);
use2(install$m);
use2(install$l);
use2(install$j);
use2(install$i);
use2(install$q);
use2(install$h);
use2(install$g);
use2(install$f);
use2(install$e);
use2(install$d);
use2(install$c);
use2(install$9);
use2(install$6);
use2(install$8);
use2(install$7);
use2(install$3);
use2(install$5);
use2(install$4);
use2(install$2);
use2(install$1);
use2(install);
use2(installUniversalTransition);
use2(installLabelLayout);
var maskLayer = {
  addXzqMaskLayer(dataList, etopMap2, options) {
    if (!etopMap2)
      return;
    if (!options) {
      options = {};
    }
    function getItem2(name2, dataList2) {
      if (!(dataList2 && dataList2.length > 0))
        return null;
      const array = dataList2.filter((item) => {
        return item.name === name2;
      });
      if (array && array.length > 0) {
        return array[0];
      } else {
        return null;
      }
    }
    const layerId = "xzqMask";
    etopMap2.removeLayerByLayerId(layerId);
    const layer2 = new mars3d$1.layer.GeoJsonLayer({
      id: options.id || layerId
    });
    const height = mars3d$1.Cesium.Cartographic.fromCartesian(
      etopMap2.map.viewer.camera.position
    ).height;
    if (height < etopMap2.hideHeight) {
      layer2.show = false;
    }
    if (options.clickCallback) {
      layer2.on(mars3d$1.EventType.click, function(event) {
        if (options.highlight) {
          event.layer.graphics.forEach((item) => {
            item.openHighlight({}, true);
          });
          event.layer.graphics.forEach((item) => {
            if (event.graphic.attr.QUNAME === item.attr.QUNAME) {
              item.openHighlight(options.highlight, false);
            }
          });
        }
        options.clickCallback(event);
      });
    }
    if (options.mouseOverCallback) {
      layer2.on(mars3d$1.EventType.mouseOver, function(event) {
        if (options.highlight) {
          event.layer.graphics.forEach((item) => {
            item.openHighlight({}, true);
          });
          event.layer.graphics.forEach((item) => {
            if (event.graphic.attr.QUNAME === item.attr.QUNAME) {
              item.openHighlight(options.highlight, false);
            }
          });
        }
        options.mouseOverCallback(event);
      });
    }
    if (options.mouseOutCallback) {
      layer2.on(mars3d$1.EventType.mouseOut, function(event) {
        event.layer.graphics.forEach((item) => {
          item.openHighlight({}, true);
        });
        options.mouseOutCallback(event);
      });
    }
    etopMap2.map.addLayer(layer2);
    let xzurl = etopMap2.options.publicPath + "/map3d/region/szxzq4.geojson";
    if (!options.height) {
      options.height = 3e3;
    }
    http.get(xzurl).then((res) => {
      res.data.features.map((feat) => {
        const item = getItem2(feat.properties.QUNAME, dataList);
        feat.geometry.coordinates.map((coords) => {
          const p = new mars3d$1.graphic.PolygonEntity({
            positions: coords,
            style: {
              height: options.height === 0 ? 0 : options.height,
              extrudedHeight: 0,
              fill: true,
              color: item && item.color ? item.color : "#005AAC",
              opacity: options.opacity ? options.opacity : 0.95,
              outline: options.outline ? options.outline : true,
              outlineStyle: {
                color: item && item.color ? item.color : "#0092FF",
                width: options.outlineWidth ? options.outlineWidth : 2,
                opacity: 1
              },
              highlight: options.highlight ? options.highlight : null,
              clampToGround: false
            },
            attr: { ...feat, ...feat.properties }
          });
          layer2.addGraphic(p);
        });
      });
    });
    setTimeout(() => {
      var _a2, _b2;
      if (((_b2 = (_a2 = etopMap2.xzqLabels) == null ? void 0 : _a2._labels) == null ? void 0 : _b2.length) > 0) {
        return;
      }
      let xzbjurl = etopMap2.options.publicPath + "/map3d/region/qu_centroids.geojson";
      http.get(xzbjurl).then((res) => {
        const features2 = res.data.features;
        etopMap2.xzqLabels = etopMap2.map.viewer.scene.primitives.add(
          new mars3d$1.Cesium.LabelCollection()
        );
        if (height < etopMap2.hideHeight) {
          etopMap2.xzqLabels.show = false;
        }
        const scale4 = 0.6 * etopMap2.bigScale;
        features2.forEach((item) => {
          const coordinates = item.geometry.coordinates;
          etopMap2.xzqLabels.add({
            position: mars3d$1.Cesium.Cartesian3.fromDegrees(
              coordinates[0],
              coordinates[1],
              options.height === 0 ? 0 + 100 : options.height + 100
            ),
            text: item.properties.QNAME,
            distanceDisplayCondition: new mars3d$1.Cesium.DistanceDisplayCondition(options.minDistanceDisplayCondition || 5e4, options.maxDistanceDisplayCondition || Number.POSITIVE_INFINITY),
            horizontalOrigin: mars3d$1.Cesium.HorizontalOrigin.CENTER,
            verticalOrigin: mars3d$1.Cesium.HorizontalOrigin.TOP,
            scale: scale4,
            showBackground: true,
            backgroundColor: new mars3d$1.Cesium.Color(0, 0.35, 0.674, 0),
            scaleByDistance: new Cesium.NearFarScalar(5e4, scale4 * 2, 7e5, 0.1)
          });
        });
      });
    }, 500);
  },
  removeXzqMaskHighlight(etopMap2) {
    const xzqLayer = etopMap2.layer.getLayerById("xzqMask");
    if (xzqLayer) {
      xzqLayer.graphics.forEach((item) => {
        item.openHighlight({}, true);
      });
    }
  },
  addJdMaskLayer(etopMap2, options) {
    if (!etopMap2)
      return;
    if (!options) {
      options = {};
    }
    const layer2 = new mars3d$1.layer.GeoJsonLayer({
      id: "xzqMask",
      name: "\u8857\u9053\u62E5\u5835",
      data: geodata.jdData,
      graphicOptions: {
        vertexCacheOptimize: true,
        asynchronous: false
      },
      zIndex: 100,
      mask: true,
      symbol: {
        type: "polygonCombine",
        styleOptions: {
          height: 3e3,
          extrudedHeight: 0,
          fill: true,
          color: "#005AAC",
          opacity: 1,
          outline: true,
          outlineStyle: {
            color: "#ffffff",
            width: 1.1,
            opacity: 1
          }
        },
        merge: true,
        styleField: options.styleField || "",
        styleFieldOptions: options.styleFieldOptions || null
      }
    });
    const height = mars3d$1.Cesium.Cartographic.fromCartesian(
      etopMap2.map.viewer.camera.position
    ).height;
    if (height < etopMap2.hideHeight) {
      layer2.show = false;
    }
    if (options.clickCallback) {
      layer2.on(mars3d$1.EventType.click, function(event) {
        options.clickCallback(event);
      });
    }
    etopMap2.map.addLayer(layer2);
  },
  addExtrudedGeoJson(viewer, url, exHeight, styleFieldOptions, clickCallback) {
    viewer.scene.fxaa = true;
    viewer.scene.postProcessStages.fxaa.enabled = true;
    const promise = new mars3d$1.Cesium.GeoJsonDataSource.load(url);
    console.log(promise);
    promise.then((datasource) => {
      console.time(12);
      console.log(datasource);
      datasource.show = false;
      viewer.dataSources.add(datasource);
      const entities = datasource.entities.values;
      console.log(entities);
      let colorstr = null;
      for (let index2 = 0; index2 < entities.length; index2++) {
        const entity = entities[index2];
        if (styleFieldOptions[entity.name]) {
          colorstr = styleFieldOptions[entity.name].color;
          entity.polygon.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
          entity.polygon.height = 0;
          entity.polygon.extrudedHeightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
          entity.polygon.extrudedHeight = exHeight;
          entity.polygon.outline = false;
          entity.polygon.material = Cesium.Color.fromCssColorString(colorstr).withAlpha(0.98);
        }
        if (index2 == entities.length - 1) {
          datasource.show = true;
          console.timeEnd(12);
        }
      }
    });
    let handler = new mars3d$1.Cesium.ScreenSpaceEventHandler(
      etopMap.map.viewer.canvas
    );
    handler.setInputAction(function(movement) {
      let pickedEntity = pickEntity(viewer, movement.position);
      if (pickedEntity == void 0) {
        return;
      }
      let obj = {};
      obj.graphic = {};
      obj.graphic.attr = {};
      obj.graphic.attr.OBJECTID = pickedEntity.properties.OBJECTID._value;
      obj.graphic.attr.QUCODE = pickedEntity.properties.JDCODE._value;
      obj.graphic.attr.QUNAME = pickedEntity.properties.QUNAME._value;
      obj.graphic.type = "MultiPolygon";
      obj.graphic.coordinates = [];
      let pos = pickedEntity.polygon.hierarchy._value.positions;
      for (let i = 0; i < pos.length; i++) {
        let car3 = etopMap.map.viewer.scene.globe.ellipsoid.cartesianToCartographic(
          pos[i]
        );
        let lat2 = Cesium.Math.toDegrees(car3.latitude);
        let lng = Cesium.Math.toDegrees(car3.longitude);
        let arra = [lat2, lng];
        obj.graphic.coordinates.push(arra);
        car3 = null;
        arra = null;
      }
      obj.position = movement;
      obj.windowPosition = movement;
      obj.cartesian = etopMap.map.viewer.scene.camera.pickEllipsoid(
        { x: movement.position.x, y: movement.position.y, z: 0 },
        etopMap.map.viewer.scene.globe.ellipsoid
      );
      obj.czmObject = pickedEntity;
      clickCallback(obj);
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    function pickEntity(viewer2, windowPosition) {
      let picked = viewer2.scene.pick(windowPosition);
      if (Cesium.defined(picked)) {
        let id = Cesium.defaultValue(picked.id, picked.primitive.id);
        if (id instanceof Cesium.Entity) {
          return id;
        }
      }
      return void 0;
    }
    etopMap.map.viewer.camera.changed.addEventListener(() => {
      const height = mars3d$1.Cesium.Cartographic.fromCartesian(
        etopMap.map.viewer.camera.position
      ).height;
      if (height < 6e4) {
        etopMap.map.dataSources._dataSources[0].show = false;
      } else {
        etopMap.map.dataSources._dataSources[0].show = true;
      }
    });
  },
  addPolyExtrudeGeoJson(viewer, url, exHeight, styleFieldOptions, clickCallback) {
    viewer.scene.fxaa = true;
    viewer.scene.postProcessStages.fxaa.enabled = true;
    let features2 = null;
    if (typeof url == "object") {
      url.then((res) => {
        features2 = res.data.features;
        addDataToGlobe(features2);
      });
    } else if (typeof url == "string") {
      http.get(url).then((res) => {
        console.log(res);
        features2 = res.data.features;
        addDataToGlobe(features2);
      });
    }
    let handler = new mars3d$1.Cesium.ScreenSpaceEventHandler(
      etopMap.map.viewer.canvas
    );
    handler.setInputAction(function(movement) {
      let pickedFeature = viewer.scene.pick(movement.position);
      if (!Cesium.defined(pickedFeature)) {
        return;
      }
      let worldPosition = viewer.scene.pickPosition(movement.position);
      let featureID = Number(pickedFeature.id.split("_")[1]);
      let obj = {};
      obj.graphic = {};
      obj.graphic.attr = {};
      obj.graphic.attr.OBJECTID = features2[featureID].properties.fid;
      obj.graphic.attr.JDNAME = features2[featureID].properties.jd_name;
      obj.graphic.attr.QUNAME = features2[featureID].properties.qu_name;
      obj.graphic.attr.JDCODE = features2[featureID].properties.qu_code;
      obj.graphic.type = "MultiPolygon";
      obj.graphic.coordinates = features2[featureID].geometry;
      obj.position = movement;
      obj.windowPosition = movement;
      obj.cartesian = worldPosition;
      obj.czmObject = pickedFeature.primitive;
      obj.features = features2[featureID];
      clickCallback(obj);
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    function addDataToGlobe(features3) {
      const instances2 = [];
      for (let i = 0; i < features3.length; i++) {
        for (let j = 0; j < features3[i].geometry.coordinates.length; j++) {
          if (styleFieldOptions[features3[i].properties.jd_name]) {
            let colorstr = styleFieldOptions[features3[i].properties.jd_name];
            let objecID = "polygon_" + i;
            const polygonArray = features3[i].geometry.coordinates[j].toString().split(",");
            const polygon4 = new Cesium.PolygonGeometry({
              polygonHierarchy: new Cesium.PolygonHierarchy(
                Cesium.Cartesian3.fromDegreesArray(polygonArray)
              ),
              extrudedHeight: exHeight,
              perPositionHeight: true,
              closeBottom: true,
              closeTop: false,
              arcType: "ArcType.RHUMB"
            });
            const geometry2 = Cesium.PolygonGeometry.createGeometry(polygon4);
            instances2.push(new Cesium.GeometryInstance({
              id: objecID,
              geometry: geometry2,
              attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(colorstr.color).withAlpha(0.9))
              }
            }));
          }
        }
      }
      const primitive = new Cesium.Primitive({
        geometryInstances: instances2,
        appearance: new Cesium.PerInstanceColorAppearance({
          flat: true
        }),
        vertexCacheOptimize: true,
        releaseGeometryInstances: false
      });
      viewer.scene.primitives.add(primitive);
    }
  }
};
var customLayer = {
  ...maskLayer
};
class layer {
  constructor(map5, options) {
    this.map = map5;
    this.bigScale = options && options.bigScale || 1;
    this.viewer = map5.viewer;
    this.baseLayerConfigs = [];
    this.baseLayers = [];
    this._primitives = [];
    this._imageryLayers = [];
    this._select_primitive = null;
    this._mouseover_primitive = null;
    this.customLayer = customLayer;
  }
  loadLayers(layerConfigs) {
    if (layerConfigs.constructor !== Array) {
      return;
    }
    layerConfigs.forEach((config) => {
      this.loadLayer(config);
    });
  }
  loadBaseLayers(layerConfigs) {
    if (layerConfigs.constructor !== Array || layerConfigs.length === 0) {
      return;
    }
    this.baseLayerConfigs = layerConfigs;
    const defaultLayer = layerConfigs.find((t) => t.default);
    let index2 = 0;
    if (defaultLayer) {
      index2 = layerConfigs.indexOf(defaultLayer);
    }
    this.switchBaseLayer(index2);
  }
  switchBaseLayer(index2) {
    if (index2 >= this.baseLayerConfigs.length) {
      return;
    }
    this.baseLayers.forEach((lyr) => {
      this.clearLayerById(lyr.id);
    });
    this.baseLayers = [];
    if (index2 == -1) {
      return;
    }
    const baseLayer = this.baseLayerConfigs[index2];
    if (baseLayer.constructor === Array) {
      baseLayer.forEach((layer2) => {
        const lyr = this.loadLayer(layer2);
        this.baseLayers.push(lyr);
      });
    } else {
      const lyr = this.loadLayer(baseLayer);
      this.baseLayers.push(lyr);
    }
  }
  loadLayer(config) {
    let lyr;
    switch (config.type) {
      case "xyz":
        lyr = this.addXyzLayer(config.options);
        break;
      case "3dtiles":
        lyr = this.add3Dtiles(config.options);
        break;
      case "mesh":
        lyr = this.addMesh(config.options);
        break;
      case "wfs":
        lyr = this.addWFSLayer(config.options);
        break;
      case "urlTemplate":
        lyr = this.addUrlLayer(config.options);
        break;
      case "baseLayer_satellite":
        lyr = this.addSatellite(config.options);
        break;
      case "baseLayer_blue":
      case "shenzhen_poi":
      case "baseLayer_white":
        lyr = this.addElectricLayer(config.options);
        break;
    }
    return lyr;
  }
  clearLayerById(id) {
    const marslayer = this.map.getLayerById(id);
    if (marslayer) {
      this.map.removeLayer(marslayer);
      return;
    }
    const primitive = this._primitives.find((p) => p.id === id);
    if (primitive) {
      this._primitives.slice(this._primitives.indexOf(primitive), 1);
      this.viewer.scene.primitives.remove(primitive);
      return;
    }
    const imageryLayer = this._imageryLayers.find((p) => p.id === id);
    if (imageryLayer) {
      this._imageryLayers = this._imageryLayers.filter(
        (imagery) => imagery != imageryLayer
      );
      this.viewer.imageryLayers.remove(imageryLayer);
    }
  }
  getLayerById(id) {
    const layer2 = this.map.getLayerById(id);
    if (layer2) {
      return layer2;
    }
    const primitive = this._primitives.find((p) => p.id === id);
    if (primitive) {
      return primitive;
    }
    const imageryLayer = this._imageryLayers.find((p) => p.id === id);
    if (imageryLayer) {
      return imageryLayer;
    }
  }
  setLayerVisible(layerId, visible) {
    const lyr = this.getLayerById(layerId);
    if (lyr) {
      lyr.show = visible;
    }
  }
  add3Dtiles(options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    var resource = new Cesium.Resource({
      url: options.url,
      headers: options.headers
    });
    const tileset = new mars3d.layer.TilesetLayer({
      type: "3dtiles",
      show: options.show,
      id: options.id,
      url: resource,
      name: options.name,
      flyTo: options.flyTo,
      baseScreenSpaceError: 512,
      cullRequestsWhileMovingMultiplier: 0.01,
      preloadWhenHidden: true,
      progressiveResolutionHeightFraction: 0.1,
      dynamicScreenSpaceErrorDensity: 500,
      dynamicScreenSpaceErrorFactor: 1,
      maximumScreenSpaceError: 16,
      maximumMemoryUsage: 2048,
      shadows: Cesium.ShadowMode.DISABLED,
      preloadFlightDestinations: true,
      preferLeaves: true,
      skipLevelOfDetail: true,
      immediatelyLoadDesiredLevelOfDetail: true,
      skipScreenSpaceErrorFactor: 16,
      skipLevels: 1,
      loadSiblings: true,
      dynamicScreenSpaceError: true,
      foveatedTimeDelay: 0.2,
      style: {
        color: {
          conditions: options.colorConditions || []
        }
      },
      luminanceAtZenith: options.luminanceAtZenith || 0.2
    });
    if (options.callback) {
      tileset.on(mars3d.EventType.load, options.callback);
    }
    this.map.addLayer(tileset);
    return tileset;
  }
  addXyzLayer(options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    const xyzLayer = new mars3d.layer.XyzLayer({
      show: options.show,
      id: options.id,
      url: options.url,
      name: options.name,
      type: "xyz",
      zIndex: 0,
      minimumLevel: 0,
      maximumLevel: 17
    });
    this.map.addLayer(xyzLayer);
    return xyzLayer;
  }
  addUrlLayer(options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    var res = new Cesium.Resource({
      url: options.url,
      headers: options.headers
    });
    const xyzoptions = {
      id: options.id,
      url: res,
      flyTo: options.flyTo
    };
    xyzoptions.tilingScheme = new Cesium.GeographicTilingScheme();
    xyzoptions.minimumLevel = 0;
    xyzoptions.customTags = {
      sz: function(imageryProvider, x2, y2, level) {
        return level - 9;
      }
    };
    const xyzLayer = new mars3d.layer.XyzLayer(xyzoptions);
    this.map.addLayer(xyzLayer);
    xyzLayer.id = options.id;
    xyzLayer.show = options.show;
    return xyzLayer;
  }
  addGeojsonLayer(options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    const geoJsonLayer = new mars3d.layer.GeoJsonLayer({
      url: options.url,
      id: options.id,
      mask: options.mask,
      data: options.data,
      symbol: options.symbol,
      zIndex: options.zIndex,
      flyTo: options.flyTo,
      pointerEvents: true
    });
    if (options.callback) {
      geoJsonLayer.on(mars3d.EventType.load, options.callback);
    }
    this.map.addLayer(geoJsonLayer);
    return geoJsonLayer;
  }
  addMesh(options) {
    var resource = new Cesium.Resource({
      url: options.url,
      headers: options.headers
    });
    const meshTiles = new Cesium.Cesium3DTileset({
      url: resource,
      maximumScreenSpaceError: 16,
      preferLeaves: true,
      skipLevelOfDetail: true,
      skipLevels: 1,
      skipScreenSpaceErrorFactor: 16,
      loadSiblings: true,
      cullRequestsWhileMovingMultiplier: 0.01,
      preloadWhenHidden: true,
      progressiveResolutionHeightFraction: 0.1,
      dynamicScreenSpaceErrorDensity: 500,
      dynamicScreenSpaceErrorFactor: 1,
      dynamicScreenSpaceError: true
    });
    this.viewer.scene.primitives.add(meshTiles);
    meshTiles.show = options.show;
    meshTiles.id = options.id;
    this._primitives.push(meshTiles);
    return meshTiles;
  }
  addSatellite(options) {
    var conf = {
      id: options.id,
      url: options.url,
      show: options.show,
      type: "xyz",
      zIndex: 0,
      minimumLevel: 0,
      maximumLevel: 18
    };
    if (options.url.indexOf("{s}") > -1) {
      conf.subdomains = "1234";
    }
    if (options.headers) {
      conf.headers = options.headers;
    }
    const baseLayer = new mars3d.layer.XyzLayer(conf);
    this.map.addLayer(baseLayer);
    return baseLayer;
  }
  addElectricLayer(options) {
    var res = new Cesium.Resource({
      url: options.url,
      headers: options.headers
    });
    var image = new Cesium.UrlTemplateImageryProvider({
      id: options.id,
      url: res,
      name: options.name,
      show: options.show,
      tilingScheme: new Cesium.GeographicTilingScheme(),
      minimumLevel: 0,
      maximumLevel: 17,
      minimumLevel: 0,
      customTags: {
        sz: function(imageryProvider, x2, y2, level) {
          return level - 9;
        }
      }
    });
    const urlTemplateImageryProvider = this.viewer.imageryLayers.addImageryProvider(image);
    this._imageryLayers.push(urlTemplateImageryProvider);
    urlTemplateImageryProvider.id = options.id;
    return urlTemplateImageryProvider;
  }
  addWFSLayer(options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    const geoJsonLayer = new mars3d.layer.GeoJsonLayer({
      id: options.id,
      name: options.name,
      url: `${options.url}?service=WFS&version=1.0.0&request=GetFeature&typeName=${options.layer}&outputFormat=application/json`,
      headers: options.headers,
      show: options.show,
      symbol: options.symbol
    });
    this.map.addLayer(geoJsonLayer);
    return geoJsonLayer;
  }
  addWMSLayer(options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    const wmsLayer = new mars3d.layer.WmsLayer({
      id: options.id,
      name: options.name,
      url: options.url,
      layers: options.layers,
      headers: options.headers,
      show: options.show
    });
    this.map.addLayer(wmsLayer);
    return wmsLayer;
  }
  addGaodeLayer(options) {
    const gaodeLayer = new mars3d.layer.GaodeLayer({
      id: options.id,
      layer: options.layer,
      brightness: options.brightness,
      alpha: options.alpha,
      contrast: options.contrast,
      hue: options.hue,
      saturation: options.saturation,
      gamma: options.gamma
    });
    this.map.addLayer(gaodeLayer);
    return gaodeLayer;
  }
  addBaiduLayer(options) {
    const baiduLayer = new mars3d.layer.BaiduLayer({
      id: options.id,
      layer: options.layer,
      brightness: options.brightness,
      alpha: options.alpha,
      contrast: options.contrast,
      hue: options.hue,
      saturation: options.saturation,
      gamma: options.gamma
    });
    this.map.addLayer(baiduLayer);
    return baiduLayer;
  }
  addLabels(data, options, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(options.id);
    }
    let graphicLayer2;
    if (options.id) {
      graphicLayer2 = this.map.getLayerById(options.id);
    }
    if (!graphicLayer2) {
      graphicLayer2 = new mars3d.layer.GraphicLayer({
        id: options.id,
        zIndex: options.zIndex
      });
      this.map.addLayer(graphicLayer2);
    }
    if (!(data && data.length > 0))
      return;
    data.forEach((item) => {
      const coor = item.position;
      const label = new mars3d.graphic.LabelEntity({
        position: new mars3d.LatLngPoint(coor[0], coor[1], coor[2]),
        style: {
          text: item.name,
          color: options.color,
          font_size: options.fontSize,
          font_weight: options.fontWeight,
          pixelOffsetY: options.pixelOffsetY || -30,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
            options.distanceDisplayConditionMin || 0,
            options.distanceDisplayConditionMax || 999999999999
          ),
          clampToGround: options.clampToGround ? options.clampToGround : false
        },
        attr: { ...item }
      });
      graphicLayer2.addGraphic(label);
    });
    return graphicLayer2;
  }
  addBillboards(data, options = {}, clearFlag = true) {
    try {
      this.rmBillboards();
      this.billboards = this.map.viewer.scene.primitives.add(
        new Cesium.BillboardCollection()
      );
      this.labels = this.map.viewer.scene.primitives.add(
        new Cesium.LabelCollection()
      );
      const scale4 = (options.billScale || 1) * this.bigScale;
      const highlightScale = ((options.billScale || 1) + 0.3) * this.bigScale;
      data.forEach((item) => {
        const coor = item.position;
        const pos = Cesium.Cartesian3.fromDegrees(coor[0], coor[1], coor[2]);
        this.billboards.add({
          id: item.id + "-" + item.text,
          position: pos,
          image: item.image,
          color: options.color,
          scale: scale4,
          disableDepthTestDistance: options.billDisableDepthTestDistance || Number.POSITIVE_INFINITY,
          distanceDisplayCondition: options.billDistanceDisplayCondition,
          eyeOffset: options.billEyeOffset,
          height: options.height,
          heightReference: options.billHeightReference,
          horizontalOrigin: options.horizontalOrigin,
          pixelOffset: options.billPixelOffset,
          pixelOffsetScaleByDistance: options.pixelOffsetScaleByDistance,
          rotation: options.rotation,
          scaleByDistance: options.billScaleByDistance,
          show: options.billShow,
          sizeInMeters: options.sizeInMeters,
          translucencyByDistance: options.billTranslucencyByDistance,
          verticalOrigin: options.billVerticalOrigin,
          width: options.width
        });
      });
      this.billMoveHandler = new Cesium.ScreenSpaceEventHandler(
        this.map.viewer.canvas
      );
      const scene = this.map.viewer.scene;
      this.billMoveHandler.setInputAction((event) => {
        if (this.labels) {
          this.labels.removeAll();
        }
        const feature2 = scene.pick(event.endPosition);
        if (feature2 && feature2.primitive && feature2.primitive.id) {
          if (!(this._select_primitive && feature2.primitive.id === this._select_primitive.id)) {
            feature2.primitive.scale = highlightScale;
            this._mouseover_primitive = feature2.primitive;
          }
          const id = feature2.primitive.id;
          const name2 = id.split("-")[1];
          this.labels.add({
            position: feature2.primitive.position,
            text: name2,
            scale: scale4,
            backgroundColor: options.backgroundColor,
            backgroundPadding: options.backgroundPadding,
            disableDepthTestDistance: options.labelDisableDepthTestDistance || Number.POSITIVE_INFINITY,
            distanceDisplayCondition: options.labelDistanceDisplayCondition,
            eyeOffset: options.labelEyeOffset,
            fillColor: options.fillColor,
            font: options.font,
            heightReference: options.labelHeightReference,
            horizontalOrigin: options.labelHorizontalOrigin,
            outlineColor: options.outlineColor,
            outlineWidth: options.outlineWidth,
            pixelOffset: options.labelPixelOffset,
            pixelOffsetScaleByDistance: options.labelPixelOffsetScaleByDistance,
            scaleByDistance: options.labelScaleByDistance,
            show: options.labelShow,
            style: options.style,
            totalScale: options.totalScale,
            translucencyByDistance: options.labelTranslucencyByDistance,
            verticalOrigin: options.labelVerticalOrigin
          });
        } else {
          if (this._mouseover_primitive && !(this._select_primitive && this._mouseover_primitive.id === this._select_primitive.id)) {
            this._mouseover_primitive.scale = scale4;
            this._mouseover_primitive = null;
          }
        }
        console.log("\u9F20\u6807\u79FB\u52A8");
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      if (options.callback) {
        this.billClickHandler = new Cesium.ScreenSpaceEventHandler(
          this.map.viewer.canvas
        );
        this.billClickHandler.setInputAction((event) => {
          const feature2 = this.map.viewer.scene.pick(event.position);
          if (feature2 && feature2.primitive && feature2.primitive.id) {
            if (this._select_primitive && feature2.primitive.id === this._select_primitive.id) {
              this._select_primitive.scale = scale4;
              this._select_primitive = null;
            } else if (this._select_primitive && feature2.primitive.id !== this._select_primitive.id) {
              this._select_primitive.scale = scale4;
              this._select_primitive = null;
              this._select_primitive = feature2.primitive;
              this._select_primitive.scale = highlightScale;
            } else {
              this._select_primitive = feature2.primitive;
              this._select_primitive.scale = highlightScale;
            }
            options.callback(
              feature2.id.split("-")[0],
              feature2.primitive.position
            );
          }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
      }
    } catch (error2) {
      console.error("addBillboards", error2);
    }
  }
  rmBillboards() {
    if (this.billboards) {
      this.map.viewer.scene.primitives.remove(this.billboards);
      this.billboards = null;
    }
    if (this.labels) {
      this.map.viewer.scene.primitives.remove(this.labels);
      this.labels = null;
    }
    if (this.billMoveHandler) {
      this.billMoveHandler.destroy();
      this.billMoveHandler = null;
    }
    if (this.billClickHandler) {
      this.billClickHandler.destroy();
      this.billClickHandler = null;
    }
  }
  setGraphicVisible(id, visible = true) {
    if (!this.billboards) {
      return;
    }
    for (let i = 0, len2 = this.billboards.length; i < len2; i++) {
      const billboard = this.billboards.get(i);
      if (billboard.id.split("-")[0] == id) {
        billboard.show = visible;
      }
    }
  }
  setGraphicsVisible(ids = [], visible = true) {
    if (!this.billboards) {
      return;
    }
    for (let i = 0, len2 = this.billboards.length; i < len2; i++) {
      const billboard = this.billboards.get(i);
      ids.indexOf(billboard.id.split("-")[0]) !== -1 ? billboard.show = visible : "";
    }
  }
  addFewBillboards(data, options = {}, clearFlag = true) {
    try {
      if (clearFlag) {
        this.clearLayerById(options.id);
      }
      let graphicLayer2;
      if (options.id) {
        graphicLayer2 = this.map.getLayerById(options.id);
      }
      if (!graphicLayer2) {
        graphicLayer2 = new mars3d.layer.GraphicLayer({
          id: options.id
        });
        this.map.addLayer(graphicLayer2);
        if (options.callback) {
          graphicLayer2.on(mars3d.EventType.click, (e2) => {
            options.callback(e2.graphic.attr, e2.graphic, e2.cartesian);
          });
        }
      }
      const scale4 = (options.scale || 1) * this.bigScale;
      const highlightScale = ((options.scale || 1) + 0.3) * this.bigScale;
      data.forEach((item) => {
        let coor = item.position;
        var label = new mars3d.graphic.BillboardEntity({
          position: new mars3d.LatLngPoint(coor[0], coor[1], coor[2]),
          style: {
            image: item.image,
            scaleByDistance: options.scaleByDistance,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            horizontalOrigin: options.horizontalOrigin,
            verticalOrigin: options.verticalOrigin,
            distanceDisplayCondition: options.distanceDisplayCondition,
            scale: scale4,
            label: options.label && {
              text: item.name,
              color: options.label.color,
              font_size: options.label.fontSize,
              font_weight: options.label.fontWeight,
              font_family: options.label.font_family,
              horizontalOrigin: options.label.horizontalOrigin,
              verticalOrigin: options.label.verticalOrigin,
              pixelOffset: options.label.pixelOffset,
              pixelOffsetScaleByDistance: options.label.pixelOffsetScaleByDistance,
              scaleByDistance: options.label.scaleByDistance,
              distanceDisplayCondition: options.label.distanceDisplayCondition,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              scale: scale4
            },
            highlight: {
              type: mars3d.EventType.click,
              scale: highlightScale
            }
          },
          attr: { ...item, image: null }
        });
        graphicLayer2.addGraphic(label);
      });
      return graphicLayer2;
    } catch (error2) {
      console.error("addFewBillboards", error2);
      return;
    }
  }
  createEmptyGraphicLayer() {
    const graphicLayer2 = new mars3d.layer.GraphicLayer();
    this.map.addLayer(graphicLayer2);
    return graphicLayer2;
  }
}
class GzLayer {
  constructor(map5, options) {
    __publicField(this, "getCesiumUrl", (option, needKey) => {
      return new Cesium.Resource({
        url: this.PROXY_IP + option.url,
        headers: needKey ? {
          "szvsud-license-key": this.SZVSUD_LICENSE_KEY
        } : {},
        retryCallback: (resource, error2) => {
          if (error2) {
            if (error2.statusCode === 401) {
              console.log(option.name + "\u65E0\u8BBF\u95EE\u6743\u9650");
            } else if (error2.statusCode === 404) {
              console.log(option.name + "\u8D44\u6E90\u627E\u4E0D\u5230");
            }
          }
          return false;
        },
        retryAttempts: 1
      });
    });
    this.map = map5;
    this.BASE_LAYERS_CONFIG = options.basemaps;
    this.PROXY_IP = options.gz_path;
    this.SZVSUD_LICENSE_KEY = options.licenseKey;
    this.hideHeight = 5e4;
    if (options.hideHeight) {
      this.hideHeight = options.hideHeight;
    }
    this.currBaseLayers = [];
    this.layer = new layer(map5, { bigScale: options.bigScale });
    const camera = this.map.viewer.camera;
    camera.percentageChanged = 0.2;
    camera.changed.addEventListener(() => {
      const coor = Cesium.Cartographic.fromCartesian(camera.position);
      const height = coor.height;
      const xzqLayer = this.layer.getLayerById("xzqMask");
      const szwall = this.layer.getLayerById("szwall");
      if (height < this.hideHeight) {
        if (xzqLayer) {
          xzqLayer.show = false;
        }
        if (this.xzqLabels) {
          this.xzqLabels.show = false;
        }
        if (szwall) {
          szwall.show = false;
        }
        if (this.photography) {
          this.photography.show = true;
        }
        if (this.gzBlueLayer) {
          this.gzBlueLayer.show = true;
        }
        if (this.gzWhiteLayer) {
          this.gzWhiteLayer.show = true;
        }
        if (this.gzSatellite) {
          this.gzSatellite.show = true;
        }
        if (this.gzSatelliteST) {
          this.gzSatelliteST.show = true;
        }
      } else {
        if (xzqLayer) {
          xzqLayer.show = true;
        }
        if (this.xzqLabels) {
          this.xzqLabels.show = true;
        }
        if (szwall) {
          szwall.show = true;
        }
        if (this.photography) {
          this.photography.show = false;
        }
        if (this.gzBlueLayer) {
          this.gzBlueLayer.show = false;
        }
        if (this.gzWhiteLayer) {
          this.gzWhiteLayer.show = false;
        }
        if (this.gzSatellite) {
          this.gzSatellite.show = false;
        }
        if (this.gzSatelliteST) {
          this.gzSatelliteST.show = false;
        }
      }
      if (this.whiteModel) {
        if (this.map.level < 14) {
          this.whiteModel.show = false;
        } else {
          this.whiteModel.show = true;
          this.whiteModel.style = new Cesium.Cesium3DTileStyle({
            color: 'color("#fff",0.4)'
          });
        }
      }
    });
  }
  loadBaseLayer(name2) {
    this.rmGzBlueLayer();
    this.rmGzSatellite();
    this.rmGzSatelliteST();
    this.rmWhiteModel();
    this.rmPhotography();
    switch (name2) {
      case "\u7535\u5B50\u5730\u56FE":
        this.addGzBlueLayer();
        break;
      case "\u767D\u8272\u7248":
        this.addGzWhiteLayer();
        break;
      case "\u536B\u661F\u5F71\u50CF":
        this.addGzSatellite();
        break;
      case "\u4E09\u7EF4\u767D\u6A21":
        this.addGzBlueLayer();
        this.addWhiteModel();
        break;
      case "\u503E\u659C\u6444\u5F71":
        this.addPhotography();
        break;
      default:
        this.addGzBlueLayer();
    }
  }
  addGzBlueLayer() {
    this.rmGzBlueLayer();
    this.gzBlueLayer = this.addGzXyzLayer(this.BASE_LAYERS_CONFIG.gzBlueSatellite.option);
  }
  rmGzBlueLayer() {
    if (!this.gzBlueLayer) {
      return;
    }
    this.map.viewer.imageryLayers.remove(this.gzBlueLayer);
    this.gzBlueLayer = null;
  }
  addGzWhiteLayer() {
    this.rmGzWhiteLayer();
    this.gzWhiteLayer = this.addGzXyzLayer(this.BASE_LAYERS_CONFIG.gzWhiteSatellite.option);
  }
  rmGzWhiteLayer() {
    if (!this.gzWhiteLayer) {
      return;
    }
    this.map.viewer.imageryLayers.remove(this.gzWhiteLayer);
    this.gzWhiteLayer = null;
  }
  addGzSatellite() {
    this.rmGzSatellite();
    this.gzSatellite = this.addLayer_XYZ(this.BASE_LAYERS_CONFIG.gzSatellite.option);
    this.addGzSatelliteST();
  }
  rmGzSatellite() {
    if (!this.gzSatellite) {
      return;
    }
    this.map.removeLayer(this.gzSatellite);
    this.gzSatellite = null;
  }
  addGzSatelliteST() {
    this.rmGzSatelliteST();
    this.gzSatelliteST = this.addLayer_XYZ(this.BASE_LAYERS_CONFIG.gzSatelliteST.option);
  }
  rmGzSatelliteST() {
    if (!this.gzSatelliteST) {
      return;
    }
    this.map.removeLayer(this.gzSatelliteST);
    this.gzSatelliteST = null;
  }
  addWhiteModel(options = {}) {
    this.rmWhiteModel();
    this.whiteModel = new Cesium.Cesium3DTileset({
      url: this.getCesiumUrl(this.BASE_LAYERS_CONFIG.gzWhiteModel.option, true)
    });
    this.whiteModel.style = new Cesium.Cesium3DTileStyle({
      color: 'color("#fff",0.4)'
    });
    if (options == null ? void 0 : options.clickCallback) {
      const eventHandler = new Cesium.ScreenSpaceEventHandler(
        this.map.viewer.canvas
      );
      eventHandler.setInputAction((event) => {
        const pick = this.map.viewer.scene.pick(event.position);
        if (pick && pick.pickId) {
          options.clickCallback(pick);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
    if (options == null ? void 0 : options.mouseCallback) {
      const eventHandler = new Cesium.ScreenSpaceEventHandler(
        this.map.viewer.canvas
      );
      eventHandler.setInputAction((event) => {
        const pick = this.map.viewer.scene.pick(event.endPosition);
        const position2 = this.map.viewer.scene.pickPosition(event.endPosition);
        const cartographic = new Cesium.Cartographic.fromCartesian(position2);
        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
        options.mouseCallback(pick, {
          longitude,
          latitude
        });
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
    if (this.map.level < 14) {
      this.whiteModel.show = false;
    }
    this.map.viewer.scene.primitives.add(this.whiteModel);
    return this.whiteModel;
  }
  rmWhiteModel() {
    if (!this.whiteModel) {
      return;
    }
    this.map.viewer.scene.primitives.remove(this.whiteModel);
    this.whiteModel = null;
  }
  addPhotography() {
    this.rmPhotography();
    this.photography = new Cesium.Cesium3DTileset({
      url: this.getCesiumUrl(this.BASE_LAYERS_CONFIG.gzSZTiles.option, true),
      maximumScreenSpaceError: 16,
      preferLeaves: true,
      skipLevelOfDetail: true,
      baseScreenSpaceError: 512,
      skipLevels: 1,
      skipScreenSpaceErrorFactor: 16,
      loadSiblings: true,
      cullRequestsWhileMovingMultiplier: 0.01,
      preloadWhenHidden: true,
      progressiveResolutionHeightFraction: 0.1,
      dynamicScreenSpaceErrorDensity: 500,
      dynamicScreenSpaceErrorFactor: 1,
      dynamicScreenSpaceError: true
    });
    const height = Cesium.Cartographic.fromCartesian(
      this.map.viewer.camera.position
    ).height;
    if (height >= 6e4) {
      this.photography.show = false;
    }
    this.map.viewer.scene.primitives.add(this.photography);
  }
  rmPhotography() {
    if (!this.photography) {
      return;
    }
    this.map.viewer.scene.primitives.remove(this.photography);
    this.photography = null;
  }
  addLayer_XYZ(option, clearFlag = true) {
    if (clearFlag) {
      this.clearLayerById(option.id);
    }
    const XyzLayer = new mars3d.layer.XyzLayer({
      id: option.id,
      name: option.name,
      url: this.PROXY_IP + option.url,
      minimumLevel: 0,
      maximumLevel: 17,
      subdomains: "1234",
      headers: {
        "szvsud-license-key": this.SZVSUD_LICENSE_KEY
      }
    });
    const height = Cesium.Cartographic.fromCartesian(
      this.map.viewer.camera.position
    ).height;
    if (height > 5e4) {
      XyzLayer.show = false;
    }
    this.map.addLayer(XyzLayer);
    return XyzLayer;
  }
  addGzXyzLayer(option) {
    const imageryProvider = new Cesium.UrlTemplateImageryProvider({
      url: this.getCesiumUrl(option, true),
      name: option.name,
      tilingScheme: new Cesium.GeographicTilingScheme(),
      minimumLevel: 0,
      maximumLevel: 17,
      customTags: {
        sz: function(imageryProvider2, x2, y2, level) {
          return level - 9;
        }
      }
    });
    const imageryLayer = this.map.viewer.imageryLayers.addImageryProvider(imageryProvider);
    const height = Cesium.Cartographic.fromCartesian(
      this.map.viewer.camera.position
    ).height;
    if (height >= 6e4) {
      imageryLayer.show = false;
    }
    return imageryLayer;
  }
  clearLayerById(id) {
    let map5 = this.map;
    if (!Array.isArray(id)) {
      id = [id];
    }
    id.map((i) => {
      const layer2 = map5.getLayerById(i);
      layer2 && map5.removeLayer(layer2);
    });
  }
}
var educationLayerUtils = {
  showEdulandWfs(params) {
    if (!params) {
      params = {};
    }
    try {
      window.etopMap.map.getLayerById("edulandWfsLayerId") && window.etopMap.map.removeLayer(window.etopMap.map.getLayerById("edulandWfsLayerId"));
      const graphicLayer2 = new mars3d$1.layer.GraphicLayer({ id: "edulandWfsLayerId", zIndex: 97 });
      window.etopMap.map.addLayer(graphicLayer2);
      if (params.clickCallback) {
        graphicLayer2.on(mars3d$1.EventType.click, function(evt) {
          params.clickCallback(evt);
        });
      }
      http.get(
        "/geoserver/gxj_20/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=gxj_20%3Aeduland&outputFormat=application%2Fjson",
        {
          headers: {
            "szvsud-license-key": "X/RF5zkOrX9RkW/DuWoAn6p0iE7kZbHfDdVThH+vjey2Rfoz8tarcELoNAzNO8D7",
            "content-type": "application/json"
          }
        }
      ).then((result) => {
        result.data.features.map((feat) => {
          feat.geometry.coordinates.map((coords) => {
            const p = new mars3d$1.graphic.PolygonEntity({
              positions: coords,
              style: {
                fill: params.fill ? params.fill : false,
                color: params.color ? params.color : "#FB8E00",
                opacity: params.opacity ? params.opacity : 0,
                outline: params.outline ? params.outline : true,
                outlineStyle: {
                  color: params.outlineColor ? params.outlineColor : "#FB8E00",
                  width: params.outlineWidth ? params.outlineWidth : 4,
                  opacity: 1,
                  material: mars3d$1.MaterialUtil.createMaterialProperty(
                    mars3d$1.MaterialType.Color,
                    {
                      color: params.outlineColor ? params.outlineColor : "#FB8E00"
                    }
                  )
                },
                clampToGround: true
              }
            });
            graphicLayer2.addGraphic(p);
          });
        });
      });
    } catch (error2) {
      console.error("showEdulandWfs", error2);
    }
  }
};
const addGeojsonLayer = (options) => {
  if (!options) {
    options = {};
  }
  if (!(options.data && options.data.features && options.data.features.length > 0))
    return;
  const graphicLayer2 = new mars3d$1.layer.GraphicLayer({ zIndex: options.zIndex || 9 });
  window.etopMap.map.addLayer(graphicLayer2);
  options.data.features.map((feat) => {
    feat.geometry.coordinates.map((coords) => {
      const p = new mars3d$1.graphic.PolygonEntity({
        positions: coords,
        style: {
          fill: options.fill ? options.fill : true,
          color: options.color ? options.color : "#FF6464",
          opacity: options.opacity ? options.opacity : 0.33,
          outline: options.outline ? options.outline : true,
          outlineStyle: {
            color: options.outlineColor ? options.outlineColor : "#FF6464",
            width: options.outlineWidth ? options.outlineWidth : 3,
            opacity: 1
          },
          clampToGround: true
        },
        flyTo: true
      });
      graphicLayer2.addGraphic(p);
    });
  });
  if (options.clickCallback) {
    graphicLayer2.on(mars3d$1.EventType.click, function(event) {
      options.clickCallback(event);
    });
  }
  return graphicLayer2;
};
const addEtopGeojsonLayer = (params) => {
  if (!params) {
    params = {};
  }
  if (!(params.id && params.url)) {
    return;
  }
  try {
    window.etopMap.map.getLayerById(params.id) && window.etopMap.map.removeLayer(window.etopMap.map.getLayerById(params.id));
    const graphicLayer2 = new mars3d$1.layer.GraphicLayer({
      id: params.id,
      zIndex: params.zIndex || 97
    });
    window.etopMap.map.addLayer(graphicLayer2);
    if (params.clickCallback) {
      graphicLayer2.on(mars3d$1.EventType.click, function(evt) {
        params.clickCallback(evt);
      });
    }
    http.get(params.url, {
      headers: {
        "szvsud-license-key": "X/RF5zkOrX9RkW/DuWoAn6p0iE7kZbHfDdVThH+vjey2Rfoz8tarcELoNAzNO8D7",
        "contetn-type": "application/json"
      }
    }).then((result) => {
      result.data.features.map((feat) => {
        feat.geometry.coordinates.map((coords) => {
          const p = new mars3d$1.graphic.PolygonEntity({
            positions: coords,
            style: {
              fill: params.fill ? params.fill : false,
              color: params.color ? params.color : "#FB8E00",
              opacity: params.opacity ? params.opacity : 0,
              outline: params.outline ? params.outline : true,
              outlineStyle: {
                color: params.outlineColor ? params.outlineColor : "#FB8E00",
                width: params.outlineWidth ? params.outlineWidth : 4,
                opacity: 1,
                material: mars3d$1.MaterialUtil.createMaterialProperty(mars3d$1.MaterialType.Color, {
                  color: params.outlineColor ? params.outlineColor : "#FB8E00"
                })
              },
              clampToGround: true
            }
          });
          graphicLayer2.addGraphic(p);
        });
      });
    });
  } catch (error2) {
    console.error("addEtopGeojsonLayer", error2);
  }
};
class HeatLayer {
  constructor(map5, options) {
    this.map = map5;
  }
  addHeatMap(option, moveCallback, clickCallback) {
    const heatLayer = new mars3d.layer.HeatLayer({
      id: option.id,
      positions: option.positions,
      heatStyle: {
        radius: option.radius || 100,
        blur: option.blur || 0.87,
        gradient: option.gradient || {
          0.7: "#67CC40",
          0.752: "#FDDF05",
          0.8: "#FB7003",
          0.9: "#FC0A00"
        }
      },
      style: {
        height: option.height,
        opacity: option.opacity || 0.6,
        classificationType: option.classificationType || Cesium.ClassificationType.BOTH,
        clampToGround: option.clampToGround || false
      }
    });
    this.map.addLayer(heatLayer);
    moveCallback && this.map.on(mars3d.EventType.mouseMove, moveCallback);
    clickCallback && this.map.on(mars3d.EventType.click, clickCallback);
    return heatLayer;
  }
  rmHeatMapById(id) {
    const heatLayer = this.map.getLayerById(id);
    if (!heatLayer) {
      return;
    }
    this.map.removeLayer(heatLayer);
  }
}
class PolylineTrailLinkMaterialProperty {
  constructor(color, duration) {
    this._definitionChanged = new mars3d$1.Cesium.Event();
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = color;
    this.duration = duration || 3e3;
    this._time = new Date().getTime();
    this.isTranslucent = function() {
      return true;
    };
  }
  getType() {
    return "PolylineTrailLink";
  }
  getValue(time, result) {
    if (!mars3d$1.Cesium.defined(result)) {
      result = {};
    }
    result.color = mars3d$1.Cesium.Property.getValueOrClonedDefault(
      this._color,
      time,
      mars3d$1.Cesium.Color.WHITE,
      result.color
    );
    result.image = mars3d$1.Cesium.Material.PolylineTrailLinkImage;
    result.time = (new Date().getTime() - this._time) % this.duration / this.duration;
    return result;
  }
  equals(other) {
    return this === other || other instanceof PolylineTrailLinkMaterialProperty && mars3d$1.Cesium.Property.equals(this._color, other._color);
  }
}
Object.defineProperties(PolylineTrailLinkMaterialProperty.prototype, {
  isConstant: {
    get: function() {
      return false;
    }
  },
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  color: mars3d$1.Cesium.createPropertyDescriptor("color")
});
mars3d$1.Cesium.PolylineTrailLinkMaterialProperty = PolylineTrailLinkMaterialProperty;
mars3d$1.Cesium.Material.PolylineTrailLinkType = "PolylineTrailLink";
mars3d$1.Cesium.Material.PolylineTrailLinkImage = new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQEAAAAgCAYAAAASa83aAAAAAXNSR0IArs4c6QAAIX9JREFUeAHtnFuSJMdxrrOqe24ARgJIQqJksmPHzsN54KsWIGyC69FgE9oEFyFqEeKDpAeZzCRRBvGQh7jMYPpS+r7/D8+sAbbQ0V0ZER5+i0h3j0tm1elyuZy+3L48vdm27YttO2/b32yfb1+dv9l+e3q7vT4B3r7e3gPfttfbZ+e77evA7rcXp1fb3fl+e3562J4B++P2sP2E8rvTi+0e/E+25+TfQvdyuzk9bu/53JyebQ/nt8BeUL6n/Hy7C/x7YM+AXbYzOGdg9/B6jFxhF+q3yVt+3PGsP/yg/RTYebtAf7tdtkfqws7weDi951Nep9PNgt8Ba/lxh0mzhXdl3ES+fB6Bn07n0IpjHUjk2V6c4Vc+G3pcztI8gKtuB/1lh4krXJ7lY/3RMVr8R9Z2vigyssQvT2Qs2Lb4VK7t4EfmI+Ug5X5XTtsdr7NGAO8L9Btyg3tufgE+sjb0E9VcmVam7/KRrjmliLMuLnS0nQDu/EIvnu2lgxvtypXvY+DSqJM4Fr20v4W1W+LQ29EPtNal6ZiVRrz2x3phtpe3Mq5l2d429Qff4QmO+SFfnIyNGZ/ShSTjJcxU+ut2GjI+pbvmo/5JZwr7PQGyy+qYDs/2d/GxAt/SS9Ni8tw/xjBKbr/cfnX+avv89PX2T0F6t312+nz79vyvUPzF9vHp9fbu/FvKD9vL0ycrKBgAXhMA7rfvMOJncf6H7Tb0BgPLj9v3p5fkBI0YhsHgWZz75faYAKDD352eEwB0ep1bJXX6Z9ur07vkZxxzAsI9N+4lNObjzDqpDq1RPSx6b/jhvI87vYHAtsPJLNdh5XE+GRDUoUFEXS7ntlc3bngMQLprh225vDecVjr51KgHLt8zeipfR9OAuAKWqUZhkPAGlq7yxZNGvsI1Ot11ZHCTQz9OKp/iyTSB5Vy+h5MVR/mPGlMMTLk63ofyD10WTfql/uKJrFx5TEC03r7Ju23lG4JF30BVPjs88tE9vI82u2eqc7af42DCHB/HTx3AimLCil/d0C51u5ogoc7S5DPOf90veZHkGRqLjus1TmUNH1nWpxYd2QWB2uIH8KWb+CZx9j4IEL76PPIDs23pI4p+ERaBUXIcVv93+mtee3npnYnh8oaVwK+2X15+vX11eb3958UAoCSTAcDcAPATnO9zKyQDgPkf+OtKYNu+2+4u32336pD0Cuc3AHxH7bw9XAwAbWkAaHljxXAT+Gl7htc8Xl6k4QU37J7gYHqPvMfF9zlz+8C37S7tXu6Cc7/dgHcb6E2CBNjUTsCfsdYw1ZmKY09uF74hjkB0sYWgg06W5iZJKW1XDDetrmtrOtkDUVWgMoQ6i1s3WT+cVJ1OjMmJPmscSKYZI6Xe2V8ay1xX3+VQfgaAOhVrueDIq/RkS6YGW/3lXjlyNRVHHsU5wee85GcVEKyhTyU0tUsNeikFvbzQHN2B8T84DQDSoqMRkcCwOCmWRAAyS1l6+zA4AA0ktpM6rimtPgXMBQcLl+oj3k5D51tWvvD+JTDIU2VXspw6oGogpf0/cIQfY1tCRm3JkJ96LulkKa3qcEnASgu8UTbsg2MZLBGtL8MzqwrqTuPip/SgLvzgQC+LoRXnGr/lxWD4aH9tYCVw+mL7DSuBv8Bxfy+jpBfbt5f32++ZlT+7/L/t3cXtwO32PY7ynoDx7enT7VOM++7ysL2F6Wv+jvSWgMBMfvlo+yhAA4HbgO/Jzzj8zPotNxC4UXBrYDpvt0uPCQWFGxDeU3yOU9et3Uq01Ktur1vdXO7j5KkSJu6C1YCi85u8Fr+z9yOrFmlNli6XG3AKayAaR7+JWweRUmuuGArplT6uPsQN4XUEijr42EwdnNvBTKgzlK5B4TGrA8ty1Vl1n1MCgvLq4JgoTiO/sds6JiQgGSQaYHAa6E8gXuuqsXdlY2BSjkmjkidMQ0PdmVranV43ti+6iA6pPiblLKNMXTrpl+zwzeYj8oS3FmQuCFTnK6h8dYSOg+VJOmJrcdQFth/TFcNNy9JbOmjkVGqu/Fd/ccRtiywrd/hU/tG69MngQRfqXrhTLQDU5aYDWWGFgeMGjeNsHZS5B8pUBTl6L9IILIjCxScFh3Lu6QzQNAgPIwBrUOL4wvlLuTy/2H6tjO0rzgT+1/ZJmL/d/ovA8P78U5bmtn3LOcC2/Qyn+Bpn6Xbgd2wHPlnbga/B+YjZn7k7vB6zGuj+X3rPBMzhw/bBs4IPtwO2Cbtdy3fPETADZtXZDrisug/dsR1wayDNi7Xf1yAvnFc4YM7cyij9nAW8x+C7Lajxz3ZAR9ARu/93W2C78otnW1cSD8joNkSduUFZVhk8lK1TPCxcy9ITfKCJP9GmCXpPexNbzg0E7tJ35A3NyDUfPOlb5g6GqPJRjAaMVR1/oBuA6OuKQiOc7YB8Y2MiECXkyz88uCZqlK70lEO79JeWuipo7ufQFH/kSKe5eR/4Bx+dMx7qGWVoCDVw+1P64kxdPPGrl2QqKa9sOVIGZL7LEQfAzk98Qcq3MPkxFtEfuHzVTbTKmXJ1Lnzoi8O1shZNBjE85FWRvefUswUIxSrbf5By/+Q7vCWccvVCk8gJz2uZq6xulQPAvlNPomyx429/YolvAv2Shn/gEPCf9pXAP2//wqz8MUvyzy6/295e3BI0/TczvgHg25PbAQOA8O+2l8z6t6dvFpbZS84EbHnH7D/gORjU2YW5HXD2dzvgoeDgCdMBrc/sP22uDVwJNHWl4JbAgz+xXQVY15nFwfx2+W4cnq11gLhuBwwYpmNroDnLwyS/S1YVrbtm6KbB+vXsf11Ge2Z+Z/hj9m/ZpfFsEyzriPqZd6srASnUWXoNA6PjjhZHuHjiK6NlbaT09HbpbfSPIWQVUAeda4NJjW54jfyhx7Wizz6LKCIJHZBfI2t5H2Pg1bhL/fJGj8zqpXYV01WLOJaFI42+9OCreOrjyoPeQ1+ctjhzLjKILU+qPPSGQD2Gd7YagxSgVDKNcCXwx1hyjTxx0ae8wVtjmoL3wvak0rTseC2wBIsmvA8DRDf7vPogjtXgWqA+uOBZrcwUUi5966Hzkv+ht80xu6qHf2kqqm3e4+B9efrl9otI83DQlYDIHgyaz0rAIPB6+9PAZiXgEwJxZub3fMBA8OODQWeAV1kJHEHgjtnYlcFL3Gxm+rs8HXhHYJinBAaCKc+MbgDpSuDFyk8fnPrPCqCn/p2xC7uJvs7mzh4/nOF/CMOgwXsGnk8ghk8PEo+ZPdE0M71nCfIYPs7MDDIyhc2s3ijsuGEItHUms07SioCVTwAf0Du2s2wvb272mlFDiJxaqHKXkxM9tIeY9Oq/Og29Imu81VH6riCKc6wEZCJPEJATG1t8Cl9OkDaDE/cLxsfBIOXgK1r69lUp1cdxu+K9+DjukQX+3idIheklXQUUJ/1cvGVfHHXo7F050lS+k8TwiSdG34EVRz7K6aqA/u84AP1f+slndBGetvTNBu5L2oc3DSbHI/x0zcobWGh2nOJ13EIiAPryjTxxlTtjfJ0LNzm8ZI/QMSrUvU/w+Fvlb7/i40rgF1Z+kFwJeDD4B84DbHIlYP4NZwPmN9urBXcOezcCafmYuHrLjX3OTPA+5wHi+0TA/D2z/zvWCZ4XfE/umYBbANsmOc+/5890tw4I2VawQnlGvUeDxwGhA9nT/Znd56DQzcg9UU9cjU1+nhkMHkv09EF4zwQsdS4/cCZI2zJ4Hih25i50Zn/lzIxfOmd0uZrUwfoP9uDRa1YGpXc1oG7mB33PBIziORRcPGPQKXuZmUyczqqlH+vAoEPvHWlyXKZ1gcgQ7r/GHv07fsFL/boPOOp+/1pIkNP7dvrBGX5pQo4cdYRD8lVx18PWaxx1h8oLHIa3WJMYx8VbnLgBjMFsdUf7cc/3JgoGRv0lLNIgPfdklW1rOvgm0ImRNuDJr8cFCoD2YVZFtmb1JdEMwKJfwgoeZdJWyW34EaDy5UWTrQkAqcRa37w55fHgn7EKeLH9dPuv7d+3v9z+P3vqF6d/Bf3T7U/4iHPPaYD7/bdnnrXj3u/OL2m52/54/ghjv2XG9EzgTtfe/oRtxcZ7Bd9S1lmeEXJ9bPYc5313fkeJg7+M+QtguNC5S3H30pw2MOs+rvMD99YsvoPLMpyOOBvqEtn7Uz+xUrBs24VHfN5wZ3kfOebWBQeX33HXQFC/gbcGZQTXAbL8hNYtjsHIxWjPD4oz5wQPIN/ykdYzg+4jixPuwIywGWxwylu9xBdKh2jPSfxq7/7ZW4S52Rw8A4EVdOHjVGrwCCB0OmSQJRCNsQXGeOcsJBrIz1ExV2bNwEeVwYfc2Vb+GrqtPWOwtPpQFcATufQgp90zEBllHANRR/gsvGi1ryBACF11AVO1wTW3X7JSd5VJT8JXGiBcLBTuLC6xuegiJB/k0XPhTHvoBmfxCKHyqXfGl1n+mwde+cqozdCU+1E9xC9NCatL+Y2uQwdm+mhd2WM/c2/aKbFIi291DPoO3/ntOCWo/RQt14w5JXNxTVEqDW+o/Wr7TR4RuhL4Pzwi/Lft57GE/02bTwd+x7kARRy8TwcsmzwTcBXwXT53nAm84yUinfGbzacDxfoIyZ4JvGWedzXw7PKKLcB1YtkeXFcIvjTkvH88HXDG7hOB0nRVYHlWAK4IZlXggZ9tPRewdCQDkmcCR2q5V0OLoYjFf3AG7/rpQJ8pzOpiVgxdC5SrTnnwn5IrhdgkvD2d7ok/9yP9JpiQn/P0oE5eXKm9Sa4E/FjHATKrW6YGzEDVR4TKlh4FAi+O+2zlrJAYPj5Wq8sVp2cOOOaiP1YXwiDmP7J1FC1sT7is+30UiQxkT5A6+tC20nMNrzJQB6s5v1iWq2Fnfl14sVvKzpQ9aWcsd/kiiV3kzLwTTOJhIjrTHr09SktAqC1H0uI9bdKPjt5Y4FdNFnfZlNXQ8SocQGBLP4DTF9BIV+Oyxk96b19XAuKstDOkYDn04l23H8AdLqLg60EfmjDKSL4BwzMBHxG+3v7v5TfUfTrwavtzlug9GASU9wTMTW4Hvt4+vnxKed4TEOrh4A2feWnoY9YLHgyafBqQAhedHTOMMpb7boBD9Mhy/YEDQrcL87CwVNeHht0i9JHftNbB7bEHej00vD7o88lAcXXka2ceLBdG3R704E9sb0iDwRwyChVTxzf3Y2puWCjc9uMA0L7JS7zaZh2/ZZ2XUYmzsgLa6YTXTeY8oRzkxlqKfuZJBsCuKOQpPszCqwZVox/5dZ/MdrsxSG9g0pmXS6kryqlfDuzkKiwJI9fQQ1+c2Xj4WHC2HupRaRJRWvRoQrmBKe07HE0RqAFXVjB3983etQpwHdeTWC5l0ncVqlP7PQTKvCrDFU0HsEoHRVs6fiJRQic7bN8rsfC2Tblaib3SdWGVu0WA0xpfMYVNsI0UcM1nzHO/dl6LNwjqkiS++uWmVO+om8vScXAlCK4ALOlyerPOBH69/eIyTwf+bftGDfZ0x2rA9wT+sL0G/jMPCy+f0epjwuM9ga8JA64BvsHQuwp44OmAIaDnAc8JKg+sAhT8LPx9bZitBYbrE4KeCdDMbN12D+NcizznjzmA9wO6CvDapwN19gkArem0XSNo2DOfu5oQeuA0FMypADdh9Vn3HSqH75wXiCAFXpxuR8btdfpj3y7+rBB0+TqWqwvfFRgZ3mJnbWfkdZ+gWwa2z/qV0BWC0hk5cHRWZ8WeN8hTJ9CBSp9ZZL9/riCEK+eQX5kGKdrA1d3O8DHo5B2ARa9+UDkM4M0YYWSU68DXTu8YqYk80rqMtPIVVLnwC/86q2WN2Q1L+sFVnUx5L6HF0LqNbNKATc7yqocM8iU1uCmrd+DpQMpXELt1pOhcfks8bYfOkeMYAW24aKm4XPkvv+qyM15jIUL7tShGeMbSNgAOkHyueJWvPG1bYyZzIkRYAE7V3KiBkMpZAkoWvuUFnrJM2OBKbgdcCVj1jUFXAr4j4MtCwn7OZ94Y9MmAsHseEd5uH6W9B4OvMdNb3hn4JLk4vixkbpo3Bp3539LCLScA6OwvcVlfJHqJg/bAsPkLuuhqYR4BWrLcOjMmetTZZyvQQ0G/L+B7A7pN3wBU/rxQZNnk/H+4uiPk2YNUuvSsFHD75WzS+JTAfFYHLdfBB89c521gmEd41itjHK4OruFnFqCf85bhvs9kjLyZdfZyyPkAnDSScuCGx3G5mejmLc1Mw83tbD032TqNqz8Gkc4yzbtFsX3RiYsQ5Q8H6TPjI88UfrR7bxuIqqs45T3GKAc+y+CqhzgGE+nbn8hZOKVHzmov1lzrqPUAYYYpHWIcZHKaoBduKsb0Jw07+4gJWoNbKbqJqL6lm3K5jXLmUFTpJUmJTdc0exmSGdeOs/Ynvnwc21QY19YFGuhW89XgF2bT0MhI8llZLDVCa3nXISJyeXN5c/5HtgM+HhTF1YCB4Hu+RPT59vPzz3hR6D+Auxp4vR4Jvtpen38P7IFA8Gr7OL3xi0MeDD6uc4F+d+CWg8C+IGQQYOUQ3H5/QNzjxSAcNm3CLqwM5nzAF4ec+YW7JZgvE7GqoCy9MJfFFw4i6SLwvgjki0LP4dNAXLiBx/bn0EhfnJZd7tXhcATetYczsjFp9K7zC1emh34+ItQRC+ty3cd3wrhd6UvbvCEHPPN5+Hgz4lTwzD2nrv7dl3PPonsdqmcI8hMHQ4XGFUHL3lgadnppNY4IuIKDkwPC0U9ZGAzgBo41vwGQPkEkj5CUKT8+S756WJSu5Wmzr+1PeYIXmsoa/U85KCx9/V5dJ7hQ9v+6D5EFSvQaIy+9q8UYfPKhW7yjH7qhf85KgiM9sihT2POMtzAbVj9P2XPJSzgpcDDIC3P87Btt8/Ee0k6LClNYsoQsvv3+hwwLy33I/RQEDLLwFH/nKz/HyHzByfayeKbgd7w9IJaX/pP7EflU7ZepCllyJcC3B7Md6Ergt6e/Wt8i/G8eD/6UACCeWwE/BgC3A9fJ7w64HXAl4PUVWwFPBFwNdBXwCphvC/w4zctCnhyYnOs9ILTMK0AXVwDCDADCju2ANVO/O+BSvy8CQZ3xd0S6NBJLQzheFBLS1BVBF/E1YANAHd+tQdcH3s9ZIXQedjk9PKR29h+YgWLabJkAM2cCvXfFcCalxMUbL08dqbw9IzDJ9xw+B1/vaNcDczAofY19ZmNQFl+xE3TIJ41NuIXodoBAE0cDI/q7tEe5lAd7qCfv9kQ0U2WoSPuYbUToW6cnRfzgSt8TIdA7PKRXnvAi2hLHuKIr24NfNfQ6xs/9hGg0L70MB1JmSOHvmk75tglfOBn4gQ/MvBiD543P305fvuUHduC57Fo4xn0JqPwngFbKui66H45B5CvcTwKnMo7+u8oLv2s2UUaGWubp19vfczD41dn3BP6SWfwWt/0drwr9ng3AT7i+5aUhTvq3P+Ox2VeQ3vKIEAfhuO/m9Kf5gtH3sPH13ntu2gu+hqwjfseM+xxnPbOlOEHvAtsZ9Z5uz+PCzhi6mI8JNXqe5OfbbhyN5VGhjsxpALw8SPQe6BC+IOTM6DcNhfkxYNhRVxOahLOk+3Ff7/Vxn9uM7HeRHz6pSydOnyhcyJ9R1wkeyLssx7GRFdOERlwfUboEn4HO4Vzq5e1NyiymJghTXhJ8AdAnTaT3zMh+LP9xaHBsVR7uGP39NqbL97bRQeqm6AR9VwHDWwkm65apORtYhrfQzsbW/YTLPkPlwK6cFzXyMmuILFfwqctv739g6tRVgVLa5+W0+gA4mcWlNJqakD3FMHRc1kyXMVTb4JjTFjL7r1EL8qIe6OTYWo8sy+q6aHacgCszPI728A6/OozFBkNx4CdD/4Njm2U/Sy5lAelPeKeDgZW+LADwv/S3jL7yWuyTL0qyK94LKKq4k1yZjk4Hk6JU68oI/hDvY2Tfbi5vvJFfnv6Obwx8QSB4sf319lc40iu2Ah+t/bnLZ1ncsgV4znmAAcAXgHxPwCVxnw78EYU/xVnfs7P39wc+8SFglufuxX2d12U0s3neETAg4M75PQFnnu8JDjq8S3AO/JCRN82irO8J6NTeaLTgcwevE7xuyftuAHv0FRCcFxsQfE+Ax4zU1V/YLTi+R2BgkJdnADqB323QkPJuQmA8YQChfHTSOqM0Bg1n6Do+XaCcpah3M/CBuRKoE0iXFLmGMZ1FHTQa6caBjoBggJSfAcOyWwz5dHUADf9jiNkOCVgwjUzniXEoeORHZlwjbS4VR44Gl60OTLq8hZl8JF55DU6YbfyT1aALUz8Dl81BSJ5S+mHw6VjZFzANLurmh2Q/rIiHFlxaH0ezP13GO26WweHjfTOXBOiCU17yhdsuiuWOm+MT8BVMfcaRxW9dOXXUBYONfEb+gVc50zbyIn+nCemiHz5WYZjxke/BJ7TWTTbMPbFv1It7jFvr08cQgWdOCk2LIVw8cu7gI8Kn3xMwsBiIDBIdsc6YOocObRATzszL4FmfwNQVzRhVl/Euskpfoy5++T79noDjoIM5Zp0VKSwjXQGR6nUb8SvJSUtHMJsZtCsS+YESvHFeeYfRgnf1tgfutEEjHeXyrD6Wf+g8yjM4GbwaSMSprPIIm+pFU3VBTwT2LEMgKc5X3SIH0NPvCTjgjOLT7wlgpEQOZ8mZ8TWSTIiMkKucgc++Oi/pgNMzAemXc4CrwdbIXLu54gK4Ust1OHF6JlD52V4Eb+hLVCewrAEjKKmzJJTIVvjYvsFw6HHaRM7lyQkAEvf0PQ4UevRp5KRNpexBk6xXafVp6jgYfCLYK3g7jfKDpnzh/UtgCMXOVOn54xIfLRf1P3DUfsbw6MmVjpG/pJOltKrDJQErLfBG2bAPjmWwRLTeG5esKqg7jYsfGEVd+MGBXhZDK841fsuLwfBhvJEs5tPvCTgKPbzzkLBHcZaefk/A4IGRaH8amUtvPCHvEsR2dMAGLi1O5xCS8hhl6tJJLx/p5buOEOEtvLUgcxFoaDmg8tURYugpD27CXSpx1AXWMfhPMty0LL2lg0au6YpX/qu/OOK2RSaVO3yCuuhsbZ2OUYIu117YdLUAUJebDuzbDLgI76pl0cjAouioIMcenAqwpbqOesERpLozQKLZ4H8YSVb6OH6aHFEK5fnF0+8JMEBd2rst8BzAQXUb0O1A27rcf/o9ARxH2+GjYWnALtk197wHn6myY5W9M3XNzYNbm7KSyHYAp5KRnxwKiohFiqRlBmfq4okvfeXHfsHv/rz6yMoFReXAJryH3+DIW36Ty8/zHvqx4Or4oZyRWZ1FO+gtK4Ok4LRNLp28APPJmNG3p98TYMC7x376PQGNr0t+Z1QMDLv0uwZPvyfgaqFzeCc3BiapK476XMurIU6mBzrzZUYPEg7HquJIAhMiyMsFDP5cHUhnmUQkEYtC/lNM+Vpmadq2gkQqB014twNpmUeBiRUKQgVjUQtkg0u0GO2qkDgEvEQTy4tO4vzLCGB4IXXwrAcmxSom0FnWziB6+j0BZxJnLfPrWZ+ZDdjT7wlgQbFGLlezdWwsXjLw5QSMWR/bdWbtSkAnpL1eFevNCmDVnbljkiKEnmzxmUO1LJ/XI8R9RkV0VwHKhIOqhK66WAeB/87elTO8nfVLk/5BV9yByXP6JKx8DhyI/V/6ZjxULHzS3bB1xh+YzdXJ/pLsd/jWU/cxGT47TvGOsbEBZs4eZPks0Ipc5S0sMiyQHF6yp98TMP45EjyYnG8OOPfOAdycCYjh6z/HS8Lz3YG2DJ7fCujM3cM7KdpmYEllBffO8guCDtZ5LOj9T6ohu6iuLqU/vpdwTe/jPQwKi8qh4Af0ix133PvvbZ8v9XSSKTSL99CnVEx4TmsAuaCg/xp7dO34BS/16z4ws6w+j2VK14PBoR+cqYMZPnKcMaj0ndWVHhYPGdUdquiYeflDIrEd0eSiRS9wnPVTFWSaCNHaB1fx3Ler50EjPfckmG0r0cE3Ti1GkIAnr4IdFygAGiIZxVENOSLymb4s+iWs4FEmbZXchh8BKl9eNNmKRaxKrPXNm6ffE2BQEo0ZIJefrAaefk8Ap4lnYtwajFXM5un3BNyyaSfajJ/WW4l3dbxWOxBwu+IQZ+iEe/aQYJZ2CcSti2aJQj3JPB8u/ls2ke/8hM2HgvFsxxPXGGgyH/rsx9PwBujT7wkwCMzmvhL19HsCCYj7Htp9+Zo+mEP6dGAsylHrSiSPKkHrY8Eu/Y+V1cyS0mO42vlKYsbsAeb0ezlG5teFF7uVt7IyZ17vyUUSu8iZeQnkpuydU3KmLczqUVoCQm25HtLeTVsYLB31HuBXTRZ32ZTV0PEqvLTqHAjA6QtooYzP20r/LUuv83YlUPpcd4YULIdevIWT9gO4w0UUfD3oQxNG6e0bMJ5+T8Ch7MLfB4PHtwi9If1mgU8MxDKJ6RbAPMupPTeQPP2eQA/0tL46FINiaY2fS/a8nowxpn2H455EiThDYMHcnda995HG9USUS5n0XYXOsIezS0V7URaujrkDVumgaEsdstSW42kJZNMv8WgRJddqNZAFnNYlrlsE/XKtBGgXNsE2UsA11/5Mtk+5EIHCV0189YuzFzfqrjGLRoMrSXAFcK+efk9gTgW4CY46Sfeu41vDkJ9+TyAWHqPNGGFSWF8d2BlsnN7xcqb1jKBuUiPFNZyd12xHIf8yTbtV7LH79jri3IvQlW3ttlKBjEV3Pw2nOM2SGtzqV1EJJzDtLfbaADNcIiI6l1/xhB6rGDWzX9JUy5Z2nhTKb+RIT1pjIa/2a1GM8IylbQDinM2Gl0q3fxTAES3JwGCh7EKaSGE/A1uIJSse5dKstv2kNtuBp98TePo9AS2qy/8YGgapMdWxYn+Uqa3ldnBibMyqy9A9rBSns9YYoxykK6casTgGE2XSNHIWTukNHG3/8FpHXR5HU2d1XaK8J6cJ+uUqyTX9pYUNO/uIiV80uKUIX529PEs35XId5cyhqNIpl54i6ZpmL0NSPUDIOBNslvzotXg1MMglvasYq2GkXD7Skc0KQ0aSz8pC9KSl1K7DyNu2p98TmN8WcLk3r+U+/Z4ADqxx5ktHmpDGxieWi5ORW8wyNuVpwyXBqxFiZfz3vX/5lU7g0+8JELiWExr3utzv+uJwYgbYQRZv4T79ngCG+PR7AjNjYBixkJ5JPP2egOPRERnPMRAZvPati7UFG0wxTIQo/upxpQNx4RLekjrTDnxg5sUYvDixgW6nX56c+ujQii0mDwL7ElD5R9bCL4ZIwVx92KEUkKxwPwZq8BpUxKFfbg+qjICyyVWGT78nkK8GP/2eAIYRa8QoWOq7II69cc3iOMf8tmlStFG3fQwt+PM7APDRncaR4nThzSbBlYWUc8KK0CmGIURPvyegm46j6tAd9wE67hmrABhr78WOc+CKl5iQ8V7IQ5z7Ud6n0/8Auwz18KpI0L8AAAAASUVORK5CYII=", self.location).href;
mars3d$1.Cesium.Material.PolylineTrailLinkSource = `czm_material czm_getMaterial(czm_materialInput materialInput) {
    czm_material material = czm_getDefaultMaterial(materialInput);
    vec2 st = materialInput.st;
    vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));
    material.alpha = colorImage.a * color.a;
    material.diffuse = (color.rgb);
    return material;
  }`;
mars3d$1.Cesium.Material._materialCache.addMaterial(
  mars3d$1.Cesium.Material.PolylineTrailLinkType,
  {
    fabric: {
      type: mars3d$1.Cesium.Material.PolylineTrailLinkType,
      uniforms: {
        color: new mars3d$1.Cesium.Color(1, 0, 0, 0),
        image: mars3d$1.Cesium.Material.PolylineTrailLinkImage,
        time: 20
      },
      source: mars3d$1.Cesium.Material.PolylineTrailLinkSource
    },
    translucent: function(material) {
      return true;
    }
  }
);
class Bus {
  constructor(map5) {
    this.map = map5;
  }
  addBusLine() {
    if (this.busLineDS) {
      return;
    }
    http.get("/jsons/bus/busLine.geojson").then((res) => {
      if (!(res && res.data && res.data.features)) {
        return;
      }
      const busLine = res.data.features;
      this.busLineDS = new mars3d$1.Cesium.CustomDataSource("busLine");
      this.map.viewer.dataSources.add(this.busLineDS);
      busLine.forEach((item) => {
        const coordinates = item.geometry.coordinates;
        const coords = [];
        coordinates.forEach((v) => {
          coords.push(v[0]);
          coords.push(v[1]);
        });
        this.busLineDS.entities.add({
          id: item.properties.id,
          name: "busLine",
          polyline: {
            positions: mars3d$1.Cesium.Cartesian3.fromDegreesArray(coords),
            width: 5,
            material: new mars3d$1.Cesium.PolylineTrailLinkMaterialProperty(
              mars3d$1.Cesium.Color.fromCssColorString("#39FFA6"),
              3e3
            ),
            distanceDisplayCondition: new mars3d$1.Cesium.DistanceDisplayCondition(0, 35e4)
          }
        });
      });
    });
  }
  addBusModel(positions) {
    if (!this.graphicLayer) {
      this.graphicLayer = new mars3d$1.layer.GraphicLayer({ zIndex: 999999 });
      this.map.addLayer(this.graphicLayer);
    }
    const flydata = {
      positions,
      speed: 500,
      point: {
        pixelSize: 20,
        scaleByDistance: true,
        visibleDepth: false,
        color: mars3d$1.Cesium.Color.RED,
        distanceDisplayCondition: new mars3d$1.Cesium.DistanceDisplayCondition(
          1,
          13e4
        ),
        disableDepthTestDistance: Number.POSITIVE_INFINITY,
        show: true
      },
      clockLoop: true
    };
    const roamLine = new mars3d$1.graphic.RoamLine(flydata);
    this.graphicLayer.addGraphic(roamLine);
    roamLine.start();
  }
  rmBusLine() {
    if (!this.busLineDS) {
      return;
    }
    this.map.viewer.dataSources.remove(this.busLineDS);
    this.busLineDS = null;
  }
  addBus() {
    http.get("/jsons/bus/busLine.geojson").then((res) => {
      if (!(res && res.data && res.data.features)) {
        return;
      }
      const busLine = res.data.features;
      busLine.forEach((item, index2) => {
        const coordinates = item.geometry.coordinates;
        if (index2 < 100)
          this.addBusModel(coordinates);
      });
    });
  }
  busLoopRequest(isOpen, interval) {
    if (isOpen) {
      if (!this.busRequestId) {
        this.addOrUpdateBus();
        this.busRequestId = window.setInterval(
          this.addOrUpdateBus.bind(this),
          (interval - 0.5) * 1e3
        );
      }
    } else {
      if (this.busRequestId) {
        window.clearInterval(this.busRequestId);
        this.busRequestId = null;
      }
    }
  }
  addOrUpdateBus() {
    this.beginTime = Date.now();
  }
  addNewBus(item) {
    const position2 = this.computeTrack(item.path);
    const orientation2 = new mars3d$1.Cesium.VelocityOrientationProperty(position2);
    const entity = this.busDS.entities.add({
      name: "bus",
      position: position2,
      orientation: orientation2,
      model: {
        uri: "./model3d/Bus/bus2.gltf",
        minimumPixelSize: 8,
        scale: 0.5,
        distanceDisplayCondition: new mars3d$1.Cesium.DistanceDisplayCondition(
          0,
          1e3
        ),
        runAnimations: false
      },
      point: {
        pixelSize: 10,
        color: mars3d$1.Cesium.Color.RED,
        outlineColor: new mars3d$1.Cesium.CallbackProperty(function color() {
          return mars3d$1.Cesium.Color.fromRandom({
            minimumRed: 0.76,
            minimumGreen: 0.78,
            minimumBlue: 0.75,
            alpha: 1
          });
        }, false),
        outlineWidth: 5,
        distanceDisplayCondition: new mars3d$1.Cesium.DistanceDisplayCondition(
          1e3,
          13e4
        ),
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      properties: new mars3d$1.Cesium.PropertyBag()
    });
    entity.properties.addProperty("lastPoint", item.path[item.path.length - 1]);
    this.busModels[item.clbm] = entity;
  }
  updateBus(busModel, item) {
    const position2 = this.computeTrack(item.path);
    const orientation2 = new mars3d$1.Cesium.VelocityOrientationProperty(position2);
    busModel.position = position2;
    busModel.orientation = orientation2;
  }
  optNodataBus(key) {
    const busModel = this.busModels[key];
    const lastPoint = busModel.properties.getValue(
      new mars3d$1.Cesium.JulianDate()
    ).lastPoint;
    if (lastPoint) {
      const position2 = mars3d$1.Cesium.Cartesian3.fromDegrees(
        lastPoint[0],
        lastPoint[1]
      );
      busModel.position = position2;
    }
  }
  computeTrack(path) {
    const position2 = new mars3d$1.Cesium.SampledPositionProperty();
    const len2 = path.length;
    const duration = this.interval - (Date.now() - this.beginTime) / 1e3;
    const tick = duration / (len2 - 1);
    const startTime = this.map.viewer.clock.currentTime;
    for (let i = 0; i < len2; i++) {
      const time = mars3d$1.Cesium.JulianDate.addSeconds(
        startTime,
        i * tick,
        new mars3d$1.Cesium.JulianDate()
      );
      position2.addSample(
        time,
        mars3d$1.Cesium.Cartesian3.fromDegrees(path[i][0], path[i][1])
      );
    }
    return position2;
  }
  rmBus() {
    if (!this.graphicLayer) {
      return;
    }
    console.log(this.graphicLayer, "graphicLayer");
    this.map.removeLayer(this.graphicLayer);
    this.graphicLayer = null;
  }
}
class VideoFusion {
  constructor(map5) {
    this.map = map5;
  }
  addVideoFusion(videoInfo) {
    this.clearVideoLayer();
    const graphicLayer2 = new mars3d$1.layer.GraphicLayer({
      zIndex: 999999,
      id: "videoGraphic"
    });
    this.map.addLayer(graphicLayer2);
    const videoElement = this.createVideoDom(videoInfo.id, videoInfo.url);
    const graphic2 = new mars3d$1.graphic.PolygonEntity({
      positions: videoInfo.positions,
      style: {
        material: videoElement,
        stRotationDegree: videoInfo.stRotation,
        clampToGround: true
      },
      attr: { remark: videoInfo }
    });
    graphicLayer2.addGraphic(graphic2);
    return graphicLayer2;
  }
  createVideoDom(className = "", url) {
    const videoElement = mars3d$1.DomUtil.create(
      "video",
      className,
      document.querySelector(".mapContainer")
    );
    videoElement.setAttribute("muted", "muted");
    videoElement.setAttribute("autoplay", "autoplay");
    videoElement.setAttribute("loop", "loop");
    videoElement.setAttribute("crossorigin", "");
    videoElement.setAttribute("controls", "");
    videoElement.style.display = "none";
    const sourceContainer = mars3d$1.DomUtil.create("source", "", videoElement);
    sourceContainer.setAttribute("src", url);
    sourceContainer.setAttribute("type", "video/mp4");
    this.map.clock.shouldAnimate = true;
    return videoElement;
  }
  clearVideoLayer() {
    const graphicLayer2 = this.map.getLayerById("videoGraphic");
    this.map.removeLayer(graphicLayer2);
  }
}
function getGeojson(i = 0, callback = (data) => {
  console.log(data);
}) {
  let url = [
    "/map3d/region/szxzq5.geojson",
    "/map3d/region/gzj_jd3.geojson",
    "/map3d/region/gjz_sq2.geojson"
  ];
  http.get(url[i]).then((res) => {
    callback(res.data);
  });
}
class Popup {
  constructor(options = {
    element: null,
    coords: null,
    position: null,
    offSet: null,
    viewer: null
  }, scale4 = 1) {
    this.bigScale = scale4;
    typeof options.element == "string" ? this.innerElement = document.getElementById(options.element) : this.innerElement = options.element;
    this.element = document.createElement("div");
    this.element.appendChild(this.innerElement);
    this.position = options.coords || null;
    this.position_cartesian3 = null;
    this.position_win_now = null;
    this.position_type = options.position || "bottom-right";
    this.offSet = options.offSet || [0, 0];
    this.viewer = options.viewer;
    this.scene = this.viewer.scene;
    this.removeHandler = null;
    this.state = false;
    this._initPosition();
    this.position_win_now && this._initRealtimePosition();
  }
  _initPosition() {
    this.position ? this.position_cartesian3 = Cesium$1.Cartesian3.fromDegrees(this.position[0], this.position[1]) : this.position_cartesian3 = null;
    if (this.position_cartesian3) {
      this.position_win_now = Cesium$1.SceneTransforms.wgs84ToWindowCoordinates(
        this.scene,
        this.position_cartesian3
      );
    }
    if (this.position_win_now) {
      this.viewer.cesiumWidget.container.appendChild(this.element);
      this.state = true;
      this.element.style.position = "absolute";
      this._refreshLocation();
    }
  }
  _refreshLocation() {
    let num = 100 * (this.bigScale - 1) / (2 * this.bigScale);
    switch (this.position_type) {
      case "bottom-right":
        this.element.style.transform = `scale(${this.bigScale}) translate(${num}%,${num}%)`;
        this.element.style.top = String(this.position_win_now.y - this.offSet[1] * this.bigScale) + "px";
        this.element.style.left = String(this.position_win_now.x + this.offSet[0] * this.bigScale) + "px";
        break;
      case "bottom-left":
        this.element.style.transform = `scale(${this.bigScale}) translate(${-num}%,${num}%)`;
        this.element.style.top = String(this.position_win_now.y - this.offSet[1] * this.bigScale) + "px";
        this.element.style.right = String(this.viewer.cesiumWidget.container.clientWidth - this.position_win_now.x - this.offSet[0] * this.bigScale) + "px";
        break;
      case "top-right":
        this.element.style.transform = `scale(${this.bigScale}) translate(${num}%,${-num}%)`;
        this.element.style.bottom = String(this.viewer.cesiumWidget.container.clientHeight - this.position_win_now.y + this.offSet[1] * this.bigScale) + "px";
        this.element.style.left = String(this.position_win_now.x + this.offSet[0] * this.bigScale) + "px";
        break;
      case "top-left":
        this.element.style.transform = `scale(${this.bigScale}) translate(${-num}%,${-num}%)`;
        this.element.style.bottom = String(this.viewer.cesiumWidget.container.clientHeight - this.position_win_now.y + this.offSet[1] * this.bigScale) + "px";
        this.element.style.right = String(this.viewer.cesiumWidget.container.clientWidth - this.position_win_now.x - this.offSet[0] * this.bigScale) + "px";
        break;
    }
  }
  _initRealtimePosition() {
    this.removeHandler = this.scene.postRender.addEventListener(() => {
      const newPosition_win = Cesium$1.SceneTransforms.wgs84ToWindowCoordinates(
        this.scene,
        this.position_cartesian3
      );
      if (newPosition_win.x != this.position_win_now.x) {
        this.position_win_now.x = newPosition_win.x;
        if (this.position_type == "bottom-right" || this.position_type == "top-right") {
          this.element.style.left = String(this.position_win_now.x + this.offSet[0] * this.bigScale) + "px";
        } else {
          this.element.style.right = String(this.viewer.cesiumWidget.container.clientWidth - this.position_win_now.x - this.offSet[0] * this.bigScale) + "px";
        }
      }
      if (newPosition_win.y != this.position_win_now.y) {
        this.position_win_now.y = newPosition_win.y;
        if (this.position_type == "top-left" || this.position_type == "top-right") {
          this.element.style.bottom = String(this.viewer.cesiumWidget.container.clientHeight - this.position_win_now.y + this.offSet[1] * this.bigScale) + "px";
        } else {
          this.element.style.top = String(this.position_win_now.y + this.offSet[1] * this.bigScale) + "px";
        }
      }
    });
  }
  setPosition(newCoords) {
    this.position = newCoords;
    if (this.position) {
      if (this.element.style.display = "none") {
        this.element.style.display = "";
      }
      this.position_cartesian3 = Cesium$1.Cartesian3.fromDegrees(this.position[0], this.position[1]);
      this.removeHandler || this._initRealtimePosition(Cesium$1);
    } else {
      this.removeHandler();
      this.removeHandler = null;
      this.position_cartesian3 = null;
      this.element.style.display = "none";
    }
  }
  setElement(newElement) {
    this.innerElement && this.innerElement.remove();
    this.innerElement = newElement;
    this.element.appendChild(this.innerElement);
  }
  setOffset(newOffset) {
    this.offSet = newOffset;
    this._refreshLocation();
  }
  destroy() {
    this.removeHandler && this.removeHandler();
    this.removeHandler = null;
    this.state && this.viewer.cesiumWidget.container.removeChild(this.element);
    this.state = false;
    this.position_cartesian3 = null;
    this.element = null;
    this.viewer = null;
    this.scene = null;
    this.state = "destroy";
  }
}
class EtopMap {
  constructor(map5, options) {
    this.options = options;
    this.map = map5;
    map5.scene.requestRenderMode = true;
    map5.turf = turf;
    this.bigScale = options && options.bigScale || 1;
    this.scaleType = options.scaleType;
    this.layer = new layer(map5, { bigScale: this.bigScale });
    this.mapDraw = mapDraw;
    this.polylineUtils = polylineUtils;
    this.etopMapUtils = etopMapUtils;
    this.controlUtils = new ControlUtils(map5);
    this.baseBoxEntityUtils = new BaseBoxEntityUtils(map5);
    this.baseRoamLineUtils = new BaseRoamLineUtils(map5);
    this.tilesetUtils = new TilesetUtils(map5);
    this.educationLayerUtils = educationLayerUtils;
    this.flyToUtils = flyToUtils;
    this.terrainUtils = Terrain;
    this.tiandituUtils = tiandituUtils;
    this.gzLayer = new GzLayer(map5, options);
    this.videoFusion = new VideoFusion(map5);
    this.heatLayer = new HeatLayer(map5);
    this.bus = new Bus(map5);
    this.getGeojson = getGeojson;
    this.hideHeight = 5e4;
    if (options.hideHeight) {
      this.hideHeight = options.hideHeight;
    }
  }
  createPopup(options) {
    return new Popup(options, this.bigScale);
  }
  get viewer() {
    return this.map.viewer;
  }
  get scene() {
    return this.map.viewer.scene;
  }
  get camera() {
    return this.map.viewer.camera;
  }
  get canvas() {
    return this.map.viewer.scene.canvas;
  }
  get dataSources() {
    return this.map.viewer.dataSources;
  }
  get imageryLayers() {
    return this.map.viewer.imageryLayers;
  }
  get terrainProvider() {
    return this.map.viewer.terrainProvider;
  }
  get entities() {
    return this.map.viewer.entities;
  }
  zoomToXzq(quName) {
    let url = this.options.publicPath + "/map3d/region/szxzq4.geojson";
    if (quName === "\u6DF1\u5733\u5E02") {
      this.resizeViewPort(true);
    } else {
      http.get(url).then((res) => {
        res.data.features.forEach((item) => {
          if (quName === item.properties.QUNAME) {
            const bbox2 = bbox$1(item.geometry);
            this.map.viewer.camera.flyTo({
              destination: new Cesium.Rectangle(
                Cesium.Math.toRadians(bbox2[0]),
                Cesium.Math.toRadians(bbox2[1]),
                Cesium.Math.toRadians(bbox2[2]),
                Cesium.Math.toRadians(bbox2[3])
              )
            });
          }
        });
      });
    }
  }
  resizeViewPort(isSZ) {
    const extend_sz = {
      west: 113.531,
      south: 22.935,
      east: 114.713,
      north: 22.352
    };
    const extend_ss = {
      west: 114.68815432965872,
      south: 22.638449324268855,
      east: 115.42826684515776,
      north: 23.080914210824943
    };
    const west = isSZ ? this.options.extend_sz ? this.options.extend_sz.west : extend_sz.west : this.options.extend_ss ? this.options.extend_ss.west : extend_ss.west;
    const south = isSZ ? this.options.extend_sz ? this.options.extend_sz.south : extend_sz.south : this.options.extend_ss ? this.options.extend_ss.south : extend_ss.south;
    const east = isSZ ? this.options.extend_sz ? this.options.extend_sz.east : extend_sz.east : this.options.extend_ss ? this.options.extend_ss.east : extend_ss.east;
    const north = isSZ ? this.options.extend_sz ? this.options.extend_sz.north : extend_sz.north : this.options.extend_ss ? this.options.extend_ss.north : extend_ss.north;
    var extend3 = Cesium.Rectangle.fromDegrees(west, south, east, north);
    this.map.viewer.camera.flyTo({
      destination: extend3,
      duration: 0.5
    });
  }
  setMask() {
    let url = this.options.publicPath + "/map3d/region/outerMask.geojson";
    http.get(url).then((res) => {
      const features2 = res.data.features;
      const holes = [];
      features2.forEach((feature2, index2) => {
        const coors = feature2.geometry.coordinates[0][0];
        const hole = {
          positions: []
        };
        coors.forEach((coor) => {
          hole.positions.push(Cesium.Cartesian3.fromDegrees(coor[0], coor[1]));
        });
        holes.push(hole);
      });
      this.map.viewer.entities.add({
        polygon: {
          height: 50,
          hierarchy: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              80,
              0,
              80,
              40,
              150,
              40,
              150,
              0
            ]),
            holes
          },
          material: new Cesium.Color(0, 0, 0, 0.8)
        }
      });
    });
  }
  addXzqLayer({
    isShowWark = true,
    isAddPrimitives = true,
    styleOptions = {
      zIndex: 0,
      fill: true,
      clampToGround: false,
      opacity: 0.95,
      height: 3e3,
      outlineStyle: {
        color: "#005AAC",
        width: 3,
        opacity: 1
      }
    }
  }) {
    let geturl = this.options.publicPath + "/map3d/region/szxzq4.geojson";
    let getqUrl = this.options.publicPath + "/map3d/region/qu_centroids.geojson";
    const layer2 = new mars3d$1.layer.GeoJsonLayer({
      id: "xzqMask",
      zIndex: styleOptions.zIndex,
      allowDrillPick: true
    });
    const height = Cesium.Cartographic.fromCartesian(
      this.map.viewer.camera.position
    ).height;
    if (height < this.hideHeight) {
      layer2.show = false;
    }
    this.map.addLayer(layer2);
    http.get(geturl).then((res) => {
      if (isShowWark) {
        this.addDeafaultWall(res.data, layer2, styleOptions);
      }
      if (isAddPrimitives) {
        this.addXzqPrimitivesLayer(res);
      }
      const graphics = mars3d$1.Util.geoJsonToGraphics(res.data, {
        symbol: {
          type: "polygonP",
          styleOptions: {
            fill: styleOptions.fill ? styleOptions.fill : false,
            color: styleOptions.color ? styleOptions.color : "#005AAC",
            opacity: styleOptions.opacity ? styleOptions.opacity : 0.95,
            outline: styleOptions.outline ? styleOptions.outline : true,
            outlineStyle: styleOptions.outlineStyle ? styleOptions.outlineStyle : {
              color: "#0092FF",
              width: 3,
              opacity: 1
            },
            arcType: Cesium.ArcType.GEODESIC,
            clampToGround: styleOptions.clampToGround
          }
        }
      });
      graphics.forEach((g) => {
        layer2.addGraphic(g);
      });
    });
    let xzqLableCol = new Cesium.LabelCollection();
    xzqLableCol.name = "xzqLableCollection";
    this.xzqLabels = this.map.viewer.scene.primitives.add(xzqLableCol);
    http.get(getqUrl).then((res) => {
      const features2 = res.data.features;
      const scale4 = 0.6 * this.bigScale;
      features2.forEach((item) => {
        const coordinates = item.geometry.coordinates;
        xzqLableCol.add({
          position: Cesium.Cartesian3.fromDegrees(
            coordinates[0],
            coordinates[1],
            800
          ),
          text: item.properties.QNAME,
          scaleByDistance: new Cesium.NearFarScalar(
            5e4,
            scale4 * 2,
            7e5,
            0.1
          ),
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.HorizontalOrigin.BOTTOM,
          scale: scale4,
          showBackground: true,
          backgroundColor: new Cesium.Color(0, 0.35, 0.674, 0)
        });
      });
    });
    const camera = this.map.viewer.camera;
    camera.percentageChanged = 0.2;
    camera.changed.addEventListener(() => {
      const coor = Cesium.Cartographic.fromCartesian(camera.position);
      const height2 = coor.height;
      if (height2 < this.hideHeight) {
        if (this.xzqLabels) {
          this.xzqLabels.show = false;
        }
      } else {
        this.xzqLabels.show = true;
      }
    });
  }
  addDeafaultWall(geojson, layer2, styleOptions) {
    const graphics = mars3d$1.Util.geoJsonToGraphics(geojson, {
      symbol: {
        type: "wallP",
        styleOptions: {
          setHeight: -3e3,
          diffHeight: styleOptions.height === 0 ? styleOptions.height : 3e3,
          color: styleOptions.color ? styleOptions.color : "rgba(0,146,255,1)",
          opacity: styleOptions.opacity ? styleOptions.opacity : 0.6,
          clampToGround: styleOptions.clampToGround
        }
      }
    });
    graphics.forEach((g) => {
      layer2.addGraphic(g);
    });
  }
  addWall(geojson) {
    const wall = new mars3d$1.layer.GeoJsonLayer({
      data: geojson,
      id: "wall",
      symbol: {
        type: "wallP",
        styleOptions: {
          setHeight: -3e3,
          diffHeight: 3e3,
          materialType: mars3d$1.MaterialType.Color,
          color: "rgba(0,146,255,1)",
          opacity: 0.6
        }
      }
    });
    this.map.addLayer(wall);
  }
  addXzqPrimitivesLayer(xzqGeojson) {
    const features2 = xzqGeojson.data.features;
    let prim = addXzqPolygon(features2, this.map.viewer.scene);
    setTimeout(function() {
      prim.destroy();
    }, 2500);
    function addXzqPolygon(features3, scene) {
      const instances2 = [];
      for (let i = 0; i < features3.length; i++) {
        for (let j = 0; j < features3[i].geometry.coordinates.length; j++) {
          const polygonArr = features3[i].geometry.coordinates[j].toString().split(",");
          const polygon4 = new Cesium.PolygonGeometry({
            polygonHierarchy: new Cesium.PolygonHierarchy(
              Cesium.Cartesian3.fromDegreesArray(polygonArr)
            ),
            vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
          });
          const geometry2 = Cesium.PolygonGeometry.createGeometry(polygon4);
          instances2.push(
            new Cesium.GeometryInstance({
              geometry: geometry2,
              attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                  new Cesium.Color(0, 0.35, 0.674, 1)
                )
              }
            })
          );
        }
      }
      const primitive = new Cesium.Primitive({
        geometryInstances: instances2,
        appearance: new Cesium.PerInstanceColorAppearance({
          translucent: true,
          closed: false
        }),
        asynchronous: false
      });
      scene.primitives.add(primitive);
      return primitive;
    }
  }
  showXZQ(options) {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    if (options.quName === "\u6DF1\u5733\u5E02") {
      xzqLayer.show = false;
      for (let i = 0, len2 = this.xzqLabels.length; i < len2; i++) {
        const label = this.xzqLabels.get(i);
        label.show = false;
      }
    } else {
      xzqLayer.show = true;
      xzqLayer.eachGraphic((g) => {
        if (g.attr.QUNAME === options.quName) {
          if (options.setMask) {
            g.show = false;
          }
          this.map.flyToGraphic(g, {
            scale: 1.8,
            heading: options.heading || 0,
            pitch: options.pitch || -90,
            roll: 0,
            duration: 1
          });
        } else {
          g.show = true;
        }
      });
      for (let i = 0, len2 = this.xzqLabels.length; i < len2; i++) {
        const label = this.xzqLabels.get(i);
        if (label.text === options.quName) {
          label.show = false;
        } else {
          label.show = true;
        }
      }
    }
  }
  showXZQLayer() {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    xzqLayer.show = true;
    xzqLayer.eachGraphic((g) => {
      g.show = true;
    });
    this.map.flyHome({
      duration: 1
    });
    for (let i = 0, len2 = this.xzqLabels.length; i < len2; i++) {
      const label = this.xzqLabels.get(i);
      label.show = true;
    }
  }
  addXZQ(quName, coordinates, type = "MultiPolygon") {
    this.rmXZQ();
    this.xzqEnts = [];
    let rectangle = null;
    this.scene.camera.computeViewRectangle();
    coordinates.forEach((coor, index2) => {
      const positions = [];
      if (type === "MultiPolygon") {
        coor[0].forEach((item) => {
          positions.push(Cesium.Cartesian3.fromDegrees(item[0], item[1]));
        });
      } else if (type === "Polygon") {
        coor.forEach((item) => {
          positions.push(Cesium.Cartesian3.fromDegrees(item[0], item[1]));
        });
      }
      if (index2 == 0) {
        rectangle = Cesium.Rectangle.fromCartesianArray(positions);
      } else {
        const newRect = Cesium.Rectangle.fromCartesianArray(positions);
        rectangle = Cesium.Rectangle.union(rectangle, newRect);
      }
      const xzqEnt = this.map.viewer.entities.add({
        id: "\u884C\u653F\u533A" + quName + index2,
        polyline: {
          positions,
          material: Cesium.Color.fromCssColorString("#00FFF9"),
          width: 2,
          clampToGround: true
        }
      });
      this.xzqEnts.push(xzqEnt);
    });
    this.camera.flyTo({ destination: rectangle });
  }
  deepColorXZQ() {
    if (!this.xzqEnts || this.xzqEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.xzqEnts.length; i < len2; i++) {
      this.xzqEnts[i].polyline.material = Cesium.Color.fromCssColorString("#00FFF9");
    }
  }
  lightColorXZQ() {
    if (!this.xzqEnts || this.xzqEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.xzqEnts.length; i < len2; i++) {
      this.xzqEnts[i].polyline.material = Cesium.Color.fromCssColorString(
        "rgba(0, 255, 249, 0.3)"
      );
    }
  }
  rmXZQ() {
    this.rmLightWall();
    if (!this.xzqEnts || this.xzqEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.xzqEnts.length; i < len2; i++) {
      this.map.viewer.entities.remove(this.xzqEnts[i]);
    }
    this.xzqEnts = [];
  }
  addJieDao(jdName, coordinates, type = "MultiPolygon") {
    this.rmJieDao();
    this.jdEnts = [];
    let rectangle = null;
    coordinates.forEach((coor, index2) => {
      const positions = [];
      if (type === "MultiPolygon") {
        coor[0].forEach((item) => {
          positions.push(Cesium.Cartesian3.fromDegrees(item[0], item[1]));
        });
      } else if (type === "Polygon") {
        coor.forEach((item) => {
          positions.push(Cesium.Cartesian3.fromDegrees(item[0], item[1]));
        });
      }
      if (index2 == 0) {
        rectangle = Cesium.Rectangle.fromCartesianArray(positions);
      } else {
        const newRect = Cesium.Rectangle.fromCartesianArray(positions);
        rectangle = Cesium.Rectangle.union(rectangle, newRect);
      }
      const jdEnt = this.map.viewer.entities.add({
        id: "\u8857\u9053" + jdName + index2,
        polyline: {
          positions,
          material: Cesium.Color.fromCssColorString("#00FFF9"),
          width: 2,
          clampToGround: true
        }
      });
      this.jdEnts.push(jdEnt);
    });
    this.map.flyToExtent(rectangle, {
      scale: 1.5,
      duration: 1,
      pitch: -90
    });
  }
  deepColorJieDao() {
    if (!this.jdEnts || this.jdEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.jdEnts.length; i < len2; i++) {
      this.jdEnts[i].polyline.material = Cesium.Color.fromCssColorString("#00FFF9");
    }
  }
  lightColorJieDao() {
    if (!this.jdEnts || this.jdEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.jdEnts.length; i < len2; i++) {
      this.jdEnts[i].polyline.material = Cesium.Color.fromCssColorString(
        "rgba(0, 255, 249, 0.3)"
      );
    }
  }
  rmJieDao() {
    this.rmLightWall();
    if (!this.jdEnts || this.jdEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.jdEnts.length; i < len2; i++) {
      this.map.viewer.entities.remove(this.jdEnts[i]);
    }
    this.jdEnts = [];
  }
  addSheQu(sqName, coordinates) {
    this.rmSheQu();
    this.sqEnts = [];
    let rectangle = null;
    coordinates.forEach((item, index2) => {
      const positions = [];
      if (item[0][0] instanceof Array) {
        item.forEach((el) => {
          el.forEach((ite) => {
            positions.push(Cesium.Cartesian3.fromDegrees(ite[0], ite[1]));
          });
        });
      } else {
        item.forEach((ite) => {
          positions.push(Cesium.Cartesian3.fromDegrees(ite[0], ite[1]));
        });
      }
      if (index2 == 0) {
        rectangle = Cesium.Rectangle.fromCartesianArray(positions);
      } else {
        const newRect = Cesium.Rectangle.fromCartesianArray(positions);
        rectangle = Cesium.Rectangle.union(rectangle, newRect);
      }
      this.addLightWall(positions);
      const sqEnt = this.map.viewer.entities.add({
        id: "\u793E\u533A" + sqName + index2,
        polyline: {
          positions,
          material: Cesium.Color.fromCssColorString("#00FFF9"),
          width: 2,
          clampToGround: true
        }
      });
      this.sqEnts.push(sqEnt);
    });
    this.map.flyToExtent(rectangle, {
      scale: 1.5,
      duration: 1,
      pitch: -90
    });
  }
  rmSheQu() {
    this.rmLightWall();
    if (!this.sqEnts || this.sqEnts.length == 0) {
      return;
    }
    for (let i = 0, len2 = this.sqEnts.length; i < len2; i++) {
      this.map.viewer.entities.remove(this.sqEnts[i]);
    }
    this.sqEnts = [];
  }
  addLightWall(positions) {
    if (!this.lightWallLayer) {
      this.lightWallLayer = new mars3d$1.layer.GraphicLayer();
      this.map.addLayer(this.lightWallLayer);
    }
    const wallEntity = new mars3d$1.graphic.WallEntity({
      positions,
      style: {
        diffHeight: 150,
        material: mars3d$1.MaterialUtil.createMaterialProperty(
          mars3d$1.MaterialType.LineFlow,
          {
            image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABEZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAQCgAwAEAAAAAQAAAQAAAAAAZ+oaSQAAIKZJREFUeF7tnYuS3MhyQ3f9/v+PddgOW+vBXUGBgZDFZ3dIQ5yIiqrKyiQpgFNN9t2Z++dff/31r3/88ce/f7T/CP2/yVwb4sxB/98f7T+/92j/9dH+53vPGOYcf4r9+eef6MtOPjz7p48Ovv3zR/uX7z3HWGMMY65p0zhy//xo//vR/s8aY9++j9F7jsc4//bhK8aP48Mf6OkN+Fh7wPW/vvcJrEFX9AA9G9E17T/x4c8/bqR/jIfe4YG4jjkbYlO95hPPKftJ2iGm+qonbMTnwOdA89J6uQ/qS98S9Fd9IVq/G24ApZQHwg3Adw3daZRpZ/K416fjTeco51APMZ48IZx7P7G1Xq4Dz9Amrekp1lMO6zfB4z9eVfwVgOiJlOnCPO716XjTOco51EOMJ08I595PbK2X68AztElreor1lMP6TfDDr98BeJGeSJkuzONen443naOcQz3EePKEcO79xNZ6uQ48Q5u0pqdYTzms38SfAEopD8RfAbir7NlFUo7X+y6l8ymnnAeaskFXaoueem+hvqg3PGa5H/WLGietGXMvtZ6k+h9MrwBq/hYpx+vThZIpp5wHmrJBV2qLnnpvob6oNzxmuR/1ixonrRlzL7WepPof+CuAH3hZ/J2U4/XpQsmUU84DTdmgK7VFT723UF/UGx6z3I/6RY2T1oy5l1pPUv0P/AmglPJAfAPwnSWRdhuAedqZUq+kWDmP+gJtOXe/Jt2Zh3Wv15qpvuyHGiZvVlq7F4r6R2Ju+l8B/EISPLkfFHOv59x7JcXKedQXaMu5+zXpzjyse73WTPVlP9QwebPS2r1Q1D8Sc9MrgF9Igif3g2Lu9Zx7r6RYOY/6Am05d78m3ZmHda/Xmqm+7IcaJm9WWrsXivpHYm56AiilPIjpFcB3JIJ4WvO6VT3Zyi3X4K6P3j8BoDl117wj1LfrqIaqv3qzR2fkHPZx9QowHQTxtOZ1q3qylVuuwRsHvd9E0Jy6a94R6tt1VEPVX73ZozNyDvu4+hJwOgjiac3rVvVkK7dcgzcOer+JoDl117wj1LfrqIaqv3qzR2fkHPax/x1AKQ9n6xXAd5/V7qK1Xq87Wnktrj1R7d0jNuD1nGt9eQ/wALrTi7OM9VuvAG766kK01uvZr+rLPbj2RLV3j9iA13Ou9eU9wAPoTi/OMtb3CeDr4doT1d49YgNez7nWl/cAD6A7vTjLWN/vAEp5MNMG4Ls/STsJcrhLsdd6tvIeqL9rTk+Ajt2jPfXA18s9vFXXaQPQm0FJF6c3DHutZyvvgfq75vQE6Ng92lMPfL3cw1t17RPA14P6u+b0BOjYPdpTD3y93MNbde13AKU8GN8AuMvrp4H2jOsuhTU0xPh/BaX1bOX1UGfozzH1V8+Sf4rXA/VU+3I/SX+g8S125fkG4CZzvjIfa7wwHk/r2crroc7Qn2Pqr54l/xSvB+qp9uV+kv5A41vsyusTwNeCOkN/jqm/epb8U7weqKfal/tJ+gONb7Err98BlPJgdAPA7uK7POced7ieXgG0T/VcK68B+qK59upRWnewjla/rpM0pP6qMxthDmIcE5+nc3zCfx2YJwYs5tzjDtfTK4D2qZ5r5TVAXzTXXj1K6w7W0erXdZKG1F91ZiPMQYxj4vN0jk/4rwPzxIDFnHvc4XqfAH49oC+aa68epXUH62j16zpJQ+qvOrMR5iDGMfF5Oscn+jcBS3k4/gqwxdaGMe1K7HVX4njPecs+oCk/HbY+AZjn+nu9Hmcal2MkzZPengewrv4Ard9NegXYgu/4E34MztnrP4jjwxdeRqApbw7VOsE819/r9TjTuBwjaZ709jyAdfUHaP1u0peAW/QJ4NcGmvLmUK0TzHP9vV6PM43LMZLmSW/PA1hXf4DW76Z/E7CUh3NkA8AOw1eAtDNNu5WiOSm/XAOaokF31zp5oTGOvZ59qi/3cFXL0/VHNgCchPl+M4AU8wvTnJRfrgFN0aC7a5280BjHXs8+1Zd7uKrl6fo+AXwtoCkadHetkxca49jr2af6cg9XtTxd3+8ASnkw0wagnwYEY8bR6ycC13QdsF5zSYqV66gH0F99U1Ie8Lji83If1DZpnPw7wlg/bQB+MwC9IdDrhXJN1wHrNZekWLmOegD91Tcl5QGPKz4v90Ftk8bJvyOM9X0C+HqoB9BffVNSHvC44vNyH9Q2aZz8O8JY3+8ASnkwR14BFKzrTsW8aRdLx0uxcg1oCV3ZMNeYwrnmgVWc43IPqifHSWN6cpZYv/ptQDU9gXW9UOZN/4h0vBQr14CW0JUNc40pnGseWMU5LvegenKcNKYnZ4n1q/8UWE1PYF0vlHnTPyIdL8XKNaAldGXDXGMK55oHVnGOyz2onhwnjenJWWJ9/x5AKQ9n6xXA4U4yrfsu5n3i6u5W/gYaT/5gnmJHuFpffibd+4hRW/Seo+uJdMzInlcAhyee1hmf+kRvpHuAxpM/mKfYEa7Wl59J9z5i1Ba95+h6Ih0zsudLQIcnntYZn/pEb6R7gMaTP5in2BGu1pefSfc+YtQWvefoeiIdM9K/B1DKwznzCjDtSntZ7V7lPPrJkPyZPJpqnHTMch/QU3++2NwfrjvM9fwlZ14BeCJlyk/surByGHhAbZM/k0dTjZOOWe4DeurPF5v7w3WHuZ6/pE8AXwd4QG2TP5NHU42TjlnuA3rqzxeb+8N1h7mev6TfAZTyYLgBcLfwXWPaaQh3HO5KfhzvgY7LObY0TJ4oU1xZ1ZfXoFpDf4WekuTLqj7CDYDJ6aSOXwQb4n4c74GOyzm2NEyeKFNcWdWX16BaQ3+FnpLky6o+0ieA35MtDZMnyhRXVvXlNajW0F+hpyT5sqqP9DuAUh7M9Aow7R7cYbiOORtiU73mE88p+0naIab6qidsxOfA50Dz0nq5D+pL3xL0V30hWr+b6RVgOoifhBeChthUr/nEc8p+knaIqb7qCRvxOfA50Ly0Xu6D+tK3BP1VX4jW76ZPAL8nSTvEVF/1hI34HPgcaF5aL/dBfelbgv6qL0Trd9PvAEp5MP4KQHSnUaadyeNen443naOcQz3EePKEcO79xNZ6uQ48Q5u0pqdYTzms3wS/Cai/DuxFeiJlujCPe3063nSOcg71EOPJE8K59xNb6+U68Axt0pqeYj3lsH4T/PDrrwN7kZ5ImS7M416fjjedo5xDPcR48oRw7v3E1nq5DjxDm7Smp1hPOazfxJ8ASikPxF8BuKvs2UVSjtf7LqXzKaecB5qyQVdqi556b6G+qDc8Zrkf9YsaJ60Zcy+1nqT6H0yvAGr+FinH69OFkimnnAeaskFXaoueem+hvqg3PGa5H/WLGietGXMvtZ6k+h/4K4AfeFn8nZTj9elCyZRTzgNN2aArtUVPvbdQX9QbHrPcj/pFjZPWjLmXWk9S/Q/8CaCU8kB8A/CdJZF2G4B52plSr6RYOY/6Am05d78m3ZmHda/Xmqm+7IcaJm9WWrsXivpHYm76XwH8QhI8uR8Uc6/n3Hslxcp51Bdoy7n7NenOPKx7vdZM9WU/1DB5s9LavVDUPxJz0yuAX0iCJ/eDYu71nHuvpFg5j/oCbTl3vybdmYd1r9eaqb7shxomb1ZauxeK+kdibnoCKKU8iOkVwHckgnha87pVPdnKLdfgro/ePwGgOXXXvCPUt+uohqq/erNHZ+Qc9nH1CjAdBPG05nWrerKVW67BGwe930TQnLpr3hHq23VUQ9VfvdmjM3IO+7j6EnA6COJpzetW9WQrt1yDNw56v4mgOXXXvCPUt+uohqq/erNHZ+Qc9rH/HUApD2frFcB3n9XuorVerztaeS2uPVHt3SM24PWca315D/AAutOLs4z1W68AbvrqQrTW69mv6ss9uPZEtXeP2IDXc6715T3AA+hOL84y1vcJ4Ovh2hPV3j1iA17PudaX9wAPoDu9OMtY3+8ASnkw0wbguz9JOwlyuEux13q28h6ov2tOT4CO3aM99cDXyz28VddpA9CbQUkXpzcMe61nK++B+rvm9ATo2D3aUw98vdzDW3XtE8DXg/q75vQE6Ng92lMPfL3cw1t17XcApTwY3wC4y+ungfaM6y6FNTTEviHwgdazlddDnaE/x9RfPUv+KV4P1FPty/0k/YHGt9iV5xuAm8z5ynys8cJ4PK1nK6+HOkN/jqm/epb8U7weqKfal/tJ+gONb7Err08AXwvqDP05pv7qWfJP8Xqgnmpf7ifpDzS+xa68fgdQyoPRDQC7i+/ynHvc4Xp6BdA+1XOtvAboi+baq0dp3cE6Wv26TtKQ+qvObIQ5iHFMfJ7O8Qn/dWCeGLCYc487XE+vANqneq6V1wB90Vx79SitO1hHq1/XSRpSf9WZjTAHMY6Jz9M5PuG/DswTAxZz7nGH630C+PWAvmiuvXqU1h2so9Wv6yQNqb/qzEaYgxjHxOfpHJ/o3wQs5eH4K8AWWxvGtCux112J4z3nLfuApvx02PoEYJ7r7/V6nGlcjpE0T3p7HsC6+gO0fjfpFWALvuNP+DE4Z6//II4PX3gZgaa8OVTrBPNcf6/X40zjcoykedLb8wDW1R+g9btJXwJu0SeAXxtoyptDtU4wz/X3ej3ONC7HSJonvT0PYF39AVq/m/5NwFIezpENADsMXwHSzjTtVormpPxyDWiKBt1d6+SFxjj2evapvtzDVS1P1x/ZAHAS5vvNAFLML0xzUn65BjRFg+6udfJCYxx7PftUX+7hqpan6/sE8LWApmjQ3bVOXmiMY69nn+rLPVzV8nR9vwMo5cFMG4B+GhCMGUevnwhc03XAes0lKVauox5Af/VNSXnA44rPy31Q26Rx8u8IY/20AfjNAPSGQK8XyjVdB6zXXJJi5TrqAfRX35SUBzyu+LzcB7VNGif/jjDW9wng66EeQH/1TUl5wOOKz8t9UNukcfLvCGN9vwMo5cEceQVQsK47FfOmXSwdL8XKNaAldGXDXGMK55oHVnGOyz2onhwnjenJWWL96rcB1fQE1vVCmTf9I9LxUqxcA1pCVzbMNaZwrnlgFee43IPqyXHSmJ6cJdav/lNgNT2Bdb1Q5k3/iHS8FCvXgJbQlQ1zjSmcax5YxTku96B6cpw0pidnifX9ewClPJytVwCHO8m07ruY94mru1v5G2g8+YN5ih3han35mXTvI0Zt0XuOrifSMSN7XgEcnnhaZ3zqE72R7gEaT/5gnmJHuFpffibd+4hRW/Seo+uJdMzIni8BHZ54Wmd86hO9ke4BGk/+YJ5iR7haX34m3fuIUVv0nqPriXTMSP8eQCkP58wrwLQr7WW1e5Xz6CdD8mfyaKpx0jHLfUBP/flic3+47jDX85eceQXgiZQpP7Hrwsph4AG1Tf5MHk01TjpmuQ/oqT9fbO4P1x3mev6SPgF8HeABtU3+TB5NNU46ZrkP6Kk/X2zuD9cd5nr+kn4HUMqD4QbA3cJ3jWmnIdxxuCv5cbwHOi7n2NIweaJMcWVVX16Dag39FXpKki+r+gg3ACankzp+EWyI+3G8Bzou59jSMHmiTHFlVV9eg2oN/RV6SpIvq/pInwB+T7Y0TJ4oU1xZ1ZfXoFpDf4WekuTLqj7S7wBKeTDTK8C0e3CH4TrmbIhN9ZpPPKfsJ2mHmOqrnrARnwOfA81L6+U+qC99S9Bf9YVo/W6mV4DpIH4SXggaYlO95hPPKftJ2iGm+qonbMTnwOdA89J6uQ/qS98S9Fd9IVq/mz4B/J4k7RBTfdUTNuJz4HOgeWm93Af1pW8J+qu+EK3fTb8DKOXB+CsA0Z1GmXYmj3t9Ot50jnIO9RDjyRPCufcTW+vlOvAMbdKanmI95bB+E/wmoP46sBfpiZTpwjzu9el40znKOdRDjCdPCOfeT2ytl+vAM7RJa3qK9ZTD+k3ww6+/DuxFeiJlujCPe3063nSOcg71EOPJE8K59xNb6+U68Axt0pqeYj3lsH4TfwIopTwQfwXgrrJnF0k5Xu+7lM6nnHIeaMoGXakteuq9hfqi3vCY5X7UL2qctGbMvdR6kup/ML0CqPlbpByvTxdKppxyHmjKBl2pLXrqvYX6ot7wmOV+1C9qnLRmzL3UepLqf+CvAH7gZfF3Uo7XpwslU045DzRlg67UFj313kJ9UW94zHI/6hc1Tloz5l5qPUn1P/AngFLKA/ENwHeWRNptAOZpZ0q9kmLlPOoLtOXc/Zp0Zx7WvV5rpvqyH2qYvFlp7V4o6h+Juel/BfALSfDkflDMvZ5z75UUK+dRX6At5+7XpDvzsO71WjPVl/1Qw+TNSmv3QlH/SMxNrwB+IQme3A+Kuddz7r2SYuU86gu05dz9mnRnHta9Xmum+rIfapi8WWntXijqH4m56QmglPIgplcA35EI4mnN61b1ZCu3XIO7Pnr/BIDm1F3zjlDfrqMaqv7qzR6dkXPYx9UrwHQQxNOa163qyVZuuQZvHPR+E0Fz6q55R6hv11ENVX/1Zo/OyDns4+pLwOkgiKc1r1vVk63ccg3eOOj9JoLm1F3zjlDfrqMaqv7qzR6dkXPYx/53AKU8nK1XAN99VruL1nq97mjltbj2RLV3j9iA13Ou9eU9wAPoTi/OMtZvvQK46asL0VqvZ7+qL/fg2hPV3j1iA17PudaX9wAPoDu9OMtY3yeAr4drT1R794gNeD3nWl/eAzyA7vTiLGN9vwMo5cFMG4Dv/iTtJMjhLsVe69nKe6D+rjk9ATp2j/bUA18v9/BWXacNQG8GJV2c3jDstZ6tvAfq75rTE6Bj92hPPfD1cg9v1bVPAF8P6u+a0xOgY/doTz3w9XIPb9W13wGU8mB8A+Aur58G2jOuuxTW0BD7hsAHWs9WXg91hv4cU3/1LPmneD1QT7Uv95P0BxrfYleebwBuMucr87HGC+PxtJ6tvB7qDP05pv7qWfJP8Xqgnmpf7ifpDzS+xa68PgF8Lagz9OeY+qtnyT/F64F6qn25n6Q/0PgWu/L6HUApD0Y3AOwuvstz7nGH6+kVQPtUz7XyGqAvmmuvHqV1B+to9es6SUPqrzqzEeYgxjHxeTrHJ/zXgXliwGLOPe5wPb0CaJ/quVZeA/RFc+3Vo7TuYB2tfl0naUj9VWc2whzEOCY+T+f4hP86ME8MWMy5xx2u9wng1wP6orn26lFad7COVr+ukzSk/qozG2EOYhwTn6dzfKJ/E7CUh+OvAFtsbRjTrsRedyWO95y37AOa8tNh6xOAea6/1+txpnE5RtI86e15AOvqD9D63aRXgC34jj/hx+Ccvf6DOD584WUEmvLmUK0TzHP9vV6PM43LMZLmSW/PA1hXf4DW7yZ9CbhFnwB+baApbw7VOsE819/r9TjTuBwjaZ709jyAdfUHaP1u+jcBS3k4RzYA7DB8BUg707RbKZqT8ss1oCkadHetkxca49jr2af6cg9XtTxdf2QDwEmY7zcDSDG/MM1J+eUa0BQNurvWyQuNcez17FN9uYerWp6u7xPA1wKaokF31zp5oTGOvZ59qi/3cFXL0/X9DqCUBzNtAPppQDBmHL1+InBN1wHrNZekWLmOegD91Tcl5QGPKz4v90Ftk8bJvyOM9dMG4DcD0BsCvV4o13QdsF5zSYqV66gH0F99U1Ie8Lji83If1DZpnPw7wljfJ4Cvh3oA/dU3JeUBjys+L/dBbZPGyb8jjPX9DqCUB3PkFUDBuu5UzJt2sXS8FCvXgJbQlQ1zjSmcax5YxTku96B6cpw0pidnifWr3wZU0xNY1wtl3vSPSMdLsXINaAld2TDXmMK55oFVnONyD6onx0ljenKWWL/6T4HV9ATW9UKZN/0j0vFSrFwDWkJXNsw1pnCueWAV57jcg+rJcdKYnpwl1vfvAZTycLZeARzuJNO672LeJ67ubuVvoPHkD+YpdoSr9eVn0r2PGLVF7zm6nkjHjOx5BXB44mmd8alP9Ea6B2g8+YN5ih3han35mXTvI0Zt0XuOrifSMSN7vgR0eOJpnfGpT/RGugdoPPmDeYod4Wp9+Zl07yNGbdF7jq4n0jEj/XsApTycM68A0660l9XuVc6jnwzJn8mjqcZJxyz3AT3154vN/eG6w1zPX3LmFYAnUqb8xK4LK4eBB9Q2+TN5NNU46ZjlPqCn/nyxuT9cd5jr+Uv6BPB1gAfUNvkzeTTVOOmY5T6gp/58sbk/XHeY6/lL+h1AKQ+GGwB3C981pp2GcMfhruTH8R7ouJxjS8PkiTLFlVV9eQ2qNfRX6ClJvqzqI9wAmJxO6vhFsCHux/Ee6LicY0vD5IkyxZVVfXkNqjX0V+gpSb6s6iN9Avg92dIweaJMcWVVX16Dag39FXpKki+r+ki/AyjlwUyvANPuwR2G65izITbVaz7xnLKfpB1iqq96wkZ8DnwONC+tl/ugvvQtQX/VF6L1u5leAaaD+El4IWiITfWaTzyn7Cdph5jqq56wEZ8DnwPNS+vlPqgvfUvQX/WFaP1u+gTwe5K0Q0z1VU/YiM+Bz4HmpfVyH9SXviXor/pCtH43/Q6glAfjrwBEdxpl2pk87vXpeNM5yjnUQ4wnTwjn3k9srZfrwDO0SWt6ivWUw/pN8JuA+uvAXqQnUqYL87jXp+NN5yjnUA8xnjwhnHs/sbVergPP0Cat6SnWUw7rN8EPv/46sBfpiZTpwjzu9el40znKOdRDjCdPCOfeT2ytl+vAM7RJa3qK9ZTD+k38CaCU8kD8FYC7yp5dJOV4ve9SOp9yynmgKRt0pbboqfcW6ot6w2OW+1G/qHHSmjH3UutJqv/B9Aqg5m+Rcrw+XSiZcsp5oCkbdKW26Kn3FuqLesNjlvtRv6hx0pox91LrSar/gb8C+IGXxd9JOV6fLpRMOeU80JQNulJb9NR7C/VFveExy/2oX9Q4ac2Ye6n1JNX/wJ8ASikPxDcA31kSabcBmKedKfVKipXzqC/QlnP3a9KdeVj3eq2Z6st+qGHyZqW1e6GofyTmpv8VwC8kwZP7QTH3es69V1KsnEd9gbacu1+T7szDutdrzVRf9kMNkzcrrd0LRf0jMTe9AviFJHhyPyjmXs+590qKlfOoL9CWc/dr0p15WPd6rZnqy36oYfJmpbV7oah/JOamJ4BSyoOYXgF8RyKIpzWvW9WTrdxyDe766P0TAJpTd807Qn27jmqo+qs3e3RGzmEfV68A00EQT2tet6onW7nlGrxx0PtNBM2pu+Ydob5dRzVU/dWbPToj57CPqy8Bp4Mgnta8blVPtnLLNXjjoPebCJpTd807Qn27jmqo+qs3e3RGzmEf+98BlPJwtl4BfPdZ7S5a6/W6o5XX4toT1d49YgNez7nWl/cAD6A7vTjLWL/1CuCmry5Ea72e/aq+3INrT1R794gNeD3nWl/eAzyA7vTiLGN9nwC+Hq49Ue3dIzbg9ZxrfXkP8AC604uzjPX9DqCUBzNtAL77k7STIIe7FHutZyvvgfq75vQE6Ng92lMPfL3cw1t1nTYAvRmUdHF6w7DXerbyHqi/a05PgI7doz31wNfLPbxV1z4BfD2ov2tOT4CO3aM99cDXyz28Vdd+B1DKg/ENgLu8fhpoz7juUlhDQ+wbAh9oPVt5PdQZ+nNM/dWz5J/i9UA91b7cT9IfaHyLXXm+AbjJnK/MxxovjMfTerbyeqgz9OeY+qtnyT/F64F6qn25n6Q/0PgWu/L6BPC1oM7Qn2Pqr54l/xSvB+qp9uV+kv5A41vsyut3AKU8GN0AsLv4Ls+5xx2up1cA7VM918prgL5orr16lNYdrKPVr+skDam/6sxGmIMYx8Tn6Ryf8F8H5okBizn3uMP19AqgfarnWnkN0BfNtVeP0rqDdbT6dZ2kIfVXndkIcxDjmPg8neMT/uvAPDFgMeced7jeJ4BfD+iL5tqrR2ndwTpa/bpO0pD6q85shDmIcUx8ns7xif5NwFIejr8CbLG1YUy7EnvdlTjec96yD2jKT4etTwDmuf5er8eZxuUYSfOkt+cBrKs/QOt3k14BtuA7/oQfg3P2+g/i+PCFlxFoyptDtU4wz/X3ej3ONC7HSJonvT0PYF39AVq/m/Ql4BZ9Avi1gaa8OVTrBPNcf6/X40zjcoykedLb8wDW1R+g9bvp3wQs5eEc2QCww/AVIO1M026laE7KL9eApmjQ3bVOXmiMY69nn+rLPVzV8nT9kQ0AJ2G+3wwgxfzCNCfll2tAUzTo7lonLzTGsdezT/XlHq5qebq+TwBfC2iKBt1d6+SFxjj2evapvtzDVS1P1/c7gFIezLQB6KcBwZhx9PqJwDVdB6zXXJJi5TrqAfRX35SUBzyu+LzcB7VNGif/jjDWTxuA3wxAbwj0eqFc03XAes0lKVauox5Af/VNSXnA44rPy31Q26Rx8u8IY32fAL4e6gH0V9+UlAc8rvi83Ae1TRon/44w1vc7gFIezJFXAAXrulMxb9rF0vFSrFwDWkJXNsw1pnCueWAV57jcg+rJcdKYnpwl1q9+G1BNT2BdL5R50z8iHS/FyjWgJXRlw1xjCueaB1Zxjss9qJ4cJ43pyVli/eo/BVbTE1jXC2Xe9I9Ix0uxcg1oCV3ZMNeYwrnmgVWc43IPqifHSWN6cpZY378HUMrD2XoFcLiTTOu+i3mfuLq7lb+BxpM/mKfYEa7Wl59J9z5i1Ba95+h6Ih0zsucVwOGJp3XGpz7RG+keoPHkD+YpdoSr9eVn0r2PGLVF7zm6nkjHjOz5EtDhiad1xqc+0RvpHqDx5A/mKXaEq/XlZ9K9jxi1Re85up5Ix4z07wGU8nDOvAJMu9JeVrtXOY9+MiR/Jo+mGicds9wH9NSfLzb3h+sOcz1/yZlXAJ5ImfITuy6sHAYeUNvkz+TRVOOkY5b7gJ7688Xm/nDdYa7nL+kTwNcBHlDb5M/k0VTjpGOW+4Ce+vPF5v5w3WGu5y/pdwClPBhuANwtfNeYdhrCHYe7kh/He6Djco4tDZMnyhRXVvXlNajW0F+hpyT5sqqPcANgcjqp4xfBhrgfx3ug43KOLQ2TJ8oUV1b15TWo1tBfoack+bKqj/QJ4PdkS8PkiTLFlVV9eQ2qNfRX6ClJvqzqI/0OoJQHM70CTLsHdxiuY86G2FSv+cRzyn6SdoipvuoJG/E58DnQvLRe7oP60rcE/VVfiNbv5I8//h9seUfE4fwNtgAAAABJRU5ErkJggg==", self.location).href,
            color: "#00FFF9",
            repeat: new Cesium.Cartesian2(5, 2),
            axisY: true,
            speed: 15
          }
        )
      }
    });
    this.lightWallLayer.addGraphic(wallEntity);
  }
  rmLightWall() {
    if (!this.lightWallLayer) {
      return;
    }
    this.map.removeLayer(this.lightWallLayer, true);
    this.lightWallLayer = null;
  }
  add3DTiles(option) {
    const tilesetLayer = new mars3d$1.layer.TilesetLayer({
      id: option.id,
      url: option.url
    });
    this.map.addLayer(tilesetLayer);
  }
  rm3DTilesById(id) {
    const tilesetLayer = this.map.getLayerById(id);
    if (!tilesetLayer) {
      return;
    }
    this.map.removeLayer(tilesetLayer);
  }
  setView(options) {
    this.map.viewer.camera.setView({
      destination: Cesium.Cartesian3.fromDegrees(
        options.lon,
        options.lat,
        options.h
      ),
      orientation: {
        heading: Cesium.Math.toRadians(options.heading || 0),
        pitch: Cesium.Math.toRadians(options.pitch || -90),
        roll: Cesium.Math.toRadians(options.roll || 0)
      }
    });
  }
  screenshot(filename) {
    const options = {
      download: true
    };
    if (filename) {
      options.filename = filename;
    }
    this.map.expImage(options);
  }
  flyToSS(options) {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    if (!xzqLayer) {
      this.map.setCameraView(
        { lat: 22.86077, lng: 115.051968, alt: 65487, heading: 0, pitch: -90 },
        { duration: 1 }
      );
      return;
    }
    xzqLayer.eachGraphic((g) => {
      if (g.attr.QUNAME === "\u6DF1\u6C55\u5408\u4F5C\u533A") {
        this.map.flyToGraphic(g, {
          scale: 1.8,
          heading: options && options.heading || 0,
          pitch: options && options.pitch || -90,
          roll: 0,
          duration: 1
        });
      }
    });
  }
  setGlobeBaseColor(colorString, opacity) {
    this.viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString(colorString).withAlpha(opacity);
  }
  zoomToFeature(column, value) {
    const wfsUrl = "/topMapServer/geoserver/wfs?SERVICE=WFS&VERSION=1.1.0&REQUEST=GetFeature&TYPENAME=gxj_20:eduland&OUTPUTFORMAT=application/json&cql_filter=" + column + "='" + value + "'";
    http.get(wfsUrl).then((res) => {
      const geometry2 = res.data.features[0].geometry;
      const bbox2 = bbox$1(geometry2);
      this.map.viewer.camera.flyTo({
        destination: new Cesium.Rectangle(
          Cesium.Math.toRadians(bbox2[0]),
          Cesium.Math.toRadians(bbox2[1]),
          Cesium.Math.toRadians(bbox2[2]),
          Cesium.Math.toRadians(bbox2[3])
        )
      });
    });
  }
  addWmsLayer(options, clearFlag = true, clickCallback) {
    if (clearFlag) {
      this.rmLayerById(options.id);
    }
    const wmsLayer = new mars3d$1.layer.WmsLayer({
      id: options.id,
      url: options.url,
      layers: options.layers,
      zIndex: options.zIndex || 0,
      parameters: {
        format: options.format,
        transparent: true
      },
      show: true
    });
    this.map.addLayer(wmsLayer);
    if (clickCallback) {
      wmsLayer.on(mars3d$1.EventType.click, function(event) {
        clickCallback(event);
      });
    }
  }
  addEduXWLabel(column, values3) {
    let valStr = "";
    values3.forEach((item) => {
      valStr += "'" + item + "', ";
    });
    valStr = valStr.substring(0, valStr.length - 2);
    const wfsUrl = "/topMapServer/geoserver/wfs?SERVICE=WFS&VERSION=1.1.0&REQUEST=GetFeature&TYPENAME=gxj_20:eduland&OUTPUTFORMAT=application/json&cql_filter=" + column + " in (" + valStr + ")";
    http.get(wfsUrl).then((res) => {
      this.eduXWBills = new Cesium.BillboardCollection();
      const scale4 = 0.3 * this.bigScale;
      res.data.features.forEach((item) => {
        const geometry2 = item.geometry;
        const centroid4 = centroid$2(geometry2);
        const coor = centroid4.geometry.coordinates;
        this.eduXWBills.add({
          id: item.properties.PLOT_NO,
          image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGwAAAB4CAYAAAAXIRdAAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAbKADAAQAAAABAAAAeAAAAABsu+tcAAAr3UlEQVR4Ae19CZgcxZVm5FVHV/WhVrekbklICCFkcYgbJBCIGx8YfJ/jkzXG9nhsz34f3vV4AM/n2Znd9fgY29gzwI7HxrvGBxg8tgS2OORBNohDHDISOlFLjdQt9V1VWVmZuf//IqO6uiX8GboFKtMhZUVkZJzvj/fixYvIbEvVuH/7wSXf/+CV4ftroqaCRwAFbr3DueWjH7j3ajbFNe356rcv/dgVF4TvPuEKb/sftluBimKlLCsWX8FX+K8sePRxY9PjT8QAHNLII3039VtDAZANJJPfMTQj6SyLRE0SI2xX6Yx4Sy1dHKbX/Fv4wZ5vXnz35z/16587TPmlf7hs6YffGt3x8eudvWvXW74Qn8VHBIpOytQgMZ5Amvr5TC6mE2dqN/dTvhColk5J2AbhLAx6zQ8II57UixFvM01s7e21w6ERK/zYW6P3TGtf9B3rhhuuaHj7lcWun69R4Re/5hwY5SpmZQFgKeEmyV8Lhg4bBiMsJl3ChoyackChlkYkiKYTEdFOQkQLCWODGnxyG8HD///7T5VZ7a3WHmv1qoufCqN4/puucfdosFgG5R7TafmHQkaBimQMJJXyeYLSaIqkFeNbmUS/przqCNa9FmBIlxoQa8GzErElSQQAgIbkcWzlcsoafCQ41oqHLoxbzko/NzQcR3q+AiAkvp0AY8CqApWAJACxZBG68GvdQejVPnyNhQWlmj5HiAAK48EbAxwBBW0hJAXcBLRwY7BIlI6hIWgYulxQmuUJhxklAooH6pM45NSDIEGE99W2jIaqUVOBcRTgPKXpJL96olI2CBxRBAo1LT0N4VlEXJAwAii2zqe1RNEGE9JXxaBUNQpWLEMgAQWe4TxmE7DxU43T6I9r7Gv3VkQdacZ/VdqQfzQ9Y4AjYMlDxiWg0Wd6MpDOKCiwJLmoYNBpwidgAdkqWMwnSTXyUjdEovxL8koBUz9jKEC68h+pR5oJs5g4ITmeUozhAT1NZQloPQKZKEnhNIcZ9V20Es16VTGogdVICZAIgnuFbaUNuiCpbAozTeTxv6SXcAinEC5w6RC2gIJmDnAbBz7ubfgRiE5W4jOu0wgmfpNc9IhHDbWpYHDOGsNZzMw8LJhpWSIiZPQwzgDH8qbcGAqQNrGhG4lI2gEExglNQW+SVmgrHjlNYiSdUQDxKLF0oEDkTdBmTrikUPqGs1iBZj08J6BMJ6OHAV3BFG6kxVineQGUwX+hEiIsKhwGNMNpRFYANQk17WUORBRcAtiY8vVCWQrmqEieiRikgCWQhwCL5TGtSY/glEsooGkDyhgxJBG4T0Azg17wQh7SkGTWISQWmkuEjpZg7Y8eEqMxUheL0U5CBiEWj/DoU5NqyjcUqNKrhkoSRwaA0/OYhORefoBB8lhzoiaw5jDiQ/rTGSbSd/wF+/LXPDCJdQH6WRIezWNCL/rAJPgz9g1Fky4mNBaZZVhJBjvSgbZCY0ONKlImgr7Q8kU4jM8PmYkPat2hAGGcuWrTvtbCh4UGfwSwP/Loj5OeY2Xc6PrjGf6Mn046HbRI1OuEF6MbVwAYLQRQuC5hXvGSZ0nU2BImvbFji6+3O5BDqwYJXYQBGYmOgLYy5Zg+VWltIuhLvho2SoLiCYK1iZHcaDhIkFSZJMCij5WOjRyb+bV+B9ro9VZCJEOrhOZV2tYSERgkj4V6CSQ1aj25Rwri/k2i2mN9UN2sTEaCcBnV0RrlQ9QS3Jt2sAaDr9T2GvzRAOmOk1RV6pBIuJedZtKcqCS0NwOfSfSjWooisroOQwGSAFSuqpimMEmn48WUwtrwTBZ+aAnuNNDMK2mTnzE3tQ9eG+GDum+A4gOyC+nLoCyaJaTpyGHPZwlWiScgIzbhMMaSJcTcQdDBZbwFBLRviZ0LcWLbIjBViweesS4DHMMSwcCUEwokyGnuSYiTMEMtWPJEaA28asUh6M3tlSRnAhgihT/IOQyhdJGfjKe1IwGNoAoH8h6tEf6SkcJ0UwAdkgIJpYVrCB7oZAy6ICecpiU5RGiISE1K3OsEwpAJJ2jAmIB053kCsx/GBNoIzIIIDUoHkLgjbglYujXkcAGP9QuADEw5oUAykAUkAgb6CA6kdZVEpDFu8IDko4QzzpzxSIrRgFUnRIg2yYDCaIXXGRNzP8VeYvsigAnio+BpFE09U76hAAkqA5o+gElEpDwGVwnHIY0RgwYsAixHDSU90mkMR+cwzWW6QG5N2wBHb7mQRQEaChCchJd0bs1xrDq5l1boHxlFNfevteAYYGo7L6TS9JJfchUCmoOSeIIFEIUHSXfkx0EcliKAtbfFdk8veIvnBggMKxPQEiCYVheonwMzgMcfXYEMAhZXDaCymjAfvaadJtPosE44ytC1ylUkEgEE7TRYpDPJaqXTOrd1x50XP3jsUfEZ53/A7eobAGjgK0Gcmh/TVOc0IDAWA6SrQUEAZZ4pdzAFyDE1sbXcxGjBU3MQ8MIdyUjOgp+A9YvvVDo9z9onSX/xi4vXd7THSy74oNs1PMIk5DShPX6YH0BIJfxBzdW1GmurOslQvattYDXyNRTQoNR2WGhdGwFmGI0jvWQxLWQEWEJ34SwD1pr7uhdXM6xeddHTjXnr6Es+7O0uloCWHMdCZspXw22sbTx4jKP8GwuXxE791FBAKG0ASgZ+FSSmIwETrtJMchBYN9zwTDlROpRa97sVJ51/3m83PbeqPH+wMIaBq7WiuClYqtSYvADkV5VxakttalD2li6ri5xFsPhsTMIbbljpNrSkrzSZoCgCoIq5fVFfp3vRx1MPEgpAjxtD70MTRvOQSVvo77rbgHXo9FOxRzQF/gTEj+j2c3ZFHyip32mr+3sstXLlwQ2+/36lVrYj0Y9FFapn0V7/gN1wg63e8QzkSE9KNWBdWfAP1s8a0pEqQLYvWeSrGztDvGNVtzps/QMWv8NRm/Y0KN9rVirIqcZ0sypirnAx/1YSv+QPKOWNqHTTgDouXbCsH4cHs2F9xFS1xPpo7qFaCTEY5j1l+XmsD5uVr5plDUPQ0gCNPtc3/Bf6BaUG63qQHiw+DkWTIznu0UWW8gt49df3IBA95cT6SuGOYfqM53OmY/o6dvUPGInvZME/riUiMARH8TJWBMoQikY+Z7o6d/UP2LY+SxVDSwUAha6CdSMvms8knCDE50zH9HXs6n8OOx7UFxMPfEJhJ10ShQOSkkYzRvF7CRCMiunr2NU/YCS+Dc6h0TN0sFGBeYuOAIkhDT9hZCuHigfT1bf78wCMQHCDj1C5zsF9qiAqAGApppsC7NWlQGoYnAXuKoO7KqGj3FRKN4hLLbIZ/Bjxtm0rG0qHg/R17A4ejfXYmVIanFOC2CMoVgIYu8bJDb5VsUUslsBhufrucn23noOrq2ipNsxRtkO13gUn6TmMz5JzDaJ2pPA8AnBdssEnT+vxp/4Bmw+yFwBCBS9kexCLcZRwGOK5PSTx4LwgtGGustT8+l7J1HfrySKuj/nLtXFoCJflYP2VkssCp4UKR1csT+L5nOmYvo5dXQMmWyt72yyVBYd5sGTYEZQLAKbnsXQ1zHj93FJI/2I7vPWAY/2LRA8cYwMw+edhHeboOYzH8PRZSuyYgbPCMua5NMTmFIe9egPzRsDklmGWIiAQeRY5LPLkUjE4DWH6UejK8wqUDqZnvjp19c9hfYGlpuNgegTFIsS8FduJ0gGFA5MZdHoc0cPc5kFLdMGJ++vb2lHXc5i6HmziNmkOo3XepdIB0xQvC9qi8W1YP6h0iKZYsSRfnXJYfQOmbgBg4LAKVPYQHFapYC8McxivGNqh8RkPY6KqUEtsBNchX526+gbsx8/A1ASOcQCYDQ5yXQcnljFn4XIAmHAYtEbG8znTMT3z1amr/zmMAEAWYtMSoGFvBbAJFjTyGlgYTw60sXCW9HWKFppd3xz2DvTAyVGth7qOOcyBlhhB6eBF273xGc/nwmVIz3x16uqfw2xwmE/ugbgLIP482BPpqCDK2x/wGU8OjGC6SpMj69f9GQAGNZ2cQy3QgZaoMHeNd44DzoPqz3Sy2Tk+Qf3c17dI5ElfAiCLZnAZNUMBbJwvygc4jOmYnvnq1NU/hxWwKWkXwGHUFAGUOSJQC4iORzqAyvRKXgSpTVE34foHzIWNkJzjYp2FpXNVJHLvkvJDH9Bx8ZY+7ig2kb6OXX0D1jiEo2sN0A6hTFDp4FYKdHzBw6bWQbMUfNliAVhUOsoQiY2FuhWJdT3alDpNqTzsg1QmLMxRMofJURzOZQRO+4wnhzFdPgOwkK9OXX1zGInuc0sF3IVvIIwqHOPQ4BwWycLaVn5Q14O0vgHL4hRvBA4TLRGijyYpSzgL6zCYOmDYQAAHp7AOo3FYq/7Y8Kzf0791PdoUj7hxL4zijiKR9kPFhTMuUUBkEQ1zFa33TIOL6ZmvTl19cxiJzuMBJWp//HIP56pxHKZfjCCQ5EBb0tcpWGx2fXOYO1NzmEtNEBc5KYaiwYsLaPo2AUzmMAvAjtg4bIp8derqFzC+29w9Qus7tD+IOnIP1fcYAMkFcWh8xhNQ7jqTI5nvRT61cKTjWLeAgfxKpUrgMABWhjUerCScxO0VXjzmZnyG+ZzpmB75JP+Rjs4h2le3gElfOvHLBTM5TNZh3FoBZ/FSMTczjU8tUadjeuarU1dXshyauq3WqLk4ILpQrnRqplK52XizsgO7yi2qff4ivHg+DcISeEH0yXcdkas01K96dmzGEYJ+FRa7lRrZrfzyXrwrsUWuC9UurABoxDri3RELWHwfxFqkTgIwx8E/FiAcgzlpASia1lTF+sqGiu5k0sptwKFR11UzFrapbFP2IKoXBouqZws+MIhXMisFX4UlH2EAVO2+Dw7chnltK4bEcwBxE/wnrQv+hM8AHVTZ4Y2otvjwVvOnlR7fjS9tpNUyAHQ+iHkucuVrc3ItDNcdx842mJm2xm6+L0o1N1pevs32Uil7+pw3q1TqGKTRKSU5UAmCrVHv7ruioFSOg+FeuzwwZFWGp8EWfIxlhRwEHbLG1unN7zCK+S2AewBfJlhnXYEvfRwB7lVfh8X34jMNkboAtDgfHHQmwlAQQCqS3LZ2xJa9Po7srb7vbnvBf922ID0czXZ2z/Gi4dmuF87xbH8G7L0Qk0GzioN2FXmaA6lW8D1nDsm43I4/X70YZv0BZfvYEQtLQSV6NlANv9kdzu7y/Lw9K/2HBel0ZYFlR8dYcXQ65r/5+FrE5WjP5WhREK+OH0ZJDwDA+6xLFL778eq4V43D4lWYhyz1LhD1cnRdiAyMIrxIuSF23LVDIw2/XbdrWfd5xzy4KOOVjna8uAMmKKoLLRBZ/N4cVPo0jgTkW5TV0KocN63aF52q0tnpB5HSL+5XPZsfU3GlpIJCnwqHMZf5ZRA/hshtQPp+zHfdYWjtKQWZ7Q9uPW/zsrnrOhpzhXOtsLICXyJcCkIZBY3icxVy/ggt33JQXYc54hUHLP4V5iRLXQuRt9z0DUfgH8Ea91fdA+0P7RzKBad07lqczvhLnDB8HdKS17Aoho/PpEgehmUCymRUpjGr7IZ2cFlWzThuhfIybZKGLEo5R7/i96p9m9ZCESmqeLhHlYcAOOcxpDRlETgd5kubdug4G/0g/czju+Zumtc44nU09yyHbH09juyfIeXrSh5CS26yXo857xVyrxhg8a/VTBDir8BRFyd9gx5nrSkEDbf9cPdXNr1vzucW5zLFc3BidxGIUJY0jhqp0sEaN4fYBC+bVanmdgA2A0oHAHvdxXjhQQNmwKIflgDYH34NRaOoosI+VR7oUaqIsBqroIQqVwOaDsd8ZcneNFLIPnRb1z89+97Zf31cg1d4H4C7EG3T9LPQO0d9HT3bW23vYQocdsAwwG21Sr0T89G1ACKLLpZhYP+Pwajph99fteyFj17xwIkZVbgQBqNpSEkSjE7uJmx8QwRs9OMtFSji6QbltcyCWIQq7zSo9qVvxjvOCYdJWeAw+CE4rOfJu/Cuc0EFw30q6H8Bc1kB9/xuMUXiqIuTe/oUu5qzJRyF6kBJNay55e7zn/qLy9fNarIH34s/CvtG1MFjdRgA8U2Y8W7HGDlsS4TDChhU8zbwyt+Dq04mRdD/+w6MtH7tvqcu2P+W5b84w7aKF2DJm0+IosWd5ipu99dy1wjuKRxjjOQiOBXnEXlAKo/ziC1zsA6bDY0vp2ae8TblZpI5LJGaRCz096sXHvkpNMsRrMN2A7AuiEb8GQUAxnJDGUiaFrUAavBYb1bAo49agQYyZ9fcsfZN6y848b7prbkDnwGuF7CPmN8eB3xfwJKgV+4n+cdMpJNcLAb2KnWqKlvfJ1jgsv0Vlf7rm3fe9DehF2TeseKnn3ad4hU4j5sDucAtuAgUL30/AhDBARLfIyAxbKv9uPQzx9qPA78A2QqAXkWlcAjRwW6ylUHUuMtGvAc8bKSz7TI+GlbEVsx+lKvr8EBc4VqU7SZhfc+26TbptiEfzMdYbriq+OZ3nP/Tv4xUkGW/2D/2E/09hf2W/k86VdG1w1CmgmKxEhP+36NsF1z18L7BGTd+d+OKgS+suGulq/zXI94XcFi5EXejvuEmAkQ2MYrGKMe1YqQ3OTPAYceqSjMW1ylwGNT53MULMa8lC2sWblzRVyO/3qLswMf7YbuVM/AkOOw5NRLuVT2qJKnIacgsYSogFIe8Z7zhOiMuzVxHHxouwPrVl9e++f5rlqxtntG073o0+0zEV6Dw/HcoJPcjPGlu0gGLV6tLgMKXQGoHff7JzTuv/urS3IbsGTMeea/tRPPRcoo1juyiAGKA0tzEpwRKz2M6HUFTahbWa03uMcrNL1Vxtl35zTgvn4F6kvZUyclgZNuq7bylykqBveCoHRrFIy6X1P61GyCuIpUJSyoVBMrBQZz0QEVZxR4VjTyheoNt4I9B1G/EpJ7bNFgHA0dAYftHaj2/xfb2dTuX/fCZyvGlq+fd/FmA9nY850dC/ta6TN0rbZqEn0kFLL5HnYwTtt9Gu1x8j/iWa++4+tZPnb8uf2LnMx/BDNYmo9aIPTaeYGnRpzkJ0xLuKRr5/VCGfTUbtsOGpvOValqgKtNwpDDXryopcpsPYuDF87gFakyLoNN2yblVwNgzlko/AmC998JqARRdux/isB8PIEqhAbrlnEqNtCi3D1GDW9Xg4IMAbhdK15waidhuECBjhAmo9jWg5DICJ87ufWrP8bd+84Flwze95eaP4CMGH0U0xHD8CetS9YROM7FfkmhSnFbbrZtQWAPU9duv/dnV37nqhA3Zc4554hpM09PRScr/soBEoLCoEbD0XBHgXj8nh0UIz1Ltal7zu5Q76yJVPCqj/Jk9qpLZh7dQaGXAQjcaxpE1rY1RE6VOkzthIdR6bK3AgFN7YVmlCs8+izTg6rhPVaIBzFUoB3NZ5JRUmB1U5VbYGJtmqrx3Nmo+GlrkLgjLA2g3Bw7Bh4iD78hQQgCOfTBDXp7HzTMbe5fgQ40bvvLgGx5545LH+TLaieD+FTd8SN1z479jME7QsSmT4yrqv6GgFoC17uYdV399ca7PvWzxI+/BYrUVndLzkQaK4o4k1hM+x6sQMuEsD0Q91jtTtXR+Qg0tbldD83epsGEXTvaCeOF+vNlwAF+26VF2GX60HxyG8mDBUBHmxVqlA4NelA/48p1EPI8rPr7bAQUH+ZjfZTkBFAWUy/JZD+tjvaz/aO8s8BnySftHYKLSBKciMiq2tVLC+VZEeNTKfnd2lh3SgfQgXSAcPw9/wm5SAIMovAjUWQ5gYEJo/7Lvn2Bf+/pfLre9aH61haNgccRy/qJmyBFLX89ZMPapRblPKG/Gh9TwMb2q0rAHQPSDoAcASh8Wvho0KxjEW5eDUA5BQCgSMBaC4BjtOFRqQZIddOF4tjyPkRbpLeRj/gjlKJTNcm0pG2HUx3pZvz3/bWph7uMCmlZK2G4NGtvPS89lWtMlz8Gx39ct//E5pAPpQbqAy87RdKpS5GUFJgUwvAh+NWsPQ++mr6y7tn/5tJtaM84IDaew96GDBMs401Gupcx8FSGNB1GzIP925S+Yo/qP24j9R4AT4M/3JECRExzcuyRyCUTzi2AsABCWIeKokUGByGKTElMLL3KX8RnP50wn6ZkP+VkOwWe5YYBJDKCxPtYb2n1qaO4uVelYpI7OvxugYVCgneQ2SgS2v5bT2D/es7/oN/tPOpAepAsfGzpJ+GX+TBgwrDfOBDGOgVzrXbt3+S8GBgacE2dtXQEwKtJ40zAtFjVwFIMEjp0P0U3sZqkF2TepcOESVWx7AQdDOfIHwAnDeM0VSkI4hLghAIT0BSgkJcx3sFRYFZQHMWeDuyB78XIfdp4TDrO5FkOYPuP5XNIhPfMxP8vR5RWUizpZB+uLwYG2cPagGp67TVUWHK86G8/CvMd/eqAZ7mL/GK4dlLqvlRM7t55LepAupI/QifSagJswYGgo1HjO+O4dD+xcGZ1+7OZMyiljewJP6KhsmM4QKI5CjlC87y/POWpnKMxzM85SI9M4yQ9D/YbIw7wUR4MY+bBOlEHYEuYp+MqHj6tSKCkbAKYXtMa5c1fGTZe+B5BAcBGosRfj5TnSMb3kY35TFstl+awnRn0OlBLW76AdbE9h+n6Var1CdWAuwpetWIu0n3Oa7o90BWENHOcz1JmKy2eQHqQL6SOJEnrpDC/9d+KAKXUGqy1W0us4mi496rEF0lyKBjo2Xvu6o6NAYlSjg7TCNTZfpYodmIMsjGyskyKIOQtgWTAlgQ2UVYYGh0v53C0uw7xUBieEcdsXPhtPe+9n4uziJbHblIbiiDISsITDEIbPeD6XdEyPfMwv5bA8KRflsx7WF6Ne1s92oEJpF9vHdmqwtGikdOA/IzGko7hnH/VUEJEepAvpox9reiXhl+xNCLD4l6oJje3E6qZAiztedLRzXj9U4gQkqurGsVNa26I2pRenfIYVkIrz81XYOCDzDFV6G6PaiTA3cYFLJaEMAAPsX+He8rEc8Ctxy9f+Z+wuOFfZOexU9j9l++tXqwM/vR9GYA0a5KyAh0yM53OmY3rmY36Wo8tjuSif9bA+qRf1q1hLA85/0j60k7txdIbL2CvaN0cd7/VgRRzpQbqQPqQTUncK3UbTv6TQhABDo1vZcmw/9D799NN2e3s7zpJVuIOsxSEFonG6g7zTnSNoIJfKwEof46uTEddUMccsiAMhFkUgoigKIcJQKsrwS7jAGU0fOSt2Z55qxWHRKtz1PWt41b0q2rtVVXq7VM8tq1Vl/z4Bjn7PrbhHPJ4znaRHPuZnOVIey5XyUU8FNnnWK/VLC6GooF1sH9vpoc9ccrP9bK3RcE0/a30MXNKDdCF9SCdNL9Lt5TlOoRNxTcyMkTM0ffp068CBAzbewDImHXaG7dOKhqlFz13Q8JgR/zwAFmTRDnACrecx/2Cq/MVOAIj7EPchErswkkf8HBHy2EctkeKC3ZuV/wyUFNigLIvwQ5zuGFS9/2sHyiGBOHRC5NUDAZGSPn32ZpWavzQpB6IK5Toon59Nd1yEUa9KQUlB+jKawe8uWmhfBe3MgMc8tU/aTy1X2xNrBya5SNsiMWxJD9KF9CGdaC2DTGmU9r+Mn4lxGP4uButEawW4bBbrndghB1ELHO2EaRhVYTojEnl6I1B9yiuCUviQl/xJQdgEeeiTJ3lD7HkxzO8u8ysAHLAcAtHzG1mMSs3BsbbjZ5KgkQ3OcLE4trGrTJGUsqHxwec94uU5Cc/0zEeny0GZKJflsx7Wx3pZfwUvueNglh4QaJ9TDDAkYNaCo8QwjsOCg6/Wsf+Mt5yC0AXPDJ0A9lBt0pcSnhiHxTDd6GZPx8RqpdNpy4/cQc+p6QztbkaTYic41mG+QkhzXgmA5XH0jLwZ4fCnww99YQzyU7AV2Jc8bG1G2IiJOeK5FQXlbvDW31upsx8Tsdb4rg+pzHPr7dLDTyl/M3aS6ShSdQi/IKZl2elF7XHmzBOVd+zpZBersvcxloN68ZWcDOpAq+XDLKgvQL0O6kc2aQuojv8AtFDGAMMiHo4AWYk0Yb94R8jMHpokgjpTcYdKpZLl+/LZP71XR7q9TDchwKw3qEGsw2CNUJ2fv/C2RTc9+omdLwxO37Vw+vCpMrooHmtFIkclNwFDzGMG1H5wadvQLuUMzVdxAy0CKdA4h4VrWbketMII2gNykRgEIcbIxzxm9V93nZr2pS8qd96K2Ft0Ji8rjwM20RDMTCPDABacnsF5jxw2SBunx1YDLMfCLLFV2fmg1feFG7FjjYHBT0IArNhLYVDgex7YpnE9GJVtrg7zAA1ygAAO4a8nDe0Af5E7tPVeCkQf9SKad9qZDU8ASXpkMpn4s+fcSq7mdLGHdEtSvmRvQoBJbThAA6FxZV4NLysWizvu2rys63PLd0KzEwv22PmLWxWG2zQEDXJ6Y2jgTpXv/pwaXID9JcwVtgMNDaveOMY9msjjagQ4oni0MVdB/FUqkXXguhtV9vLjVPqcq5R71DIBxQEwWo8bQwwrLmPh/fw6y//PO1Vx1Sb5owQO5iSbHOwBEFcDZmGrxsLutQ3gbPmqDs5Goh3ZbluxnXrAaau9Vq7IW2jnOMf+h6pMeoAuMemD1lPiPszx93LdxAGLHez1RFe6Tvmqk+YN/ui5fYv9vkLuuWnZkRPQEa146EkYjU3EoNkQrGCO4Ty2DyIit2+9yjSfrvx2LGKjJoxszAFoHlsISQkigrPKCABQsBjUfmh2uAprtlkj9/5vnOXAi7EXHKu8WR3KmTYLTACOKuJIW98LKnihWwX3Pacq0CAo2lQWHw8TUcvycLmYn1J48wVH5QhWxeUJKhhsrSaAllbZnunK2veI6gZ/UVminOC2i+kHgWBYi0PcyL3VV8xtHqos9k+at9cmfXS882stKuTuJf9MGDDr8uDhcLW9FX8pY+HrO267/Oldn7xnzfZz1r/t+Ht4vJqjjEqG5jTNYeQWrrU4zChOuEkxorqLP1Kd27LKK5yphuc9KxoiSClcFQWYXywstCEmLaj7NtS5GKo2PoAI0CgooXJDm/Qf2K78cBvuxzkoEfIGC4zDHDbyNibEIL+vaOGIN+fLyOE3qgAUOQtgxQ7AAnCZvUcpd8dTanfxdrQU8xraTLC0tks5MQocayVoeo/MX7PjnEcxd4WkC1oAsRxvsS8LwGEv300YMFZtW/bNoNz/aEgXP/aGE9b+/lfPnDewbO6G9Z2Ne8+RjunDKxQdxtqhNwT1mkyfBxwEiP7wrWphd4vK2/NUoQNrJ6ho/MAy/ooAiAiiwuoQY0FrueAy6PqOB9FIqw+uCgCjam5zKVBDEAEd5KIW6FIDBKfyDxLwC9xUCyOApSD6bIhCHg2nH9uN4OC8ym9aouy+Z9T2ke9BdNM8rcFi8TxGQLCMG7ORiYlqcOb6x7pPH3jDCQ82ky7oQ0w6TYS7WBXEwyS4S4I10MgfwqDLn9r82H9Npcrhv65794ain+6S0Waq0KJRg2VGJkcqRywncn62fMvId1S0/Q7VuKVNuYVOEJRH2FrBAVhsOti1xlsqsQeRmWqEktCIDUvMMZkcTkuhDA+jPXvwxXh5jjRMz3zMb6Mc5UKZYLkoX+pBfayX9Vf2fk9tHvk2+N8VsIxWyLaOgqWPCWiJQSBz7Pe3H3nfE6QD6UG6kD4KdDKkeLk+RcSEHf54ujXyy/zMjCp9H4dmW0bC/J3feOyvbpnm7Gj8xLIfXOFalRnCXcZkQ04z89lYY7BeQ7FFM7Ggbml+u4qmzVWltqIKGvdhYQ3rB+yNcUxbAwy1mMNcWCUCLEmhjMM6ARGFuc+GbxwVFXmdltwFLuE3Ey1wV4ylQhQ3gNuwZIBSwa9xp4ZmKK83i+MCu1T/wE9wLBS702i5C4DKVW4aBat23kpEIf44xb5vr3v/3X3h/KFPn/r1j+ac4aug1fSXVOYvcm8Y3gvgRttm2vgS/EkDjHUGq3OnWFH5W3iPzhss53/wrQ2fur0jv6npgyf95LK0F8xKRCLnM6oj2tLNkA7z0KY2qjKG4GJVhpfv+ArRZdi+n6/CaY7yG/HaUApqO8BSNkCDyYhQRFh7yTrNggF3vIvTshCGTAJnACyuvSKKPtRQzqv0UJty+qDIDO5QxcHVWKj0okT+09ogOStAmLkNZx0CLD/0ur/35NtXdw8fN/jJpd98Z1Nq+P1Y8AX4bvQnvctGHmerjgjA2BByGf3KqsylUAxuDCqOC067+1uPf+SWlmxv7mMn3nZpNu3PFiCYUM9nWhkx3EZfm3s0eExHiz7dTCgCeW8h9rZg/8PLD0ET5l+cMIvSg8rPIg1MU2iEBo16iHGQ+vr9Z7QPb2R6RcyZPhQKH+FBHJAp4GjAyO/VcLAFHNUPYDhRjAJFpUgrS1xDcQrSPjmKF3uCObpYTO/5l0ffd09/2DbyyVNuJWdd4bmYZ2P7evfy0j3MOlGwpAz+TJYjaDfeeKN13Zn/sNJR4ZcrEVa+YfqJ1ZvP+doT+xcVPr38/53S0dTNRTUsG+imWVSP+to6zgYRPM5vJBhBpKN1hMuAaTCeZnHsLZedi/lsPnQHzHU4Kcrj22JWglJBXQIKJZQHoAdmtMCJdkC75B5Y5LeroWIXhOqALCnI0ZyX6Mw8pS0yeoHMk8GGszRIbIsGDhNo92DHY9946N2Pnzx9c8Nli/7zM2nHP9m1K1BhnS/848Ofv//666+HrWViolDaJs0zoUnwDZcRtM8u/cfTM+nw78LImR5EXv/OoTn/fPsf3vrkirn3zzh/we+Xpd1gpgBGgVY7t7EdBIvCxxzLNhyon1GUclTzTyVq7iNXNAoBU1BbPPlHszIXDDDfYngEwCzApg3sishHR42POrIBRvu1gB18FpFPtcYrgPkVb+8D285at3bXyn3vfN3PTprX2PWXnh20OHa4v+Q7X/zqhuvWEyxWd0QCxobVgvbBJd+a0Zkf+DK+LLQ0jB0Lb6qs++2es299fOfRQx8+++eL5k/bfTxkPLTAhPDj/VqgOM8RXD0L6aMF5EDtMJclYYLAxS2d5hwS16SrBYQDhRxM6wtnwdFnzFsr+nhvOArpI8vt29E3+5n/87srN58yb3vjuZ2/+wjeaFnmWFg7WPET3SNNf/O9jZ/cN9lgsRmTonSwoFpXC1pHxx7nA7NvexfWR9eEod0Qxm5lwM/9ZsP+pXc/unPJ/rctvWv+sa07Tkg70CTHcxoL1VokgdLcxDgSl/dcYxGMWmC4SCe3jIJJ4sM2ibRMT8c8BN+IPx17MEg6bXXO8gO357kD85/+6YY37zht3sbpS6dvuKI5PXKRY1Vcx4lwgsr57r/vft+Purs7w8MBFptzWACTfiZKCMUj7u2rT/zXWa2ZA58GqS7kOAwj1xoJsg9tHlx452+2rdz5xmPunH1Sx7bFDenCHBCT34oaPcvIAukMB+o7DabhDgOGefZivgHYcJBJRw4yHGzCtNQA2kKl4fkndy/Y9B9br9p90YL75y1q2nJVzisuh1kTcgNLCEutOVBq/cbNT/2XF1BcdLjAYlMPG2AsvJbTlixZYvX19dlXzvzbxU3e0DWwJC3Dbgp2FqGph+kn9xbbHvhd18mPl+zG8gVzfjNnXsve2Y3pkXnoP+x7wl1sqxZt4+9Z2XgwGTfeGbGm43V5VN0pZo2TNHZpyM89//z+mXvWdF+0KxMNpc6e88QpM7O950OhOAkKFZRRfMTKttYNBo3f/fneLz07bdq0aOPGjfHhBItNPKyAVWkwjtsQb19z8ncWNnnD78Ry6lKob2koJ7QrxaUg/Wx/ufGRzb3HPfpE99E9ly367ayFbV2dmCOaUk5pumtHsFCAwOMBInfQaeKPgmu4ZrzPtAknQbcfKgeZ/cN+emjbgXm7V28+94WTO7a3L2rbdFpLauiMjOfjhXbYsmD2gs+9u3sGg/zt333i41tQCtcQh5Wr2FTjXhHAWJnhNoaNmETQfsuCn7XMze+40POi87DgORUKSiqGIQJvaVrl0N1djBqeHPbzz/cWWrs29ryuK3KC8JSZG1tmN3e3tmSHpqXwNjIUwZSHP47jODG+dgmOjKM07BoePq2CbRrbx/ebg9DC6Z3ArthuqlQuO3G/33hg90DHgcf3Lum3Q89Z0v6HOW0NB+bk08NHZe3CSSmnMhtvV8JuAhlgR2Us8B5D/gd3Dc9fc8e2t3LXeQxQ7NdkaYIs68XcKwaYacChgOvo6OCOrL3E/nl+aeeGZZ7jrwBky0CBPMc0yIaZAnDSV+6+csV7vhimdxYrmd4gSheCilcsBOniUDmDnaeWQn+hudg7Mr3UltufaWkYwMGF/obGVCnb4PlZzw2y+FREQ9YttWUdf17KDY7CWYAZ0O6o4aFKfAWEG9txPAzBty4I02s37Fm6bmN05TB21KPu7m6KzypHsV+vBFCGfq84YKbi8cBxjsMcwPbQIG3PzT7vXb541UmZqLQYoggfQIkXYBE0D/nScmAE4IFSoCtpy1JxA2esiDQZ4hsSjMJ8Ix5+CH2SEs8IDs0YILiPu5242wbRvLVkZ55d9ezlT+4qHsUVnnAS2hfXzlEs8ZUEivXRVbuib1/53/HAsQUGPMN5OHXEdtrZwvPOW05dO6fJGzwWXHI0LIGt2OzMY/JvgPKXB/1z+LwU/riKlQMwGWBSQvwIPlcwAqTwzT1rGMoOlgP2MCyRB8Cd2weDpufueGxFV7HhKCr+UWtra2w4yYDENhllguFXAyjWS/eqA6aboX9fDDw+JfcRQIgkC0TlkTppe1NTkzU4OFjtx/DwwZ+HzefzmtVQDtLHSC/3BAflxCg3pqgjQEld4h8pILFNxlU7aiKOFL8WPNOmRFkRDmRcIkLNY7Vnzx7rtNNOq96bwKOPPqo6OzuroDH+j4Fj8r2anGTaMN4/YgEb31DeHwrE2nQG0No4E67lFhNX6x+J4NS2z4T/P3dSaFBscfkZAAAAAElFTkSuQmCC", self.location).href,
          position: Cesium.Cartesian3.fromDegrees(coor[0], coor[1]),
          scale: scale4,
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
            10,
            5e4
          )
        });
      });
      this.map.viewer.scene.primitives.add(this.eduXWBills);
    });
  }
  rmLayerById(id) {
    const layer2 = this.map.getLayerById(id);
    if (layer2) {
      this.map.removeLayer(layer2);
    }
  }
  filterWmsLayer(layerId, column, values3) {
    const wmsLayer = this.map.getLayerById(layerId);
    if (wmsLayer) {
      const options = wmsLayer.options;
      let valStr = "";
      values3.forEach((item) => {
        valStr += "'" + item + "', ";
      });
      valStr = valStr.substring(0, valStr.length - 2);
      options.parameters.cql_filter = column + " in (" + valStr + ")";
      wmsLayer.setOptions(options);
    }
  }
  addEmergency(eventPos, emerPosArr) {
    if (!this.emerLayer) {
      this.emerLayer = new mars3d$1.layer.GraphicLayer();
      this.map.addLayer(this.emerLayer);
    }
    const eventPrimitive1 = new mars3d$1.graphic.CirclePrimitive({
      position: new mars3d$1.LatLngPoint(eventPos[0], eventPos[1], 100),
      style: {
        radius: 1e3,
        color: "#FF0000",
        opacity: 0.4,
        outlineColor: "#FF0000"
      }
    });
    this.emerLayer.addGraphic(eventPrimitive1);
    const eventPrimitive2 = new mars3d$1.graphic.EllipsoidPrimitive({
      position: new mars3d$1.LatLngPoint(eventPos[0], eventPos[1], 100),
      style: {
        radii: new Cesium.Cartesian3(2e3, 2e3, 2e3),
        innerRadii: new Cesium.Cartesian3(1e3, 1e3, 1e3),
        minimumCone: Cesium.Math.toRadians(89.8),
        maximumCone: Cesium.Math.toRadians(90.2),
        color: "#F9E900",
        opacity: 0.4,
        outlineColor: "#F9E900"
      }
    });
    this.emerLayer.addGraphic(eventPrimitive2);
    const eventPrimitive3 = new mars3d$1.graphic.EllipsoidPrimitive({
      position: new mars3d$1.LatLngPoint(eventPos[0], eventPos[1], 100),
      style: {
        radii: new Cesium.Cartesian3(4e3, 4e3, 4e3),
        innerRadii: new Cesium.Cartesian3(2e3, 2e3, 2e3),
        minimumCone: Cesium.Math.toRadians(89.8),
        maximumCone: Cesium.Math.toRadians(90.2),
        color: "#00D0FF",
        opacity: 0.4,
        outlineColor: "#00D0FF"
      }
    });
    this.emerLayer.addGraphic(eventPrimitive3);
    addEmergencyFun(this.map, {
      colors: null,
      rounds: [],
      lng: eventPos[0],
      lat: eventPos[1],
      height: 100
    });
    if (!this.emerBills) {
      this.emerBills = new Cesium.BillboardCollection();
      this.map.viewer.scene.primitives.add(this.emerBills);
    }
    this.emerBills.add({
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAACRCAYAAAChW7QMAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAXaADAAQAAAABAAAAkQAAAAD3Ky42AAAjwElEQVR4Ae1dCZRU1ZmuvXpvoOmFBppmp2m6ERAVUdSIBBdG0ZBRiWiMQcbEGA0aB6Nh1Dg5opPJxLgNMahjVHCJQBANKiOyREUUZG+gQYSmF6AXeqnu6pr/e13f69uvX1W96g3mnLrn3Pr/+2/3/t+7dd9eZbPFSgyBGAIxBGIIxBCIIRBDIIZADIEYAjEEYgjY7GcgBsYxGduRhhwwGBjbBnXPN6NNqDtGqI7BjDeTGcehAkueFLaheGOcHmmrCfVIh8FO2C8pxODZDsXTDpTFCCjboGY8/FQ54/QYdfVYTy0dqaBCYgYuZA5Fp/qQh69azACGrFkqdeGApk6N2W18T4FOsFQKnpUgh6K0o78REBVY8AQ7FKW9WRyjrMvb3Q06QVIpAVQBBs/qVHjYUk4/MxAIIkBWgQbvD8qoU/X0M8aEvNtKd4JuBjSBI5AEGFStjkFTpiSNmTPnkvi0tEmuxMSRnuSUQa6kxBSXx+tyxMfD1tZcV+dv8jU0NdWcqvJVVx1sOnVqd11FxcavX3rpo4Mff1wDE6kAXa2UYSzcACr44KHrNuAJjPTRpYXgIih5Ag2qAgweG9857tZbM3OvuGJuUla/qxJzcrIcLleHxtfc1BQ4dehQSU3J0ZXFq1Y9v+WFF45JfADfFKTGjQDw1Q0gTX1fAL5LS4eSijACggwz8GZgayCLDtT93aef/U7fvFELUoYPH2p3OLQxBaRU7tnVdPyLLU1VxQf8Nfv3+2uPHGlurK0NNNXUaLPQlZRkdyck2BOysx1JQ4Y4U3IHO/uMH+dKHTHKZZcisW2B5uZA1d69+8p37nrsvTvmfSiiRqkEnxQbgcATfBF1D/DawBC9CwpjgaoVM5mzGyBrQINe/swz300vGPtw0pDBWdK2Nfv9gbIN6xsPrVzZcGz9J42NNdUQR13cScm2zAsudOdceaU3/fzJbofTqY2tZv+BkmNbv3zwvTvueF+CAnBuAIIPwLEBuNyQiqjrlhsChaCdKYyjgs0ZzuWDYLvH3X77gFHfm/Vs7/z8QnTqb2gI7Hvttfq9S16o85043jqOgLbxWtutHPszX3ftrQB5+6TZht38w/ih118f5/R6Nb8T27dv3fXGsnlbnnvusIQE8Gbgc8Z3OfAcfGs6HeNUsMFzZquAe0TuvuL5xdcMuPQ7T7pkZ4glBLN651P/VVd3rKQFwFagOzu2lnjBDRCfmWXP++nP4nOuusqLpadJdsKHP/jwF6vm3vZXGRdA90nFjOes55JD0EnFpHOls4mh93CAu0XP6pm57M0H+00+/xb4lG7a6Nv2xBO1VUV7mmVequPQeclS58XHchGnFsBbPFp52QApw0Y4CubPT8g4bxImQeDo+g1L3p513SPCA3TOelDubI0zvjWeGHWkYCZ2pgAUtaozXAc7bcyYlKtffvkvGWeffaVN9m87n326bsvCX9c2VFSgb9XfHgSaMuPYKDfSkHYwlEJ7W8PxCts3f1sBgAPpE89xJw8cOG7otGmTj3755aq60lIAzdJpcBnISDsDup6IBFXXb8Qk4N78G+dkX/TIw++njhw5vLm+vvnT+3956sDS133K7NZwUcDmGBlfpdQZqWpDnjZaGx9SgsRmL9/8eVNVUZE/e8pF7oT+/fvnXjhlVlNd48qybV/ViR0BJ9Wcg3LGoCxq2lHQ2TEoKme4vrMUmbdPfn7yxY8+8l5Sbm5GbUmJf93tP64p/+wfTUHANd8wYEedjMGBY6NYa+NDikaqD+zzH123rjHrwinuxAEDkvuOGH71N5s2vVpXVsYjGNgCeFa0WYKh2LROO+oIP1YCzhmOtRI17vrVq1/rUzh2AgD/39k3VNWXl3NkWr9BwNvI2OgGCuC0Ip2T12hc3762i155NSUhK8t5fOtXm1+bPv16MayXimWIa32oNV6LGc0HAIu2EGxSLi2Y5Zzp3muWvvEAAMeSsvGuO2tUwAE2arBjxol2HNHa6/0o/WtjwNgwRowVY8bYJbhXKpZJ5sU8GYc02nFop+PROrEzDgIzXAdbeO/0p5+9JmfaZfdhp4k1vPzTf3AHpYKNfrWkwfRgUftsOW2VzhvKywPVBw/6B3x3uic5Z+BZaUOHHyr628q9wXHhG8HKoaLdoRLtmk7AQQG6Cri2rBTcfHPOmB/96H8cbrcDRykHXn8dh18oZwLgLSNpu7F14Kv375PDw0Ag/eyJnuRBg6b6Kk/+tfSrr3BaTMBVylhRUwDXkULw2wE/ZvYPnsKJD47Ddz37DNZFFBVw+rZoOvApF8JsqJ0s+jgESZ3HmDF25IBcpA9MJi4zmGTIWbcXPuoSDejsiNQIuPvS//iPy3qPGVOAM81tixbVyfzQbINJRT04M4cBl01zX/m/65JRwZvZdESmAy9jxtiRA3JBThIP/YQCnnhY7jYa0BkUncCPoHOJ8WSfc+5DMDq0YoWvqmgvzuRgqxZjW9VF4u1xffrYz3ro13FuXF2UCl6urWAcnYpr6NiOsSMHyIM5Ybbjq4VcOds73C8crRYkplYOQNuJTn3yd5ckDxmSiYtXO//4B5xgaEWZ5Z0GZvTP74nzpKToccDn//xuHGWg6PKWZlSfmq8yVhtyQC7ICblJNHWmI3f4qNVyh1ZB1wYVjAoefqjoXPvqZZw1dr7wNlwtrCvRLl4Z13GoO1K0vtMKxjpyr7mm3UIOGXTBwOo4o+1L8+UygxyQC4IEc+MSE2qmW+6bg7U6QARWAQcIrlEzZ2bKaf5gXA+Xy7MYqOUBROhYj1O4YEGcHFjobd1PZIUP/Guc3u7Cvote/HM9ckJuyFH60PIVGgp4ZRih2WhAR8Ks8EPHqK4Rs2b9EHd8cAPCd7zlerjyVW0PlDhFUwbPmuXuPXo0+jItvfPynbAxVUYn1MbKseOCHHJCbshRQgF05g0MiEdUOVoFXQ0OH4KubfnUgTnfFZntYHDnA74LipaIrNu20T/9Gddt2/GtW/27//v5BlTw7Ac23tRUNqMCgU5m9ODKldoONZhjqJlOfMxCtJNZAV1NgMG5tZ2ZhYVJiYMGZeIQq3TDetwA6Iq1XO8z/2d3eb29euntyt27/Nuf+oMPFTwzgs3oO1s3DsZBXZRU8+PaXrr+kybkhhyRq8TScw/2ofaj8iG7tQI6nRGQs5zUWXDLLVNw1/7krl3+xupqGWvXlV55eY7c77VdNuRxDD0xlUevsIVP141A7mpITid37/QjR+QqsQE68yfVx2Slb6sDRFC1wk/b4snZ2RPR0fEtX2izHHywRDUQOgnV/c66f0Ec7+pTrwLtSmjdANDDFj60hUjho2FVPzueSIBzMFfOdGAAO7XCLGKxCjoDoQN2pgHvTk4eDiUekwDlTgh8B4qe7KAZV7v7nHUWEmxT3ImJetud1MpTCB/4si1Uj6nILLHMhbkFc+VMV7GwFI9GVkBHcGOFn1a9vfoMQLCaAy2gg+9scSUm2cbcfTfOAtsVpzK7VV41hC9idFVhbsFc9dwlvhEXtCMWK6AzCAOC6h27U5K07OqOHOnses74tvyf3OH1pmmn9+xbp67EBFNeFwoDX8RQZHpsRWaZZW7BXPXcJQDjklqKGQ3oCIjgbSqeLYSi8dSpzoCuDzp1yFDH4OtvVJcHhNeLW5npKq8bBBnEQCxFrvehyCyxzC2Ya5v8JUDUcdVBhRsAA7frkA9zysObKui0DxfTVFe44AEvn8gyM1B3pE55pM7MBjLEGPvAA+psD2UaSq7HZm7BXNthEAyg24cKSLlV0GFvDMrOGaujVI8rd21c6RMnat+cUMFcCa3Li7pTNbPve/ZEF2IqOr0vRRYta5Z3VHGjAd1scHY8rgyFOgPNDCPJAGbBL+ZbmZn2jHPOdaJKzIjJIqa6oSKNw0zP3IK5RuzTLIYq6yzotqaGeg10mXUdiaUnMGru7Z74zExLMS7478UJqGoioXjERGxFr/epyMKyzI25hjW2oLSUZJg4gcbqGjx8b4vPzo46GcZNysmxD/vBTSowVHUJRWz00dFgzC2Yq7rv6lDIaEA3doZ2oOHE8cPoOWnw4GhiwUUHoVDOIuVGtt6GMkwJHJNrPMc2btDOEsPY6SrERh+6QOlbkYVk5dl3LbdgrlreBmMjNgZ126ZVoBiUHeq04eTJ/QiJB/KV0LRXROZs9iWXOLMmT1Z3duaGQem2Jxc1rP+XeXXr591et/OZpxvCGitK9IG+FFEkVs8hZVCu5hfMVc9dApBHLN0+UmCroDMOO9Fp5aFDX0CJNyBoZIFqs9rh8dgK7/2lOgMjupZ8/LF+ZbF0/Qadj+goBugLfQaL1W+WnlswVz13iUOeMS3RaEBHByiguOms1W1LlmzEOz69RuY55dqE5UQQaOStP/LIw5vRjME28KoZ+sYdcHmbw0GEDFvQF/oMa2RQIifkhhyRq6j13IVXMTF4hm5aSZhbU6V6xxV79pyqKS4uwxW+jMkX6ICE7rJVM/CKK0KeebZateVG/Xiu99LXlyVcuvSNhKGzfxAVgIiUGeUYkRNyQ47IVULouQuvYkIe3YQtVkBXAyAwOiXF19t/Yl/RhzAadOWVHpnq0Fkq3r7pUX0zGDR11Cin3LeMZn2mq03u7lvOGbkgJzgHc9TylaaKgeV8OQirA0BgtaJTDsC//aWXXsNbbOkyKzy9exPIiIPZ9dwzDfDjYHqABvYsXqzdfovQlzYmrzxng5wwRuSo5iw8gVdxiRC2RR3NcoDg6EitGvDFH31UdnLnzkPy4tag4bfc6v36d09aOqrY++KLjQeWLWuMa9lQ3FiWBt4Bo0B9ZSVeh7TsKi+IadeB5MWwg8hRHDnRVAwIvuW4VkAH2ASEW5Wdg+J4uengR2ufEdB/O/SGG7z7//I/vtpjx2hLX9NBNdXW2mrk3VBRop4JRRtHQmamHblgQMhNiJanUDV347gt5dCR5YVbWQccA9rw2KMbqouKyvDaoLzFFukw0NLgJG53lrBjQA7IBTkhNxkIQQdF7sSBwIeNpyZiFXT4qMHRIbc4BoHHoRsPvP/e74XacmbMcKcOG87YoQYTSo4Q3V1C9a3JMXbkgEHsf2/1fwrR8hNKwAk67FmFtVYIjDXrlg64hdWZrg3qk0cfXVe+ZctuHGLJa4ORZjv6DJW81fF0xC5inxg7ckAu63/zm0+kExV0Ak8cIsYzDjKawy6szWrFBkOFjLyztqx08+Dp069NHjzEFZDn4Mo//xwbByXs2m5BrwXpxEckcDT9qHnzPLkzr/Pi5d51v3rgJyf37z8hfeJRQRwcoGIDqMAzLqmow5doQGckAo+2CjpiOWSQDYlpfUsyJoy/MP2cc12Ve/f6q/fvx6xAiQR8i1XPf2qAZU+9zDXuVw/Fo/sdS17896/+tPhLYVXAcbgJwFHVmW4ZcPHTnl0BtVJUsGHPNmc52tpGOLj2o8PpefkpvYYPG91vyhR3ybqPG+W5QAzsTAXdJidbjsl/eCoRDxUVr3r37TX3/BzH5XjkG7MbwAPwULNcVNZLR2Y6ohM8Aq8DLjoN+L3L3/ky96KLJiTJ42jynqbr23dXNcpX9kwEPiA/5GO/YPELid7evR1ln3/29Ts3XP+w5GEE3Ag6clGrNK2VaEEnyIhOPhR1yAnFx0MvmzY9aeDAxP5yr7Lss0+bgjOe/tZG2T1WAEyb4QAc75DKMljxzk033dFYU1MrKsxuLi1GwLG0aP5Coy7Rgq52ALDVQvAh03gZfHPFrr1r+5894VIAP+iqGZ7q4uIzYY3XAMMajiUFMxyAf3jf/fOO79yBZ70JOJcVgm52qBg1+B0BXQWXABspN4i9+ptDDUWrVr2bPX782ORBuRkDpk93BwLN0RzVIHZXFg0kHKVgp4k1vPSzT7cvn3PTTwyA82gFgJvtPDs8po6AbtaZDrIoVR62dpnx/h2vvfZB35F5yb1HDB+FX59Ik2cOK3ft9jccP86ZQj+z+F0h0/rBic/Ex/49HoeFCHpg5d/eWT77xkdljLhsyxlOwNXjc+PRCuJx7AhluXQU9A4BVLRi+RZvYvLRtPz8STiOH/z973sS+w9wVO7Y7udTVDLyDsUOk7EGDK6lyH3S+LMefDA+aWCOE8fhX//phUUfzr/ndfEl2KQAnUsKj8mNS0uYLsOrOpMgfOnPw0ZsRFScQqNiNrHiDBXVm3Pxxdnnzb/3wb7jx4+QdsvPSb36qk/eV2poOHGCs4exYdKRosXBa5C4WigXrzz8OanyL77Ys+mJRY8cWrv2iATmISEA5wwH5SwH2ASc5xuIzXEKG13pbGIEnhTgG4HHTQACD6oBL9Rz7r33Th5+1Yw75Ffq+kq75YfT5M0HeeWkEW91+Nq+ZBBprDoIHrnFhjs+cgPCjevhfExPfrWufO/KFU//Y9Gi9dIdZjIBV8HmDAfoKuAEmlTUHSuRErESlYCTmgGPWW8EH22tnjf/vvNyL5t6q1waHqD+RCDe7pCXDfxVB/b7a4oPNNd9eySg/URg8LlJPHmFnwiM759tT8od7EgZPMTZZ9x4Zy+5s4RrJxg8bkDI9fDDxX9f88KmJx7fJCKAyhoK7G4DHGPqCtAZh6CDqsDjmj0qAFbB10EPyt39zz8/vWDOnJlpo/IulNtqaTiyEF3UBTeRcQhYsWvnuq+XLHnz8KZN+N0qLhcEHBSgg0IHyqOUbpnhEl8rHUqKzgplHFBWdZ0n8ACdVd0IlMEOvDM1Jycxf/bsiX2GDSuQ22a58X3TszypKQlOb5zLGR/vwAaR94H8/ob6Jl9lVW1deVlJfUXFwRP79m3d/sorn8njEjjBAYgAlJTgqhQ8bbjTNDtSEbOOr+NwZiFYbHeGMhZBJ8Uaz5mvgk+ACTgo9aTcP9AfVIt7x5Gjbz2d3W+mtLHGEiTOUFIVTIJLyg0BqoINX67bpCLqGsARCMl1VcEA1YI2NwQHD0qAmCyTJ9CgAJttdaPpoIseBbOZMQk0qRpf5bkhYAc57TkuUMRE4bhbWl302ZWgc0gcMAAnIBw820gMYDJxFWjObsrYJvgEHv3hhIYxCR4pgWYfKqUNqBFsxEPhmFtaXfjZHaBzwMZhcgYxSSRMIAGQEVwj6FxiuGwhPmY646pAkldnMmWwB89xEFyViloDHbTLS3eBjoEiCc52tU0Z9EgcYAIEUAJLyo3CDUIbxEBRlxeCSXBVSoBJ2XcooCHvttKdoGPQZoOHjMCDEnjwABWzk6CbUcgIOs4iEY9gEmi0yVOvUvCswurjhKzbS3eDzgTMkoEM4BF48qAAFqCpoJOnnai1Y2vEUUEn4KTQs8LHyFMG2iOlp0BnMkjYWChTwQRgABnVyKt2OBKBP2xYsbHAQw4eBTz7YVul4Hus9DToTIwAgAJEFJVvkbSCBR0rNgR9ACrkKuBqG3IUyFhUnrIepacLdDVJFQTwBBSAkVftwVNO0OHH2c0NABkrfM6YciaAbgQDQKmFwJGqG4MyI6U/5GdcwVc1VnoYgRjoPQw4uouBHgP9NCBwGrqMzfQY6KcBgdPQZWymx0A/DQichi5jMz0G+mlA4DR0GZvpMdBPAwKnocvYTI+BfhoQOA1dxmb6aQD9TLqezhsTRhiMcrQpI1Wvm0PGNvWMSTnbp4WeDtCNQBgTpx7UyLNt5kN7AEs7UoLNttGfeqO8W9o9BbpZsmYysySNdmhTRqqCBpnaRkzagVcL7VQ9Zapdl/LdCbqaCAZtbIdLBLas9FXbRl/qQAEaKArbLa32n7SjRvWFrFs2QFeDbkzC2GZypJH0sDPaoE0ZqQoOZMY24hiLakMd46ENvbFNu07RrgJdHRwGZGxzkJbl0+bP9zhHj05wJSXFO2tr3f5AwG3zep0Bv98VkKfT5bcebFe+8spQe3Nzk93pbLI1NPjlufVGv8PRKL9eVOffsaP2/SeewEP/xkKwjWOhnPbUU25s0y5qykBROyoOagyVp0lI2bDLL3dOvO++ZHlHKNWbkJBqczoTAnZ7nDzwH2/z+22+U6d8TT5ffVN9vS3g8zX7GxsDgYaGZvnDp+as8yZtLNm0cZK8T+Swe+VXn+RXRuWntu2gLo8nzpOY6JHHBuzyxy11DqkSr1ZqZXV5eeVnjz9eXfTuu+qDSBwrKYFmG1SVqbxqY4k3A8SSoxipvipPf6PMfvEtt7gG//CH6e7s7HSH3d5LZm+SvBxUU19dXe1sbj7RePJkXfXhw/X71qyp3/ryy3zUAnFwPsGKtl1eCiiXlwLwghgAQOXzLqCarPCmmxxDp06Ncw0YEJfSq1d8wOPp5YmPT2G/zYHAycYjR8oO/PnPZWuXLMEzlEYwjW0xaWNjpodN2GIEJqyxolT9QvEwt09btMibO316lvy/Z6YkmyYvXp3w19SUVB07VrnxkUdqDm/ciBmnxtD85AMgQ45KwHWZgF4moKeLTgNYaDvQgzIjMIEBkyY5J957b3KfQYNSnElJWfJyWW/Z+BXybumx4tWrS96/914sS+38RMai6lSe+rDUmGxY46BS9QnJz1q9OqX30KG5ToejX6PPV+KrqCjb++abZRt/9zt+rRHOzJ8yAqxSPDINPWb6MQEd/yeHpFERl7PcSEWlFRUgnZ90993O4dddl+5JS0t3ezxZ/ubmo/LuUvGy6dOrxEu3s8i39BTmkwmGMWmjUu3NePucNWtS4wYPzpPFNMlfV3fw0IsvHpIdGt5cQ6EPqZmMOm12j/vpT5P6FRSkedPT+zji4lJkB+qRddzbt3DsK+Vbv5otxg0Ckk/+lLuqoazs+NFt2yq2PPUUfgeQMx99EDgjbafDDjxH/rJZdsqDZP9SU3/gwM6Xpk6tNImh+hp5tEMWJhjSQFGotuRJbbJeu4fdf/8Id1xc/7oTJ3Z+smDBUdlZIXEW2oakIydPdp718MPD47OyRjkcjhzZoeJHzwN+n69KNmCV7FSrmn2+QJOUvqPznyvfsf12mZlOu8vlkJ1nigCVInwK3kUVo29kYxyUv7jc9eVDD+3dvX49vglG0EO1bbKTd1zw0EP94vv1y2usr/+26Le/3SPrPp4SRqFfOF4zNPsgAGY6o4y2pNBrfP6sWc4pjz8+qbGuruHY0qVbVyxcyMExhtGHbY1et2LFoD4jR15sd7sLBawSeVN6u/yu45H9q1d/u/n3v8d7ReqbGNoSI8tLsSwvuaIDAFxaQP0T7rorccj06f3l9wCy5cgoXzZEVqCxcevx3bvXvjljxkGxQSFwoORVOXjbjIUL3Znf/36hMxCo2rp48QFZHvmtNfNRZZq/2QeTN9OpMtqRQqfxAPyCxx6bIMfPcc+PGvWJ6qTw9FMpdrLJOddcc6ssF319lZUffrNq1eYPHngAIMMO4GKJIeAqxZq+T0AfKnokqoFtoPiWabP70t/8JlF+THmCJzX1O3K4WV6yYcPLK2++Gb/rAl8CZaSiai23bd1a6ExJyfz8uuv+vnnzZn6D6QND8qStzgaOIBjE7Zq0a0fn7tyZJycnWc+NGLG2nVerQPUDb5/17rs5vfPy7vPX1q59Z+bMv5bv3o1ENF2QqoDjJA6gkwL0PQL6CJEhSYDLl7pIIUNM6LXaV36n65/eeGOqKzn5qtItWx7568yZx6gLUiE6eODblLlFRVfaGhv3PZ+Xt1MUBDcUbeOrNpCY1ULgaG+//M47nTaPJ+fo22/jnXvL5epXX+3be+TIO6q//Xbxn0aPfksBnDFU8O3x8ob0P7/33oxbd+x4cl7xwff+5ZvDn8EQFG3IoYediFVfxgO1o58XCgrer9y1678yxo17EONQDYQngAZxS7PkzTc/QL5a3i39qHZGfFRdGz4a0OmoB4+75JIkadQv/+Uv8cJVuNImmZQRI4Y3NzbueXXy5K1BJ8YENfKOm7Z+/ae0gsI/xvXqPVN+6X+IfLO0f3sFRRty6GEn/kbgjTFtr0+fXtTc0PAFxhFu0EYd8pRg9chb0XG8iig8awX0kEHl9DykLny3/y+0bSaKOuIIeUfExAroan9t+Or336+RkcVdvnAhfkDS2FnIQVft2bPX4fWO/+fVq4e1CWjesL9UkD+37Mstd9Ydr3hH/lb+gOy0cdzsB0UbcuhhZzKOdlFvWL++UP4RZgTG0U4ZRoA8kS/yDmMWUWUEysyBNmbUftu2bXlyoWnI88OGrRJnFWjw9EFc8HqdsXRpVr9zzvmV7+TJvy3/3vfWHC8qMu5IebSCnSd/rAEUci4h6AN+2GniMBU7UVLIUGGjVflFDcfM5cuvlv+8u7hi27ZFwcNHXR+0E6IVyNuM//Y9ey6SjXxscUEBd6SwQQlFW7SGTzWoQaU3aWNG7fn5+fbJy5dfJpdWjz4/evQ23as9A/82ddof/5iWM23abDmZyfCdOPHB/rfe+mLdY4+ph4xmwIcC3QxwDfQLFyxIHHLttePlXwwulWs/pQeWLv2zHJpWy3iMgBO8dqP/8d6958vZcPJHd9319+BJH31hSz8jbRcHAgJpqlSEBEv10WUT5s51T7jnnnNtDkft0b/8ZZvJyRH96KNS28y33spJGz1aPzmSX/TfWXv06LdFK1YckRMSvIrOQ0VS+jNxgMtDxabC225LGDZjRnZCv37941JT83hyVLFjx9q3r732EAYjhb5G2qINfuLkqN+NNxbYmpsTPrz77g3KWTb9GIsU8rAFg7dSmCRt1bYWY9KsWa7CX/96hC0+vn9DaemOTx5+WL0MwH7op1I95pAJE5zj5DJAUnb2SDkqyZFr4zmiDPjr66vl7ymrfULlunpAjnya/H5/o9PpdMva7LJ7PHZPXFyy/LxUslOo+Njl2vshuWRwqObIkd1b5DLA/s2budSwP4KmUug00HgZwJuRMdpWV/ft1n/7tz0bly3DhkUhsPRtkbZuSLZNKcEwVSpC2kWithtWrEhNHDECJ0xJgbq64kOrVx+SS6W8LGAE2yyeauPInzMnud/YsWlxmZl9AKosD16Xy+W2ud0eOVHxyWWYRlmeGrBR6o8dO370q68q5E9DsHS0OTGSNoFCWipY5DW9XPBy44KXnBzkyo665tSePTtfnTEDO24WxolEad+OMul2CoOAdqRQkzdSzXXmiy+mpJ1zTq6A3092PiX1paVl8nta5XJzArMFPkY/tU09d5igrNRp/cgHQQPIrJAZQYe9GVABudnhGnPLLX3jMjLSPV5vlnyNjlZ8+mnx2zffjEu7ajHzp96oo7wdZaLtFCYC2hopTM1kWoiLFy7ETYx+juTkTLki2FuuGJ6UGVl6/ODBys+eeKKmbPt2fO1VfyNP4CFXqxZfPpCssaqAw456jU/Pz3dOnD8/SW5ipMo3KMMpd5Tkmv+J5upq3MQ4unbhwnD3Vgku45pRyEIWJhjSQFGotuRJYRaKZwj7hBkzXCPnzUv3ZGdnyHF6qjgkyRpdK1cnK+UmR1V1ZWVtQ3Fx/YGPPqrfv2YNNwbjgrIyJilBJSBae8jUqc7Bl1wS583NjUtOTU2QmxQp7vj4VNkHJIhBjZyVVvqOHCnd/eyzZZtXrMA3kP6MC6rKzHgzmerfjmdC7RQhBLQnpRnbpEa5sa3ZZcuO8+xf/CI5PiMjNT4lJVWOMhLkCAh/6hdva2qyyc5QforOV48b0nJT2S/rebPINSo3LZrlpoZD1nOHzeVyalT2rLwxLXes4uTpAS2G3e+vk0vGtXVVVZV1paWVnz/5ZPWRlh0rxkXQSDnWcG3qSNU49A9JjSCFNFQUqo8VHq6R7FS9Zn/u7NnupIkT4+WOUZyc7jodSUlYZpzNdjt+UdQhJ2QO+fth7ckAOYJpsvl8/mb56XD5pXm/3EGqP7l+ff3mZcusXvsOB14oXSg5xh+2GJMNa6woVb9QPMxVXbh2JDszX8iMRQWCOqOMbdJIdmZ61VflaRuWGpMNa2xQqr4qTzOjLFw7nI7xSI22kIdL3KhT2ypvFseoN9qY6WETtpglENbBRKnGUHmaWpFZsWG8aKgZKEaZsY34kWRmesvjwnWMrihG0Ixt9hFKTr1KO5WYBArl31l5KH917GH5aEAIGyioNMYzto0xIulpb9UO9lZBiWRn1BvbHFvUNJpkog1ujG1sh4sXjW24ONBFA5bR1tiO1JclfVcmF65Ds37MZOFidIfODFQzWZf2fToSj9RnJH1HAIgEZCR9R/oM6dMdCYbsLIKiJ8bSo+BGyDemjiEQQyCGQAyBGAIxBGII/D9B4P8AuKbO55e0PKoAAAAASUVORK5CYII=", self.location).href,
      position: Cesium.Cartesian3.fromDegrees(eventPos[0], eventPos[1], 300),
      scale: 0.5
    });
    this.emerBills.add({
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAACRCAYAAAChW7QMAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAXaADAAQAAAABAAAAkQAAAAD3Ky42AAAkk0lEQVR4Ae19CXyV5ZX+3bdsJCQkISFA2IRAsFALFEVUqqLijrbjjE5xaf91OtVq7b92am07Y6dqq7bq2FZ07Kp1o2hdQREXtBoEZJGdhEA2luzJ3ec8373PzZsv392y4cwv7+/33nPe855z3nOe773vt99rMo2UEQRGEBhBYASBEQRGEBhBYASBEQRGEBhBYAQBk/kziIE+Jn07WchhnYK+rese/ma6CQ1FhGoMRryRTB+HCix5UujG4/V+hqWtJjQsA0YH4bikEINnOx5PPVAWPaBsgxrxsFPl9DNs1DZsI0UGUkGFxAhcyCxKn2pDHrZqMQIYspBU9iUCmn2qzyHjhwt0gqVS8KwEOR6lHu31gKjAgifY8Sj1jfzoZYPeHmrQCZJKCaAKMHhWq8JDl3LaGYFAEAGyCjT4YFTGPrWfdnqfkA9ZGUrQjYAmcASSAIOq1bJoSnHmtWeWnTEmy7Ugw2GbluO2jfc4Ldlum83mcliga+r2hYJdgUCg0xtqbekKVHf4Ajsb27o3rHyj5s31u+vaRYWgA3hWyhALN4AKPnj0DRnwBEbGGNRCcOGUPIEGVQEGj41v/dri8sILPjfuhpJc5wVlee4im8Xcr/gCoXC45lhX/aHj3hdf/Pjgb369bl+D+AfogSjlBgAF8Kx68IcE+H4lJUEmKgQZOuCNwNZAlj5Q+2PXzTtzxtjs26cWeiYJzlpMkm3407r2QFV1W2Dfsc7gvsauYF2LN9TmDYTbvUENjEyn1ZzltJmLc5yW8jFua3mexzp3fJbtpOJMmzjR/Aj+4V0NnXu3H269a8WjH7wh4/mlEnxSI/BFLbYTBj9oRQtskLzRF6haMZM5uwGyBjTo49fPP2d2ac6PywvcRdI2BQWgd/Yc96/e1OQFbfUCk/RLttNmOm1Krn3Z7ALnqZNz7dbohtzX1FW/qablBytWvv+aeIVzbgCCjxmPDcAZTyqiwVtuCBScDqTQjwo2ZziXD4Jtv/GsyaVfnj/hkVklmZUY1CvrwR8/qO9+9N2DXcc7gUO0hCOzlU2FcjxtxivyCGvuASjP4zBdu7DUfdW8IpdT1isofHKofcuT7x/4+kNr99RKEwMagY8NQNA5Dql09b8w+P57iFiqYIPnzFYBd4jc/sT18y7+0szCn3vsFqtkEP7rpkbvA2uru+rbvJGEeoAeaGwRf9ENUJTlNH/rrPHui04e4xTH5k5/KPj61oZbrvntB6skLoDuk4oZz1nPJQd+1CrNgZWBJobR4UOtKuB26WN1vHDz6T+Qr/0/Q/+9fS2+n72yr3NXY0dIUlLjiPGSaYwXm5SLGEUAj1j08LIBpo7JsHz33HLPF8tzMAnCb+8+/t/L7nvrJ8IDdM56UIA+JMBjJg6kABS1GgHumDl+dPbTN37xT1+YmHM+dpO/erOm6werd3cebUduvezNUaDpUx8b5XoaVw+KUqhvOtrhN63e0ugLh03h+eU5djlK+tzS2SULP6ppfamxpQsgs/RsLEoGiQ4E9FgiEou6fsMnZ7fz6tMmjr3n8lmvnVSUMUWOq0O3PLOz48mP6nzK7NZwUcBmavSvUvbpqapDnjpaGx9SosRk/rC6JSBHNcEzpubZS3NdJWeeNGZ5ZyD04uaa5i7RI+CkmnFUTh+UpU37CzoHBkXlDI/tLEXmrCjLy7p3eeWrE/LdY+pavcEVv9vW/sGB5kAUcM02AdhpJ6MzYGwUa218SNHI3iOdwbd2H/efPjXXPi7XlTW9OOeit/ce/3NTZMYTcFBWzTj6EXWlilLjAVZ/i5aEGBNwbECCjvXS+fBVJ/+OgF/x682tctzN9VsLOAo4x6c/tgeL9vKrjIldrBkxITZMCsSKmBG7VG3HLxQ5ITdU5NrLn7TTLv2Z6RyUlAFxSUGwrtU3nf5v88pHnYclBTNczhAxW1DUdVtrQwZmiAvjxTAaz0E7fUHTBwda/RdXjnGU5rlKvjilMPvP71e/J3rqDGf8pP0OdyCgY6tzlnOGY4Y4V674wsVLZ425DTtNrOEf7G/mDoqAM2DmzfZwUHXM2HWGI+2+8P6jXcHzZuU7xo92nyy416z++NDuaEAEXwVc5dOKO13QETCrHnDMcMe1iyaW3XDGpD/IaaAFRylPflinHaLATqLslXBakQ6ucq842Njb1BkKyVHNvIk5jgkFGUuaO32rPq5ubpOhVdDJ9zsiANefEhf4a06b9CBOfHAc/vBbNd1R5yrgtO3PuINpE4sjOhk07BEzYkcOyEUG1K/twCxm25+A0gGdA5HqZ7r9oatP+VJlSeYsSSIsJz5d2FEhwGhS/YlPtYGvISsx4CVmxI4ckAtykkG5v+JOVQWeeKQcG5ykWzAIBiXoWKLgx7FgUu4dQk2rNjX6djXImWbv5QRdSYEb5bGZcfUQygalj7y1MxCWAw+oCk49xW23mLr8CCFpgU/V1ozYkcMlcskgmtMbosNLBMgXA8KGVdjUSzqgIzi1YnACbn/wmrlnlBd4CnHx6pdyLYUhSFQEipRdvahdrkU9+A/TPadPyUsnJpPsCcPPbmwI3L5qN5cy061fmuhcsXCs/Zmqev8PX9zbLWefyQpigxp2rJo2cjhvZr4DOSG3f3miilcmATjy5qRiXslHiUaB2ZpKoWPogldnuvbVm1OWeys6cbWwvlW7eKUuK6o91PqU82eNsacLOJwIUuZLP1dol1N6AKGVOWVZFlyXv+LzxY6fXTrNHTtEoYIx1WIE8NJtRg7IBarR3LjEYBzmr+al8jCLW1IFnQ7gmANyltuWn1JaKKf5E3E9XC7PItCUA4g6NpfkOnrFclhuWOBUPV491OzttXaU5rhiY9796j5vhy9yo+PCygL7PZdNBfCxfiaThJpXvlvbjZyQG3IUfXwLUeMBn8RlpDudrzKCZgVAGFgD/sp5E7+KmfXW7mO+43JBCSU6Y8AmS7ZPv1z5C3ztj9u65PAtbsHsfegrM9xnTossR3KkF/OzqbY9dP3vt3Y+enWFx2O3mS+Qb1Fjmy9896sHvOIwgVct1tgyc6zDZ8LNFPkGOpDj0x/W/lTsmTcwwJisifyKWk/pNbt6xH04OgaFDUHXtvzEAvc5sJA7Prg8OuDy5s5jsmdI7AbIrN1xBDs3w3JcdrDd3nDYFwyFDxztCl09v8TuiOyfkUPK5YXNkZyiOcab6cQnJb+pgK4GSefc2tbK0tGZcgZXKBiE395zDCCktZYbRSlfaSNxH1lkAekjNmU6bKb/vmaWZ3SW3fyfL+/3btjbHMBN7jHZDjWXvoYRiaYjEWi5rt99LIDckCNyFZVY7sITD/pKxb82Y2mQjMIhZzmp9bozxy9CQtvrOoJtsgImc6LrTylInU1PM4zt27dMH+uxFGY7LNjJ3nHBJNdXvlCMExwJPjZcjOlr3VuCnHbUtQeRI3KVXoDO/ElT9gfvMEqlwKlaYadt8bJczylw8HF1qzbLwUdLWoHQKC1q7lnH5XAlZvpRdWvohy/s6ZYdoW93Yyev+8T6U2B6nEneG+WJBNhEc+VMBwYqJqpNwiHS2ZHCERxzMA34bJd9CjpwbRo0+rUEO6zly58vtrd2BcIba9uCTa2+8FMf1Wt79FyP3TVljAdApV2QiyQcZm7RXDnTVSzS8p0K6HCurwBcq7kZjlKMuO9Ir1tdEPW7CEjwnbSoehVjM60PXDndjQeNfvH6Ae9j7x3ihbakfpIpMLdorrHcxU6PC9qGS546RiqgUx8OUUBjA2e6LNi5mOqao3fz0RhguWreWLtbLlMePNbd61hcdTsuz2m+RE6KVBl4rL23nTPRtbOhM/Tu3uP9WVr0LmO5RXON5S6KKiZ97OIJ0gEdPjBIr4pnC9HR7sNOfnCKDGC+bE5fQBN5l2dZgh/XtAavXjBW22mePyvfngR05JFSzMwtmmuv/MUH2mmVlL7G4pGO+wzIhznb5XE3ZWTqK6KhZf9SVee/65V9+LppcYzL6zlD7efIsRyYWzTXPhhE/cf0k42XKujwo3fKwZONMSz9uPuAImftGk3xeoumm+aHUd56bBK6TAd0I0dmPK6Mjkx5kNNIIYEsXf0Eroa2i7lFcx1w3AMF3dQZCERAd9gG7Gtooeu/dznD1XJjrv33FLEcKFDh9u4gHr43FY/CI4L/Nwtzi+YaWb8GkGo6oOsHQzssVxVrMX55vjsdXwMIefhNJxVEcovmquWti0KPja67dzNVoOiUA8aoXP7cB5eT8nud9VG/92j/u1qxHMpHR3KL5hrLXdIhj8xi+snSTBV0+uEgMbr/SPtGdM6RNyCo9FmgvCwj50qxcPB4WX8Kc4vmGstdfJFPy206oDNiUJwpavXRNw9swKn39OJMa5Yr7g3ltIIaiHLtsciZcUVJhvXaU0scp03O1a67+OW6en2LjzlgCJWPOyRyQm7IEbmKYix3xUdKvjhIKqDDob7GBt7V0NJx4Ehnk8wn82lp3lRmEINJX97apF1zcdms5u/IDerRmfJYgJQ1nx4NCHBpD4WckBtyRK7iIJa78HpcUhogFdDVQOEUg5LicDG4s77jDSgtqyzAXYKUBob+UJSH3qrxvbL1SK+LXX+Xe60/kqcC0h0PuSAn2EVz1PKVpopB2vmmug7DsVoxKAMIPr5+75NLZxVcKW9Z2EZl2MzHO7TLz9CXuJOXhZNyredUFKQai6HD5XOL7XI1MPTxwbbgTU9/2j1tvcc3rTDDcuBod2jLoTbEq5ZkQGn9eRkO+fbm2vCGHnIUB7GchSfwKi7qGHH5dGY6nGMgtWpBrNne0LT9cHsN3mK7bmEZHiJNuWQ4rKYHv3KSe2o/r3lzoJPHZVnvv2K6i21cZVy9pSlgADhVktIVC0vlsSe5Kya5IUcxIOgqBgQ/qT8qpAK6Oiu4VTk4KKZ1YO32xv+C03+cV+Qs7rkXqdqiWy1aX5c/aKqR2ah29Jf/+4EWxJOsJIoJtlo/ckAuEERz0/KUppo7dFV/Kg9Tw5LS118soYcNhIplANexERBmlkdqBupHd5797OQxnoLnP27wfW/Vbj7llWgMrQ932uQFXLPMKmSQSF+GMS5eOTpplDtGxr0xabJ+KGo6P714iluu1zv2NHY2ff7O1y4TOXaiqJ1SsX/A4xzYd2BjcOan4l8DUGxSKnDIikG4xTEoBve//En9A988q/zfL5abC4+/d9irvTkXsUkIJA4q5OEhBkwqLgetpOpT08MbeMgBo7+0pf5+IVp+QpEr8+ayAptU/YtqZOZqTIofcM6tisH5ldOC+sGzW96uqm7dKQib//+5E2PrawLfaQWbwE+irrTHQOzIAbnc8dyWd8S5CjqBJw5p+0/nhi1mq1q53EBG3trY2lV13sljL5VrMTaJJvxhzzoLvXglUV88m2TydMHQ9G9cXOa4fE6hEy/3fvepTTfuaWw/LgNxOVGXFEw6znbEkvJ46YAOxygEHjzAJujaXXIJ0puf5aw/ZWLuafJQpw2vDeINByhLSQRuor6IdWqfKSevuNNszp6Rb/vRskluyB9dv/+nv35z7yZhVcDVt6rVmZ7WmOmAroKNuNjmLEdb2whrtzfUzizNzZ5amDljsbwu+NbuZj/e6YGRlGTgJuuPeOn9Sd+9pam1NNuTijItj/zD9Ayb1WJ+cXPD8zf+rgrH5TgYwOwG8HyjWl1e+jVuOqDLuLFCYEBZ1Vlvfq6qdtOZM4rmTsj3FJ4+Ldf2t0+a/J0+bcLTNubsRDP5mXbzE1+dlSHPyFj+vr956yW/fOfHEpMecD3oAFytKaeRLugEGAOQj0ctr+9oXL+0svhceRU8Q85YbR/sbw1EZ/xnAfjYDAfgxdlOqyyDR5c/vOEb7d1+HhZyadEDrq7lKYNNxXRBpx2oHjiCzz6zBB/aUde6bt6k/LMA/EWzCxz7j3anusarYw02rwGONRxLCmY4AL/pTx9/fXttyzEZDGCzAnCCru48+zXLkUh/QFfBhQ+Cr9IYX3O007t6c93Lp5SPni1LzRh5T9MuN+xTPaqB/8EuGuA4SsFOE2u4vOe6TWb4jTrAsZajAnAeGqs7z37H1R/QjQaLgSydKg9dzPjgH947sHZGSW7WtKLMk+Q9TfucsmzrDnnSV36VQgNBsYPNUBRtHJz43HPZNDcOCzHI6k0Nf73sV+/8u8SIs03ObgKuHp+rgPd7lmPM/oJOYOEj5fJ8Ve3HGS573axxoxbgOP7L8ghz6SinRS4oBfm7XOKsX74TBKGBjWsp319a7v7RhZPdZXkuK47DH1m3755//UPVU2JLsEk5wwE6j1b0S0uCIRN39Rd0eAU4BIgUcs5cUlVmenNHY/WmmuNrJxXmzCwZ5czHXRk8P44fQNvR0B6U3QDtVJ/wkW7R/ORl2M3/sni86+7Lp3lmlmRpNyTkUepd3/7Txm+vXL+fx+Eq2PpZHg9sxpluXDHQ0jaMGhB4Uhw2YkOi4toFKm4C4KvMissD4B3fX1ax8OI5Y78xpTAjX9raD6fhfaPVm5v878hbHa29XzJIthFiIGTLLTbc8ZEbEHZcD+cPp+1u6DiyauPhh//jhW3vynBYqwEwACfQ6gzHLAfgetAxTmws4dMuyRJJxSEBJzUC3gh8bAyt3n7hjPnnzixeMbMks1RuJGsxSVZhvN2xsboluFcew94vNyjqmrvDbfKgakd0Y2QIuFkO+YnAUS7zRHkEZFK+2zpnfI51RnEGbtZqfnADYuuh9tpXttY9dtfq7e/LmDwaIegEHG2u4UMGOADVAgMzwAI/alWBx6VgVACsgh8DPSq3nzp1TMGKReWXCPinlRdkjMZjz9KXdsFN5H1NHUcF7LdXrtvz7Lt7jhwVJwRUDzrBBuVRypDMcCbSr6RorFD60QNP8Ak8QGdVNwJl0ANvLcvLzLhm0fhTphVlzcrPdE4oyHIWZbmtHjyu7HZYLNgg8j6Q9rOvbV3BzqY2b73U6l0NbVueWF/9Yc2xdpzgAESATQpeBZkbgjrcaRodqYjpwJYVOEAhWJHWwD7pSwUePNZ3I/AJMAEH5cYh5f6B9qCa/+aHL35u1DdWXSJtrK8EiTOUVAVTBZhyUhVs2HLdJhXR4AAOR0husAoCVAva3BAMHpQAIVFWJE+gQQE22+pGi4Eu/SiYzfRJoEnpW08JNPTQR33GBQqfKIw70hqkz8EEnSExYABOQBg820gMYDJxFWjObsrYJvgEHuPhhIY+CR4pweYYKqUOqB5s+ENhzJHWIH4OBegMWB8mZxCTRMIEEgDpwdWDziVGW16izjHT6VcFkrw6kymDPnjGQXBVCvcEH/yglqECHUEiaM52tU0Z+pE4wAQIoASWlBuFG4Q68IGiLi8Ek+CqlACTcmxQVvgDj0IaaQ3y51CCHi94JETgQQk8eICK2UnQjShkBB0nNvBHMAk02uTZr1LwrMLGQIZsyMtQg84EjJKBDOARePKgABagqaCTp550a4d/8KOCTsBJ0c8KGz1PGeiwlOECnckgYX2hTAUTgAFkVD2v6uFIBPbQYcXGAg85eBTwHIdtlYIftjLcoDMxAgAKEFFUPiLpAQt9rNgQtAGokKuAq23IUSBjUXnKhpWeKNDVJFUQwBNQAEZe1QdPOUGHHWc3NwBkrLD5zJTPAuh6MACUWggcqboxKNNT2kP+mSv4qo6UYUZgBPRhBhzDjYA+AvoJQOAEDDky00dAPwEInIAhR2b6COgnAIETMOTITB8B/QQgcAKGHJnpI6CfAAROwJAjM30E9BOAwAkYcmSmnwDQP0vX03ljQg+DXo42ZaTqdXPI2GY/fVLO9gmhJwJ0PRD6xNkPqufZNrKhPoClHinBZltvz369fEjawwW6UbJGMqMk9XpoU0aqggaZ2oZP6oFXC/XUfspUvUHlhxJ0NREErW8nSgS6rLRV23pb9oECNFAUtiOtvp/UY49qC9mQbIDBBl2fhL7N5EiT9UNPr4M2ZaQqOJDp2/CjL6oO++gPbfTr29QbEB0s0NXgEJC+zSBTlt96dqVjRkmOpyA77O4IhezynL/dEbZYAxazzRKIPG38l/936iT5IfGA/LhxwGcOBeXPjPw2i8Xf1Gru2n6opfPe17bgLQt9Idj6WCinPvsp17eplzalo7QNFQPVh8pTJa5s6dLJ1tvmlWaVetw5dpMtx2wxeeS9TpfJGnTj4bpWX8DnD5m7u7sC8ihXKOSXP4wSQchrCoYWTS7YsH5P0wKnyWpx2C0W/J+Ox2o124TaLWFXtsPmMMkfZQQCeN083BUOmTr9pkBLbWdXy90f1La9/PIe9UEkxkpKoNkGVWUqr+qkxBsBkpKhKKm2Kk97vcx85+LFtvOWOApKM5wF8hzFKHm9KFNeCWrv6PbLP32Ej7e0+7vqm83dz+9u6v79a1v4qAX84HyCFW2zvBRwRF4KwAtiAACVz7uAarJ/OrvSsmSKyzVlVKYrJ9Pudlmso5wOazbHFYfNtR3eppfW+JruXLcOz1DqwdS3RaWXjlE/dBIWPTAJlZVO1S4eD3XzPf9U6bxyVnmR1RkuNAWDowMh8/F2v6++urWz5Sfr9rdv2FCLGaf60OzkAyBDjkrAYzIBvUlAL5A+DWChfUCPyvTAhBcsKLV+Z2FZ1rTRWdmZdkeRzRLONVmtR4Nec8NTn+yr/87vtWWpj534Y1H7VJ79Cak+2YTK0U7VJi7/ys3nZFeWOSbID3MV+3zB+qZ2b9Mft3U03ff0Bn6t4c7InjICrFI8Mo1+zPQGAb1QeCSNCr+c5XoqXVpRAYrxNy9fYL2qIqOgINNZ4HBYi8LBcN2WGt+Bc+97tVWsYnop8pGREnwywQQqvbpUfSPevOZ7Z+XMKPJMF1wy5aevq/+69WCNzBy8XIVCG1IjGfu02X3bhdMypxfljS7MsOU5HRZZGiwOa9jknD0+54+bq1uukvfvvP5wyOf1hVobOgLHdtQfO3r36p34eXHOfIxB4PS0T598Mx0XzRxXlumyjhez9u31nTuW/HRti4EP1VbPox23MMG4CkqHqkue1CTrtf3ai7On2qzhkuZ2/45vr9xT9/KePUichbpx6cJp+dZ7L6ucMibXdZLNbC2zW01l8v50WF6ibu32y7u8vmCrX95X9IZCgVklOb/+5FDL15xWqxX/Z+2Stdplt2XL/5pmy6/fmeUvOg6GTKHqxuPdn9767Jbd7+48gm+CHvR4bdPSyZMtd107ubgo0z49EDQfWrmqdZes+3hKGIV2iXhN0eiDABj16WXUJUW/xi9fXmH95WnlC7r9Ju8T6w5vufOFKgZHH3obtjX66i2Lx1eUZC622yyVgml9a1dwW0Or9/DzW+sPPfDCNrxXpL6JoS0xsrwckOVlgvQBAC4toMFvLavIWDYzv6QkO2NstttaIa8/FsnG2rLtUPu6c36+rlp0UAgcKHlVDt5057K59msWj620hC2t93/QuF+WR35rjWxUmWZv9MHkjfpUGfVI0afxyysqrA9eN3Wu/L6Bq/SW1e+oRgpPO5ViJ5v15c+NXyEvPec3t/veeOaT2qrv/3krQIYewMUSQ8BVijV9r4A+SfqRqAa2juJbps3u//jKzIzLZ5XOHZXpOFNeuD6yYdeR31/xyAb8rgtsCZSeSldP2XPv+ZUZdlvhBb+rfb2qqorfYNpAkTxpj7GOIwg6cZ8m9frQg7+4aHrIEi4af9PqdX2segSqHXjzG7edUTazNOs2+Q+hdUt/+/dVO3ceQSJaX5SqgOMkDqCTAvRdAvpUkSFJgMuXukghg0/0a3XatHzL366bvyTbabmg6nDrT5b+57oG9kWpkBh44HuVw/ctO78rHNw76dsv7ZAOghuP9rJVGwRDlRnxBIN9WvubcnLz3bNnLHn1k6Prr33sXbz/E69wHM1u1TcWFcyfmnPr4Vb/k3PueGVL1EjV0XaiItdmt9vttr/8rfkXjh/tWSK/BzBbzjpHy7qdI+t9i5yOHpXfCthcfbRzzdIH3l/d1dWFpU2d+QQdw2gAvf3dMyZPK8n61/c+bb7z4ofX4zd0qUMAodunrFyx0HXOrNGLfvba9jW/ipxc0Y66+jblvSiSS7cQHNNFJ4/PNFlC3UkAh/9eyUwZlzHFFw7vigM4/WsbSGwte+5asvLkspyHcjPslzislnIADqegaEOOfuhBLJW2KoWJ5vu0n725pzsY2og4IEy1aHlKvlrePUaaz55mci4V0OM67fIF4/YlH/ozr9FroqjRJsk7KSapgK6O14t/tupAuylkcf3yqnn4AUn9YHGD3n2wY7fLapmDr3kvh8YN86TvvX5D1YHmb8ov3f3VGwjtx7IiqvKTxqYWtCFHP/QM4ujjdeOPz610mM1TEUefzgQCLU/JV8s7gV6yLj1QRvrUMaLmffdcON1lC5ePvfmFl8RYBRo8beAXfKyuvnVR0fyyUf/W3BX823m/3bBmz55j+h0pj1aw8+SPNYBCziUEY8AOazjWcuxESbmuQ0erkyfnWV77+vyL5M+iFsuf1t4TPXyM9Uf1hGgF8l7xV99/4eldfl/DSd95hTtS6KDEo5Fe3afqVNcVa1LHiJorKirMa66b9CU5LaybcNsLn8Ss+jKw71Uf++opo889uegqCXlMc4dv7R+qajbe9dwO9ZDRCPh4oBsBDuDDt186PeMf55bNGZXhOEsiaHz8/f2Py6FpG/oMqoj6loO/WPZFuQqadf2DO16PnvTRFsqDDjqcEizypNqGuEFOIO5YXDIvbDV3rlxb+4nByZGqT1+kphdvWlRWOS5LTo6scnIUqm9u8++oa/Md+svmw4cffW0nXkXnoSIpbZk4wOWhYuC6s6d5rpg9dmxxlqNkVJZ9uhztyMlRcMuWg23rLrh/fQ2CkUJbPY30Rj9xcnTtWaWzzMGw5/o129+TS8L4ZqHQjjwp5AmLBlpCjUgnk6Sq2tZ83Lxgge2bl4+eareZSo50Brbf3vsyAMehnUpjPueW51rvvXz2lOJc9zSnjZcBzPI39MG2Tl+grbM72Ia/zpEfqJd/cjHJDQuT3Wm12Ozy24oelzXL47BlOazWLIv8yRH+gMAbCNbUHe/aeeszm3dX7dP+EFYFhKCpFLFoOrwMkO+xzfAHTId+9czRXfdt2IANi0I/tI1Ie28IyvpQgtGnQyegXjJqeuGWxTmzSzKmy4WpzC5f6ED0ghfWWRQ92Eb+VB3LDUvKs2aOzRtdnGXPy3DZskxhs1Nmrt1mMzsCgbBPvhl+kzns7egOtNW1+Y9tPXzs6G/W7MPS0evESNoECnGoYJHX+uUs2Y4LXvLrSRPC4VD75kMdO5b9fB123Cz0k4xSvw9l0n06dALqkaKbvJ5qps/deFb23ImuCVabpdjrDdbXt3Y3PfLhkSNycwKzBTZ6O7XNfu4wQVnZp40jHwQNILNCpgcd+kZAheVmh+3rp+TnF2W7CpxOa1EwEKqr2t994NKH1uLSrlqM7Nmv76O8D2WifToMBNTVU6gayTQXdy6vcF5RObHY6TYXuuRmgVz9az7c2tl4+Fi45UdvbWvftq0J67Fqr+cJPORq1fzLB5LVVxVw6LFf4ysqCqw/PL0ic2yeOWdstmeM/CTkqG65ueLtCjf8Zcv+ujuf3pbo3irBpV8jClncwgTjKigdqi55UqjF4+nCfMPcubYrz80pKM10jLHZrDkWWYIC/kBnpz/Y0tje3draEeg8eCzY/eKupu41Vfu4MegXlJU+SQkqAdHaS+aWW8+Y6nGdlJftys6wecZkurI9dmuOzW7zhGTpkL9Sbalt9zU+9UpL02+qqvANpD39gqoyI95Iptr34ZlQn444AuqTUo1tUr1c39b05s4da73l1HFZk3IzcxwWe47LZvbIeu0y20JuHHnLdfNuX8DcjRvSIWs4GJKb0rIfDXrDQv2WkNUesjjNFovsR60WuTltCZqtuEHtsIVd8GOVg8uA39wt92G7ugNh+fl2f8ve4+0tP3/nYFtV1WFsVBSCRhqR9siN2tQlVf1QPy7VgxRXUelQbVLhYZpMT+3X9K+aN9kuv0TtHpdndZkcFmuG/Dl92K79K4/NLU8AWBxBS8hnDXXJiakjbJLHBsLBDnkawyR/v4xvy7vybXm6al+q174TgRevL55cgcqY1SdrrNVXqtrF42Gl9iVqJ9MzsoVMX1Qg2KeXsU2aTM+oX7VVeeompPpkEyrrOlVblaeaXpaonaiP/kj1upAnSlzfp7ZV3siPvl+vY9QPnYTFKIGEBgadqg+Vp2oqslR06C8dagSKXqZvw38ymVF/ynHhOsZgFD1o+jbHiCdnv0oHlJg4imc/UHk8ezX2hHw6ICR0FO3U+9O39T6S9VM/VT3opwpKMj19v77N2NKm6SSTrnO9b307kb90dBP5QV86YOl19e1kY6XUP5jJJRrQaBwjWSIfQ9FnBKqRbFDHPhGJJxszWX9/AEgGZLL+/owZ12YoEow7WJKO4YhlWMFNku9I9wgCIwiMIDCCwAgCIwiMIPC/BIH/Ae+FhnIXoG0zAAAAAElFTkSuQmCC", self.location).href,
      position: Cesium.Cartesian3.fromDegrees(
        eventPos[0] + 0.01,
        eventPos[1] + 0.01,
        300
      ),
      scale: 0.5
    });
    this.emerBills.add({
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAACRCAYAAAChW7QMAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAXaADAAQAAAABAAAAkQAAAAD3Ky42AAAmD0lEQVR4Ae19CXhU1dn/7JPJCmQhJBDCFjZBAVERRVRUXKiiYrVWcKtaq7W1aH1stdTt66NYP/tv3YqKWoobooAIVIGKiIrIJmELSUBIgCRAFrJMMjP/93czv+Hk5s7MnZCA3/PkPM+Z9z3vds77u2fO3Wcsls7SiUAnAp0IdCLQiUAnAp0IdCLQiUAnAp0IdCJgsf4IMdCPSd+ONuSAzkDf1qlPfDPWhDpihOoYjHgjmX4cKrDkSWEbjtfHOSFtNaET0mGwE/ZLCjF4tsPxtANl0QPKNqgRDz9VzjgnjDpOWE/NHamgQmIELmQ2Raf6kIevWowAhswvlbpIQFOnxuww/kSBTrBUCp6VIIejtKO/HhAVWPAEOxylvVEcvazd2x0NOkFSKQFUAQbPald42FJOPyMQCCJAVoEG7wvKqFP19NPHhLzDSkeCbgQ0gSOQBBhUrbbe48YlnjJ16vme1NQxjoSEga6k5N6OxIRkh8vtsHk8sLX46+p8Td6Gpqaao1Xe6qrdTUePbq+rqFjz/Ztvrtj9+ec1MJEK0NVKGcbCDaCCDx66DgOewEgf7VoILoKSJ9CgKsDgsfHtI269tXvuZZfdkZjZ44qEnJxMm8PRpvH5m5oCR/fs2V+zv3RR8eLFr6x/7bUDEh/ANwWpfiMAfHUDSDO0LwDfrqVNSUUZAUGGGXgjsDWQRQfqvOSFly5IGzzo4eQBA/pZbTZtTAEplTu2NR36bn1TVXGRr6aw0FdbUuJvrK0NNNXUaLPQkZhodcbHW+OzsmyJffvak3P72LuNHOFIyRvksEqR2JaA3x+o2rlzV/nWbU8tvfuu5SJqlErwSbERCDzBF1HHAK8NDNHboTAWqFoxkzm7AbIGNOilL754SfqwUx9L7NsnU9oWv88XKPtydeOeRYsaDqz+orGxphrimIszMcnS/ZxznTmXX+5OP3us02a3a2OrKSzaf2DThkeW3n33MgkKwLkBCD4AxwbgckMqovZbbggUgh5PYRwVbM5wLh8E2znizjt7Drp2yktdhw4djk59DQ2BXW+/Xb9z9mt13sOHjo0joG28Y+1jHPszXnetxwByd0u19J92i6ff9dfH2d1uze/wli2btr3/3l3rX355r4QE8Ebgc8a3O/Ac/LF02sapYIPnzFYBd4ncedkrs67qeeEFzzpkZ4glBLN669//Vld3YH8zgMeAPt6xNccLbgBP90zr4Ht+7cm54go3lp4m2Qnv/Wz57xbfcfuHMi6A7pWKGc9ZzyWHoJOKyfGV400MvUcC3Cl6Vtfk9+Y90mPs2TfD5+BXa7ybZ86srSrY4Zd5qY4jxEuWIV58TBdxaga82eMYLxsguX+ebdj06fEZZ43BJAiUrv5y9vwp1zwuPEDnrAflzlY/44/FE6O2FMzE4ykARa3qDA+BnXrKKclXvvXWvzNOP/1yi+zftr70Qt36GX+qbaioQN+qvzUINGX6sVGup2HtYCiF9paGQxWWHz5eCIAD6aPPcCb16jWi38UXjy3dsGFx3cGDAJrluMFlID09HtBDiUhQdf1GTALuHvqzqVnnPf7YspSBAwf46+v93zz0+6NF777jVWa3hosCNsfI+CqlTk9VG/K00dr4kBIkFmv5um+bqgoKfFnjznPGZ2dn5547bkpTXeOiss0b68SOgJNqzkE5Y1AWM20r6OwYFJUzPLSzFJm729ChSeOfeHxpYm5uRu3+/b5Vd/6ipnzt101BwDXfCGDHnIzOgWOjWGvjQ4pGqot2+UpXrWrMPHecM6Fnz6S0vAFX/vDVV3Prysp4BANbAM+KNkswFJvmaVsd4cdKwDnDsVaixl2/ZMnb3YafOgqA//fGG6rqy8s5Mq3fIOAtZGx0AAVwWpHOyWs0Li3Nct6cucnxmZn2Q5s2rnt74sTrxbBeKpYhrvXh1ngtZiwfACzWQrBJubRglnOmu6969/0/AHAsKWvuu7dGBRxgowY7ZpxYxxGrfagfpX9tDBgbxoixYswYuwR3S8UyybyYJ+OQxjoO7XQ8Vid2xkFghofAFt498YWXrsq5+KIHsdPEGl7+zdfcQalgo18taTAmC/smNenWwkzts/m0VdQN5eWB6t27fT0vmehKyul1Wmq/AXsKPl60M+iJbwQrg6HdphLrms5kQQG6Cri2rAybNi3nlNtu+5fN6bThKKXonXdw+IWiAs44zZrIn5qtVc4qT7n3167RT8+My7vlVndidk/roQ3rfT6vN5ZY7Ak+LCHgqwt3yeFhIJB++mhXUu/eE7yVRz48uHEjTosJuErpHzNtK+hhZ/mFz8x8IyE7OxPH4TgslBFpoMhomShptMFqfjDyZHS3jn3hxfiel17mdMTFWVHlbNbe6/IrnJXbtvlrS/YBjJB9tMBBvWofAh5HNamnjbAn9enjTM7MPP37t96aJ/aIrz9eRxjIYy6xgM5BghrNcveFf/3rJT0vuPAWnGl+/Zv7jjYc0k7p9TM82iDZj2aXNmqUbdw/Z8Un9unTaqxOueDV+ydXOuwul6Vs7VqfTFL4tPCP1pmiDwEvG9LX57rr3J7u3bsnZ2dvK1q6tEjsEFxfFXfzLMCLtRB0As8lxpV1xpmPItiehQu9VQU7MTNga7a0AMudkmI57aGH3efOei3e1a1bpHFa82673X3B2+/Gdz9rjLphWsSLMAj9GK0YO3KATzAnLJ3YbyE+KsaDqvcVUfSiDjKaNTthh9x5YkDuCc8+NyFr3Lk/xcWrr+//TY1cfkU8M7O8BTgJWVnW/j+/yXX6U3/xpJ1+eugSrRxh+L1HjgQaq6tDFX055NIuOpLDPlvOpEnO1BEj7XK50nK0pNTvb9RwaxEftgaF4IVm+5Gt+U19rvupOy49PTElq2d+4bKlxeKHiYSKGU8qrFYgM1UAnJnCQcEWPIHHRtPOPjNOO3U6lLhaWLdfu3gVEfC0kSPtckfI6pQan5VtS+yda+s24jRbUu9cw4nw5b2/qjuSn49EQ6XbKcPt4+fMiQ8JhMk46ywHqr+xMVD27VrfkS1bfDXFe/zeqiMBuYIZqNi0iUdSqht45IUFSgMeOSCXvGnTPMHcVoieF8SYvzoezR+BohWzoDOOHnD4OwZNntxdTvP74Hq4XJ7FSQXsIpa8237hzjznnFj7bxEzYPGHnV1y9GTtPuZsByqd8l/8R30E0GlGai144/X6/j//eRxyQ47b5s/fK0rE45VIgK+f8fQPS+FktgBIVvhhRqI68qZMuQV3fHADwtu888T3j8CTimmoWDc+8Vh9U11tWNBClkHGnZTcKo4rIbGVTO/HduE773i3vfQSD18p1lMtHseOC3LICbkhRzEG4MwbGMCeVVhzxSzoDAwKH4KOQThSeuVcgu52B3c+4KOVo6WlgR2vvqotutFsoR/4y1+67MH1G23wkIGPVmpLS/2bZj7dELRDDqbL7kWLtDEGc9TyFWcATxxUbEzFNQO6Okh2wK1t7z58eGJC797dcZh48MvV+NpFXMvVURXM+ZdXTkDUdVFVt+DTRox0nD9nrkcux9pRwUPWwihMY/s/X/b6vaa3r5ZvcLZbD67+ogm5IUfkKl2EcheeeLBnFSvKWlEzoNMJAbl1Se3Dbr55HO7aH5FjWxxZ0NgMbaqttRS8+Wa0r3woVLLcfD531qvxqOBDighM3YED/t0ffWS6D30o5HRk+1YfckSuoldnOXEwBTZjmwWdW5QUftoWT8rKGo1gh9Z/p81yBhZqaiAFb8/1Nh49GtPGUvqIyhbOndsoj2REtdMZqGO34okE6IO5cqYDA+JBqgtj3DQLOr0RnJ1pwDuTkgZAicckQLkTAm+m4Hi++P332jwTI/Uh12UCxfPnmV5X9LGYC3ML5sqZrmKhd43YNrMmciuqFIBr1d2lW0/0UFPUDHrE3sIot77yckP2JRMdcj0bMS0Aq/7AgUBt2UG/t7wiIEcRgYbKIwFfXb3FV1+vfSvscv3F7omzuFO6WN2pqVZXWqo1Pj3DFte9u1UuC2CslpJly5oajhwBe1yFuQVzDeUuQVVMyEf91poBnQPWEgl2FOrYmZyInYulrqQkamcMpKfa2WtwCVj/5z/VF33wwXHN/NzJk50jZzwWF5fVg2PWdxlTm7kFcw3lLkEYn9RUXG1mmbJsNkLwFhXPFkJ1POtyxhln2uN79tTGkjZqtN2dnh5TEs1Da/50p6VZUyUGWukjRzkQW9W3hWduwVxb5C/xYh6r2ZnOwK065MOc8vAmZrpqZyq/Qbf/wjX4V/eEjrd7XXGFM/vSSx0HVq3y7Vu2pLHkvyt98oBoxG+RMznZ2uO88fbsCRMc8mSXQ30G8pxZr3ry//a8d9usf8a6tiMXrd9gbpZgrq0wCCbK3KPmbRZ0BNIHZedROwlnIBe0bEPu/TVui7UoeAyux/jxDlRRBKp37fIf2rLF31Be5pdHKAL+Rp/FlZJsTenX35Y4YIAtKTfXxmcgWwRCIxCwSh+uHxZ/3Hj0OJZAJa5R3npsFPPWbCygt/aWDYHHlW1JSQ5cvPKaPwHRYuVcMSk0w42CB2XWpH797KgRbKKprOlnnOk4+uH8Nu0rkBs6QK5CYgLYaGCxrumtYjQ11GuHinK1MOZYcXJHqFXADhJYnW2fX8yNuR7vEGMGStehXNtuvnDukevgOl3UZvX27aYuAUQNFM3Aag0cWvdduEu60bwtzC2Ya8T9S9RgYhAL6PrO0A40HD60Fx3J7bRYYsHFsv21WQ1Hf/ihw4EveOuNxkrtprPWbcwf8uy7llswVy1vXRA9Njp1y6ZZoBiUHYaonHwUIiQeyFdC014RtWa91dWWVbfdUluxfn2bZ2HrqC0kciVzVsOmmTN5hbGFMkojlENy8MZKMNdQ7uJPHqFC9lHixjTTGZgdabRyz57voMAbENE6M9LXypnnf2+eWvvlPXfX1uzZ3W6zvnTF8sb/XDmp9ns5XAzesDbq3pSMuQVzbZG/BDANNjszO9Nhz+CgAEerm2fPXoN3fLoMHGyXaxMxr+sIjLJfjss3PR265t0sbOOnt6oqsPaPDzdUFxcbbUTmYSo6ckJuyBG5ilMod+EZi9RUTDOgI6C+hjqu2LHjaE1xcRketM8Ya/r2m+Eg96/6vGn/5/+N+ZKgPtP8559riHZCpfcJ10ZOyA05IlexC+UuvB4Xw7z0sc2ArvogKDolxVrsO7yrYDmMel9+Oa40meo4GANuLco3Dz5Qfzg/v81r/M7Zr3sL338/3PG42bFpY0IuyAmNYI5avtJUMYgpJmKZBR2B1YpOOQDfljfffBtvsaXLrHB17colJubBYEDyWkrg81un1e5b8kk44GDWquDK5Mannqrf/Nxfw+00YxmPZuvu1s2KnJAbcpROQzkLT+BVXFqNy0hgFnT4Ijg6Uqs2iOIVK8qObN26B6fvA26+tdVpPZzDFEMgcAn3698/WL/m3nvqDm3YgD7CFjxqsXfJ4sbPrr6qdtc7c2PaUGGDBhXygpgbOSE35Chigq5iQPCjhQvpzRxxABh19qLNzkGxBjftXrHyRXm+8C/9brjBXfjvf3lxVCJy1VeahiWsTams76i4xtLn2mud6WeeZY/v1cuG+53yFJavZPly3+6PPmzEQ0iGkY8Jo+mPWTaP2RIv1+WRCxTITYiWp1A1d8RVY6u8qIwLwTTWHpPCDt8KVGwoPGCEAcVJxcM+Cag3fb5qXlL//um7FyzwrnvkD3iNBCWWPpo92vfTFBBKl5r9qMef9PT+yU9c1QUFZW+NO/ca0WMnioqHYvFsD5YxfLOwMTjzTfUV6/KCoKjohFscnaLzxqJlS58XasHjbSn9BzC2qYGIm1k7dGGmcKxmbGmjjQFjRw4QFi5d8r9CtPyEIlfmzWUl5n4IjMQyVdABt2poaRGZNqgvnnhiVfn69dtxiCWvDeJbEGuJOYEwHWjghdFFFWPsyAG5rH7yyS/EQQWdwBOHmPtST92jDQbLhFqxwVDVpccu9zXX9Zk48eqkPn0dATkVLP/2W2wcFLPLTLN17PbwixkAdkbfQXfd5cqdfI0bL/eu+uMffnWksPCw6LicqEsK8uJsRxjTfccCOgKjEHjwKuiIZZNBNiSkpu3PGDXyXFzDrty501ddWIjBocQKvFkf0wlro2j9oflnTbjIMeKPj3qgzp/9xv9sfHXWBmFVwHH3CTMdVZ3pMfUfC+gq2NJnCHz9jLfuXrlib/rgocldBvQf0mPcOKecaTbijj6cpLQF+GbPjvnUxiUPidrG/r+/J+BWX/HiT+Z/ev9vcFyOgwHMbgAPwLHMqMsLcxKx+RIL6GpUAscNAarOeuvOBR9tyD3vvFGJ8jiavKfp2PfJ4kb5yiIGfdV4J5WXH/KxnjPrtQR31642ebz6+49uuP4xGZAecD3oAFytpnOIFXSCjA7Ih6M2OaH4vN9FF09M7NUrAc+1lK39pulHNONDMxyA4x1SWQYrPrrpprsba2p4WMilRQ+4upabBpuGsYJOP1D9jCX41Fll8P6KbTtXZp8+6kIA31vuicqVv+Nd49UxtJXXAMcajiUFMxyAL3/wobsObc3Hi1IAmxWAE3R159mmWY4BtwV0FVzEIPgqDfHVP+xpKFi8+JOskSNPlbcsMnpOnOgMBPzHc1SDPo+naIDjKAU7TazhB9d+s2XB1Jt+pQMcazkqADfaebZ5DG0B3aizEMiiVHnYYsb78t9++7O0gYOTuuYNGIRfn0g97TR75bbtPnkDTwNB8YNPRxStH5z4jH7qfzw4LEQnRYs+/mjBjT97QsaIs03ObgKuHp/rj1Y402Mea1tBJ7AxdViwcMF6d0JSaerQoWNwHC+vDboSsnvaKvO3+PgUlQRsU+wIA9HAxrWU4Q897DntkUc8ib1y7DgO//7V155ZPv3+d8SXYJNyhqtHK/qlJUKXkVXHkyB86c/DRmxEVO3lL6GYTaw4Q0V154wfn3XW9AcekZe98qTd/HNSc+d65X2lhobDh9tr5mtx4uTyLK4WysUrF39Oqvy773Z8NfOZx/esXFki3QNgFWz9LAfYBJznG22e5RIrBBr4thQCTwrw9cDjJgCBB9WAF+o684EHxg64YtLd8it1adJu/uE0efNBXjlpxFsdcuOaGwBqbmDwRiVk65JbbLjjIzcgnLgejsuzcJBfrSvfuWjhC18/88xqaWKtJuAEGpQ7TcxyFXACTSrqtpVoiZiJSsBJjYDHzNeDj7ZWz5r+4Fm5F024VS4N9+TjcXjlBG93yMsGvqqiQnktschft68koP1EYPAlAu2VSHn3yJOdZU3M7WNL7tPX3k3eI+0yaJAd104weNyAkB9K21v8n09f+2rm01+JCKCyhgO7wwDHmNoDdMYh6KAq8LgUjAqAVfBDoAflzuyzz04fNnXq5NRBg89N6ts3VX0QVGxMF9xExiFgxbatq76fPXve3q++wu9WcadIwEHVmY02j1I6ZIYzgfYEHTH1wBN8As+1nuCrFDzsQO0pOTkJQ2+8cXS3/v2HyW2zXE9aeqY8NBpvd8c57B6PDRtE3gfy+Rrqm7yVVbV15WX76ysqdh/etWvTljlz1srjEjjBAYjcGaqggwfIlNFGPcXnCZC6nISWMPFtc2kv0DEAxlKBB4813gh8AgyQWblxSLl/oD+oFv/uktIPXsjqMVnaAIKHc5yhpCqYKsCUk6pgw5dAk4rI/FVEGEcqSK69in4WoM0NwcGDEiB+lTkbCTQowGZb3Wgh0EWPgtnMmASaVI2v8gQadpDTnuPiDBdVCHzw7VbaE3QOCiCgAHACAsrK5AAmE1eB5uymjG2CT+DFXbt9xj4IHimBZh8qpQ0ox0OwEQ+F421uteNnR4DOAeuHyaSYJBImkABID64edC4x2vISDI6ZzrgqkOTVmUwZ7MFzHARXpQhP8MG3a+ko0DFIDJqzXW1TBj0SB5gAAZTAknKjcIPQBjFQ1OWFYBJclRJgUvYNyop44FFIm1vt/NmRoIcbPBIi8KAEHjxAxewk6EYUMoKOM0nEI5gEGm3y1KsUPKuwIZAh6/DS0aAzAaNkIAN4BJ48KIAFaCro5Gknau2wD3FU0Ak4KfSs8NHzlIGekHKiQGcySFhfKFPBBGAAGVXPq3Y4EoE/bFixscBDDh4FPPthW6XgT1g50aAzMQIAChBRVL5Zcgws6FixIegDUCFXAVfbkKNAxqLylJ1QerJAV5NUQQBPQAEYedUePOUEHX6c3dwAkLHC50dTfgyg68EAUGohcKTqxqBMT+kP+Y+u4KvaWU4wAp2gn2DA0V0n6J2gnwQETkKXnTO9E/STgMBJ6LJzpneCfhIQOAldds70TtBPAgInocvOmd4J+klA4CR02TnTO0E/CQichC47Z/pJAP3HdD2dNyb0MOjlaFNGql43h4xt6hmTcrZPCj0ZoOuB0CdOPaieZ9vIh/YAlnakBJttvT/1enmHtE8U6EbJGsmMktTboU0ZqQoaZGobMWkHXi20U/WUqXbtynck6GoiGLS+HSkR2LLSV23rfakDBWigKGw3t1p/0o4a1ReyDtkA7Q26Pgl9m8mRRtPDTm+DNmWkKjiQ6duIoy+qDXWMhzb0+jbtjou2F+jq4DAgfZuDNC2/ePp0l33IkHhHYqLHXlvr9AUCTovbbQ/4fI6APJ2On/27fM6cfla/v0n+wbHJ0tDgk+fWG302W6P8HnudLz+/dpnx7zESbP1YKNePlXLas027mCkDxeyoOKgxVJ4mYWX9L73UPvrBB5PkHaEUd3x8isVujw9YrXHywL/H4vNZvEePepu83vqm+npLwOv1++SnowINDX75Eyt/5llj1uz/as0YeZ/IZnXLrz7Jn0nJT21bQR0uV5wrIcEljw1Y5S2aOptUiVcrtbK6vLxy7dNPVxd88on6IBLHSmoErCpTefqYpkaAmHVWfVWe/nqZdfzNNzv63HJLujMrK91mtXaR2ZsoLwfV1FdXV9v9/sONR47UVe/dW7/r00/rN731Fh+1QBycT7CibZWXAsrlpQC8IAYAUPm8C6gmG37TTbZ+EybEOXr2jEvu0sUTcLm6uDyeZPbrl9eaGktKyopef71s5ezZeIZSD6a+LSYtbIz0sIlY9MBENFaUql84HubWi595xp07cWKmw+PpLsmmyotXh301NfurDhyoXPP44zV716zBjFNjaH7yAZAhRyXgIZmAXiagp4tOA1hoK9CDMj0wgZ5jxthHP/BAUrfevZPtiYmZ8nJZV9n4FfJu6YHiJUv2L3vgAbyL1MpPZCyqTuWpj0j1yUY0DipVn7D8lCVLkrv265drt9l6NHq9+70VFWU7580rW/Pcc/xaI5yRP2UEWKV4ZBp6zPQDAnp34ZE0KuJyluupqLSiAhTix/z2t/YB11yT7kpNTXe6XJk+v79U3l0qfm/ixCrxCtmZ5Jt7ivDJBCOYtFCp9ka8deqnn6bE9ekzWBbTRF9d3e49b7yxR3ZoeKkKhT6kRjLqtNk94p57EnsMG5Yq/5PRzRYXlyw7UJes4+604afOKd+08UYxbhCQvPKn3FUNZWWHSjdvrlj/97/jfzk589EHgdPTVjrswHPkL5tlp9xb9i819UVFW9+cMKHSIIbqq+fRDluYYFgDRaHakie1yHrt7P/QQ3nOuLjsusOHt37x8MOlsrNC4iy0DUsHjh1rP+2xxwZ4MjMH2Wy2HNmh5ohxQH7osko2YJXsVKvk5wEDTVLShgx9uTx/y50yM+1Wh/wNhsuVLEAlC5+Md1HF6AfZGLvlLy63bXj00Z3bV6/GN0EPeri2RXbytnMefbSHp0ePwY319fsK/vKXHbLu4ylhFPpF4jVDow8CYKTTy2hLCr3GD50yxT7u6afHNNbVNRx4991NC2fM4OAYQ+/DtkavWbiwd7eBA8dbnc7hAtZ+eVN6i/yuY0nhkiX71j3/PH4oQX0TQ1tiZHkpluUlV3QAgEsLqG/Uffcl9J04MVt+DyBLjoyGyobIDDQ2bjq0ffvKeZMm7RYbFAIHSl6Vg7dMmjHD2f2664bbA4GqTbNmFcnyyG+tkY8q0/yNPpi8kU6V0Y4UOo0H4Oc89dQoOX6Oe2XQoC9UJ4Wnn0qxk03KueqqW2W5SPNWVi7/YfHidZ/94Q8AGXYAF0sMAVcp1vRdAno/0SNRDWwdxbdMm90XPvlkQq/LLhvlSkm5QA43y/d/+eVbi6ZNw++6wJdA6amojpXbN20abk9O7v7tNdf8Z926dfwG0weG5EmPOes4gqATt2rSrhW9Y+vWwXJykvlyXt7KVl7HBKofeOuUTz7J6Tp48IO+2tqVH02e/GF58181aDropaqA4yQOoJMC9B0Cep7IkCTA5UtdpJABHOi1mia/0/WT99+f4EhKuuLg+vWPfzh58gHqglRICDzwLcodBQWXWxobd70yePBWURDccLSFr9pAYmYLgaO99dJ777VbXK6c0vnz8c696XLl3LlpXQcOvLt6375Zrw4Z8oECOGOo4Fs98ob0T5cunXRrfv6zdxXvXvrLH/auhSEo2pBDDzsRq76MB2pFP68NG7ZM/i39bxkjRjyCcagGwhNAnbi5uX/evM+Qr5Z3cz+qnR4fVdeCjwV0OoaCx51/Pv76tn7B73+PF64ilRbJJOflDZAfJt4xd+zYTUEnxgTV87abNn3/auqw4f+I69J1ss3l6ivfrBT4gaINOfSwE7EeeH1MyzsTJxb4Gxq+wzgQx2xBnhKsHnkrPhyvIorMmgE9bFA5PQ+ri9zt/wlti4mijjhK3lExMQO62l8LvnrZshoZWdylM2bgByT1nYUddNWOHTttbvfIny5Z0r9FQOOG9c1hQ+8o27D+3rpDFR/J39YXyU4bx80+ULQhhx52BuNoFfWG1auHyx9/52EcrZQRBMgT+SLvCGZRVXqgjBxoY0Stt2/ePFguNPV9pX//xeKsAg2ePogLPlQnvftuZo8zzvij/Az3xwuuvfbTQwUF2OmF9MLzaAU7T/xgAynkXELQB49ScJiKnSgpdqSosNGq/KKGbfKCBVfK/1OPr9i8+Zng4WNIH7QTohXIW4z/zh07zpONfGDWsGHckcIGJRxt1uo+1aA6VahJGyNqHTp0qHXsggUXyaXV0leGDNkc8mrNwL9Fvfgf/0jNufjiG+VkJsN7+PBnhR988N2qp55SDxmNgA8HuhHgGujnPvxwQt+rrx4p/2JwoVz7OVj07ruvy6FptYxHDzjBazX6X+zcebacDSetuO++/wRP+ugLW/rpaas4EBBIQ6UiJFiqT0g26o47nKPuv/9Mi81WW/rvf282ODmiH31Uapn8wQc5qUOGhE6O6isrt8o/oO8rWLiwRE5I8Co6DxVJ6c/EAS4PFZuG3357fP9Jk7Lie/TIjktJGcyTo4r8/JXzr756DwYjhb562qwNfuLkqMfPfjbM4vfHL//tb79UzrLpx1ikkEcsGLyZwiRpq7a1GGOmTHEM/9Of8iweT3bDwYP5Xzz2mHoZgP3QT6WhmH1HjbKPkMsAiVlZA+WoJEeujeeIMiD/tlstf09Z7RUq19XlXxobm3w+X6PdbnfK2uywyj/tuuLikuTnpZLkH3mTxMcq1973yCWDPTUlJdvXy2WAwnXruNSwP4KmUug00HgZwJ2RMcRSV7dv05//vGPNe+9hw6IQWPo2S49tSLYNKcEwVCpC2kWjlhsWLkxJyMvDCVNioK6ueM+SJXvkUikvC+jBNoqn2tiGTp2a1OPUU1Plb4y7AVRZHtwOh8NpcTpdcqLilcswjbI8NWCjyF8kHyrduLFC/jQES0eLEyNpEyikpYJFXtPLBS8nLnjJyUGu7Khrju7YsXXupEnYcbMwTjRK+1aUSbdS6AS0I4WavJ5qrpPfeCM59YwzcgX8HrLz2V9/8GCZ/J5WudycwGyBj95PbVPPHSYoK3VaP/JB0AAyK2R60GFvBFRAbnY4Trn55rS4jIx0l9udKV+j0opvvimeP20aLu2qxcifer2O8laUibZSGAhoq6cwNZJpIcbPmIGbGD3kP0u7yxXBrnLF8IjMyIOHdu+uXDtzZk3Zli342qv+ep7AQ65WLb58IFl9VQGHHfUanz50qH309OmJchMjRb5BGfJH4F3kmv9hf3U1bmKUrpwxAzcx9MUIVL2Mbb1vizYTbCEM01BtyZPCJRzPcNZRkyY5Bt51V7orKytDjtNTxCFR1uhauTpZKTc5qqorK2sbiovri1asqC/89FNuDMYFZWVMUoLKpLV23wkT7H3OPz/OnZsbl5SSEi83KZKdHk+K7APixaBGzkorvSUlB7e/9FLZuoUL8Q2kP+OCqjIj3kim+rfimVArRRgB7UlpxjapXq5va3ZZsuM8/Xe/S/JkZKR4kpNT5CgjXo6A4mQn6rHIv6vLzlB+is5bjxvSclPZJ+u5X+QalZsWfrmpgb85tlkcDrtGZc/KG9Nyx0r+396txbD6fHVyybi2rqqqsu7gwcpvn322uqR5x4pxETRSjjVSmzpSNQ79w1I9SGENFYXqY4aHazQ7Va/Zn3njjc7E0aM9cscoTk537bbERCwzdr/Vil8UtckJmU3+flh7MkCOYJosXq/PLz8dLr8075M7SPVHVq+uX/fee2avfUcCL5wunBzjj1j0yUY0VpSqXzge5qouUjuanZEvZPqiAkGdXsY2aTQ7I73qq/K0jUj1yUY01ilVX5WnmV4WqR1Jx3ikelvIIyWu16ltlTeKo9frbYz0sIlYjBKI6GCgVGOoPE3NyMzYMF4s1AgUvUzfRvxoMiO96XHhOkZ7FD1o+jb7CCenXqXHlZgECud/vPJw/urYI/KxgBAxUFCpj6dv62NE09PerB3szYISzU6v17c5tphpLMnEGlwfW9+OFC8W20hxoIsFLL2tvh2tL1P69kwuUodG/RjJIsXoCJ0RqEaydu37ZCQerc9o+rYAEA3IaPq29BnWpyMSDNtZFMWJGMsJBTdKvp3qTgQ6EehEoBOBTgQ6EehE4P8IAv8f6DZKCREcsVYAAAAASUVORK5CYII=", self.location).href,
      position: Cesium.Cartesian3.fromDegrees(
        eventPos[0] + 0.02,
        eventPos[1] - 0.02,
        300
      ),
      scale: 0.5
    });
    this.emerBills.add({
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAACRCAYAAAChW7QMAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAXaADAAQAAAABAAAAkQAAAAD3Ky42AAAmVklEQVR4Ae1dCXRURbruvdNZgZAAAUPYN0EB2UFRAXFhRnSYUXlu6Cg6+pxx0PE5ozLuT1HHcUNFRX1uIC6ALIrKE1lcEAVlDSRECJAFyEI6W3e//7vp71K56eV2SIB3Tuqcyl/1b1X/dyt169Zd2mJpSS0ItCDQgkALAi0ItCDQgkALAi0ItCDQgkALAhbrSYiBsU/GerQuBwwKxrpBfPyrsQbUHD1U+xCqHIpn7IcKLMuk0A1XNvo5LnU1oOPSYLARtksKNsqshytTD5TJCCjroKHKsFP59HPcqOO4tVTXkAoqOKHABc+myFQblmGrplAAg+eXTFkkoClTfTZb+XiBTrBUijIzQQ5HqUd7IyAqsCgT7HCU+qH8GHlNXm9u0AmSSgmgCjDKzHalDF3yaRcKBIIIkFWgUfYFeZSpctoZfYLfbKk5QQ8FNIEjkAQYVM22zmeemXjqVVed7UlNHeFISOjlSkru7EhMSHa43A6bxwNdi9/r9dVWV9XWlh8prS4r3V175Mg2b3Hx2p/feOPL3V99VQ4VyQBdzeShLzwAKvgoQ9ZswBMYaaNJE8GFU5YJNKgKMMo4+PaB06a1y7rgghsS23e4KCEzs73N4WhU//y1tYEjeXn7y/fvW5y7ZMlLG1599YD4B/C1QWo8CABfPQBS1c8FKDdpalRQUXpAkKGGciiwNZBFBuo87/nZ57Tt0/vu5B49ulltNq1PAUkl27fWHvxhQ21pbo6vfNcuX0V+vr+moiJQW16ujUJHYqLVGR9vjc/IsCV27WpPzupibzNooCOlZ2+HVZL4tgT8/kDpjh07i7ZsfXj5zdO/EFaNZIJPioNA4Am+sJoHeK1j8N4Eib5A1YyRzNENkDWgQc9/4YXz0vqfdn9i1y7tpW7x+3yBwjWra/IWL646sPrrmpryMrBjTs7EJEu70WOcmRde6E4bOcpps9u1vpXvytl/YOOP9yy/+eZPxSkA5wEg+AAcB4DTDamwmm66IVBweiyJflSwOcI5fRBs58Abb+zU+3dTZrfu128AGvVVVQV2vvtu5Y65r3qrDx082o+AdvCO1o+W2F7oedd6FCB3m1RL96uv9XS77LI4u9ut2R365ZeNW9+fP33Diy/uEZcAPhT4HPFNDjw7fzScxpVUsFHmyFYBdwnfecFLcy7udO45TzjkZIgpBKN6y7P/9noP7K8D8CjQx9q3On/BA+Bp197a55b/9GRedJEbU0+tnIT3fP7FX5fccP1H0i+AXi0ZI56jnlMOQScVlWNLxxoYWo8EuFPkzK7J8xfc02HUyGtgU7BubfWmWbMqSrO3+2Vcqv3QyxKlXhYb00mM6gCvszhalgOQ3L2nrf+MGfHpw0dgEAT2rV4z98Mplz4gZYDOUQ/Kk61xxB/1J0qNSRiJx5IAiprVEa6DnXrqqcm/ffPNt9PPOONCi5zftsx+3rth5n0VVcXFaFu1twaBJs/YN/KNNKweFCVR31J1sNjy6yeLAHAgbchQZ9IppwzsNmHCqH0//rjEW1AAoJmOGVw6MtJjAV0PRJyq8zd8EnB3vyuuyjjrgfs/TenVq4e/stL/7V1/O5Iz771qZXRruChgs4/0r1LKjFTVYZk6Wh1/JAWJxVq0/vva0uxsX8aZZznjO3bsmDXmzCm13prFhZt+8ooeASfVjIN8+iAvZtpY0NkwKDJHuH6yFJ67Tb9+SWMffGB5YlZWesX+/b5VN/6xvOi7b2qDgGu2EcCOORiDAftGtlbHH0kaKcvZ6du3alVN+zFnOhM6dUpq27PHb39dt+4db2EhVzDQBfDMqDMFXbFqnjbWEHbMBJwjHHMlctxly5a922bAaYMB+P9Ovby0sqiIPdPaDQJej8dKM1AApyVpnGWNxrVtaznrrXeS49u3tx/c+NP6dydOvEwUKyVjGuJcH26O13zG8geAxZoINimnFoxyjnT3xfPe/zsAx5Sy9rZby1XAATZysGH6ibUfserr7Sjta31A39BH9BV9Rt/FuVsypknGxTjphzTWfmiX47EasTF2AiNcB1vK7onPz744c8L4O3HSxBxe9O03PEGpYKNdLWgUjmNS26y7bJXGq4qKAmW7d/s6nTfRlZR5yump3XrkZX+yeEewX/iPYGZXUW9UinVOJ+CgAF0FXJtW+l99deap1133Pzan04ZVSs5772H5hXQyAF7Xk/oHWwe+bNdOWR4GAmlnDHElde48rrrk8EcFP/2Ey2ICrlL6ipkCuMYkgt8A+FOn/sezuPDBOnzr7BcwLyKpgNO2ThLlrzslxTr6xZfjf7Pum6TT//ZfcfLfE5N9BPe6H0FSL6PP6DtiQCxij8HEaQaDDDHr+lKOOcUy0tkQaAOwhec+98knz+t0zrnX4krzmz/fdqTqoHZJrwKODsLeTLJi82vEM8950ocNc8h/jrV1//725C5dbPmffy4roAD7Y8aXGR19xJds3err8vvfuz3t2rVL7thxa87y5TniQB3lLJvx20CnMSOdoBN4TjGujKHD7kULeYsWVZdm78CVnBFgY71Bh4IMTW/AjBnutKFDcb7QU8fzJjqHPjYrzmrXx4tZn7oPQ8Fob0XfEQP0gjFhtKMfaBQZsSMbbYUVPcUCOhpQMzugnUTHPfHU2Uldu7bD5tWW557BBYaWgv+6KJvtoKaXedEkR7epVyLYBqnj+PHO4bOeaHLglb5aEANiQUyITTqhTjGIXcXCbGxaLGZBV52izCONxrWrz/TTT5sBj9gt9O7XNq/UaUW1h1q4pOnJ7qNt4L33xYVTAr/DOec6hz/1L4/c6KCa2Taob6SafRB4K2JALFAKxqbFKdVwI910+2ZBZwfhWAUcETt6T57cTi7zu2A/XLZn0VHTHaBjUtmKtQ5/6mkPt2HJD0U7nDXWMezpf3tkvqe40e3SgUKt2a+/VomYEBtiFJkWr9BwwCvm4YuxgI6AmGGHhpEdPadMuRYnPdyAqK47eeKsQwBIRTVi0vTsLifu9kRUVIUdRo9xjPj3Mx6bS5+JzLanumFZs2XfsSGHmBAbYhQlgM64gQH0maVoLpkFnY5BYUPQtSOfckrmeWhud/Dkg3JjUptTB9hkyyCwatq1FbK/bhr5diNHOUbKKkf+O9gs+tkkaffixdoJNRhjuJFOfEy1aQZ0NQA659G2txswIDGhc+d2WCYWrFmNGwCNmsuzLp7sGPvWW/FCnUfy9wZWXTfNW1lYaBr49OHDHSOfe8Fj9+inArXfpsAIKml2nNsLVn9di9gQI2IVHT12xBrMQVP9v5v1kNQM6DREAxzlpPb+11xzJu7aH5a1bU1ZmfS1canHtGmYH6yD/nm/O3PSbxzlv/7q/+q6a71VxUWmgU8bMsQx8vnZHkd8PDvRWOBpb0FMh7dt8SFGxCoCgM74SWNqB0ZmEo8oKey0I56UkTEEDg5u+EEb5YqzmDrir6yiqXXwAw/GZV5wgaN8927/quuu88p5wjzwgwY7Rr0w22NPSND9sRADVftuxRMJsA3GypEODIgHqakmzIJOZ3DOxjTgnUlJPSDEYxKgPAmhbDJpAf785BNVeF4FNriHOfihR+I6TTjPUZqzy7/q+uu8VYcPmwY+9fSBjjHPz453JGA20JLWBitmKWNhbMFYOdJVLMy61PTMgA7nxgw7LbtbtekET+U5daCj3Jh0YN1a3/d3/a0S8yfssWI449H/jss4d5yjZGe2/+sbrgfwmsyM/zann24f8+JL8fJsDNUbBTyMGVswVj12ERlxMdWGGdCNnYZjvWFncl1U3vx804DQoZHu+ezT2g3/vK9KhrrmC8+rDH3s8biMsWMdJdu2+VffdGNFdWmp6XawVzPm5VfiXUlJbMoUKFQmZWzBWPXYRU5/pDSJSGMBHY7gvF7Gs4UQ1Bw5YhoM6IdLuR9+WLPpyVn6BI8T2NBZT8a1HzPGfnjzZv+am6Z7a4JPeIXzofJb9+1rHz1nTrzsVpIdE0AwYmzBWOvFL+KY/ZkFnY4bNMiHOeXhTRV06jPQcDSk3o65c2u2vfzSUeBlh3HYk//ytBs50n7w502+NTfd6K2Vx+vCOTXyW/UW4GXEu1u1oihkuxQGqa7D2IKxgm/MMNH1g/ZhiVnQQzllw2GdmxFgeSfzdwPVnPnzana9+652YQKh3eWyDpPtgfShw+zFGzf6Vt883VvrNQ+8XMrbx8x5NT6uTZsGbcXICBW3acDRVsNoY+uBFY8rw0QeZ46pYTGxdr9iqvOiVasTL/zfVYmpAwfqfQGwZ897PyF3wbwaucrlnSeLIy7OOvyZZz2yHrcXb9jgW3PLn7y1lZWmR7w8oGo/45FHPcEQTfeXsQVjNW0XbKcB0QNtIDHJqK2q1EB3JiTE7Kv39JvcmLNdycnWntdcq22eYNSfdtd/uWUqsI6a/bJn+ysvV+d/vqIe8CMEeDlI9qLvv/etu/WWmIBv3X8AlnwxJcbGWGMyDqEcM1AGH4GasnI8fG/xZGTEMgI0XZfciqO/xM5ZNtknd+DGRVK3bhow7tRU25BHH4379s47Kg/UbTFo6g5PvHWUXHmmDhhgL5Cb3uv+fJvXV11tasTnvj9fP4BsOxplbMFYTbUTyWcsoBsbQz1QdejgHjSQKLfRIjUUTZbUpYt92KwnPcYbFzkLFtTIRZMFwBbVXfVqruRcYB35woueNqf2txesXeP75vY/e/01NcY+6s1iO+G7u+70bpKLMJ1psiDPvmuxBWPV4jaYhm3XoKdVzQJFp2xQp3LBsgue8EC+0gD1FZZe1Ee3zglTOLx1sy9nft3IlLs4ltU331QpjznzcQ6LU14KGCmX/K369rXtX7XK9+2M2yt5VUuXuNja9fbb1csnTTry69Kl2uU8ZVGoHkNy5ywttmCseuxizzJc6fpR/MZ8ImUjOi3Jy/sBjeANiGiNxSLHrbIfH3iwSm5A62Y+WSbKclGe9M3Wgcf5YNQLL8bL6sSWv3JlLaYi3HiA0aFNm3xfXv6Hih//+5Gq2iPaLKj7iqXA2IKx6rGLD5ZjcWdqbYn/BmQcbdyiwQkP+6fYyktI7dmz7ZQVn3+GG8WfjBklL1zpb0+EG9E6/5KfNumXiuV5u/07XntVWyIG/AELHvCUncajiEtjTO62ba1jX3s9Xt5L0v9TsTfz9bRrvdgywLnBJSdi/pfQzkBD+lZ0NDmuZi9ctTo54PNZ5o87d3zx9u14NvCI5ArJfPQO5wkMBOwPRd0j0jstyuESj6ZK6dwvnThSnptbiE2q9FGjGz3aK4uL/TkffFCDnPvRhzXhAEcn8TSW7MXUu9Ehqx3b6JfneHABtPezz2qjAB4u1gZ8xITYECNiFQU9dimrmLDcwIeRYQZ01QaO0Sgpjq7v0M7sL6DU+cILXTKMIWv2dGTfvsCqP16PZ9zRH4u8zOX7Zsbt2BSL1rZpcBALYoLDYIxavFJVMYg5XrMjkx0lRaPsgO+XN954N3P8hD+kyahwtW5trTp0CP2Erj6VgGFM1SUlAS4ba6RslEery357YOl544/Ed+hgLc/LM2NvRgfNanruNm2siAlv6CFG4esxS5nAQ5dZitFTLCMdjtGQmrVO5H75ZeHhLVvysCvY45pp+o3KaM1vfemFKpz05DwQ2D73Nf2SP5qdKpdloqWJAdfdywtibsSE2BCjCAi6igHB1+2iFcyArh31oCMeUTYOimVY7e4vV74AnW6XX+6Ob9eOI1y1hRhJ52X/z1s1i0ePLP/krDHlclmPzodLbFe3Dado4DfGTmsDMSAW+AvGpsUpVTV2+mezpvpnBnQ4pHNQHmUdcOHVrnn4wTVl2dmFeF5F3mLT7w7DOETSOye7hRasDEIktU1VHI4fSkflxVRGDIgFMSE2MSbooOgwcTDTn3ptmwUdRqpzNMgjjk5gyVST8+nyp4VaMidNcqZ070HfsAuVIvHDyYx+1D6pZaOe2brWLvqOGGC0a/myfwnR4hNKwAl6o9okMPBvJqERHmE0zKOvderrBx9cVbRhwzYsseS1wWijHe2pnWYZ/BOa0HfEgFhWP/TQ19IZFXQCTxzQ75iSeukezRDztJpxwJDBY9leUViwvsvEiZckdenqCMjlJHYCRY7Eeb6udvL91cDrPX26K2vypW683LvqH3//0+Fdu7AUw0UQ9myQcQBU4Ak6qYgjp1hApycCj7oKOnzZpJNVCalt96cPHjQmbegwR4msn8t27cKoQDpZgdcAyxg33jHwH/dq++2b577+yE+vzPlR+qwCjhUW/7vVkW4acIAQC+gq2LBlnaMcde0g7F755Z60Pv2SW/Xo3rfDmWc696/6qkYuYtCxkxF0DTDs3Yx65tkE7O/nLln64Yrb/4x1OR75xuhWL/dDjXJRMZ9iAV31SvAIvA64KGnA71j48Y9ZZ501OFEeR5P3NB17ly6pkX/ZkxJ4+ZCPdfScVxPcrVvbCr//7uePL7/sfonDCDhGuTq1IBY1S9VcihV0ggzvLIejNrmg+Krb+AkTE085JUHeoHAUfvdtbXDE095cL5tHSx/hABzvkMo0WPzxlVfeLE8bcDOLU4sRcEwtmn1juhYr6GobAFtNBB88rSyd9xdv3bGy4xmDzwXwnS+a5CrLzT0Z5ngNMMzhmFIwwgH4F3feNf3gls14UQpgMwNwgh5qqRgz+I0BXQVX+qPP0zwIqtxa9mteVfaSJUszBg06LalzVnqniROdAdm7PYGrGg0krFJw0sQcXvDdt78svOrKPxkA52oFgIc6eSL2RqXGgB6qoZCABxWtMuJ9m9999/O2vfokte7Zoze+PpEqj72VbN3mkzfwOFLoI5T/puBp7eDCZ8jDj3iwLITTnMWffLxw6hUPSh+xbcvRTcDV9blxtQJ/7DtcmU6NBb1RAGUvWrjBnZC0L7VfvxFYx8trg66Ejp1sJZt/8fEpKul5o3xHiFgDBnspA+6623P6Pfd4Ek/JtGMd/vMrrz7+xYzb3xNbgk0K0DmlcLVinFoiNBlZdCwBwpb2XDbiICLjEhoZo4kZV6jI7syxYzOGz7jjnraDBvWUet3npN55p1reV6qSbWGOHvqGSmOS5kceLrJit1A2r1x8j6nohx+2r5v1+AN5K1fmi2MuCQE4RzgoRznAJuC83oBv9lOKsaVjDYzAkwJ8I/C4CUDgQTXghbqG3XHHqB4XTbpZHgJqK/W6D6fJmw/yykkN3urAli/4wRStr7qu3GLT7mLJDQgn9sOxPQsfcqOjaMfiRc9/8/jjq6WKkUzAVbA5wgG6CjiBJhVx41K0QMx4JeCkoYDHqDeCj7qWh8+4c3jW+HHT5FXGTnhEGo3iLj7e7pCXDXzyjLqvPDfH792bH9A+ERh8bhJPXuETgZ6OGdbErC625C5d7W0GDrK36t3bjr0TzY/cgJAnCPbkfrbi1XWzHlsnPIDKHA7sZgMcfdI6hsIxJgJOqgKPu1PIAFgFXwc9yHd2HDkyrf9VV01O7d1njLw0m4qVhchiTngMA0vA4q1bVv08d+6CPevW4btVnC4IOChAB4UMlKuUZhnh4l9LjQqKxgqlH4IOqs7zBB6gM6sHgTzooWxPycxM6Dd16pA23bv3l9tmWZ62ae1dKcnxdnecw+7x2HBA5H0gn6+qsra6pLTCW1S4X25u7z60c+fGX9566zt5XAIXOAARgJISXJWiTB2eNEOtVESt8fM4jJkIFuvHQulLBR5lzPEc+Sr4BJiAg1JOyvMD7UE1/zfn7/vg+YwOk6WOOZYgcYSSqmASXFIeCFAVbNhy3iYVVtMADkcIrqkSOqgm1Hkg2HlQAsRgGTyBBgXYrKsHTQdd5EgYzfRJoElV/2qZBwJ64FOf/QKFTyT2u67WRH+bEnR2iR0G4ASEnWcdgQFMBq4CzdFNHusEn8CjPVzQ0CfBIyXQbEOl1AE1gg1/SOxzXa0J/zYH6OywsZscQQwSARNIAGQE1wg6pxhtegk6x0inXxVIltWRTB70UWY/CK5K4Z7go9ykqblARyfRaY52tU4e5AgcYAIEUAJLyoPCA0Id+EBSpxeCSXBVSoBJ2TYoM/yhjERaV2viv80JerjOIyACD0rgUQaoGJ0EPRQFj6DjKhL+CCaBRp1lylWKMrMUdZDBa/bU3KAzgFDBgAfwCDzLoAAWoKmgs0w9EWtra/hRQSfgpJAzw8ZYJg/0uKTjBTqDQcDGRJ4KJgADyMjGsqqHlQjsocOMg4Uy+Cgjocx2WFcpysctHW/QGRgBAAWISGq5jnMULMiYcSBoA1DBVwFX6+Ajgceklsk7rvREga4GqYKAMgEFYCyr+iiTT9Bhx9HNAwAeM2xOmnQygG4EA0CpicCRqgeDPCOlPfgnXcK/aks6zgi0gH6cAUdzLaC3gH4CEDgBTbaM9BbQTwACJ6DJlpHeAvoJQOAENNky0ltAPwEInIAmW0Z6C+gnAIET0GTLSG8B/QQgcAKabBnpJwD0k2k/nTcmjDAY+aiTR6rum4PHOuX0ST7rJ4SeCNCNQBgDpxzUWGY9lA31ASz1SAk260Z7yo38ZqkfL9BDBRuKFypIox7q5JGqoIGn1uGTeiiriXqqnDxVr0nLzQm6Ggg6baxHCgS6zLRV60ZbykABGigS63W1hn+pR4lqC16zHICmBt0YhLHO4EijyaFn1EGdPFIVHPCMdfgxJlWHMvpDHXJjnXrHRJsKdLVz6JCxzk6a5k+YMcNl79sXH5332CsqnL5AwGlxu+3ybRhHQJ5Ox6cDL3zrrW5Wv79WvpRXa6mq8slz6zU+m62mtrzc69u8ueLTWUc/Cc4OCCXYxr6QT1XKyTfWqRczpaOYDRUD1YdapkpYXvfzz7cPufPOJHlHKMUdH59isdvjA1ZrnDzw77HIh3eqjxyprq2urpSPGFsC1dV+n3xhNFBV5ZdPUPnbDx+xdv+6tSPkfSKb1S1ffZLPfcuntq2gDpcrzpWQ4JLHBqzyFo3XJln8VUguKSsqKvnuscfKspcuVR9EYl9JCTTroCpPLas6psqhADFlKEqqrVqmvZFnHXvNNY4u116b5szISLNZra1k9CbKy0HllWVlZXa//1DN4cPesj17KneuWFG58c03+agF/OB6ghl1q7wUUCQvBeAFMQCAzOddQDXegCuvtHUbNy7O0alTXHKrVp6Ay9XK5fEks12/vNZUk59fmPPaa4Ur587FM5RGMI11UamnE0oOnYjJCExEZUWo2oUrQ9064fHH3VkTJ7aX3/dsJ8GmypffDvnKy/eXHjhQsvaBB8r3rF2LEaf60OzkD0AGH5mA6zwBvVBATxOZBrDQBqAHeUZgAp1GjLAPueOOpDadOyfbExPby8tlreXgF8u7pQdyly3b/+kdd+BdpAZ2wmNSZWqZ8ojUGGxE5aBQtQlbnrJsWXLrbt2y7DZbh5rq6v3VxcWFOxYsKFz71FP8t4a7UPbkEWCV4pFpyDHSDwjo+D05BI0MvxzlRioiLakA6eURf/mLvcell6a5UlPTnC5Xe5/fv0/eXcqdP3FiqVjpeibLdS1F+MsAI6jUE6n6ocrWq1asSInr0qWPTKaJPq93d97rr+fJCQ1vriHRhjQUjzJtdA+85ZbEDv37p7rT0trY4uKS5QTqknnc3XbAaW8VbfxpqihXCUjV8qPcpVWFhQf3bdpUvOHZZ/FhXY58tEHgjLSBDCfwTPnJZjkpd5bzS3llTs6WN8aNKwnhQ7U1llEPmxhgWAVFoOqyTGqR+drZ/a67ejrj4jp6Dx3a8vXdd++TkxUCZ6JuWNpr1Cj76fff38PTvn1vm82WKSfUTFEOyLfRS+UAlspJtdQv30mvldS2b78Xizb/cqOMTLvV4bDJyTNZgEqWcjLeRRWlX+Vg7JafuNz647337ti2ejX+E4ygh6tb5CRvG33vvR08HTr0qams3Jv96KPbZd7HU8JItItU1hRD/SEAoWRGHnVJIdfK/aZMsZ/52GMjarzeqgPz5m1cNHMmO0cfRhvWNXrpokWd2/TqNdbqdA4QsPbLm9K/VBw4kL9r2bK9659+Gu8VqW9iaFOMTC+5Mr1kiQwAcGoB9Q2+7baErhMndpTvAWTIyqifHIj2gZqajQe3bVu5YNKk3aKDROBAWVb5KFsmzZzpbPf73w+wBwKlG+fMyZHpkf+1oWxUnmYf6g+DDyVTedQjhUwrA/DRDz88WNbPcS/17v21aqSUaadSnGSTMi++eJpMF23lE7Bf/LpkyfrP//53gAw9gIsphoCrFHP6TgG9m8gRqAa2geK/TBvd5z70UMIpF1wwWD4xe44sN4v2r1nz5uKrr8Z3XWBLoIxUREfT9Rs3DrAnJ7f7/tJLP1u/fj3/g2kDRZZJjxobSgTBwG5QpV4DesOWLX3k4qT9iz17rmxgdZSh2qFsnbJ0aWbrPn3ulG+ir/x48uSPiuTHo8BXsgo4LuIAOilA3y6g9xQeggS4fKmLFDz4hFzLbeU7Xb95//1xjqSkiwo2bHjgo8mTD1AWpEJ08FCul27Izr7QUlOz86U+fbaIgOCGo/Vs1QoCM5sIHPWt5996q93icmXu+/BDvHNvOv32nXfatu7V6+ayvXvnvNK37wcK4PShgm/1yBvSf1i+fNK0zZufmJ67e/lNv+75DoqgqIMPOfSErdrSH6gV7bzav/+n8mvp/04fOPAe9ENVkDIBNLDrqvsXLPgc8Wpx17Wj6hnxUWX1yrGATkPdedzZZydKpXLh3/6GF64ipXrBJPfs2UM+TLz9nVGjNgaN6BPUWLZdufHnV1L7D3gurlXryfILu13lP0v7eS5Q1MGHHHpibwTe6NPy3sSJ2f6qqh/Qj0idNsoQpzirRNyKjP1VWJGLZkAP61Quz8PKIjf7/0Jab6CoPY4Sd1RMzICutlevXPbpp+XSs7jzZ87EBySNjYXtdOn27TtsbvegPyxb1r2ew9AV6xv9+91Q+OOGW70Hiz+W38rIkZM21s0+UNTBhxx6IfrRwOvlq1cPkB8D74l+NBBGYCBOxIu4I6hFFRmBCmVAnVDUev2mTX1ko6nrS927LxFjFWiUaQO/KOt50rx57TsMHfqP6sOHP1n4u9+tOJidbTyRcrWCkyc/1gAKPqcQtAE7nDSxTMVJlBQ8ZOhoWb6oYZu8cOFv7fHxY4s3bXo8uHzU5UE9IVoCv17/b9y+/Sw5yAfm9O/PEyl0kMLROqnhr+rUINKr1AlFrf369bOOWrhwvGyt7nupb99NulXDAuzr5QnPPZeaOWHCVLmYSa8+dOjzXR988MOqhx9Wl4yhgA8HeijANdDH3H13QtdLLhkkv2Jwruz9FOTMm/eaLE3xiylGwAleg97/cceOkXI1nPTlbbd9Frzooy10aWekDfyAQSBDChUmwVJtdN7gG25wDr799mEWm61i39tvbwpxcUQ72qjUMvmDDzJT+/bVL44qS0q2VOzbtzd70aJ8uSDBq+hcKpLSnoEDXC4Vawdcf31890mTMuRnGzrGpaT04cVR8ebNKz+85JI8dEYSbY20Thr8i4ujDldc0d/i98d/8Ze/rFGusmlHX6TgR0zovJnEIKmr1jUfI6ZMcQy4776eFo+nY1VBweav779f3QZgO7RTqe6z6+DB9oGyDZCYkdFLViWZsjeeKcKAr7KyTH6esqxaqOyrB2TlU+vz+WrsdrtT5mb58TuX1RUXlySfl0qyCxUbq+y958mWQV55fv62DbINsGv9ek41bI+gqRQyDTRuA7jT0/tavN69G//5z+1r58/HgUUisLSt4x49kKyHpAQjpFBhUi8atVy+aFFKQs+euGBKDHi9uXnLluXJVim3BYxgh/Kn6tj6XXVVUofTTkuNa9euDUCV6cHtcDicFqfTJRcq1bINUyPTk/x41JGyygMHDu776adi+dEQTB31LoykTqAQlgoWy5pcNryc2PCSi4MsOVGXH9m+fcs7kybhxM1EP9Eo9RtQBt1AYGBQjxRilo1UM538+uvJqUOHZgn4HeTks7+yoKBQvqdVJDcnMFpgY7RT65TzhAnKTJnWjvwhaACZGTwj6NAPBVRAbnY4Tr3mmrZx6elpLre7vfwb7Sv+9tvcD6++Glu7agplT7lRRn4DykAbCEIwqGukUA3F01yMnTkTNzE62JKS2smOYGvZMTwsI7Lg4O7dJd/NmlVeWPdbdKq9sUzgwVez5l/+IFhjVgGHHuVaOa1fP/uQGTMS5SZGivwHpcsPzLaSPf9D/rIy3MTYt3LmTNzEMKZQoBp5rBtt69UZYD1mmIqqyzIpTMKV6c46eNIkR6/p09NcGRnpsk7H72ImyhxdIbuTJXKTo7SspKSiKje3MufLLyt3rViBORg+6Zdl1ukXlKAyaK3eddw4e5ezz45zZ2XFJaWkxMtNimSnx5Mi54B4USiXq9KS6vz8gm2zZxeuX7QI/4G0N/pmXZWzTAodtUybBjRUAA2UFAb1SSlindTIN9Y1vQw5cZ7x178medLTUzzJySmyyoiXFVCcnEQ9Fvk5TDkZyqfoqitxQ1puKvtkPvcLX6Ny08IvNzVsMp/bLA6HXaNyZuWNabljFSdPD2g+rD6fV7aMK7ylpSXegoKS7594oiy/7sSKfhEoUvY1Up0yUtUP7cNSI0hhFRWBamOmDNNoeqpc0x82daozccgQj9wxipPLXbstMRHTjN1vteKLoja5ILPJzw9rTwbICqbWUl3t88unw+VL8z65g1R5ePXqyvXz55vd+44EXjhZOD76HzEZg42orAhVu3BlqKuySPVoeqFswTMmFQjKjDzWSaPphZKrtmqZuhGpMdiIygahaquWqWbkRapHktEfqVEX/EiBG2VqXS2H8mOUG3VCyaETMYUKIKJBCKHqQy1T1QzPjA79xUJDgWLkGevwH40XSm66X9jHaIpkBM1YZxvh+JSr9JgCE0fh7I+VH85e7XvEciwgRHQUFBr9GetGH9Hk1DerB32zoETTM8qNdfYtZhpLMLE6N/o21iP5i0U3kh/IYgHLqGusR2vLlLwpg4vUYKh2QvEi+WgOWShQQ/GatO0TEXi0NqPJGwNANCCjyRvTZlib5ggwbGNRBMejL8cV3CjxtohbEGhBoAWBFgRaEGhBoAWB/ycI/B8HKHT5pgspSgAAAABJRU5ErkJggg==", self.location).href,
      position: Cesium.Cartesian3.fromDegrees(
        eventPos[0] - 0.01,
        eventPos[1] + 0.02,
        300
      ),
      scale: 0.5
    });
  }
  addLandForeducation3D(data, colors2, length3, width, totalHeight) {
    if (!this.educationLayer) {
      this.educationLayer = new mars3d$1.layer.GraphicLayer();
      this.map.addLayer(this.educationLayer);
    }
    showStandColumn(
      this.educationLayer,
      data,
      colors2,
      length3,
      width,
      totalHeight
    );
    return this.educationLayer;
  }
  addLandForeducation2D(data, colors2, length3, totalHeight, obj) {
    if (!this.educationColumnLayer) {
      this.educationColumnLayer = new mars3d$1.layer.DivLayer();
      this.map.addLayer(this.educationColumnLayer);
    }
    try {
      showStandColumn2D(
        this.educationColumnLayer,
        data,
        colors2,
        length3,
        totalHeight,
        obj
      );
    } catch (error2) {
      console.error("addLandForeducation2D", error2);
    }
    return this.educationColumnLayer;
  }
  setCameraViewHander(cameraView, cameraOptions) {
    this.map.setCameraView(
      { ...this.map.getCameraView(), ...cameraView },
      { ...cameraOptions }
    );
  }
  onXzqMaskClickHander(callback) {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    xzqLayer.on(mars3d$1.EventType.click, callback);
  }
  offXzqMaskClickHander(callback) {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    xzqLayer.off(mars3d$1.EventType.click, callback);
  }
  onXzqMaskMouseOverHander(callback) {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    xzqLayer.on(mars3d$1.EventType.mouseOver, callback);
  }
  onXzqMaskMouseOutHander(callback) {
    const xzqLayer = this.layer.getLayerById("xzqMask");
    xzqLayer.off(mars3d$1.EventType.mouseOut, callback);
  }
  clickMap(callback) {
    this.map.on(mars3d$1.EventType.clickMap, callback);
  }
  rmClickMap(callback) {
    this.map.off(mars3d$1.EventType.clickMap, callback);
  }
  mouseMoveMap(callback) {
    this.map.on(mars3d$1.EventType.mouseMove, callback);
  }
  rmMouseMoveMap(callback) {
    this.map.off(mars3d$1.EventType.mouseMove, callback);
  }
  enableCameraZoom() {
    this.map.scene.screenSpaceCameraController.enableZoom = true;
  }
  unableCameraZoom() {
    this.map.scene.screenSpaceCameraController.enableZoom = false;
  }
  addDivLayer(data, options = {}, id, clickCallback, mouseOverCallback, mouseOutCallback) {
    if (!(data && data.length > 0))
      return;
    try {
      const divLayer = new mars3d$1.layer.DivLayer();
      if (id !== void 0 && id !== null) {
        divLayer.id = id;
      }
      this.map.addLayer(divLayer);
      const offsetX = options && options.offsetX ? options.offsetX * this.bigScale : 0;
      const offsetY = options && options.offsetY ? options.offsetY * this.bigScale : 0;
      data.forEach((item) => {
        if (item.html) {
          item.div_html = item.html;
          let num = 100 * (this.bigScale - 1) / (2 * this.bigScale);
          if (options.horizontalOrigin || options.verticalOrigin) {
            item.div_html = `<div style="transform: scale(${this.bigScale}) translateZ(10px)">` + item.div_html + "</div>";
          } else {
            item.div_html = `<div style="transform: scale(${this.bigScale}) translateZ(10px) translateX(${num}%)">` + item.div_html + "</div>";
          }
          const graphic2 = new mars3d$1.graphic.DivGraphic({
            position: item.position,
            pointerEvents: true,
            attr: {
              ...item
            },
            style: {
              html: item.div_html,
              horizontalOrigin: options.horizontalOrigin === 0 ? 0 : options.horizontalOrigin || Cesium.HorizontalOrigin.LEFT,
              verticalOrigin: options.verticalOrigin === 0 ? 0 : options.verticalOrigin || Cesium.VerticalOrigin.CENTER,
              offsetX,
              offsetY,
              distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
                options.distanceDisplayConditionMin || 0,
                options.distanceDisplayConditionMax || 999999999999
              )
            }
          });
          divLayer.addGraphic(graphic2);
        }
      });
      if (clickCallback) {
        divLayer.on(mars3d$1.EventType.click, function(event) {
          clickCallback(event);
        });
      }
      if (mouseOverCallback) {
        divLayer.on(mars3d$1.EventType.mouseOver, function(event) {
          mouseOverCallback(event);
        });
      }
      if (mouseOutCallback) {
        divLayer.on(mars3d$1.EventType.mouseOut, function(event) {
          mouseOutCallback(event);
        });
      }
      return divLayer;
    } catch (error2) {
      console.error("addDivLayer", error2);
      return;
    }
  }
  removeLayerByLayerId(layerId) {
    let layer2 = this.map.getLayerById(layerId);
    if (!layer2) {
      return;
    }
    layer2.clear();
    this.map.removeLayer(layer2, true);
    layer2 = null;
  }
  removeLayerByLayer(layer2) {
    if (!layer2) {
      return;
    }
    layer2.clear();
    this.map.removeLayer(layer2, true);
    layer2 = null;
  }
  addMarkTextLayer(list, clickCallback, options = {}) {
    var _a2, _b2;
    if (!(list && list.length > 0))
      return;
    try {
      const graphicLayer2 = new mars3d$1.layer.GraphicLayer({});
      this.map.addLayer(graphicLayer2);
      const scale4 = (((_a2 = options.styleOptions) == null ? void 0 : _a2.scale) || 0.5) * this.bigScale;
      const highlightScale = (((_b2 = options.styleOptions) == null ? void 0 : _b2.highlightScale) || 0.8) * this.bigScale;
      list.forEach((item) => {
        const graphic2 = new mars3d$1.graphic.BillboardPrimitive({
          name: item.name,
          position: item.position,
          style: {
            image: item.image,
            scale: scale4,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            clampToGround: options.clampToGround ? options.clampToGround : false,
            label: {
              text: item.name,
              scale: scale4,
              font_family: options.label.font_family || "\u6977\u4F53",
              font_size: options.label.font_size ? options.label.font_size : 18,
              color: options.label.color ? options.label.color : "#ffffff",
              pixelOffsetY: options.label.pixelOffsetY || -30,
              distanceDisplayCondition: options.label.distanceDisplayCondition ? options.label.distanceDisplayCondition : true,
              distanceDisplayCondition_far: options.label.distanceDisplayCondition_far ? options.label.distanceDisplayCondition_far : 5e5,
              distanceDisplayCondition_near: options.label.distanceDisplayCondition_near ? options.label.distanceDisplayCondition_near : 0
            },
            highlight: {
              type: mars3d$1.EventType.click,
              scale: highlightScale
            }
          },
          attr: { ...item }
        });
        graphicLayer2.addGraphic(graphic2);
      });
      const _map = this.map;
      if (clickCallback) {
        graphicLayer2.on(mars3d$1.EventType.click, function(event) {
          if (!event.graphic) {
            _map.flyTo(event.pickedObject.id, { duration: 1 });
          } else {
            clickCallback(event);
          }
        });
      }
      return graphicLayer2;
    } catch (error2) {
      console.error("addMarkTextLayer", error2);
      return;
    }
  }
  addMarkLayer(list, clickCallback, options = {}) {
    var _a2, _b2;
    if (!(list && list.length > 0))
      return;
    try {
      const graphicLayer2 = new mars3d$1.layer.GraphicLayer({
        clustering: options.clustering ? options.clustering : false,
        zIndex: options.zIndex
      });
      this.map.addLayer(graphicLayer2);
      const scale4 = (((_a2 = options.styleOptions) == null ? void 0 : _a2.scale) || 0.5) * this.bigScale;
      const highlightScale = (((_b2 = options.styleOptions) == null ? void 0 : _b2.highlightScale) || 0.8) * this.bigScale;
      list.forEach((item) => {
        const graphic2 = new mars3d$1.graphic.BillboardPrimitive({
          name: item.name,
          position: item.position,
          style: {
            image: item.image,
            scale: scale4,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            clampToGround: options.clampToGround ? options.clampToGround : false,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            highlight: {
              type: mars3d$1.EventType.click,
              scale: highlightScale
            }
          },
          attr: { ...item }
        });
        graphicLayer2.addGraphic(graphic2);
      });
      const _map = this.map;
      if (clickCallback) {
        graphicLayer2.on(mars3d$1.EventType.click, function(event) {
          if (!event.graphic) {
            _map.flyTo(event.pickedObject.id, { duration: 1 });
          } else {
            clickCallback(event);
          }
        });
      }
      graphicLayer2.on(mars3d$1.EventType.mouseOver, function(event) {
        if (event && event.graphic) {
          event.graphic.setStyle({ scale: highlightScale });
        }
      });
      graphicLayer2.on(mars3d$1.EventType.mouseOut, function(event) {
        if (event && event.graphic) {
          event.graphic.setStyle({ scale: scale4 });
        }
      });
      return graphicLayer2;
    } catch (error2) {
      console.error("addMarkLayer", error2);
      return;
    }
  }
  addMarkPopupLayer(list, clickCallback, options) {
    var _a2, _b2;
    if (!(list && list.length > 0))
      return;
    const defaultOptions = {
      layerOption: {
        layerId: "billboard-Popup-Layer",
        show: true,
        isPopup: false
      },
      billboardStyleOption: {
        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        clampToGround: true,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      }
    };
    let layerOptions = {
      ...defaultOptions.layerOption,
      ...options.layerOption
    };
    options.billboardStyleOption.scale = (((_a2 = options.billboardStyleOption) == null ? void 0 : _a2.scale) || 1) * this.bigScale;
    options.billboardStyleOption.highlight.scale = (((_b2 = options.billboardStyleOption.highlight) == null ? void 0 : _b2.scale) || 1.2) * this.bigScale;
    const billboardOption = {
      ...defaultOptions.billboardStyleOption,
      ...options.billboardStyleOption
    };
    try {
      const graphicLayer2 = new mars3d$1.layer.GraphicLayer(layerOptions);
      this.map.addLayer(graphicLayer2);
      list.forEach((item) => {
        const graphic2 = new mars3d$1.graphic.BillboardPrimitive({
          name: item.name,
          position: item.position,
          style: {
            image: item.image,
            ...billboardOption
          },
          attr: { ...item }
        });
        graphicLayer2.addGraphic(graphic2);
      });
      if (layerOptions.isPopup) {
        graphicLayer2.bindPopup(function(event) {
          const attr = event.graphic.attr || {};
          return attr.html;
        });
      }
      if (clickCallback) {
        graphicLayer2.on(mars3d$1.EventType.click, function(event) {
          clickCallback(event);
        });
      }
      return graphicLayer2;
    } catch (error2) {
      console.error("addMarkPopupLayer", error2);
      return;
    }
  }
  addMarkAndDivLayer(list, options = {}, clickCallback) {
    var _a2, _b2;
    if (!(list && list.length > 0))
      return;
    try {
      const graphicLayer2 = new mars3d$1.layer.GraphicLayer();
      this.map.addLayer(graphicLayer2);
      const scale4 = (((_a2 = options.markStyleOptions) == null ? void 0 : _a2.scale) || 1) * this.bigScale;
      const highlightScale = (((_b2 = options.markStyleOptions) == null ? void 0 : _b2.highlightScale) || 1.2) * this.bigScale;
      const offsetX = options && options.offsetX ? options.offsetX * this.bigScale : 40 * this.bigScale;
      const offsetY = options && options.offsetY ? options.offsetY * this.bigScale : -20 * this.bigScale;
      list.forEach((item) => {
        const graphic2 = new mars3d$1.graphic.BillboardPrimitive({
          name: item.name,
          position: item.position,
          style: {
            image: item.image,
            scale: scale4,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            clampToGround: options.clampToGround ? options.clampToGround : true,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            highlight: {
              type: mars3d$1.EventType.click,
              scale: highlightScale
            }
          },
          attr: { ...item, clickLayerType: "mark" }
        });
        if (item.html) {
          item.div_html = item.html;
          if (item.div_html instanceof Object) {
          }
          let num = 100 * (this.bigScale - 1) / (2 * this.bigScale);
          if (options.horizontalOrigin || options.verticalOrigin) {
            item.div_html = `<div style="transform: scale(${this.bigScale}) translateZ(10px)">` + item.div_html + "</div>";
          } else {
            item.div_html = `<div style="transform: scale(${this.bigScale}) translateZ(10px) translateX(${num}%)">` + item.div_html + "</div>";
          }
          const divGraphic = new mars3d$1.graphic.DivGraphic({
            position: item.position,
            pointerEvents: true,
            attr: {
              ...item,
              clickLayerType: "div"
            },
            style: {
              html: item.div_html,
              horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              offsetX,
              offsetY,
              distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
                options.distanceDisplayConditionMin || 0,
                options.distanceDisplayConditionMax || 999999999999
              )
            }
          });
          graphicLayer2.addGraphic(divGraphic);
        }
        graphicLayer2.addGraphic(graphic2);
      });
      if (clickCallback) {
        graphicLayer2.on(mars3d$1.EventType.click, function(event) {
          clickCallback(event);
        });
        graphicLayer2.on(mars3d$1.EventType.mouseOver, function(event) {
          if (event && event.graphic) {
            event.graphic.setStyle({ scale: highlightScale });
          }
        });
        graphicLayer2.on(mars3d$1.EventType.mouseOut, function(event) {
          if (event && event.graphic) {
            event.graphic.setStyle({ scale: scale4 });
          }
        });
      }
      return graphicLayer2;
    } catch (error2) {
      console.error("addMarkAndDivLayer", error2);
      return;
    }
  }
  getBorderFeatureByPoint(point4, type = "area") {
    let url = "";
    switch (type) {
      case "area":
        url = this.options.publicPath + "/map3d/region/szxzq4.geojson";
        break;
      case "street":
        url = this.options.publicPath + "/map3d/region/gzj_jd3.geojson";
        break;
      case "community":
        url = this.options.publicPath + "/map3d/region/gjz_sq2.geojson";
        break;
    }
    return new Promise((resolve, reject) => {
      http.get(url).then((res) => {
        const features2 = res.data.features;
        if (features2 && features2.length > 0) {
          const list = features2.filter((item) => {
            if (item.geometry && item.geometry.coordinates && item.geometry.coordinates.length > 0) {
              let poly = null;
              if (item.geometry.type === "Polygon") {
                poly = polygon(item.geometry.coordinates);
              } else {
                poly = multiPolygon(item.geometry.coordinates);
              }
              if (!poly)
                return false;
              return booleanPointInPolygon(point4, poly);
            }
          });
          if (list && list.length > 0) {
            resolve(list[0]);
          } else {
            resolve(null);
          }
        } else {
          resolve(null);
        }
      }).catch((error2) => {
        reject(error2);
      });
    });
  }
  clickHightLight(options) {
    yqMixin.methods.clickHightLight(options);
  }
  addThreeAreasLayer(options) {
    const obj = yqMixin.methods.addThreeAreasLayer(options);
    return obj;
  }
  addGeojsonLayer(options) {
    return addGeojsonLayer(options);
  }
  addEtopGeojsonLayer(options) {
    return addEtopGeojsonLayer(options);
  }
  async showXzqFxMask(quName = "\u6DF1\u5733\u5E02") {
    let url = this.options.publicPath + "/map3d/region/szxzq4.geojson";
    let res = await http.get(url);
    const features2 = res.features;
    let geojsonFilter = features2.filter((v, i) => {
      return v.properties.QUNAME === quName;
    });
    const featureCollection2 = featureCollection$1(geojsonFilter);
    let maskLayer2 = this.map.getLayerById("masksz");
    if (maskLayer2) {
      maskLayer2.load({ data: featureCollection2 });
    } else {
      const geoJsonLayer = new mars3d$1.layer.GeoJsonLayer({
        id: "masksz",
        data: featureCollection2,
        mask: true,
        show: false,
        zIndex: 1,
        symbol: {
          styleOptions: {
            fill: true,
            color: "#000217",
            opacity: 0.45,
            outline: true,
            outlineStyle: {
              color: "#ededed",
              width: 1,
              opacity: 1
            },
            arcType: Cesium.ArcType.GEODESIC,
            clampToGround: true
          }
        }
      });
      this.map.addLayer(geoJsonLayer);
    }
  }
  addWallPrimitive(layer2, data, style) {
    this.map.addLayer(layer2);
    const wallPrimitive = new mars3d$1.graphic.WallPrimitive({
      positions: data,
      style
    });
    const PolylineGlowPrimitive = new mars3d$1.graphic.PolylineEntity({
      positions: data,
      style: {
        width: 40,
        material: mars3d$1.MaterialUtil.createMaterialProperty(
          mars3d$1.MaterialType.PolylineGlow,
          {
            color: Cesium.Color.fromCssColorString(style.color),
            glowPower: 0.05,
            taperPower: 1
          }
        ),
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 8e3)
      }
    });
    layer2.addGraphic(PolylineGlowPrimitive);
    layer2.addGraphic(wallPrimitive);
  }
  addDivPrimitive(layer2, point4, html) {
    this.map.addLayer(layer2);
    let graphic1 = new mars3d$1.graphic.DivGraphic({
      position: Cesium.Cartesian3.fromDegrees(point4[0], point4[1], 0),
      style: {
        html,
        horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        scaleByDistance: new Cesium.NearFarScalar(100, 0.8, 5e3, 0.1),
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5e3),
        clampToGround: true
      }
    });
    layer2.addGraphic(graphic1);
  }
  addGeojsonLayerByOptions(options, clearFlag = true) {
    if (clearFlag) {
      this.rmLayerById(options.id);
    }
    const graphicLayer2 = new mars3d$1.layer.GeoJsonLayer({
      id: options.id,
      data: options.featureCollection,
      symbol: options.symbol,
      show: options.show,
      zIndex: options.zIndex
    });
    this.map.addLayer(graphicLayer2);
  }
  showMaskByName({
    quName,
    isLocate,
    maskColor,
    opacity,
    outlineStyleColor,
    outlineWidth,
    outlineOpacity
  } = {}) {
    regionMask.showMaskByName({
      quName,
      isLocate,
      maskColor,
      opacity,
      outlineStyleColor,
      outlineWidth,
      outlineOpacity
    });
  }
  showMaskSzOutside({
    opacity,
    maskColor,
    maskOutLineColor,
    maskOutLineWidth
  } = {}) {
    regionMask.showMaskSzOutside({
      opacity,
      maskColor,
      maskOutLineColor,
      maskOutLineWidth
    });
  }
  clearLayerById(id) {
    let map5 = window.etopMap.map;
    if (!Array.isArray(id)) {
      id = [id];
    }
    id.map((i) => {
      const layer2 = map5.getLayerById(i);
      layer2 && map5.removeLayer(layer2);
    });
  }
  graphicViewShed(positions) {
    const tiles3dLayer = new mars3d$1.layer.TilesetLayer({
      type: "3dtiles",
      center: {
        lat: 22.011214,
        lng: 114.17,
        alt: 70296,
        heading: 0,
        pitch: -45
      },
      url: "//data.mars3d.cn/3dtiles/qx-xuexiao/tileset.json",
      maximumScreenSpaceError: 1,
      maximumMemoryUsage: 1024,
      dynamicScreenSpaceError: true,
      cullWithChildrenBounds: false,
      luminanceAtZenith: 0.6
    });
    this.map.addLayer(tiles3dLayer);
    if (!this.graphicViewShedData) {
      this.graphicViewShedData = new mars3d$1.layer.GraphicLayer();
      this.map.addLayer(this.graphicViewShedData);
    }
    this.viewShed = new mars3d$1.graphic.ViewShed({
      ...positions
    });
    this.graphicViewShedData.addGraphic(this.viewShed);
  }
  addWayLines(Cesium2, viewer, positions, lineWidth, colorArr, id, callback) {
    if (Cesium2 == void 0 || viewer == void 0 || positions == void 0) {
      return;
    }
    if (lineWidth == void 0) {
      lineWidth = 10;
    } else if (colorArr == void 0) {
      colorArr = ["#F593FE"];
    } else if (id == void 0) {
      id = "polyline" + Math.round(Math.random() * 10 + 1e3);
    }
    let scene = viewer.scene;
    let colors2 = [];
    let remainder = positions.length % colorArr.length;
    let integer = parseInt(positions.length / colorArr.length);
    let remainderColorArr = colorArr.slice(0, remainder);
    for (let i = 0; i < integer; i++) {
      colors2 = colors2.concat(colorArr);
      if (i == integer - 1) {
        colors2 = colors2.concat(remainderColorArr);
      }
    }
    let perSegmentPolyline = new Cesium2.GeometryInstance({
      id,
      geometry: new Cesium2.PolylineGeometry({
        positions,
        colors: colors2,
        width: lineWidth,
        vertexFormat: Cesium2.PolylineColorAppearance.VERTEX_FORMAT,
        colorsPerVertex: true
      })
    });
    scene.primitives.add(
      new Cesium2.Primitive({
        geometryInstances: [perSegmentPolyline],
        appearance: new Cesium2.PolylineColorAppearance()
      })
    );
  }
}
export { EtopMap };
//# sourceMappingURL=etop3d.es.js.map
